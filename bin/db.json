{
  "searchResList": [],
  "articleDetail": [
    {
      "source": "掘金",
      "id": "1arngbnsgo3k",
      "author": "神三元",
      "title": "写给新手前端的各种文件上传攻略，从小图片到大文件断点续传",
      "content": "写在前面今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。这篇文章比较基础，在国庆期间的业余时间写的，这几天又完善了下，力求把更多的前端所涉及到的关于文件上传的各种场景和应用都涵盖了,若有疏漏和问题还请留言斧正和补充。自测读不读以下是本文所涉及到的知识点，breakorcontinue?文件上传原理最原始的文件上传使用koa2作为服务端写一个文件上传接口单文件上传和上传进度多文件上传和上传进度拖拽上传剪贴板上传大文件上传之分片上传大文件上传之断点续传node端文件上传原理概述原理很简单，就是根据http协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件。我们都知道如果要上传一个文件，需要把form标签的enctype设置为multipart/form-data,同时method必须为post方法。那么multipart/form-data表示什么呢？multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTMLForms和POST方法上传文件，具体的定义可以参考RFC7578。multipart/form-data结构看下http请求的消息体\">请求头：Content-Type:multipart/form-data;boundary=----WebKitFormBoundaryDCntfiXcSkPhS4PN表示本次请求要上传文件，其中boundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由———XXX开始，以———XXX结尾。消息体-FormData部分每一个表单项又由Content-Type和Content-Disposition组成。Content-Disposition:form-data为固定值，表示一个表单元素，name表示表单元素的名称，回车换行后面就是name的值，如果是上传文件就是文件的二进制内容。Content-Type：表示当前的内容的MIME类型，是图片还是文本还是二进制数据。解析客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪是普通表单哪些是附件。可能大家马上能想到通过正则或者字符串处理分割出内容，不过这样是行不通的，二进制buffer转化为string,对字符串进行截取后，其索引和字符串是不一致的，所以结果就不会正确，除非上传的就是字符串。不过一般情况下不需要自行解析，目前已经有很成熟的三方库可以使用。至于如何解析，这个也会占用很大篇幅，后面的文章在详细说。最原始的文件上传使用form表单上传文件在ie时代，如果实现一个无刷新的文件上传那可是费老劲了，大部分都是用iframe来实现局部刷新或者使用flash插件来搞定，在那个时代ie就是最好用的浏览器（别无选择）。DEMO\">这种方式上传文件，不需要js，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。HTML\"post\"action=\"http://localhost:8100\"enctype=\"multipart/form-data\">选择文件:type=\"file\"name=\"f1\"/>input必须设置name属性，否则数据无法发送标题：type=\"text\"name=\"title\"/>type=\"submit\"id=\"btn-0\">上传复制代码文件上传接口服务端文件的保存基于现有的库koa-body结合koa2实现服务端文件的保存和数据的返回。在项目开发中，文件上传本身和业务无关，代码基本上都可通用。在这里我们使用koa-body库来实现解析和文件的保存。koa-body会自动保存文件到系统临时目录下，也可以指定保存的文件路径。\">然后在后续中间件内得到已保存的文件的信息，再做二次处理。ctx.request.files.f1得到文件信息，f1为inputfile标签的name获得文件的扩展名，重命名文件NODE/***服务入口*/varhttp=require('http');varkoaStatic=require('koa-static');varpath=require('path');varkoaBody=require('koa-body');//文件保存库varfs=require('fs');varKoa=require('koa2');varapp=newKoa();varport=process.env.PORT||'8100';varuploadHost=`http://localhost:${port}/uploads/`;app.use(koaBody({formidable:{//设置文件的默认保存目录，不设置则保存在系统临时目录下osuploadDir:path.resolve(__dirname,'../static/uploads')},multipart:true//开启文件上传，默认是关闭}));//开启静态文件访问app.use(koaStatic(path.resolve(__dirname,'../static')));//文件二次处理，修改名称app.use((ctx)=>{varfile=ctx.request.files.f1;//得道文件对象varpath=file.path;varfname=file.name;//原文件名称varnextPath=path+fname;if(file.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);}//以json形式输出上传文件地址ctx.body=`{\"fileUrl\":\"${uploadHost}${nextPath.slice(nextPath.lastIndexOf('/')+1)}\"}`;});/***httpserver*/varserver=http.createServer(app.callback());server.listen(port);console.log('demo1serverstart......');复制代码CODEgithub.com/Bigerfe/fe-…多文件上传在ie时代的多文件上传是需要创建多个inputfile标签，现在html5只需要一个标签加个属性就搞定了,file标签开启multiple。DEMO\">HTML//设置multiple属性type=\"file\"name=\"f1\"multiple/>复制代码NODE服务端也需要进行简单的调整，由单文件对象变为多文件数组，然后进行遍历处理。//二次处理文件，修改名称app.use((ctx)=>{varfiles=ctx.request.files.f1;//多文件，得到上传文件的数组varresult=[];//遍历处理files&&files.forEach(item=>{varpath=item.path;varfname=item.name;//原文件名称varnextPath=path+fname;if(item.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);//文件可访问路径放入数组result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf('/')+1));}});//输出json结果ctx.body=`{\"fileUrl\":${JSON.stringify(result)}}`;})复制代码CODEgithub.com/Bigerfe/fe-…局部刷新-iframe这里说的是在ie时代的上传文件局部刷新，借助iframe实现。DEMO\">局部刷新页面内放一个隐藏的iframe，或者使用js动态创建，指定form表单的target属性值为iframe标签的name属性值，这样form表单的shubmit行为的跳转就会在iframe内完成，整体页面不会刷新。拿到接口数据然后为iframe添加load事件，得到iframe的页面内容，将结果转换为JSON对象，这样就拿到了接口的数据HTML\"temp-iframe\"name=\"temp-iframe\"src=\"\"style=\"display:none;\">\"post\"target=\"temp-iframe\"action=\"http://localhost:8100\"enctype=\"multipart/form-data\">选择文件(可多选):type=\"file\"name=\"f1\"id=\"f1\"multiple/>input必须设置name属性，否则数据无法发送标题：type=\"text\"name=\"title\"/>type=\"submit\"id=\"btn-0\">上传variframe=document.getElementById('temp-iframe');iframe.addEventListener('load',function(){varresult=iframe.contentWindow.document.body.innerText;//接口数据转换为JSON对象varobj=JSON.parse(result);if(obj&&obj.fileUrl.length){alert('上传成功');}console.log(obj);});复制代码NODE服务端代码不需要改动，略.CODEgithub.com/Bigerfe/fe-…无刷新上传无刷新上传文件肯定要用到XMLHttpRequest,在ie时代也有这个对象，单只支持文本数据的传输，无法用来读取和上传二进制数据。现在已然升级到了XMLHttpRequest2，较1版本有非常大的升级，首先就是可以读取和上传二进制数据，可以使用·FormData·对象管理表单数据。当然也可使用fetch进行上传。DEMO\">HTML选择文件(可多选):type=\"file\"id=\"f1\"multiple/>type=\"button\"id=\"btn-submit\">上传复制代码JSxhrfunctionsubmitUpload(){//获得文件列表，注意这里不是数组，而是对象varfileList=document.getElementById('f1').files;if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象fd.append('title',document.getElementById('title').value);//多文件上传需要遍历添加到fromdata对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(this.readyState==4&&this.status==200){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){alert('上传成功');}}}}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码JSFetchfetch('http://localhost:8100/',{method:'POST',body:fd}).then(response=>response.json()).then(response=>{console.log(response);if(response.fileUrl.length){alert('上传成功');}}).catch(error=>console.error('Error:',error));复制代码CODEgithub.com/Bigerfe/fe-…多文件，单进度借助XMLHttpRequest2的能力，实现多个文件或者一个文件的上传进度条的显示。DEMO\">说明页面内增加一个用于显示进度的标签div.progressjs内处理增加进度处理的监听函数xhr.upload.onprogressevent.lengthComputable这是一个状态，表示发送的长度有了变化，可计算event.loaded表示发送了多少字节event.total表示文件总大小根据event.loaded和event.total计算进度，渲染div.progressPS特别提醒xhr.upload.onprogress要写在xhr.send方法前面，否则event.lengthComputable状态不会改变，只有在最后一次才能获得，也就是100%的时候.HTML选择文件(可多选):type=\"file\"id=\"f1\"multiple/>\"progress\">\"red\">type=\"button\"id=\"btn-submit\">上传复制代码JSfunctionsubmitUpload(){varprogressSpan=document.getElementById('progress').firstElementChild;varfileList=document.getElementById('f1').files;progressSpan.style.width='0';progressSpan.classList.remove('green');if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象fd.append('title',document.getElementById('title').value);for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://10.70.65.235:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(xhr.readyState==4){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){//alert('上传成功');}}}xhr.onprogress=updateProgress;xhr.upload.onprogress=updateProgress;functionupdateProgress(event){console.log(event);if(event.lengthComputable){varcompletedPercent=(event.loaded/event.total*100).toFixed(2);progressSpan.style.width=completedPercent+'%';progressSpan.innerHTML=completedPercent+'%';if(completedPercent>90){//进度条变色progressSpan.classList.add('green');}console.log('已上传',completedPercent);}}//注意send一定要写在最下面，否则onprogress只会执行最后一次也就是100%的时候xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码CODEgithub.com/Bigerfe/fe-…多文件上传+预览+取消上一个栗子的多文件上传只有一个进度条，有些需求可能会不大一样，需要观察到每个文件的上传进度，并且可以终止上传。DEMO\">说明为了预览的需要，我们这里选择上传图片文件，其他类型的也一样，只是预览不方便页面内增加一个多图预览的容器div.img-box根据选择的文件信息动态创建所属的预览区域和进度条以及取消按钮为取消按钮绑定事件，调用xhr.abort();终止上传使用window.URL.createObjectURL预览图片，在图片加载成功后需要清除使用的内存window.URL.revokeObjectURL(this.src);HTML选择文件(可多选):\"addfile\">添加文件type=\"file\"id=\"f1\"multiple/>\"img-box\">type=\"button\"id=\"btn-submit\">上传复制代码JS//更改网络为慢3g，就可以比较明显的看到进度条了varfileMaxCount=6;varimgBox=document.getElementsByClassName('img-box')[0];varwillUploadFile=[];//保存待上传的文件以及相关附属信息document.getElementById('f1').addEventListener('change',function(e){varfileList=document.getElementById('f1').files;if(willUploadFile.length>fileMaxCount||fileList.length>fileMaxCount||(willUploadFile.length+fileList.length>fileMaxCount)){alert('最多只能上传'+fileMaxCount+'张图');return;}for(vari=0;i<fileList.length;i++){varf=fileList[i];//先预览图片varimg=document.createElement('img');varitem=document.createElement('div');varprogress=document.createElement('div');progress.className='progress';progress.innerHTML='Abort';item.className='item';img.src=window.URL.createObjectURL(f);img.onload=function(){//显示要是否这块儿内存window.URL.revokeObjectURL(this.src);}item.appendChild(img);item.appendChild(progress);imgBox.appendChild(item);willUploadFile.push({file:f,item,progress});}});functionxhrSend({file,progress}){varprogressSpan=progress.firstElementChild;varbtnCancel=progress.getElementsByTagName('button')[0];btnCancel.removeEventListener('click',function(e){});btnCancel.addEventListener('click',function(e){if(xhr&&xhr.readyState!==4){//取消上传xhr.abort();}});progressSpan.style.width='0';progressSpan.classList.remove('green');varfd=newFormData();//构造FormData对象fd.append('f1',file);varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);//调用abort后，state立即变成了4,并不会变成0//增加自定义属性xhr.uploadedif(xhr.readyState==4&&xhr.uploaded){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){//alert('上传成功');}}}xhr.onprogress=updateProgress;xhr.upload.onprogress=updateProgress;functionupdateProgress(event){if(event.lengthComputable){varcompletedPercent=(event.loaded/event.total*100).toFixed(2);progressSpan.style.width=completedPercent+'%';progressSpan.innerHTML=completedPercent+'%';if(completedPercent>90){//进度条变色progressSpan.classList.add('green');}if(completedPercent>=100){xhr.uploaded=true;}console.log('已上传',completedPercent);}}//注意send一定要写在最下面，否则onprogress只会执行最后一次也就是100%的时候xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;returnxhr;}//文件上传functionsubmitUpload(willFiles){if(!willFiles.length){return;}//遍历文件信息进行上传willFiles.forEach(function(item){xhrSend({file:item.file,progress:item.progress});});}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',function(){submitUpload(willUploadFile);});复制代码问题1这里没有做上传的并发控制，可以通过控制同时可上传文件的个数（这里控制为最多6个）或者上传的时候做好并发处理，也就是同时只能上传X个文件。问题2在测试过程中，取消请求的方法xhr.abort()调用后，xhr.readyState会立即变为4,而不是0，所以这里需要做容错处理。MDN上说是0.\">如果大家有不同的结果，欢迎留言。CODEgithub.com/Bigerfe/fe-…拖拽上传html5的出现，让拖拽上传交互成为可能，现在这样的体验也屡见不鲜。DEMO\">说明定义一个允许拖放文件的区域div.drop-box取消drop事件的默认行为e.preventDefault();，不然浏览器会直接打开文件为拖拽区域绑定事件,鼠标在拖拽区域上dragover,鼠标离开拖拽区域dragleave,在拖拽区域上释放文件dropdrop事件内获得文件信息e.dataTransfer.filesHTML\"drop-box\"id=\"drop-box\">拖动文件到这里,开始上传type=\"button\"id=\"btn-submit\">上传复制代码JSvarbox=document.getElementById('drop-box');//禁用浏览器的拖放默认行为document.addEventListener('drop',function(e){console.log('documentdrog');e.preventDefault();});//设置拖拽事件functionopenDropEvent(){box.addEventListener(\"dragover\",function(e){console.log('elemenetdragover');box.classList.add('over');e.preventDefault();});box.addEventListener(\"dragleave\",function(e){console.log('elemenetdragleave');box.classList.remove('over');e.preventDefault();});box.addEventListener(\"drop\",function(e){e.preventDefault();//取消浏览器默认拖拽效果varfileList=e.dataTransfer.files;//获取拖拽中的文件对象varlen=fileList.length;//用来获取文件的长度（其实是获得文件数量）//检测是否是拖拽文件到页面的操作if(!len){box.classList.remove('over');return;}box.classList.add('over');window.willUploadFileList=fileList;},false);}openDropEvent();functionsubmitUpload(){varfileList=window.willUploadFileList||[];if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){if(xhr.readyState==4){varobj=JSON.parse(xhr.responseText);//返回值if(obj.fileUrl.length){alert('上传成功');}}}xhr.send(fd);//发送}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码CODEgithub.com/Bigerfe/fe-…剪贴板上传掘金的写文编辑器是支持粘贴上传图片的，比如我从磁盘粘贴或者从网页上右键复制图片。DEMO\">说明页面内增加一个可编辑的编辑区域div.editor-box,开启contenteditable为div.editor-box绑定paste事件处理paste事件，从event.clipboardData||window.clipboardData获得数据将数据转换为文件items[i].getAsFile()实现在编辑区域的光标处插入内容insertNodeToEditor方法问题1测试中发现复制多个文件无效，只有最后一个文件上传，在掘金的编辑器里也同样存在，在坐有知道原因的可以留言说下。问题2mac系统可以支持从磁盘复制文件后上传，windows系统测试未通过，剪贴板的数据未拿到。HTML\"editor-box\"id=\"editor-box\"contenteditable=\"true\">可以直接粘贴图片到这里直接上传复制代码JS//光标处插入dom节点functioninsertNodeToEditor(editor,ele){//插入dom节点varrange;//记录光标位置对象varnode=window.getSelection().anchorNode;//这里判断是做是否有光标判断，因为弹出框默认是没有的if(node!=null){range=window.getSelection().getRangeAt(0);//获取光标起始位置range.insertNode(ele);//在光标位置插入该对象}else{editor.append(ele);}}varbox=document.getElementById('editor-box');//绑定paste事件box.addEventListener('paste',function(event){vardata=(event.clipboardData||window.clipboardData);varitems=data.items;varfileList=[];//存储文件数据if(items&&items.length){//检索剪切板itemsfor(vari=0;i<items.length;i++){console.log(items[i].getAsFile());fileList.push(items[i].getAsFile());}}window.willUploadFileList=fileList;event.preventDefault();//阻止默认行为submitUpload();});functionsubmitUpload(){varfileList=window.willUploadFileList||[];varfd=newFormData();//构造FormData对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){if(xhr.readyState===4){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){varimg=document.createElement('img');img.src=obj.fileUrl[0];img.style.width='100px';insertNodeToEditor(box,img);//alert('上传成功');}}}xhr.send(fd);//发送}复制代码CODEgithub.com/Bigerfe/fe-…大文件上传-分片在ie时代由于无法使用xhr上传二进制数据，上传大文件需要借助浏览器插件来完成。现在来看实现大文件上传简直soeasy。如果太大的文件，比如一个视频1g2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分比如2M。DEMO\">\">说明相信大家都对Blob对象有所了解，它表示原始数据,也就是二进制数据，同时提供了对数据截取的方法slice,而File继承了Blob的功能，所以可以直接使用此方法对数据进行分段截图。把大文件进行分段比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件服务端保存各段文件浏览器端所有分片上传完成，发送给服务端一个合并文件的请求服务端根据文件标识、类型、各分片顺序进行文件合并删除分片文件HTML代码略，只需要一个inputfile标签。JS//分片逻辑像操作字符串一样varstart=0,end=0;while(true){end+=chunkSize;varblob=file.slice(start,end);start+=chunkSize;if(!blob.size){//截取的数据为空则结束//拆分结束break;}chunks.push(blob);//保存分段数据}functionsubmitUpload(){varchunkSize=2*1024*1024;//分片大小2Mvarfile=document.getElementById('f1').files[0];varchunks=[],//保存分片数据token=(+newDate()),//时间戳name=file.name,chunkCount=0,sendChunkCount=0;//拆分文件像操作字符串一样if(file.size>chunkSize){//拆分文件varstart=0,end=0;while(true){end+=chunkSize;varblob=file.slice(start,end);start+=chunkSize;if(!blob.size){//截取的数据为空则结束//拆分结束break;}chunks.push(blob);//保存分段数据}}else{chunks.push(file.slice(0));}chunkCount=chunks.length;//分片的个数//没有做并发限制，较大文件导致并发过多，tcp链接被占光，需要做下并发控制，比如只有4个在请求在发送for(vari=0;i<chunkCount;i++){varfd=newFormData();//构造FormData对象fd.append('token',token);fd.append('f1',chunks[i]);fd.append('index',i);xhrSend(fd,function(){sendChunkCount+=1;if(sendChunkCount===chunkCount){//上传完成，发送合并请求console.log('上传完成，发送合并请求');varformD=newFormData();formD.append('type','merge');formD.append('token',token);formD.append('chunkCount',chunkCount);formD.append('filename',name);xhrSend(formD);}});}}functionxhrSend(fd,cb){varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(xhr.readyState==4){console.log(xhr.responseText);cb&&cb();}}xhr.send(fd);//发送}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码NODE服务端需要做一些改动，保存分片文件、合并分段文件、删除分段文件。PS合并文件这里使用streampipe实现，这样更节省内存，边读边写入，占用内存更小，效率更高，代码见fnMergeFile方法。//二次处理文件，修改名称app.use((ctx)=>{varbody=ctx.request.body;varfiles=ctx.request.files?ctx.request.files.f1:[];//得到上传文件的数组varresult=[];varfileToken=ctx.request.body.token;//文件标识varfileIndex=ctx.request.body.index;//文件顺序if(files&&!Array.isArray(files)){//单文件上传容错files=[files];}files&&files.forEach(item=>{varpath=item.path;varfname=item.name;//原文件名称varnextPath=path.slice(0,path.lastIndexOf('/')+1)+fileIndex+'-'+fileToken;if(item.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];//varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf('/')+1));}});if(body.type==='merge'){//合并分片文件varfilename=body.filename,chunkCount=body.chunkCount,folder=path.resolve(__dirname,'../static/uploads')+'/';varwriteStream=fs.createWriteStream(`${folder}${filename}`);varcindex=0;//合并文件functionfnMergeFile(){varfname=`${folder}${cindex}-${fileToken}`;varreadStream=fs.createReadStream(fname);readStream.pipe(writeStream,{end:false});readStream.on(\"end\",function(){fs.unlink(fname,function(err){if(err){throwerr;}});if(cindex+1<chunkCount){cindex+=1;fnMergeFile();}});}fnMergeFile();ctx.body='mergeok200';}});复制代码CODEgithub.com/Bigerfe/fe-…大文件上传-断点续传在上面我们实现了大文件的分片上传，解决了大文件上传超时和服务器的限制。但是仍然不够完美，大文件上传并不是短时间内就上传完成，如果期间断网，页面刷新了仍然需要重头上传。方法1基于上面一个栗子进行改进，服务端已保存了部分片段，重新上传的时候，服务端对当前的分段进行对比，只接收本地没有的分段，前提是分段大小一致。在上面为了方便，使用了时间戳作为这个文件的标志，其实可以使用spark-md5来生成文件的hash值，这样服务器就可以进行文件的对比了。但是不好的地方是每个分段都要重新发送请求。方法2-断点续传方法1中，重新上传时请求和数据还会发到服务器，其实已上传的分段就不应该再发送到服务器了，所以我们可以使用断点续传来进行改进。为每个分段生成hash值，使用spark-md5库将上传成功的分段信息保存到本地重新上传时，进行和本地分段hash值的对比，如果相同的话则跳过，继续下一个分段的上传PS生成hash过程肯定也会耗费资源，但是和重新上传相比可以忽略不计了。DEMO\">\">HTML代码略复制代码JS模拟分段保存，本地保存到localStorage//获得本地缓存的数据functiongetUploadedFromStorage(){returnJSON.parse(localStorage.getItem(saveChunkKey)||\"{}\");}//写入缓存functionsetUploadedToStorage(index){varobj=getUploadedFromStorage();obj[index]=true;localStorage.setItem(saveChunkKey,JSON.stringify(obj));}//分段对比varuploadedInfo=getUploadedFromStorage();//获得已上传的分段信息for(vari=0;i<chunkCount;i++){console.log('index',i,uploadedInfo[i]?'已上传过':'未上传');if(uploadedInfo[i]){//对比分段sendChunkCount=i+1;//记录已上传的索引continue;//如果已上传则跳过}varfd=newFormData();//构造FormData对象fd.append('token',token);fd.append('f1',chunks[i]);fd.append('index',i);(function(index){xhrSend(fd,function(){sendChunkCount+=1;//将成功信息保存到本地setUploadedToStorage(index);if(sendChunkCount===chunkCount){console.log('上传完成，发送合并请求');varformD=newFormData();formD.append('type','merge');formD.append('token',token);formD.append('chunkCount',chunkCount);formD.append('filename',name);xhrSend(formD);}});})(i);}复制代码node端上传图片不只会从客户端上传文件到服务器，服务器也会上传文件到其他服务器。读取文件bufferfs构建form-dataform-data上传文件node-fetchNODE/***filepath=相对根目录的路径即可*/asyncfunctiongetFileBufer(filePath)=>{returnnewPromise((resolve)=>{fs.readFile(filePath,function(err,data){varbufer=null;if(!err){resolve({err:err,data:data});}});});}/***上传文件*/letfetch=require('node-fetch');letformData=require('form-data');module.exports=async(options)=>{let{imgPath}=options;letdata=awaitgetFileBufer(imgPath);if(data.err){returnnull;}letform=newformData();form.append('xxx',xxx);form.append('pic',data.data);returnfetch('http://xx.com/upload',{body:form,method:'POST',headers:form.getHeaders()//要活的form-data的头，否则无法上传}).then(res=>{returnres.json();}).then(data=>{returndata;})}复制代码其他在浏览器端对文件的类型、大小、尺寸进行判断file.type判断类型file.size判断大小通过动态创建img标签，图片加载后获得尺寸,naturalWidthnaturalHeightorwidthheightJSvarfile=document.getElementById('f1').files[0];//判断类型if(f.type!=='image/jpeg'&&f.type!=='image/jpg'){alert('只能上传jpg图片');flag=false;break;}//判断大小if(file.size>100*1024){alert('不能大于100kb');}//判断图片尺寸varimg=newImage();img.onload=function(){console.log('图片原始大小width*height',this.width,this.height);if(this.naturalWidth){console.log('图片原始大小naturalWidth*naturalHeight',this.naturalWidth,this.naturalHeight);}else{console.log('oImg.width*height',this.width,this.height);}}复制代码inputfile外观更改由于inputfile的外观比较传统，很多地方都需要进行美化。定义好一个外观，然后将fileinput定位到该元素上，让他的透明度为0。使用label标签for=\"file\">Choosefiletouploadtype=\"file\"id=\"file\"name=\"file\"multiple>复制代码隐藏inputfile标签，然后调用input元素的click方法PSfile标签隐藏后在ie下无法获得文件内容，建议还是方法1兼容性强。源码在这里以上代码均已上传githubgithub.com/Bigerfe/fe-…参考资料developer.mozilla.org/zh-CN/docs/…developer.mozilla.org/zh-CN/docs/…cloud.tencent.com/developer/n…最后希望本文可以给你带了一些帮助，文中如有错误，欢迎在评论区指。如果这篇文章帮助到了你，欢迎点赞和关注。推荐关注我的微信公众号【前端张大胖】，每天推送高质量文章和自学经验和心得，我们一起交流成长。\">其他你对SSR有兴趣吗？如果你对服务端渲染ssr技术有兴趣，可以关注我的开源项目：Zz.jsgithub:github.com/Bigerfe/koa…官网：zz.bigerfe.com/SSR技术原理juejin.im/post/5d7dee…",
      "time": "2019年10月17日"
    },
    {
      "source": "掘金",
      "id": "1qdz9bgvyjgg",
      "author": "裂泉",
      "title": "(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)",
      "content": "笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！第一篇:JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在JS中，存在着7种原始值，分别是：booleannullundefinednumberstringsymbolbigint引用数据类型:对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math）函数Function2.说出下面运行的结果，解释原因。functiontest(person){person.age=26person={name:'hzj',age:18}returnperson}constp1={name:'fyq',age:19}constp2=test(p1)console.log(p1)//->?console.log(p2)//->?复制代码结果:p1：{name:“fyq”,age:26}p2：{name:“hzj”,age:18}复制代码原因:在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age=26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。3.null是对象吗？为什么？结论:null不是对象。解释:虽然typeofnull会输出object，但是这只是JS存在的一个悠久Bug。在JS的最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象然而null表示为全零，所以将它错误的判断为object。4.'1'.toString()为什么可以调用？其实在这个语句运行的过程中做了这样几件事情：vars=newString('1');s.toString();s=null;复制代码第一步:创建String类实例。第二步:调用实例方法。第三步:执行完方法立即销毁这个实例。整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean,Number和String。参考:《JavaScript高级程序设计(第三版)》P1185.0.1+0.2为什么不等于0.3？0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。6.如何理解BigInt?什么是BigInt?BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。为什么需要BigInt?在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。console.log(999999999999999);//=>10000000000000000复制代码同时也会有一定的安全性问题:9007199254740992===9007199254740993;//→true居然是true!复制代码如何创建并使用BigInt？要创建BigInt，只需要在数字末尾追加n即可。console.log(9007199254740995n);//→9007199254740995nconsole.log(9007199254740995);//→9007199254740996复制代码另一种创建BigInt的方法是用BigInt()构造函数、BigInt(\"9007199254740995\");//→9007199254740995n复制代码简单使用如下:10n+20n;//→30n10n-20n;//→-10n+10n;//→TypeError:CannotconvertaBigIntvaluetoanumber-10n;//→-10n10n*20n;//→200n20n/10n;//→2n23n%10n;//→3n10n**3n;//→1000nconstx=10n;++x;//→11n--x;//→9nconsole.log(typeofx);//\"bigint\"复制代码值得警惕的点BigInt不支持一元加号运算符,这可能是某些程序可能依赖于+始终生成Number的不变量，或者抛出异常。另外，更改+的行为也会破坏asm.js代码。因为隐式类型转换可能丢失信息，所以不允许在bigint和Number之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。10+10n;//→TypeError复制代码不能将BigInt传递给Webapi和内置的JS函数，这些函数需要一个Number类型的数字。尝试这样做会报TypeError错误。Math.max(2n,4n,6n);//→TypeError复制代码当Boolean类型与BigInt类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。if(0n){//条件判断为false}if(3n){//条件为true}复制代码元素都为BigInt的数组可以进行sort。BigInt可以正常地进行位运算，如|、&、<<、>>和^浏览器兼容性caniuse的结果:\">其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。我们期待BigInt的光明前途！第二篇:JS数据类型之问——检测篇1.typeof是否能正确判断类型？对于原始类型来说，除了null都可以调用typeof显示正确的类型。typeof1//'number'typeof'1'//'string'typeofundefined//'undefined'typeoftrue//'boolean'typeofSymbol()//'symbol'复制代码但对于引用数据类型，除了函数之外，都会显示\"object\"。typeof[]//'object'typeof{}//'object'typeofconsole.log//'function'复制代码因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为trueconstPerson=function(){}constp1=newPerson()p1instanceofPerson//truevarstr1='helloworld'str1instanceofString//falsevarstr2=newString('helloworld')str2instanceofString//true复制代码2.instanceof能否判断基本数据类型？能。比如下面这种方式:classPrimitiveNumber{static[Symbol.hasInstance](x){returntypeofx==='number'}}console.log(111instanceofPrimitiveNumber)//true复制代码如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。3.能不能手动实现一下instanceof的功能？核心:原型链的向上查找。functionmyInstanceof(left,right){//基本数据类型直接返回falseif(typeofleft!=='object'||left===null)returnfalse;//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象letproto=Object.getPrototypeOf(left);while(true){//查找到尽头，还没找到if(proto==null)returnfalse;//找到相同的原型对象if(proto==right.prototype)returntrue;proto=Object.getPrototypeof(proto);}}复制代码测试:console.log(myInstanceof(\"111\",String));//falseconsole.log(myInstanceof(newString(\"111\"),String));//true复制代码4.Object.is和===的区别？Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。源码如下：functionis(x,y){if(x===y){//运行到1/x===1/y的时候x和y都为0，但是1/+0=+Infinity，1/-0=-Infinity,是不一样的returnx!==0||y!==0||1/x===1/y;}else{//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x!==x，那么一定是NaN,y同理//两个都是NaN的时候返回truereturnx!==x&&y!==y;}复制代码第三篇:JS数据类型之问——转换篇1.[]==![]结果是什么？为什么？解析:==中，左右两边都需要转换为数字然后进行比较。[]转换为数字为0。![]首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,因此![]为false，进而在转换成数字，变为0。0==0，结果为true2.JS中类型转换有哪几种？JS中，类型转换只有三种：转换成数字转换成布尔值转换成字符串转换具体规则如下:注意\"Boolean转字符串\"这行结果指的是true转字符串的例子\">3.==和===有什么区别？===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false判断的是否是null和undefined，是的话就返回true判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较console.log({a:1}==true);//falseconsole.log({a:1}==\"[objectObject]\");//true复制代码4.对象转原始类型是根据什么流程运行的？对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：如果Symbol.toPrimitive()方法，优先调用再返回调用valueOf()，如果转换为原始类型，则返回调用toString()，如果转换为原始类型，则返回如果都没有返回原始类型，会报错varobj={value:3,valueOf(){return4;},toString(){return'5'},[Symbol.toPrimitive](){return6}}console.log(obj+1);//输出7复制代码5.如何让if(a==1&&a==2)条件成立？其实就是上一个问题的应用。vara={value:0,valueOf:function(){this.value++;returnthis.value;}};console.log(a==1&&a==2);//true复制代码第四篇:谈谈你对闭包的理解什么是闭包？红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，MDN对闭包的定义为：闭包是指那些能够访问自由变量的函数。（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）闭包产生的原因?首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。比如:vara=1;functionf1(){vara=2functionf2(){vara=3;console.log(a);//3}}复制代码在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:functionf1(){vara=2functionf2(){console.log(a);//2}returnf2;}varx=f1();x();复制代码这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。那是不是只有返回函数才算是产生了闭包呢？、回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：varf3;functionf1(){vara=2f3=function(){console.log(a);}}f1();f3();复制代码让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。闭包有哪些表现形式?明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？返回一个函数。刚刚已经举例。作为函数参数传递vara=1;functionfoo(){vara=2;functionbaz(){console.log(a);}bar(baz);}functionbar(fn){//这就是闭包fn();}//输出2，而不是1foo();复制代码在定时器、事件监听、Ajax请求、跨窗口通信、WebWorkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。以下的闭包保存的仅仅是window和当前作用域。//定时器setTimeout(functiontimeHandler(){console.log('111');}，100)//事件监听$('#app').click(function(){console.log('DOMListener');})复制代码IIFE(立即执行函数表达式)创建闭包,保存了全局作用域window和当前函数的作用域，因此可以全局的变量。vara=2;(functionIIFE(){//输出2console.log(a);})();复制代码如何解决下面的循环输出问题？for(vari=1;i<=5;i++){setTimeout(functiontimer(){console.log(i)},0)}复制代码为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。解决方法：1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中for(vari=1;i<=5;i++){(function(j){setTimeout(functiontimer(){console.log(j)},0)})(i)}复制代码2、给定时器传入第三个参数,作为timer函数的第一个函数参数for(vari=1;i<=5;i++){setTimeout(functiontimer(j){console.log(j)},0,i)}复制代码3、使用ES6中的letfor(leti=1;i<=5;i++){setTimeout(functiontimer(){console.log(i)},0)}复制代码let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例://i=1{setTimeout(functiontimer(){console.log(1)},0)}//i=2{setTimeout(functiontimer(){console.log(2)},0)}//i=3...复制代码因此能输出正确的结果。第五篇:谈谈你对原型链的理解1.原型对象和构造函数有何关系？在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。\">2.能不能描述一下原型链？JavaScript对象通过prototype指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条,即原型链。\">对象的hasOwnProperty()来检查对象自身中是否含有该属性使用in检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回true第六篇:JS如何实现继承？第一种:借助callfunctionParent1(){this.name='parent1';}functionChild1(){Parent1.call(this);this.type='child1'}console.log(newChild1);复制代码这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。第二种:借助原型链functionParent2(){this.name='parent2';this.play=[1,2,3]}functionChild2(){this.type='child2';}Child2.prototype=newParent2();console.log(newChild2());复制代码看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：vars1=newChild2();vars2=newChild2();s1.play.push(4);console.log(s1.play,s2.play);复制代码可以看到控制台：\">明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。那么还有更好的方式么？第三种：将前两种组合functionParent3(){this.name='parent3';this.play=[1,2,3];}functionChild3(){Parent3.call(this);this.type='child3';}Child3.prototype=newParent3();vars3=newChild3();vars4=newChild3();s3.play.push(4);console.log(s3.play,s4.play);复制代码可以看到控制台：\">之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype=newParent3();）。这是我们不愿看到的。那么如何解决这个问题？第四种:组合继承的优化1functionParent4(){this.name='parent4';this.play=[1,2,3];}functionChild4(){Parent4.call(this);this.type='child4';}Child4.prototype=Parent4.prototype;复制代码这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：vars3=newChild4();vars4=newChild4();console.log(s3)复制代码\">子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。第五种(最推荐使用):组合继承的优化1functionParent5(){this.name='parent5';this.play=[1,2,3];}functionChild5(){Parent5.call(this);this.type='child5';}Child5.prototype=Object.create(Parent5.prototype);Child5.prototype.constructor=Child5;复制代码这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。ES6的extends被编译后的JavaScript代码ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。那最后编译成了什么样子呢？function_possibleConstructorReturn(self,call){//...returncall&&(typeofcall==='object'||typeofcall==='function')?call:self;}function_inherits(subClass,superClass){//...//看到没有subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}varParent=functionParent(){//验证是否是Parent构造出来的this_classCallCheck(this,Parent);};varChild=(function(_Parent){_inherits(Child,_Parent);functionChild(){_classCallCheck(this,Child);return_possibleConstructorReturn(this,(Child.__proto__||Object.getPrototypeOf(Child)).apply(this,arguments));}returnChild;}(Parent));复制代码核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass,superClass)，这是用来干啥的呢？答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。追问:面向对象的设计一定是好的设计吗？不一定。从继承的角度说，这一设计是存在巨大隐患的。从设计思想上谈谈继承本身的问题假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。classCar{constructor(id){this.id=id;}drive(){console.log(\"wuwuwu!\");}music(){console.log(\"lalala!\")}addOil(){console.log(\"哦哟！\")}}classotherCarextendsCar{}复制代码现在可以实现车的功能，并且以此去扩展不同的车。但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。如果让新能源汽车的类继承Car的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。那如何来解决继承的诸多问题呢？用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。functiondrive(){console.log(\"wuwuwu!\");}functionmusic(){console.log(\"lalala!\")}functionaddOil(){console.log(\"哦哟！\")}letcar=compose(drive,music,addOil);letnewEnergyCar=compose(drive,music);复制代码代码干净，复用性也很好。这就是面向组合的设计方式。参考出处:ES5实现继承那些事重学JS系列:聊聊继承JS最新基本数据类型:BigInt(译)yck前端面试之道更多有趣内容见微信公众号:\">",
      "time": "2019年10月21日"
    }
  ],
  "hotResList": [
    {
      "detail": "写在前面今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。这篇文章比较基础，在国庆期间的业余时间写的，这几天又完善了下，力求把更多的前端所涉及到的关于文件上传的各种场景和应用都涵盖了,若有疏漏和问题还请留言斧正和补充。自测读不读以下是本文所涉及到的知识点，breakorcontinue?文件上传原理最原始的文件上传使用koa2作为服务端写一个文件上传接口单文..."
    },
    {
      "detail": "笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！第一篇:JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在JS中，存在着7种原始值，分别是：booleannullundefinednumberstringsymbolbigint引用数据类型:对象Object（包含..."
    }
  ]
}