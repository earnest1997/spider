{
  "searchResList": [],
  "hotArticleDetailList": [
    {
      "content": "写在前面今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。这篇文章比较基础，在国庆期间的业余时间写的，这几天又完善了下，力求把更多的前端所涉及到的关于文件上传的各种场景和应用都涵盖了,若有疏漏和问题还请留言斧正和补充。自测读不读以下是本文所涉及到的知识点，breakorcontinue?文件上传原理最原始的文件上传使用koa2作为服务端写一个文件上传接口单文件上传和上传进度多文件上传和上传进度拖拽上传剪贴板上传大文件上传之分片上传大文件上传之断点续传node端文件上传原理概述原理很简单，就是根据http协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件。我们都知道如果要上传一个文件，需要把form标签的enctype设置为multipart/form-data,同时method必须为post方法。那么multipart/form-data表示什么呢？multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTMLForms和POST方法上传文件，具体的定义可以参考RFC7578。multipart/form-data结构看下http请求的消息体\">请求头：Content-Type:multipart/form-data;boundary=----WebKitFormBoundaryDCntfiXcSkPhS4PN表示本次请求要上传文件，其中boundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由———XXX开始，以———XXX结尾。消息体-FormData部分每一个表单项又由Content-Type和Content-Disposition组成。Content-Disposition:form-data为固定值，表示一个表单元素，name表示表单元素的名称，回车换行后面就是name的值，如果是上传文件就是文件的二进制内容。Content-Type：表示当前的内容的MIME类型，是图片还是文本还是二进制数据。解析客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪是普通表单哪些是附件。可能大家马上能想到通过正则或者字符串处理分割出内容，不过这样是行不通的，二进制buffer转化为string,对字符串进行截取后，其索引和字符串是不一致的，所以结果就不会正确，除非上传的就是字符串。不过一般情况下不需要自行解析，目前已经有很成熟的三方库可以使用。至于如何解析，这个也会占用很大篇幅，后面的文章在详细说。最原始的文件上传使用form表单上传文件在ie时代，如果实现一个无刷新的文件上传那可是费老劲了，大部分都是用iframe来实现局部刷新或者使用flash插件来搞定，在那个时代ie就是最好用的浏览器（别无选择）。DEMO\">这种方式上传文件，不需要js，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。HTML\"post\"action=\"http://localhost:8100\"enctype=\"multipart/form-data\">选择文件:type=\"file\"name=\"f1\"/>input必须设置name属性，否则数据无法发送标题：type=\"text\"name=\"title\"/>type=\"submit\"id=\"btn-0\">上传复制代码文件上传接口服务端文件的保存基于现有的库koa-body结合koa2实现服务端文件的保存和数据的返回。在项目开发中，文件上传本身和业务无关，代码基本上都可通用。在这里我们使用koa-body库来实现解析和文件的保存。koa-body会自动保存文件到系统临时目录下，也可以指定保存的文件路径。\">然后在后续中间件内得到已保存的文件的信息，再做二次处理。ctx.request.files.f1得到文件信息，f1为inputfile标签的name获得文件的扩展名，重命名文件NODE/***服务入口*/varhttp=require('http');varkoaStatic=require('koa-static');varpath=require('path');varkoaBody=require('koa-body');//文件保存库varfs=require('fs');varKoa=require('koa2');varapp=newKoa();varport=process.env.PORT||'8100';varuploadHost=`http://localhost:${port}/uploads/`;app.use(koaBody({formidable:{//设置文件的默认保存目录，不设置则保存在系统临时目录下osuploadDir:path.resolve(__dirname,'../static/uploads')},multipart:true//开启文件上传，默认是关闭}));//开启静态文件访问app.use(koaStatic(path.resolve(__dirname,'../static')));//文件二次处理，修改名称app.use((ctx)=>{varfile=ctx.request.files.f1;//得道文件对象varpath=file.path;varfname=file.name;//原文件名称varnextPath=path+fname;if(file.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);}//以json形式输出上传文件地址ctx.body=`{\"fileUrl\":\"${uploadHost}${nextPath.slice(nextPath.lastIndexOf('/')+1)}\"}`;});/***httpserver*/varserver=http.createServer(app.callback());server.listen(port);console.log('demo1serverstart......');复制代码CODEgithub.com/Bigerfe/fe-…多文件上传在ie时代的多文件上传是需要创建多个inputfile标签，现在html5只需要一个标签加个属性就搞定了,file标签开启multiple。DEMO\">HTML//设置multiple属性type=\"file\"name=\"f1\"multiple/>复制代码NODE服务端也需要进行简单的调整，由单文件对象变为多文件数组，然后进行遍历处理。//二次处理文件，修改名称app.use((ctx)=>{varfiles=ctx.request.files.f1;//多文件，得到上传文件的数组varresult=[];//遍历处理files&&files.forEach(item=>{varpath=item.path;varfname=item.name;//原文件名称varnextPath=path+fname;if(item.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);//文件可访问路径放入数组result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf('/')+1));}});//输出json结果ctx.body=`{\"fileUrl\":${JSON.stringify(result)}}`;})复制代码CODEgithub.com/Bigerfe/fe-…局部刷新-iframe这里说的是在ie时代的上传文件局部刷新，借助iframe实现。DEMO\">局部刷新页面内放一个隐藏的iframe，或者使用js动态创建，指定form表单的target属性值为iframe标签的name属性值，这样form表单的shubmit行为的跳转就会在iframe内完成，整体页面不会刷新。拿到接口数据然后为iframe添加load事件，得到iframe的页面内容，将结果转换为JSON对象，这样就拿到了接口的数据HTML\"temp-iframe\"name=\"temp-iframe\"src=\"\"style=\"display:none;\">\"post\"target=\"temp-iframe\"action=\"http://localhost:8100\"enctype=\"multipart/form-data\">选择文件(可多选):type=\"file\"name=\"f1\"id=\"f1\"multiple/>input必须设置name属性，否则数据无法发送标题：type=\"text\"name=\"title\"/>type=\"submit\"id=\"btn-0\">上传variframe=document.getElementById('temp-iframe');iframe.addEventListener('load',function(){varresult=iframe.contentWindow.document.body.innerText;//接口数据转换为JSON对象varobj=JSON.parse(result);if(obj&&obj.fileUrl.length){alert('上传成功');}console.log(obj);});复制代码NODE服务端代码不需要改动，略.CODEgithub.com/Bigerfe/fe-…无刷新上传无刷新上传文件肯定要用到XMLHttpRequest,在ie时代也有这个对象，单只支持文本数据的传输，无法用来读取和上传二进制数据。现在已然升级到了XMLHttpRequest2，较1版本有非常大的升级，首先就是可以读取和上传二进制数据，可以使用·FormData·对象管理表单数据。当然也可使用fetch进行上传。DEMO\">HTML选择文件(可多选):type=\"file\"id=\"f1\"multiple/>type=\"button\"id=\"btn-submit\">上传复制代码JSxhrfunctionsubmitUpload(){//获得文件列表，注意这里不是数组，而是对象varfileList=document.getElementById('f1').files;if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象fd.append('title',document.getElementById('title').value);//多文件上传需要遍历添加到fromdata对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(this.readyState==4&&this.status==200){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){alert('上传成功');}}}}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码JSFetchfetch('http://localhost:8100/',{method:'POST',body:fd}).then(response=>response.json()).then(response=>{console.log(response);if(response.fileUrl.length){alert('上传成功');}}).catch(error=>console.error('Error:',error));复制代码CODEgithub.com/Bigerfe/fe-…多文件，单进度借助XMLHttpRequest2的能力，实现多个文件或者一个文件的上传进度条的显示。DEMO\">说明页面内增加一个用于显示进度的标签div.progressjs内处理增加进度处理的监听函数xhr.upload.onprogressevent.lengthComputable这是一个状态，表示发送的长度有了变化，可计算event.loaded表示发送了多少字节event.total表示文件总大小根据event.loaded和event.total计算进度，渲染div.progressPS特别提醒xhr.upload.onprogress要写在xhr.send方法前面，否则event.lengthComputable状态不会改变，只有在最后一次才能获得，也就是100%的时候.HTML选择文件(可多选):type=\"file\"id=\"f1\"multiple/>\"progress\">\"red\">type=\"button\"id=\"btn-submit\">上传复制代码JSfunctionsubmitUpload(){varprogressSpan=document.getElementById('progress').firstElementChild;varfileList=document.getElementById('f1').files;progressSpan.style.width='0';progressSpan.classList.remove('green');if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象fd.append('title',document.getElementById('title').value);for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://10.70.65.235:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(xhr.readyState==4){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){//alert('上传成功');}}}xhr.onprogress=updateProgress;xhr.upload.onprogress=updateProgress;functionupdateProgress(event){console.log(event);if(event.lengthComputable){varcompletedPercent=(event.loaded/event.total*100).toFixed(2);progressSpan.style.width=completedPercent+'%';progressSpan.innerHTML=completedPercent+'%';if(completedPercent>90){//进度条变色progressSpan.classList.add('green');}console.log('已上传',completedPercent);}}//注意send一定要写在最下面，否则onprogress只会执行最后一次也就是100%的时候xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码CODEgithub.com/Bigerfe/fe-…多文件上传+预览+取消上一个栗子的多文件上传只有一个进度条，有些需求可能会不大一样，需要观察到每个文件的上传进度，并且可以终止上传。DEMO\">说明为了预览的需要，我们这里选择上传图片文件，其他类型的也一样，只是预览不方便页面内增加一个多图预览的容器div.img-box根据选择的文件信息动态创建所属的预览区域和进度条以及取消按钮为取消按钮绑定事件，调用xhr.abort();终止上传使用window.URL.createObjectURL预览图片，在图片加载成功后需要清除使用的内存window.URL.revokeObjectURL(this.src);HTML选择文件(可多选):\"addfile\">添加文件type=\"file\"id=\"f1\"multiple/>\"img-box\">type=\"button\"id=\"btn-submit\">上传复制代码JS//更改网络为慢3g，就可以比较明显的看到进度条了varfileMaxCount=6;varimgBox=document.getElementsByClassName('img-box')[0];varwillUploadFile=[];//保存待上传的文件以及相关附属信息document.getElementById('f1').addEventListener('change',function(e){varfileList=document.getElementById('f1').files;if(willUploadFile.length>fileMaxCount||fileList.length>fileMaxCount||(willUploadFile.length+fileList.length>fileMaxCount)){alert('最多只能上传'+fileMaxCount+'张图');return;}for(vari=0;i<fileList.length;i++){varf=fileList[i];//先预览图片varimg=document.createElement('img');varitem=document.createElement('div');varprogress=document.createElement('div');progress.className='progress';progress.innerHTML='Abort';item.className='item';img.src=window.URL.createObjectURL(f);img.onload=function(){//显示要是否这块儿内存window.URL.revokeObjectURL(this.src);}item.appendChild(img);item.appendChild(progress);imgBox.appendChild(item);willUploadFile.push({file:f,item,progress});}});functionxhrSend({file,progress}){varprogressSpan=progress.firstElementChild;varbtnCancel=progress.getElementsByTagName('button')[0];btnCancel.removeEventListener('click',function(e){});btnCancel.addEventListener('click',function(e){if(xhr&&xhr.readyState!==4){//取消上传xhr.abort();}});progressSpan.style.width='0';progressSpan.classList.remove('green');varfd=newFormData();//构造FormData对象fd.append('f1',file);varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);//调用abort后，state立即变成了4,并不会变成0//增加自定义属性xhr.uploadedif(xhr.readyState==4&&xhr.uploaded){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){//alert('上传成功');}}}xhr.onprogress=updateProgress;xhr.upload.onprogress=updateProgress;functionupdateProgress(event){if(event.lengthComputable){varcompletedPercent=(event.loaded/event.total*100).toFixed(2);progressSpan.style.width=completedPercent+'%';progressSpan.innerHTML=completedPercent+'%';if(completedPercent>90){//进度条变色progressSpan.classList.add('green');}if(completedPercent>=100){xhr.uploaded=true;}console.log('已上传',completedPercent);}}//注意send一定要写在最下面，否则onprogress只会执行最后一次也就是100%的时候xhr.send(fd);//发送时Content-Type默认就是:multipart/form-data;returnxhr;}//文件上传functionsubmitUpload(willFiles){if(!willFiles.length){return;}//遍历文件信息进行上传willFiles.forEach(function(item){xhrSend({file:item.file,progress:item.progress});});}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',function(){submitUpload(willUploadFile);});复制代码问题1这里没有做上传的并发控制，可以通过控制同时可上传文件的个数（这里控制为最多6个）或者上传的时候做好并发处理，也就是同时只能上传X个文件。问题2在测试过程中，取消请求的方法xhr.abort()调用后，xhr.readyState会立即变为4,而不是0，所以这里需要做容错处理。MDN上说是0.\">如果大家有不同的结果，欢迎留言。CODEgithub.com/Bigerfe/fe-…拖拽上传html5的出现，让拖拽上传交互成为可能，现在这样的体验也屡见不鲜。DEMO\">说明定义一个允许拖放文件的区域div.drop-box取消drop事件的默认行为e.preventDefault();，不然浏览器会直接打开文件为拖拽区域绑定事件,鼠标在拖拽区域上dragover,鼠标离开拖拽区域dragleave,在拖拽区域上释放文件dropdrop事件内获得文件信息e.dataTransfer.filesHTML\"drop-box\"id=\"drop-box\">拖动文件到这里,开始上传type=\"button\"id=\"btn-submit\">上传复制代码JSvarbox=document.getElementById('drop-box');//禁用浏览器的拖放默认行为document.addEventListener('drop',function(e){console.log('documentdrog');e.preventDefault();});//设置拖拽事件functionopenDropEvent(){box.addEventListener(\"dragover\",function(e){console.log('elemenetdragover');box.classList.add('over');e.preventDefault();});box.addEventListener(\"dragleave\",function(e){console.log('elemenetdragleave');box.classList.remove('over');e.preventDefault();});box.addEventListener(\"drop\",function(e){e.preventDefault();//取消浏览器默认拖拽效果varfileList=e.dataTransfer.files;//获取拖拽中的文件对象varlen=fileList.length;//用来获取文件的长度（其实是获得文件数量）//检测是否是拖拽文件到页面的操作if(!len){box.classList.remove('over');return;}box.classList.add('over');window.willUploadFileList=fileList;},false);}openDropEvent();functionsubmitUpload(){varfileList=window.willUploadFileList||[];if(!fileList.length){alert('请选择文件');return;}varfd=newFormData();//构造FormData对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){if(xhr.readyState==4){varobj=JSON.parse(xhr.responseText);//返回值if(obj.fileUrl.length){alert('上传成功');}}}xhr.send(fd);//发送}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码CODEgithub.com/Bigerfe/fe-…剪贴板上传掘金的写文编辑器是支持粘贴上传图片的，比如我从磁盘粘贴或者从网页上右键复制图片。DEMO\">说明页面内增加一个可编辑的编辑区域div.editor-box,开启contenteditable为div.editor-box绑定paste事件处理paste事件，从event.clipboardData||window.clipboardData获得数据将数据转换为文件items[i].getAsFile()实现在编辑区域的光标处插入内容insertNodeToEditor方法问题1测试中发现复制多个文件无效，只有最后一个文件上传，在掘金的编辑器里也同样存在，在坐有知道原因的可以留言说下。问题2mac系统可以支持从磁盘复制文件后上传，windows系统测试未通过，剪贴板的数据未拿到。HTML\"editor-box\"id=\"editor-box\"contenteditable=\"true\">可以直接粘贴图片到这里直接上传复制代码JS//光标处插入dom节点functioninsertNodeToEditor(editor,ele){//插入dom节点varrange;//记录光标位置对象varnode=window.getSelection().anchorNode;//这里判断是做是否有光标判断，因为弹出框默认是没有的if(node!=null){range=window.getSelection().getRangeAt(0);//获取光标起始位置range.insertNode(ele);//在光标位置插入该对象}else{editor.append(ele);}}varbox=document.getElementById('editor-box');//绑定paste事件box.addEventListener('paste',function(event){vardata=(event.clipboardData||window.clipboardData);varitems=data.items;varfileList=[];//存储文件数据if(items&&items.length){//检索剪切板itemsfor(vari=0;i<items.length;i++){console.log(items[i].getAsFile());fileList.push(items[i].getAsFile());}}window.willUploadFileList=fileList;event.preventDefault();//阻止默认行为submitUpload();});functionsubmitUpload(){varfileList=window.willUploadFileList||[];varfd=newFormData();//构造FormData对象for(vari=0;i'f1',fileList[i]);//支持多文件上传}varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){if(xhr.readyState===4){varobj=JSON.parse(xhr.responseText);//返回值console.log(obj);if(obj.fileUrl.length){varimg=document.createElement('img');img.src=obj.fileUrl[0];img.style.width='100px';insertNodeToEditor(box,img);//alert('上传成功');}}}xhr.send(fd);//发送}复制代码CODEgithub.com/Bigerfe/fe-…大文件上传-分片在ie时代由于无法使用xhr上传二进制数据，上传大文件需要借助浏览器插件来完成。现在来看实现大文件上传简直soeasy。如果太大的文件，比如一个视频1g2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分比如2M。DEMO\">\">说明相信大家都对Blob对象有所了解，它表示原始数据,也就是二进制数据，同时提供了对数据截取的方法slice,而File继承了Blob的功能，所以可以直接使用此方法对数据进行分段截图。把大文件进行分段比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件服务端保存各段文件浏览器端所有分片上传完成，发送给服务端一个合并文件的请求服务端根据文件标识、类型、各分片顺序进行文件合并删除分片文件HTML代码略，只需要一个inputfile标签。JS//分片逻辑像操作字符串一样varstart=0,end=0;while(true){end+=chunkSize;varblob=file.slice(start,end);start+=chunkSize;if(!blob.size){//截取的数据为空则结束//拆分结束break;}chunks.push(blob);//保存分段数据}functionsubmitUpload(){varchunkSize=2*1024*1024;//分片大小2Mvarfile=document.getElementById('f1').files[0];varchunks=[],//保存分片数据token=(+newDate()),//时间戳name=file.name,chunkCount=0,sendChunkCount=0;//拆分文件像操作字符串一样if(file.size>chunkSize){//拆分文件varstart=0,end=0;while(true){end+=chunkSize;varblob=file.slice(start,end);start+=chunkSize;if(!blob.size){//截取的数据为空则结束//拆分结束break;}chunks.push(blob);//保存分段数据}}else{chunks.push(file.slice(0));}chunkCount=chunks.length;//分片的个数//没有做并发限制，较大文件导致并发过多，tcp链接被占光，需要做下并发控制，比如只有4个在请求在发送for(vari=0;i<chunkCount;i++){varfd=newFormData();//构造FormData对象fd.append('token',token);fd.append('f1',chunks[i]);fd.append('index',i);xhrSend(fd,function(){sendChunkCount+=1;if(sendChunkCount===chunkCount){//上传完成，发送合并请求console.log('上传完成，发送合并请求');varformD=newFormData();formD.append('type','merge');formD.append('token',token);formD.append('chunkCount',chunkCount);formD.append('filename',name);xhrSend(formD);}});}}functionxhrSend(fd,cb){varxhr=newXMLHttpRequest();//创建对象xhr.open('POST','http://localhost:8100/',true);xhr.onreadystatechange=function(){console.log('statechange',xhr.readyState);if(xhr.readyState==4){console.log(xhr.responseText);cb&&cb();}}xhr.send(fd);//发送}//绑定提交事件document.getElementById('btn-submit').addEventListener('click',submitUpload);复制代码NODE服务端需要做一些改动，保存分片文件、合并分段文件、删除分段文件。PS合并文件这里使用streampipe实现，这样更节省内存，边读边写入，占用内存更小，效率更高，代码见fnMergeFile方法。//二次处理文件，修改名称app.use((ctx)=>{varbody=ctx.request.body;varfiles=ctx.request.files?ctx.request.files.f1:[];//得到上传文件的数组varresult=[];varfileToken=ctx.request.body.token;//文件标识varfileIndex=ctx.request.body.index;//文件顺序if(files&&!Array.isArray(files)){//单文件上传容错files=[files];}files&&files.forEach(item=>{varpath=item.path;varfname=item.name;//原文件名称varnextPath=path.slice(0,path.lastIndexOf('/')+1)+fileIndex+'-'+fileToken;if(item.size>0&&path){//得到扩展名varextArr=fname.split('.');varext=extArr[extArr.length-1];//varnextPath=path+'.'+ext;//重命名文件fs.renameSync(path,nextPath);result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf('/')+1));}});if(body.type==='merge'){//合并分片文件varfilename=body.filename,chunkCount=body.chunkCount,folder=path.resolve(__dirname,'../static/uploads')+'/';varwriteStream=fs.createWriteStream(`${folder}${filename}`);varcindex=0;//合并文件functionfnMergeFile(){varfname=`${folder}${cindex}-${fileToken}`;varreadStream=fs.createReadStream(fname);readStream.pipe(writeStream,{end:false});readStream.on(\"end\",function(){fs.unlink(fname,function(err){if(err){throwerr;}});if(cindex+1<chunkCount){cindex+=1;fnMergeFile();}});}fnMergeFile();ctx.body='mergeok200';}});复制代码CODEgithub.com/Bigerfe/fe-…大文件上传-断点续传在上面我们实现了大文件的分片上传，解决了大文件上传超时和服务器的限制。但是仍然不够完美，大文件上传并不是短时间内就上传完成，如果期间断网，页面刷新了仍然需要重头上传。方法1基于上面一个栗子进行改进，服务端已保存了部分片段，重新上传的时候，服务端对当前的分段进行对比，只接收本地没有的分段，前提是分段大小一致。在上面为了方便，使用了时间戳作为这个文件的标志，其实可以使用spark-md5来生成文件的hash值，这样服务器就可以进行文件的对比了。但是不好的地方是每个分段都要重新发送请求。方法2-断点续传方法1中，重新上传时请求和数据还会发到服务器，其实已上传的分段就不应该再发送到服务器了，所以我们可以使用断点续传来进行改进。为每个分段生成hash值，使用spark-md5库将上传成功的分段信息保存到本地重新上传时，进行和本地分段hash值的对比，如果相同的话则跳过，继续下一个分段的上传PS生成hash过程肯定也会耗费资源，但是和重新上传相比可以忽略不计了。DEMO\">\">HTML代码略复制代码JS模拟分段保存，本地保存到localStorage//获得本地缓存的数据functiongetUploadedFromStorage(){returnJSON.parse(localStorage.getItem(saveChunkKey)||\"{}\");}//写入缓存functionsetUploadedToStorage(index){varobj=getUploadedFromStorage();obj[index]=true;localStorage.setItem(saveChunkKey,JSON.stringify(obj));}//分段对比varuploadedInfo=getUploadedFromStorage();//获得已上传的分段信息for(vari=0;i<chunkCount;i++){console.log('index',i,uploadedInfo[i]?'已上传过':'未上传');if(uploadedInfo[i]){//对比分段sendChunkCount=i+1;//记录已上传的索引continue;//如果已上传则跳过}varfd=newFormData();//构造FormData对象fd.append('token',token);fd.append('f1',chunks[i]);fd.append('index',i);(function(index){xhrSend(fd,function(){sendChunkCount+=1;//将成功信息保存到本地setUploadedToStorage(index);if(sendChunkCount===chunkCount){console.log('上传完成，发送合并请求');varformD=newFormData();formD.append('type','merge');formD.append('token',token);formD.append('chunkCount',chunkCount);formD.append('filename',name);xhrSend(formD);}});})(i);}复制代码node端上传图片不只会从客户端上传文件到服务器，服务器也会上传文件到其他服务器。读取文件bufferfs构建form-dataform-data上传文件node-fetchNODE/***filepath=相对根目录的路径即可*/asyncfunctiongetFileBufer(filePath)=>{returnnewPromise((resolve)=>{fs.readFile(filePath,function(err,data){varbufer=null;if(!err){resolve({err:err,data:data});}});});}/***上传文件*/letfetch=require('node-fetch');letformData=require('form-data');module.exports=async(options)=>{let{imgPath}=options;letdata=awaitgetFileBufer(imgPath);if(data.err){returnnull;}letform=newformData();form.append('xxx',xxx);form.append('pic',data.data);returnfetch('http://xx.com/upload',{body:form,method:'POST',headers:form.getHeaders()//要活的form-data的头，否则无法上传}).then(res=>{returnres.json();}).then(data=>{returndata;})}复制代码其他在浏览器端对文件的类型、大小、尺寸进行判断file.type判断类型file.size判断大小通过动态创建img标签，图片加载后获得尺寸,naturalWidthnaturalHeightorwidthheightJSvarfile=document.getElementById('f1').files[0];//判断类型if(f.type!=='image/jpeg'&&f.type!=='image/jpg'){alert('只能上传jpg图片');flag=false;break;}//判断大小if(file.size>100*1024){alert('不能大于100kb');}//判断图片尺寸varimg=newImage();img.onload=function(){console.log('图片原始大小width*height',this.width,this.height);if(this.naturalWidth){console.log('图片原始大小naturalWidth*naturalHeight',this.naturalWidth,this.naturalHeight);}else{console.log('oImg.width*height',this.width,this.height);}}复制代码inputfile外观更改由于inputfile的外观比较传统，很多地方都需要进行美化。定义好一个外观，然后将fileinput定位到该元素上，让他的透明度为0。使用label标签for=\"file\">Choosefiletouploadtype=\"file\"id=\"file\"name=\"file\"multiple>复制代码隐藏inputfile标签，然后调用input元素的click方法PSfile标签隐藏后在ie下无法获得文件内容，建议还是方法1兼容性强。源码在这里以上代码均已上传githubgithub.com/Bigerfe/fe-…参考资料developer.mozilla.org/zh-CN/docs/…developer.mozilla.org/zh-CN/docs/…cloud.tencent.com/developer/n…最后希望本文可以给你带了一些帮助，文中如有错误，欢迎在评论区指。如果这篇文章帮助到了你，欢迎点赞和关注。推荐关注我的微信公众号【前端张大胖】，每天推送高质量文章和自学经验和心得，我们一起交流成长。\">其他你对SSR有兴趣吗？如果你对服务端渲染ssr技术有兴趣，可以关注我的开源项目：Zz.jsgithub:github.com/Bigerfe/koa…官网：zz.bigerfe.com/SSR技术原理juejin.im/post/5d7dee…",
      "id": "svegcnmtq3k",
      "author": "神三元",
      "title": "写给新手前端的各种文件上传攻略，从小图片到大文件断点续传"
    },
    {
      "content": "笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！第一篇:JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在JS中，存在着7种原始值，分别是：booleannullundefinednumberstringsymbolbigint引用数据类型:对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math）函数Function2.说出下面运行的结果，解释原因。functiontest(person){person.age=26person={name:'hzj',age:18}returnperson}constp1={name:'fyq',age:19}constp2=test(p1)console.log(p1)//->?console.log(p2)//->?复制代码结果:p1：{name:“fyq”,age:26}p2：{name:“hzj”,age:18}复制代码原因:在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age=26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。3.null是对象吗？为什么？结论:null不是对象。解释:虽然typeofnull会输出object，但是这只是JS存在的一个悠久Bug。在JS的最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象然而null表示为全零，所以将它错误的判断为object。4.'1'.toString()为什么可以调用？其实在这个语句运行的过程中做了这样几件事情：vars=newString('1');s.toString();s=null;复制代码第一步:创建String类实例。第二步:调用实例方法。第三步:执行完方法立即销毁这个实例。整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean,Number和String。参考:《JavaScript高级程序设计(第三版)》P1185.0.1+0.2为什么不等于0.3？0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。6.如何理解BigInt?什么是BigInt?BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。为什么需要BigInt?在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。console.log(999999999999999);//=>10000000000000000复制代码同时也会有一定的安全性问题:9007199254740992===9007199254740993;//→true居然是true!复制代码如何创建并使用BigInt？要创建BigInt，只需要在数字末尾追加n即可。console.log(9007199254740995n);//→9007199254740995nconsole.log(9007199254740995);//→9007199254740996复制代码另一种创建BigInt的方法是用BigInt()构造函数、BigInt(\"9007199254740995\");//→9007199254740995n复制代码简单使用如下:10n+20n;//→30n10n-20n;//→-10n+10n;//→TypeError:CannotconvertaBigIntvaluetoanumber-10n;//→-10n10n*20n;//→200n20n/10n;//→2n23n%10n;//→3n10n**3n;//→1000nconstx=10n;++x;//→11n--x;//→9nconsole.log(typeofx);//\"bigint\"复制代码值得警惕的点BigInt不支持一元加号运算符,这可能是某些程序可能依赖于+始终生成Number的不变量，或者抛出异常。另外，更改+的行为也会破坏asm.js代码。因为隐式类型转换可能丢失信息，所以不允许在bigint和Number之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。10+10n;//→TypeError复制代码不能将BigInt传递给Webapi和内置的JS函数，这些函数需要一个Number类型的数字。尝试这样做会报TypeError错误。Math.max(2n,4n,6n);//→TypeError复制代码当Boolean类型与BigInt类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。if(0n){//条件判断为false}if(3n){//条件为true}复制代码元素都为BigInt的数组可以进行sort。BigInt可以正常地进行位运算，如|、&、<<、>>和^浏览器兼容性caniuse的结果:\">其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。我们期待BigInt的光明前途！第二篇:JS数据类型之问——检测篇1.typeof是否能正确判断类型？对于原始类型来说，除了null都可以调用typeof显示正确的类型。typeof1//'number'typeof'1'//'string'typeofundefined//'undefined'typeoftrue//'boolean'typeofSymbol()//'symbol'复制代码但对于引用数据类型，除了函数之外，都会显示\"object\"。typeof[]//'object'typeof{}//'object'typeofconsole.log//'function'复制代码因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为trueconstPerson=function(){}constp1=newPerson()p1instanceofPerson//truevarstr1='helloworld'str1instanceofString//falsevarstr2=newString('helloworld')str2instanceofString//true复制代码2.instanceof能否判断基本数据类型？能。比如下面这种方式:classPrimitiveNumber{static[Symbol.hasInstance](x){returntypeofx==='number'}}console.log(111instanceofPrimitiveNumber)//true复制代码如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。3.能不能手动实现一下instanceof的功能？核心:原型链的向上查找。functionmyInstanceof(left,right){//基本数据类型直接返回falseif(typeofleft!=='object'||left===null)returnfalse;//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象letproto=Object.getPrototypeOf(left);while(true){//查找到尽头，还没找到if(proto==null)returnfalse;//找到相同的原型对象if(proto==right.prototype)returntrue;proto=Object.getPrototypeof(proto);}}复制代码测试:console.log(myInstanceof(\"111\",String));//falseconsole.log(myInstanceof(newString(\"111\"),String));//true复制代码4.Object.is和===的区别？Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。源码如下：functionis(x,y){if(x===y){//运行到1/x===1/y的时候x和y都为0，但是1/+0=+Infinity，1/-0=-Infinity,是不一样的returnx!==0||y!==0||1/x===1/y;}else{//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x!==x，那么一定是NaN,y同理//两个都是NaN的时候返回truereturnx!==x&&y!==y;}复制代码第三篇:JS数据类型之问——转换篇1.[]==![]结果是什么？为什么？解析:==中，左右两边都需要转换为数字然后进行比较。[]转换为数字为0。![]首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,因此![]为false，进而在转换成数字，变为0。0==0，结果为true2.JS中类型转换有哪几种？JS中，类型转换只有三种：转换成数字转换成布尔值转换成字符串转换具体规则如下:注意\"Boolean转字符串\"这行结果指的是true转字符串的例子\">3.==和===有什么区别？===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false判断的是否是null和undefined，是的话就返回true判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较console.log({a:1}==true);//falseconsole.log({a:1}==\"[objectObject]\");//true复制代码4.对象转原始类型是根据什么流程运行的？对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：如果Symbol.toPrimitive()方法，优先调用再返回调用valueOf()，如果转换为原始类型，则返回调用toString()，如果转换为原始类型，则返回如果都没有返回原始类型，会报错varobj={value:3,valueOf(){return4;},toString(){return'5'},[Symbol.toPrimitive](){return6}}console.log(obj+1);//输出7复制代码5.如何让if(a==1&&a==2)条件成立？其实就是上一个问题的应用。vara={value:0,valueOf:function(){this.value++;returnthis.value;}};console.log(a==1&&a==2);//true复制代码第四篇:谈谈你对闭包的理解什么是闭包？红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，MDN对闭包的定义为：闭包是指那些能够访问自由变量的函数。（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）闭包产生的原因?首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。比如:vara=1;functionf1(){vara=2functionf2(){vara=3;console.log(a);//3}}复制代码在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:functionf1(){vara=2functionf2(){console.log(a);//2}returnf2;}varx=f1();x();复制代码这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。那是不是只有返回函数才算是产生了闭包呢？、回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：varf3;functionf1(){vara=2f3=function(){console.log(a);}}f1();f3();复制代码让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。闭包有哪些表现形式?明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？返回一个函数。刚刚已经举例。作为函数参数传递vara=1;functionfoo(){vara=2;functionbaz(){console.log(a);}bar(baz);}functionbar(fn){//这就是闭包fn();}//输出2，而不是1foo();复制代码在定时器、事件监听、Ajax请求、跨窗口通信、WebWorkers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。以下的闭包保存的仅仅是window和当前作用域。//定时器setTimeout(functiontimeHandler(){console.log('111');}，100)//事件监听$('#app').click(function(){console.log('DOMListener');})复制代码IIFE(立即执行函数表达式)创建闭包,保存了全局作用域window和当前函数的作用域，因此可以全局的变量。vara=2;(functionIIFE(){//输出2console.log(a);})();复制代码如何解决下面的循环输出问题？for(vari=1;i<=5;i++){setTimeout(functiontimer(){console.log(i)},0)}复制代码为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。解决方法：1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中for(vari=1;i<=5;i++){(function(j){setTimeout(functiontimer(){console.log(j)},0)})(i)}复制代码2、给定时器传入第三个参数,作为timer函数的第一个函数参数for(vari=1;i<=5;i++){setTimeout(functiontimer(j){console.log(j)},0,i)}复制代码3、使用ES6中的letfor(leti=1;i<=5;i++){setTimeout(functiontimer(){console.log(i)},0)}复制代码let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例://i=1{setTimeout(functiontimer(){console.log(1)},0)}//i=2{setTimeout(functiontimer(){console.log(2)},0)}//i=3...复制代码因此能输出正确的结果。第五篇:谈谈你对原型链的理解1.原型对象和构造函数有何关系？在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。\">2.能不能描述一下原型链？JavaScript对象通过prototype指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条,即原型链。\">对象的hasOwnProperty()来检查对象自身中是否含有该属性使用in检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回true第六篇:JS如何实现继承？第一种:借助callfunctionParent1(){this.name='parent1';}functionChild1(){Parent1.call(this);this.type='child1'}console.log(newChild1);复制代码这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。第二种:借助原型链functionParent2(){this.name='parent2';this.play=[1,2,3]}functionChild2(){this.type='child2';}Child2.prototype=newParent2();console.log(newChild2());复制代码看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：vars1=newChild2();vars2=newChild2();s1.play.push(4);console.log(s1.play,s2.play);复制代码可以看到控制台：\">明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。那么还有更好的方式么？第三种：将前两种组合functionParent3(){this.name='parent3';this.play=[1,2,3];}functionChild3(){Parent3.call(this);this.type='child3';}Child3.prototype=newParent3();vars3=newChild3();vars4=newChild3();s3.play.push(4);console.log(s3.play,s4.play);复制代码可以看到控制台：\">之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype=newParent3();）。这是我们不愿看到的。那么如何解决这个问题？第四种:组合继承的优化1functionParent4(){this.name='parent4';this.play=[1,2,3];}functionChild4(){Parent4.call(this);this.type='child4';}Child4.prototype=Parent4.prototype;复制代码这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：vars3=newChild4();vars4=newChild4();console.log(s3)复制代码\">子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。第五种(最推荐使用):组合继承的优化1functionParent5(){this.name='parent5';this.play=[1,2,3];}functionChild5(){Parent5.call(this);this.type='child5';}Child5.prototype=Object.create(Parent5.prototype);Child5.prototype.constructor=Child5;复制代码这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。ES6的extends被编译后的JavaScript代码ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。那最后编译成了什么样子呢？function_possibleConstructorReturn(self,call){//...returncall&&(typeofcall==='object'||typeofcall==='function')?call:self;}function_inherits(subClass,superClass){//...//看到没有subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}varParent=functionParent(){//验证是否是Parent构造出来的this_classCallCheck(this,Parent);};varChild=(function(_Parent){_inherits(Child,_Parent);functionChild(){_classCallCheck(this,Child);return_possibleConstructorReturn(this,(Child.__proto__||Object.getPrototypeOf(Child)).apply(this,arguments));}returnChild;}(Parent));复制代码核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass,superClass)，这是用来干啥的呢？答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。追问:面向对象的设计一定是好的设计吗？不一定。从继承的角度说，这一设计是存在巨大隐患的。从设计思想上谈谈继承本身的问题假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。classCar{constructor(id){this.id=id;}drive(){console.log(\"wuwuwu!\");}music(){console.log(\"lalala!\")}addOil(){console.log(\"哦哟！\")}}classotherCarextendsCar{}复制代码现在可以实现车的功能，并且以此去扩展不同的车。但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。如果让新能源汽车的类继承Car的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。那如何来解决继承的诸多问题呢？用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。functiondrive(){console.log(\"wuwuwu!\");}functionmusic(){console.log(\"lalala!\")}functionaddOil(){console.log(\"哦哟！\")}letcar=compose(drive,music,addOil);letnewEnergyCar=compose(drive,music);复制代码代码干净，复用性也很好。这就是面向组合的设计方式。参考出处:ES5实现继承那些事重学JS系列:聊聊继承JS最新基本数据类型:BigInt(译)yck前端面试之道更多有趣内容见微信公众号:\">",
      "id": "232y8b6b3dr4",
      "author": "荒山",
      "title": "(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)"
    },
    {
      "content": "写一篇关于ReactFiber的文章，这个Flag立了很久，这也是今年的目标之一。最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。我会以最通俗的方式将它讲透,因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!\">一年一度的React春晚:ReactConf即将到来，不知道今年会不会有什么惊喜，去年是ReactHooks，前年是ReactFiber...我得赶在ReactConf之前发布这篇文章:😲ReactFiber已经出来这么久了，这文章是老酒装新瓶吧?对于我来说，通过这篇文章我重新认识了ReactFiber，它不是一个新东西,它也是老酒装新瓶，不信你就看吧...🆕ReactFiber不是一个新的东西，但在前端领域是第一次广为认知的应用。😦了解它有啥用?ReactFiber代码很复杂，门槛很高，你不了解它，后面React新出的KillerFeature你可能就更不能理解了🤥我不是升到Reactv16了吗?没什么出奇的啊?真正要体会到ReactFiber重构效果，可能下个月、可能要等到v17。v16只是一个过渡版本，也就是说，现在的React还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗？😁不好意思，一不小心又写得有点长，你就当小说看吧,代码都是伪代码以下文章大纲单处理进程调度:Fiber不是一个新的东西类比浏览器JavaScript执行环境何为Fiber1.一种流程控制原语2.一个执行单元React的Fiber改造1.数据结构的调整2.两个阶段的拆分3.Reconcilation4.双缓冲5.副作用的收集和提交⚠️未展开部分🚧--中断和恢复凌波微步站在巨人的肩膀上单处理进程调度:Fiber不是一个新的东西\">这个黑乎乎的界面应该就是微软的DOS操作系统微软DOS是一个单任务操作系统,也称为’单工操作系统‘.这种操作系统同一个时间只允许运行一个程序.invalids在《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》的回答中将其称为:'一种压根没有任务调度的“残疾”操作系统'.在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。直到Windows3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。注意并发和并行不是同一个概念。现代操作系统都是多任务操作系统.进程的调度策略如果按照CPU核心数来划分，可以分为单处理器调度和多处理器调度。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象,因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行。\">这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了.这就是所谓的并发(Concurrent)(单处理器)。\">相比而言,火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是并行(严格地讲这是Master-Slave架构，分身虽然物理存在，但应该没有独立的意志)。所以说🔴并行可以是并发，而并发不一定是并行，两种不能划等号,并行一般需要物理层面的支持。关于并发和并行，Go之父RobPike有一个非常著名的演讲Concurrencyisnotparallelism扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过操作系统原理,你可以很快理解以下几种单处理器进程调度策略(我就随便科普一下，算送的,如果你很熟悉这块，可以跳过)：0️⃣先到先得(First-Come-First-Served,FCFS)这是最简单的调度策略,简单说就是没有调度。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).FCFS上面DOS的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。FCFS对短进程不利。短进程即执行时间非常短的进程，可以用饭堂排队来比喻:在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像长进程一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久...FCFS对I/O密集不利。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。可以类比ZF部门办业务:假设CPU一个窗口、I/O一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了,需要去I/O搞一下，Ok去I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平...所以FCFS这种原始的策略在单处理器进程调度中并不受欢迎。1️⃣轮转这是一种基于时钟的抢占策略，这也是抢占策略中最简单的一种:公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来。决策模式:抢占策略相对应的有非抢占策略，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。这种调度策略的要点是确定合适的时间片长度:太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的FCFS没什么区别了;太短了也不好，因为进程抢占和切换都是需要成本的,而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。因此时间片的长度最好符合大部分进程完成一次典型交互所需的时间.轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和FCFS一样，轮转策略对I/O进程还是不公平。2️⃣最短进程优先(ShortestProcessNext,SPN)上面说了先到先得策略对短进程不公平，最短进程优先索性就让'最短'的进程优先执行，也就是说:按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略。这样可以让短进程能得到较快的响应。但是怎么获取或者评估进程执行时间呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。SPN的缺陷是:如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。另外因为它不是抢占性策略,尽管现在短进程可以得到更多的执行机会，但是还是没有解决FCFS的问题:一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。3️⃣最短剩余时间(ShortestRemainingTime,SRT)SRT进一步优化了SPN，增加了抢占机制。在SPN的基础上，当一个进程添加到就绪队列时，操作系统会比较刚添加的新进程和当前正在执行的老进程的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。相比轮转的抢占，SRT没有中断处理的开销。但是在SPN的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。另外长进程饥饿问题还是没有解决。4️⃣最高响应比优先(HRRN)为了解决长进程饥饿问题，同时提高进程的响应速率。还有一种最高响应比优先的策略，首先了解什么是响应比:响应比=（等待执行时间+进程执行时间）/进程执行时间复制代码这种策略会选择响应比最高的进程优先执行：对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行5️⃣反馈法SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是事后反馈的方式。这种策略下:每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列。举个例子:队列1队列2...队列N复制代码新增的任务会推入队列1，队列1会按照轮转策略以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入队列2。队列2会在队列1任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以队列2的轮转时间片长度是2。反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。\">没有一种调度策略是万能的,它需要考虑很多因素:响应速率。进程等待被执行的时间公平性。兼顾短进程、长进程、I/O进程这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下Linux相关的进程调度算法，这方面的资料也非常多,例如《Linux进程调度策略的发展和演变》。类比浏览器JavaScript执行环境\">JavaScript就像单行道JavaScript是单线程运行的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理,这些任务可以类比上面’进程‘。这里特指Javascript引擎是单线程运行的。严格来说，页面绘制由单独的GUI渲染进程负责，只不过GUI渲染线程和Javascript线程是互斥的.另外底层的异步操作实际上也是多线程的。\">图片来源:RenderingPerformance它只是一个'JavaScript'，同时只能做一件事情，这个和DOS的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差。对于’前端框架‘来说，解决这种问题有三个方向:1️⃣优化每个任务，让它有多快就多快。挤压CPU运算量2️⃣快速响应用户，让用户觉得够快，不能阻塞用户的交互3️⃣尝试Worker多线程Vue选择的是第1️⃣,因为对于Vue来说，使用模板让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新,读者可以去看一下今年VueConf尤雨溪的演讲，非常棒!；而React选择了2️⃣。对于Worker多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。React为什么要引入Fiber架构？看看下面的火焰图，这是ReactV15下面的一个列表渲染资源消耗情况。整个渲染花费了130ms,🔴在这里面React会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们,一气呵成。这个过程React称为Reconcilation(中文可以译为协调).\">在Reconcilation期间，React会霸占着浏览器资源，一则会导致用户触发的事件得不到响应,二则会导致掉帧，用户可以感知到这些卡顿。这样说，你可能没办法体会到，通过下面两个图片来体会一下(图片来源于：DanAbramov的BeyondReact16演讲,推荐看一下👍.另外非常感谢淡苍将一个类似的DEMO分享在了CodeSandbox上🎉，大家自行体验):同步模式下的React:\">优化后的Concurrent模式下的React:\">React的Reconcilation是CPU密集型的操作,它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。所以React是怎么优化的？划重点，🔴为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源.你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率,同时兼顾任务执行效率。🔴所以React通过Fiber架构，让自己的Reconcilation过程变成可被中断。'适时'地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:与其一次性操作大量DOM节点相比,分批延时对DOM进行操作，可以得到更好的用户体验。这个在《「前端进阶」高性能渲染十万条数据(时间分片)》以及司徒正美的《ReactFiber架构》都做了相关实验司徒正美在《ReactFiber架构》也提到：🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正.这就是为什么React需要Fiber😏。何为Fiber对于React来说，Fiber可以从两个角度理解:1.一种流程控制原语Fiber也称协程、或者纤程。笔者第一次接触这个概念是在学习Ruby的时候，Ruby就将协程称为Fiber。后来发现很多语言都有类似的机制，例如Lua的Coroutine,还有前端开发者比较熟悉的ES6新增的Generator。本文不纠结Processes,threads,greenthreads,protothreads,fibers,coroutines:what'sthedifference?🔴其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。要理解协程，你得和普通函数一起来看,以Generator为例:普通函数执行的过程中无法被中断和恢复：consttasks=[]functionrun(){lettaskwhile(task=tasks.shift()){execute(task)}}复制代码而Generator可以:consttasks=[]function*run(){lettaskwhile(task=tasks.shift()){//🔴判断是否有高优先级事件需要处理,有的话让出控制权if(hasHighPriorityEvent()){yield}//处理完高优先级事件后，恢复函数调用栈，继续执行...execute(task)}}复制代码ReactFiber的思想和协程的概念是契合的:🔴React渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。那么现在你应该有以下疑问:1️⃣浏览器没有抢占的条件,所以React只能用让出机制?2️⃣怎么确定有高优先任务要处理，即什么时候让出？3️⃣React那为什么不使用Generator？答1️⃣:没错,主动让出机制一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：合作式调度(CooperativeScheduling),相对应的有抢占式调度(PreemptiveScheduling)这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任。比如可以由浏览器给我们分配执行时间片(通过requestIdleCallback实现,下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。\">这种调度方式很有趣，你会发现这是一种身份的对调，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久;现在为了我们共同的用户体验统一了战线,一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。当然你超时不还浏览器也拿你没办法🤷‍...合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。答2️⃣:requestIdleCallbackAPI上面代码示例中的hasHighPriorityEvent()在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。只能换一种思路，通过超时检查的机制来让出控制权。解决办法是:确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器。举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是16ms。其实浏览器提供了相关的接口——requestIdleCallbackAPI：window.requestIdleCallback(callback:(dealine:IdleDeadline)=>void,option?:{timeout:number})复制代码IdleDeadline的接口如下：interfaceIdleDealine{didTimeout:boolean//表示任务执行是否超过约定时间timeRemaining():DOMHighResTimeStamp//任务可供执行的剩余时间}复制代码单从名字上理解的话,requestIdleCallback的意思是让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行,为了不耽误事，我们最好在这个时间范围内执行完毕。那浏览器什么时候有空？我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:\">你可以打开Chrome开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task),花费了多少时间。\">图片来源:你应该知道的requestIdleCallback浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:处理用户输入事件Javascript执行requestAnimation调用布局Layout绘制Paint上面说理想的一帧时间是16ms(1000ms/60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用requestIdleCallback的回调。例如\">但是在浏览器繁忙的时候，可能不会有盈余时间，这时候requestIdleCallback回调可能就不会被执行。为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间。另外不建议在requestIdleCallback中进行DOM操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用getBoundingClientRect)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。目前requestIdleCallback目前只有Chrome支持。所以目前React自己实现了一个。它利用MessageChannel模拟将回调延迟到'绘制操作'之后执行:\">简单看一下代码constel=document.getElementById('root')constbtn=document.getElementById('btn')constch=newMessageChannel()letpendingCallbackletstartTimelettimeoutch.port2.onmessage=functionwork(){//在绘制之后被执行if(pendingCallback){constnow=performance.now()//通过now-startTime可以计算出requestAnimationFrame到绘制结束的执行时间//通过这些数据来计算剩余时间//另外还要处理超时(timeout)，避免任务被饿死//...if(hasRemain&&noTimeout){pendingCallback(deadline)}}}//...functionsimpleRequestIdleCallback(callback,timeout){requestAnimationFrame(functionanimation(){//在绘制之前被执行//记录开始时间startTime=performance.now()timeout=timeoutdosomething()//调度回调到绘制结束后执行pendingCallback=callbackch.port1.postMessage('hello')})}复制代码任务优先级上面说了，为了避免任务被饿死，可以设置一个超时时间.这个超时时间不是死的，低优先级的可以慢慢等待,高优先级的任务应该率先被执行.目前React预定义了5个优先级,这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:Immediate(-1)-这个优先级的任务会同步执行,或者说要马上执行且不能中断UserBlocking(250ms)这些任务一般是用户交互的结果,需要即时得到反馈Normal(5s)应对哪些不需要立即感受到的任务，例如网络请求Low(10s)这些任务可以放后，但是最终应该得到执行.例如分析通知Idle(没有超时时间)一些没有必要做的任务(e.g.比如隐藏的内容),可能会被饿死答3️⃣:太麻烦官方在《FiberPrinciples:ContributingToFiber》也作出了解答。主要有两个原因：Generator不能在栈中间让出。比如你想在嵌套的函数调用中间让出,首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。Generator是有状态的,很难在中间恢复这些状态。上面理解可能有出入，建议看一下原文可能都没看懂，简单就是React尝试过用Generator实现，后来发现很麻烦，就放弃了。2.一个执行单元Fiber的另外一种解读是’纤维‘:这是一种数据结构或者说执行单元。我们暂且不管这个数据结构长什么样，🔴将它视作一个执行单元，每次执行完一个'执行单元',React就会检查现在还剩多少时间，如果没有时间就将控制权让出去.上文说了，React没有使用Generator这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：假设用户调用setState更新组件,这个待更新的任务会先放入队列中,然后通过requestIdleCallback请求浏览器调度：updateQueue.push(updateTask);requestIdleCallback(performWork,{timeout});复制代码现在浏览器有空闲或者超时了就会调用performWork来执行任务：//1️⃣performWork会拿到一个Deadline，表示剩余时间functionperformWork(deadline){//2️⃣循环取出updateQueue中的任务while(updateQueue.length>0&&deadline.timeRemaining()>ENOUGH_TIME){workLoop(deadline);}//3️⃣如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度if(updateQueue.length>0){requestIdleCallback(performWork);}}复制代码workLoop的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘执行单元‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复://保存当前的处理现场letnextUnitOfWork:Fiber|undefined//保存下一个需要处理的工作单元lettopWork:Fiber|undefined//保存第一个工作单元functionworkLoop(deadline:IdleDeadline){//updateQueue中获取下一个或者恢复上一次中断的执行单元if(nextUnitOfWork==null){nextUnitOfWork=topWork=getNextUnitOfWork();}//🔴每执行完一个执行单元，检查一次剩余时间//如果被中断，下一次执行还是从nextUnitOfWork开始处理while(nextUnitOfWork&&deadline.timeRemaining()>ENOUGH_TIME){//下文我们再看performUnitOfWorknextUnitOfWork=performUnitOfWork(nextUnitOfWork,topWork);}//提交工作，下文会介绍if(pendingCommit){commitAllWork(pendingCommit);}}复制代码画个流程图吧！\">React的Fiber改造Fiber的核心内容已经介绍完了，现在来进一步看看React为Fiber架构做了哪些改造,如果你对这部分内容不感兴趣可以跳过。1.数据结构的调整\">左侧是VirtualDOM，右侧可以看作diff的递归调用栈上文中提到React16之前，Reconcilation是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为StackReconcilation.你可以通过这篇文章《从Preact中了解React组件和hooks基本原理》来回顾一下历史。栈挺好的，代码量少，递归容易理解,至少比现在的ReactFiber架构好理解😂,递归非常适合树这种嵌套数据结构的处理。只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复,不利于异步处理。这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始,恢复到之前的调用栈。因此首先我们需要对React现有的数据结构进行调整，模拟函数调用栈,将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代.React目前的做法是使用链表,每个VirtualDOM节点内部现在使用Fiber表示,它的结构大概如下:exporttypeFiber={//Fiber类型信息type:any,//...//⚛️链表结构//指向父节点，或者render该节点的组件return:Fiber|null,//指向第一个子节点child:Fiber|null,//指向下一个兄弟节点sibling:Fiber|null,}复制代码用图片来展示这种关系会更直观一些：\">使用链表结构只是一个结果，而不是目的，React开发者一开始的目的是冲着模拟调用栈去的。这个很多关于Fiber的文章都有提及,关于调用栈的详细定义参见Wiki：\">调用栈最经常被用于存放子程序的返回地址。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存本地变量、函数参数、环境传递(Scope?)ReactFiber也被称为虚拟栈帧(VirtualStackFrame),你可以拿它和函数调用栈类比一下,两者结构非常像:函数调用栈Fiber基本单位函数VirtualDOM节点输入函数参数Props本地状态本地变量State输出函数返回值ReactElement下级嵌套函数调用子节点(child)上级引用返回地址父节点(return)Fiber和调用栈帧一样,保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看performUnitOfWork的实现,它其实就是一个深度优先的遍历：/***@paramsfiber当前需要处理的节点*@paramstopWork本次更新的根节点*/functionperformUnitOfWork(fiber:Fiber,topWork:Fiber){//对该节点进行处理beginWork(fiber);//如果存在子节点，那么下一个待处理的就是子节点if(fiber.child){returnfiber.child;}//没有子节点了，上溯查找兄弟节点lettemp=fiber;while(temp){completeWork(temp);//到顶层节点了,退出if(temp===topWork){break}//找到，下一个要处理的就是兄弟节点if(temp.sibling){returntemp.sibling;}//没有,继续上溯temp=temp.return;}}复制代码你可以配合上文的workLoop一起看，Fiber就是我们所说的工作单元，performUnitOfWork负责对Fiber进行操作，并按照深度遍历的顺序返回下一个Fiber。因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的Fiber继续遍历下去。整个迭代顺序和之前递归的一样,下图假设在div.app进行了更新：\">比如你在text(hello)中断了，那么下一次就会从p节点开始处理这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的return回溯即可。2.两个阶段的拆分\">如果你现在使用最新的React版本(v16),使用Chrome的Performance工具，可以很清晰地看到每次渲染有两个阶段：Reconciliation(协调阶段)和Commit(提交阶段).我在之前的多篇文章中都有提及:《自己写个React渲染器:以Remax为例(用React写小程序)》除了Fiber工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:⚛️协调阶段:可以认为是Diff阶段,这个阶段可以被中断,这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等,这些变更React称之为'副作用(Effect)'.以下生命周期钩子会在协调阶段被调用：constructorcomponentWillMount废弃componentWillReceiveProps废弃staticgetDerivedStateFromPropsshouldComponentUpdatecomponentWillUpdate废弃rendergetSnapshotBeforeUpdate()⚛️提交阶段:将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。这个阶段必须同步执行，不能被打断.这些生命周期钩子在提交阶段被执行:componentDidMountcomponentDidUpdatecomponentWillUnmount也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，⚠️React协调阶段的生命周期钩子可能会被调用多次!,例如componentWillMount可能会被调用两次。因此建议协调阶段的生命周期钩子不要包含副作用.索性React就废弃了这部分可能包含副作用的生命周期方法，例如componentWillMount、componentWillMount.v17后我们就不能再用它们了,所以现有的应用应该尽快迁移.现在你应该知道为什么'提交阶段'必须同步执行，不能中断的吧？因为我们要正确地处理各种副作用，包括DOM变更、还有你在componentDidMount中发起的异步请求、useEffect中定义的副作用...因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更,不容差池。关于为什么要拆分两个阶段，这里有更详细的解释。3.Reconcilation接下来就是就是我们熟知的Reconcilation(为了方便理解，本文不区分Diff和Reconcilation,两者是同一个东西)阶段了.思路和Fiber重构之前差别不大,只不过这里不会再递归去比对、而且不会马上提交变更。首先再进一步看一下Fiber的结构:interfaceFiber{/***⚛️节点的类型信息*///标记Fiber类型,例如函数组件、类组件、宿主组件tag:WorkTag,//节点元素类型,是具体的类组件、函数组件、宿主组件(字符串)type:any,/***⚛️结构信息*/return:Fiber|null,child:Fiber|null,sibling:Fiber|null,//子节点的唯一键,即我们渲染列表传入的key属性key:null|string,/***⚛️节点的状态*///节点实例(状态)：//对于宿主组件，这里保存宿主组件的实例,例如DOM节点。//对于类组件来说，这里保存类组件的实例//对于函数组件说，这里为空，因为函数组件没有实例stateNode:any,//新的、待处理的propspendingProps:any,//上一次渲染的propsmemoizedProps:any,//Thepropsusedtocreatetheoutput.//上一次渲染的组件状态memoizedState:any,/***⚛️副作用*///当前节点的副作用类型，例如节点更新、删除、移动effectTag:SideEffectTag,//和节点关系一样，React同样使用链表来将所有有副作用的Fiber连接起来nextEffect:Fiber|null,/***⚛️替身*指向旧树中的节点*/alternate:Fiber|null,}复制代码Fiber包含的属性可以划分为5个部分:🆕结构信息-这个上文我们已经见过了，Fiber使用链表的形式来表示节点在树中的定位节点类型信息-这个也容易理解，tag表示节点的分类、type保存具体的类型值，如div、MyComp节点的状态-节点的组件实例、props、state等，它们将影响组件的输出🆕副作用-这个也是新东西.在Reconciliation过程中发现的'副作用'(变更需求)就保存在节点的effectTag中(想象为打上一个标记).那么怎么将本次渲染的所有节点副作用都收集起来呢？这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过nextEffect连接起来🆕替身-React在Reconciliation过程中会构建一颗新的树(官方称为workInProgresstree，WIP树)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的旧树，React就是一边和旧树比对，一边构建WIP树的。alternate指向旧树的同等节点。现在可以放大看看beginWork是如何对Fiber进行比对的:functionbeginWork(fiber:Fiber):Fiber|undefined{if(fiber.tag===WorkTag.HostComponent){//宿主节点diffdiffHostComponent(fiber)}elseif(fiber.tag===WorkTag.ClassComponent){//类组件节点diffdiffClassComponent(fiber)}elseif(fiber.tag===WorkTag.FunctionComponent){//函数组件节点diffdiffFunctionalComponent(fiber)}else{//...其他类型节点，省略}}复制代码宿主节点比对:functiondiffHostComponent(fiber:Fiber){//新增节点if(fiber.stateNode==null){fiber.stateNode=createHostComponent(fiber)}else{updateHostComponent(fiber)}constnewChildren=fiber.pendingProps.children;//比对子节点diffChildren(fiber,newChildren);}复制代码类组件节点比对也差不多:functiondiffClassComponent(fiber:Fiber){//创建组件实例if(fiber.stateNode==null){fiber.stateNode=createInstance(fiber);}if(fiber.hasMounted){//调用更新前生命周期钩子applybeforeUpdateHooks(fiber)}else{//调用挂载前生命周期钩子applybeforeMountHooks(fiber)}//渲染新节点constnewChildren=fiber.stateNode.render();//比对子节点diffChildren(fiber,newChildren);fiber.memoizedState=fiber.stateNode.state}复制代码子节点比对:functiondiffChildren(fiber:Fiber,newChildren:React.ReactNode){letoldFiber=fiber.alternate?fiber.alternate.child:null;//全新节点，直接挂载if(oldFiber==null){mountChildFibers(fiber,newChildren)return}letindex=0;letnewFiber=null;//新子节点constelements=extraElements(newChildren)//比对子元素while(index<elements.length||oldFiber!=null){constprevFiber=newFiber;constelement=elements[index]constsameType=isSameType(element,oldFiber)if(sameType){newFiber=cloneFiber(oldFiber,element)//更新关系newFiber.alternate=oldFiber//打上TagnewFiber.effectTag=UPDATEnewFiber.return=fiber}//新节点if(element&&!sameType){newFiber=createFiber(element)newFiber.effectTag=PLACEMENTnewFiber.return=fiber}//删除旧节点if(oldFiber&&!sameType){oldFiber.effectTag=DELETION;oldFiber.nextEffect=fiber.nextEffectfiber.nextEffect=oldFiber}if(oldFiber){oldFiber=oldFiber.sibling;}if(index==0){fiber.child=newFiber;}elseif(prevFiber&&element){prevFiber.sibling=newFiber;}index++}}复制代码上面的代码很粗糙地还原了Reconciliation的过程,但是对于我们理解React的基本原理已经足够了.这里引用一下Youtube:LinClarkpresentationinReactConf2017的Slide，来还原Reconciliation的过程.LinClark这个演讲太经典了，几乎所有介绍ReactFiber的文章都会引用它的Slide.偷个懒，我也用下:这篇文章《ReactFiber》用文字版解释了LinkClarkSlide.\">上图是Reconciliation完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了'标签'。在提交阶段，React就会将这些打上标签的节点应用变更。4.双缓冲WIP树构建这种技术类似于图形化领域的'双缓存(DoubleBuffering)'技术,图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。放到React中，WIP树就是一个缓冲，它在Reconciliation完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。Dan在BeyondReact16演讲中用了一个非常恰当的比喻，那就是Git功能分支，你可以将WIP树想象成从旧树中Fork出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉.这或许就是’提交(commit)阶段‘的提交一词的来源吧？:\">5.副作用的收集和提交接下来就是将所有打了Effect标记的节点串联起来，这个可以在completeWork中做,例如:functioncompleteWork(fiber){constparent=fiber.return//到达顶端if(parent==null||fiber===topWork){pendingCommit=fiberreturn}if(fiber.effectTag!=null){if(parent.nextEffect){parent.nextEffect.nextEffect=fiber}else{parent.nextEffect=fiber}}elseif(fiber.nextEffect){parent.nextEffect=fiber.nextEffect}}复制代码最后了，将所有副作用提交了:functioncommitAllWork(fiber){letnext=fiberwhile(next){if(fiber.effectTag){//提交，偷一下懒，这里就不展开了commitWork(fiber)}next=fiber.nextEffect}//清理现场pendingCommit=nextUnitOfWork=topWork=null}复制代码⚠️未展开部分🚧--中断和恢复上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。也就是说，到目前为止：⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了.对于那些需要优先处理的更新任务还是会被阻塞。我个人觉得这才是ReactFiber中最难处理的一部分。实际情况是，在React得到控制权后，应该优先处理高优先级的任务。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。但是如果不按顺序执行任务，可能会导致前后的状态不一致。比如低优先级任务将a设置为0，而高优先级任务将a递增1,两个任务的执行顺序会影响最终的渲染结果。因此要让高优先级任务插队,首先要保证状态更新的时序。解决办法是:所有更新任务按照顺序插入一个队列,状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行,例如：\">红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态,从而保证状态的最终一致性：\">最终红色的高优先级任务C执行时的状态值是a=5,b=3.在恢复控制权时，会按照优先级先执行C,前面的A、B暂时跳过\">上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子a、b可能会影响Foo组件树，而c会影响Bar组件树。所以为了保证视图的最终一致性,所有更新任务都要被执行。\">首先C先被执行，它更新了Foo组件接着执行A任务，它更新了Foo和Bar组件，由于C已经以最终状态a=5,b=3更新了Foo组件，这里可以做一下性能优化，直接复用C的更新结果，不必触发重新渲染。因此A仅需更新Bar组件即可。接着执行B，同理可以复用Foo更新结果。道理讲起来都很简单，ReactFiber实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证状态的一致性和视图的一致性，这给了React团队很大的考验，以致于现在都没有正式release出来。凌波微步\">同样来自LinkClark的Slider前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作,地老天荒...就是为了上面的小人可以在练就凌波微步,它脚下的坑是浏览器的调用栈。React开启ConcurrentMode之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。\">来源：FlarnieMarchan-ReadyforConcurrentMode?开启ConcurrentMode后，我们可以得到以下好处(详见ConcurrentRenderinginReact):快速响应用户操作和输入，提升用户交互体验让动画更加流畅，通过调度，可以让应用保持高帧率利用好I/O操作空闲期或者CPU空闲期，进行一些预渲染。比如离屏(offscreen)不可见的内容，优先级最低，可以让React等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。用Suspense降低加载状态(loadstate)的优先级，减少闪屏。比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。为了共同创造美好的世界，我们要严律于己，该做的优化还需要做:纯组件、虚表、简化组件、缓存...尤雨溪在今年的VueConf一个观点让我印象深刻：如果我们可以把更新做得足够快的话，理论上就不需要时间分片了。时间分片并没有降低整体的工作量，该做的还是要做,因此React也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：ReactFiber本质上是为了解决React更新低效率的问题，不要期望Fiber能给你现有应用带来质的提升,如果性能问题是自己造成的，自己的锅还是得自己背.站在巨人的肩膀上本文之所以能成文，离不开社区上优质的开源项目和资料。迷你Fiber实现:React现在的代码库太复杂了!而且一直在变动和推翻自己，Hax在《为什么社区里那些类React库至今没有选择实现Fiber架构？》就开玩笑说:Fiber性价比略低...到了这个阶段，竞品太多，facebook就搞一个fiber来作为护城河……这种工程量不是一般团队能Hold住的，如果你只是想了解Fiber，去读React的源码性价比也很低，不妨看看这些Mini版实现,感受其精髓，不求甚解:anu司徒正美开发的类React框架Fre伊撒尔开发的类React框架，代码很精简⁉️Luydidact优秀的文章&演讲本文只是对ReactFiber进行了简单的科普，实际上React的实现比本文复杂的多，如果你想深入理解ReactFiber的，下面这些文章不容错过:LinClark-ACartoonIntrotoFiber-ReactConf2017👍🎦ReactFiber启蒙，YouTubeBeyondReact16-DanAbramov👍🎦ConcurrentRenderinginReact-AndrewClarkandBrianVaughn👍🎦司徒正美:ReactFiber架构👍看不如写展望React17，回顾React往事👍看完Heaven的相关文章，会觉得你了解的React知识真的只是冰山一角，我们都没资格说我们懂React。浅入React16/fiber系列👍同样来自Heaven淡苍：深入剖析ReactConcurrent👍DidactFiber:Incrementalreconciliation👍实现了简单的ReactFiber程墨:ReactFiber是什么译深入Reactfiber架构及源码黯羽轻扬:完全理解ReactFiberFiberPrinciples:ContributingToFiberSchedulinginReact桃翁:DeepInReact之浅谈ReactFiber架构（一）为Luy实现ReactFiber架构妖僧风月:ReactFiberFlarnieMarchan-ReadyforConcurrentMode?🎦WebFundamentals>Performance你应该知道的requestIdleCallback深入探究eventloop与浏览器渲染的时序问题Accuratelymeasuringlayoutontheweb自荐React相关文章回顾一下今年写的关于React的相关文章React组件设计实践总结系列共5篇自己写个React渲染器:以Remax为例(用React写小程序)谈谈React事件机制和未来(react-events)2019年了，整理了N个实用案例帮你快速迁移到ReactHooks浅谈React性能优化的方向从Preact中了解React组件和hooks基本原理React性能测量和分析本文讲了React如何优化CPU问题，React野心远不在于此,I/O方向的优化也在实践，例如Suspend...还有很多没讲完，后面的文章见！问卷调查，你觉得这种文章风格怎样？A.事无巨细，太啰嗦了B.娓娓道来，深入浅出我喜欢C.内容不够深入D.文章篇幅太长，可以拆分多选，下方评论，👍点赞走起改了一个正经一点的网名：sx(傻叉)->荒山⛰\">",
      "id": "h7ju32v00vk",
      "author": "火狼1",
      "title": "这可能是最通俗的 React Fiber(时间分片) 打开方式"
    },
    {
      "content": "前言是时候撸一波JS基础啦,撸熟了,银十速拿offer;本文不从传统的问答方式梳理,而是从知识维度梳理,以便形成知识网络;包括函数,数组,对象,数据结构,算法,设计模式和http.1.函数1.1函数的3种定义方法1.1.1函数声明//ES5functiongetSum(){}function(){}//匿名函数//ES6()=>{}//如果{}内容只有一行{}和return关键字可省,复制代码1.1.2函数表达式(函数字面量)//ES5varsum=function(){}//ES6letsum=()=>{}//如果{}内容只有一行{}和return关键字可省,复制代码1.1.3构造函数constsum=newFunction('a','b','returna+b')复制代码1.1.4三种方法的对比1.函数声明有预解析,而且函数声明的优先级高于变量;2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串1.2.ES5中函数的4种调用在ES5中函数内容的this指向和调用方法有关1.2.1函数调用模式包括函数名()和匿名函数调用,this指向windowfunctiongetSum(){console.log(this)//window}getSum()(function(){console.log(this)//window})()vargetSum=function(){console.log(this)//window}getSum()复制代码1.2.2方法调用对象.方法名(),this指向对象varobjList={name:'methods',getSum:function(){console.log(this)//objList对象}}objList.getSum()复制代码1.2.3构造器调用new构造函数名(),this指向构造函数functionPerson(){console.log(this);//指向构造函数Person}varpersonOne=newPerson();复制代码1.2.4间接调用利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向windowfunctionfoo(){console.log(this);}foo.apply('我是apply改变的this值');//我是apply改变的this值foo.call('我是call改变的this值');//我是call改变的this值复制代码1.3ES6中函数的调用箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误箭头函数的this是和定义时有关和调用无关调用就是函数调用模式(()=>{console.log(this)//window})()letarrowFun=()=>{console.log(this)//window}arrowFun()letarrowObj={arrFun:function(){(()=>{console.log(this)//arrowObj})()}}arrowObj.arrFun();复制代码1.4.call,apply和bind1.IE5之前不支持call和apply,bind是ES5出来的;2.call和apply可以调用函数,改变this,实现继承和借用别的对象的方法;1.4.1call和apply定义调用方法,用一个对象替换掉另一个对象(this)对象.call(新this对象,实参1,实参2,实参3.....)对象.apply(新this对象,[实参1,实参2,实参3.....])1.4.2call和apply用法1.间接调用函数,改变作用域的this值2.劫持其他对象的方法varfoo={name:\"张三\",logName:function(){console.log(this.name);}}varbar={name:\"李四\"};foo.logName.call(bar);//李四实质是call改变了foo的this指向为bar,并调用该函数复制代码3.两个函数实现继承functionAnimal(name){this.name=name;this.showName=function(){console.log(this.name);}}functionCat(name){Animal.call(this,name);}varcat=newCat(\"BlackCat\");cat.showName();//BlackCat复制代码4.为类数组(arguments和nodeList)添加数组方法push,pop(function(){Array.prototype.push.call(arguments,'王五');console.log(arguments);//['张三','李四','王五']})('张三','李四')复制代码5.合并数组letarr1=[1,2,3];letarr2=[4,5,6];Array.prototype.push.apply(arr1,arr2);//将arr2合并到了arr1中复制代码6.求数组最大值Math.max.apply(null,arr)复制代码7.判断字符类型Object.prototype.toString.call({})复制代码1.4.3bindbind是function的一个函数扩展方法，bind以后代码重新绑定了func内部的this指向,不会调用方法,不兼容IE8varname='李四'varfoo={name:\"张三\",logName:function(age){console.log(this.name,age);}}varfooNew=foo.logName;varfooNewBind=foo.logName.bind(foo);fooNew(10)//李四,10fooNewBind(11)//张三,11因为bind改变了fooNewBind里面的this指向复制代码1.4.4call,apply和bind原生实现call实现:Function.prototype.newCall=function(context,...parameter){if(context.instanceof!==Object)context={}context.fn=this;context.fn(...parameter);deletecontext.fn;}letperson={name:'Abiel'}functionsayHi(age,sex){console.log(this.name,age,sex);}sayHi.newCall(person,25,'男');//Abiel25男复制代码apply实现:Function.prototype.newApply=function(context,parameter){if(typeofcontext==='object'){context=context||window}else{context=Object.create(null)}letfn=Symbol()context[fn]=thiscontext[fn](parameter);deletecontext[fn]}复制代码bind实现:Function.prototype.bind=function(context,...innerArgs){varme=thisreturnfunction(...finnalyArgs){returnme.call(context,...innerArgs,...finnalyArgs)}}letperson={name:'Abiel'}functionsayHi(age,sex){console.log(this.name,age,sex);}letpersonSayHi=sayHi.bind(person,25)personSayHi('男')复制代码1.4.5三者异同同:都是改变this指向,都可接收参数异:bind和call是接收单个参数,apply是接收数组1.5.函数的节流和防抖类型概念应用节流某个时间段内,只执行一次滚动条,resize事件一段时间触发一次防抖处理函数截止后一段时间依次执行onscroll,resize事件触发完后一段时间触发节流:1.5.1节流letthrottle=function(func,delay){lettimer=null;returnfunction(){if(!timer){timer=setTimeout(function(){func.apply(this,arguments);timer=null;},delay);}};};functionhandle(){console.log(Math.random());}window.addEventListener(\"onscroll\",throttle(handle,1000));//事件处理函数复制代码1.5.2防抖functiondebounce(fn,wait){vartimeout=null;returnfunction(){if(timeout!==null)clearTimeout(timeout);//如果多次触发将上次记录延迟清除掉timeout=setTimeout(function(){fn.apply(this,arguments);timeout=null;},wait);};}//处理函数functionhandle(){console.log(Math.random());}//滚动事件window.addEventListener(\"onscroll\",debounce(handle,1000));复制代码1.6.原型链1.6.1定义对象继承属性的一个链条1.6.2构造函数,实例与原型对象的关系\">varPerson=function(name){this.name=name;}//person是构造函数varo3personTwo=newPerson('personTwo')//personTwo是实例复制代码\">原型对象都有一个默认的constructor属性指向构造函数1.6.3创建实例的方法1.字面量letobj={'name':'张三'}复制代码2.Object构造函数创建letObj=newObject()Obj.name='张三'复制代码3.使用工厂模式创建对象functioncreatePerson(name){varo=newObject();o.name=name;};returno;}varperson1=createPerson('张三');复制代码4.使用构造函数创建对象functionPerson(name){this.name=name;}varperson1=newPerson('张三');复制代码1.6.4new运算符1.创了一个新对象;2.this指向构造函数;3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象4.手动封装一个new运算符varnew2=function(func){varo=Object.create(func.prototype);//创建对象vark=func.call(o);//改变this指向，把结果付给kif(typeofk==='object'){//判断k的类型是不是对象returnk;&emsp;//是，返回k}else{returno;//不是返回返回构造函数的执行结果}}复制代码1.6.5对象的原型链\">1.7继承的方式JS是一门弱类型动态语言,封装和继承是他的两大特性1.7.1原型链继承将父类的实例作为子类的原型1.代码实现定义父类://定义一个动物类functionAnimal(name){//属性this.name=name||'Animal';//实例方法this.sleep=function(){console.log(this.name+'正在睡觉！');}}//原型方法Animal.prototype.eat=function(food){console.log(this.name+'正在吃：'+food);};复制代码子类:functionCat(){}Cat.prototype=newAnimal();Cat.prototype.name='cat';//&emsp;TestCodevarcat=newCat();console.log(cat.name);//catconsole.log(cat.eat('fish'));//cat正在吃：fishundefinedconsole.log(cat.sleep());//cat正在睡觉！undefinedconsole.log(catinstanceofAnimal);//trueconsole.log(catinstanceofCat);//true复制代码2.优缺点简单易于实现,但是要想为子类新增属性和方法，必须要在newAnimal()这样的语句之后执行,无法实现多继承1.7.2构造继承实质是利用call来改变Cat中的this指向1.代码实现子类:functionCat(name){Animal.call(this);this.name=name||'Tom';}复制代码2.优缺点可以实现多继承,不能继承原型属性/方法1.7.3实例继承为父类实例添加新特性，作为子类实例返回1.代码实现子类functionCat(name){varinstance=newAnimal();instance.name=name||'Tom';returninstance;}复制代码2.优缺点不限制调用方式,但不能实现多继承1.7.4拷贝继承将父类的属性和方法拷贝一份到子类中1.子类:functionCat(name){varanimal=newAnimal();for(varpinanimal){Cat.prototype[p]=animal[p];}Cat.prototype.name=name||'Tom';}复制代码2.优缺点支持多继承,但是效率低占用内存1.7.5组合继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用1.子类:functionCat(name){Animal.call(this);this.name=name||'Tom';}Cat.prototype=newAnimal();Cat.prototype.constructor=Cat;复制代码1.7.6寄生组合继承functionCat(name){Animal.call(this);this.name=name||'Tom';}(function(){//创建一个没有实例方法的类varSuper=function(){};Super.prototype=Animal.prototype;//将实例作为子类的原型Cat.prototype=newSuper();})();复制代码1.7.7ES6的extends继承ES6的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this//父类classPerson{//constructor是构造方法constructor(skin,language){this.skin=skin;this.language=language;}say(){console.log('我是父类')}}//子类classChineseextendsPerson{constructor(skin,language,positon){//console.log(this);//报错super(skin,language);//super();相当于父类的构造函数//console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this)this.positon=positon;}aboutMe(){console.log(`${this.skin}${this.language}${this.positon}`);}}//调用只能通过new的方法得到实例,再调用里面的方法letobj=newChinese('红色','中文','香港');obj.aboutMe();obj.say();复制代码1.8.高阶函数1.8.1定义函数的参数是函数或返回函数1.8.2常见的高阶函数map,reduce,filter,sort1.8.3柯里化1.定义:只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数fn(a,b,c,d)=>fn(a)(b)(c)(d)复制代码2.代码实现:constcurrying=fn=>{constlen=fn.lengthreturnfunctioncurr(...args1){if(args1.length>=len){returnfn(...args1)}return(...args2)=>curr(...args1,...args2)}}复制代码1.8.4反柯里化1.定义:obj.func(arg1,arg2)=>func(obj,arg1,arg2)复制代码2.代码实现:Function.prototype.uncurrying=function(){varthat=this;returnfunction(){returnFunction.prototype.call.apply(that,arguments);}};functionsayHi(){return\"Hello\"+this.value+\"\"+[].slice.call(arguments);}letsayHiuncurrying=sayHi.uncurrying();console.log(sayHiuncurrying({value:'world'},\"hahaha\"));复制代码1.8.5偏函数1.定义:指定部分参数来返回一个新的定制函数的形式2.例子:functionfoo(a,b,c){returna+b+c;}functionfunc(a,b){returnfoo(a,b,8);}复制代码2.对象2.1.对象的声明方法2.1.1字面量vartest2={x:123,y:345};console.log(test2);//{x:123,y:345};console.log(test2.x);//123console.log(test2.__proto__.x);//undefinedconsole.log(test2.__proto__.x===test2.x);//false复制代码2.1.2构造函数vartest1=newObject({x:123,y:345});console.log(test1);//{x:123,y:345}console.log(test1.x);//123console.log(test1.__proto__.x);//undefinedconsole.log(test1.__proto__.x===test1.x);//false复制代码new的作用:1.创了一个新对象;2.this指向构造函数;3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象2.1.3内置方法Obejct.create(obj,descriptor),obj是对象,describe描述符属性(可选)lettest=Object.create({x:123,y:345});console.log(test);//{}console.log(test.x);//123console.log(test.__proto__.x);//3console.log(test.__proto__.x===test.x);//true复制代码2.1.4三种方法的优缺点1.功能:都能实现对象的声明,并能够赋值和取值2.继承性:内置方法创建的对象继承到__proto__属性上3.隐藏属性:三种声明方法会默认为内部的每个成员（属性或方法）生成一些隐藏属性，这些隐藏属性是可以读取和可配置的,属性分类见下面4.属性读取:Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptor()5.属性设置:Object.definePropertype或Object.defineProperties2.2.对象的属性2.2.1属性分类1.数据属性4个特性:configurable(可配置),enumerable(可枚举),writable(可修改),value(属性值)2.访问器属性2个特性:get(获取),set(设置)3.内部属性由JavaScript引擎内部使用的属性;不能直接访问,但是可以通过对象内置方法间接访问,如:[[Prototype]]可以通过Object.getPrototypeOf()访问;内部属性用[[]]包围表示,是一个抽象操作,没有对应字符串类型的属性名,如[[Prototype]].2.2.2属性描述符1.定义:将一个属性的所有特性编码成一个对象返回2.描述符的属性有:数据属性和访问器属性3.使用范围:作为方法Object.defineProperty,Object.getOwnPropertyDescriptor,Object.create的第二个参数,2.2.3属性描述符的默认值1.访问对象存在的属性特性名默认值value对应属性值get对应属性值setundefinedwritabletrueenumerabletrueconfigurabletrue所以通过上面三种声明方法已存在的属性都是有这些默认描述符2.访问对象不存在的属性特性名默认值valueundefinedgetundefinedsetundefinedwritablefalseenumerablefalseconfigurablefalse2.2.3描述符属性的使用规则get,set与wriable,value是互斥的,如果有交集设置会报错2.2.4属性定义1.定义属性的函数有两个:Object.defineProperty和Object.defineProperties.例如:Object.defineProperty(obj,propName,desc)2.在引擎内部,会转换成这样的方法调用:obj.[[DefineOwnProperty]](propName,desc,true)2.2.5属性赋值1.赋值运算符(=)就是在调用[[Put]].比如:obj.prop=v;2.在引擎内部,会转换成这样的方法调用:obj.[[Put]](\"prop\",v,isStrictModeOn)2.2.6判断对象的属性名称含义用法in如果指定的属性在指定的对象或其原型链中，则in运算符返回true'name'intest//truehasOwnProperty()只判断自身属性test.hasOwnProperty('name')//true.或[]对象或原型链上不存在该属性，则会返回undefinedtest.name//\"lei\"test[\"name\"]//\"lei\"2.3.Symbol2.3.1概念是一种数据类型;不能new,因为Symbol是一个原始类型的值，不是对象。2.3.2定义方法Symbol(),可以传参vars1=Symbol();vars2=Symbol();s1===s2//false//有参数的情况vars1=Symbol(\"foo\");vars2=Symbol(\"foo\");s1===s2//false复制代码2.3.3用法1.不能与其他类型的值进行运算;2.作为属性名letmySymbol=Symbol();//第一种写法vara={};a[mySymbol]='Hello!';//第二种写法vara={[mySymbol]:'Hello!'};//第三种写法vara={};Object.defineProperty(a,mySymbol,{value:'Hello!'});//以上写法都得到同样结果a[mySymbol]//\"Hello!\"复制代码3.作为对象属性名时，不能用点运算符,可以用[]leta={};letname=Symbol();a.name='lili';a[name]='lucy';console.log(a.name,a[name]);复制代码4.遍历不会被for...in、for...of和Object.keys()、Object.getOwnPropertyNames()取到该属性2.3.4Symbol.for1.定义:在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值2.举例:vars1=Symbol.for('foo');vars2=Symbol.for('foo');s1===s2//true复制代码2.3.5Symbol.keyFor1.定义:返回一个已登记的Symbol类型值的key2.举例:vars1=Symbol.for(\"foo\");Symbol.keyFor(s1)//\"foo\"vars2=Symbol(\"foo\");Symbol.keyFor(s2)//undefined复制代码2.4.遍历2.4.1一级对象遍历方法方法特性for...in遍历对象自身的和继承的可枚举属性(不含Symbol属性)Object.keys(obj)返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)Object.getOwnPropertyNames(obj)返回一个数组,包括对象自身的所有可枚举属性(不含Symbol属性)Object.getOwnPropertySymbols(obj)返回一个数组,包含对象自身的所有Symbol属性Reflect.ownKeys(obj)返回一个数组,包含对象自身的所有(不枚举、可枚举和Symbol)属性Reflect.enumerate(obj)返回一个Iterator对象,遍历对象自身的和继承的所有可枚举属性(不含Symbol属性)总结:1.只有Object.getOwnPropertySymbols(obj)和Reflect.ownKeys(obj)可以拿到Symbol属性2.只有Reflect.ownKeys(obj)可以拿到不可枚举属性2.4.2多级对象遍历数据模型:vartreeNodes=[{id:1,name:'1',children:[{id:11,name:'11',children:[{id:111,name:'111',children:[]},{id:112,name:'112'}]},{id:12,name:'12',children:[]}],users:[]},];复制代码递归:varparseTreeJson=function(treeNodes){if(!treeNodes||!treeNodes.length)return;for(vari=0,len=treeNodes.length;i<len;i++){varchilds=treeNodes[i].children;console.log(treeNodes[i].id);if(childs&&childs.length>0){parseTreeJson(childs);}}};console.log('-------------递归实现------------------');parseTreeJson(treeNodes);复制代码2.5.深度拷贝2.5.1Object.assign1.定义:将源对象（source）的所有可枚举属性，复制到目标对象（target）2.用法:合并多个对象vartarget={a:1,b:1};varsource1={b:2,c:2};varsource2={c:3};Object.assign(target,source1,source2);复制代码3.注意:这个是伪深度拷贝,只能拷贝第一层2.5.2JSON.stringify1.原理:是将对象转化为字符串,而字符串是简单数据类型2.5.3递归拷贝functiondeepClone(source){consttargetObj=source.constructor===Array?[]:{};//判断复制的目标是数组还是对象for(letkeysinsource){//遍历目标if(source.hasOwnProperty(keys)){if(source[keys]&&typeofsource[keys]==='object'){//如果值是对象，就递归一下targetObj[keys]=source[keys].constructor===Array?[]:{};targetObj[keys]=deepClone(source[keys]);}else{//如果不是，就直接赋值targetObj[keys]=source[keys];}}}returntargetObj;}复制代码2.6.数据拦截定义:利用对象内置方法,设置属性,进而改变对象的属性值2.6.1Object.defineProterty1.ES5出来的方法;2.三个参数:对象(必填),属性值(必填),描述符(可选);3.defineProterty的描述符属性数据属性:value,writable,configurable,enumerable访问器属性:get,set注:不能同时设置value和writable,这两对属性是互斥的复制代码4.拦截对象的两种情况:letobj={name:'',age:'',sex:''},defaultName=[\"这是姓名默认值1\",\"这是年龄默认值1\",\"这是性别默认值1\"];Object.keys(obj).forEach(key=>{Object.defineProperty(obj,key,{get(){returndefaultName;},set(value){defaultName=value;}});});console.log(obj.name);console.log(obj.age);console.log(obj.sex);obj.name=\"这是改变值1\";console.log(obj.name);console.log(obj.age);console.log(obj.sex);letobjOne={},defaultNameOne=\"这是默认值2\";Object.defineProperty(obj,'name',{get(){returndefaultNameOne;},set(value){defaultNameOne=value;}});console.log(objOne.name);objOne.name=\"这是改变值2\";console.log(objOne.name);复制代码5.拦截数组变化的情况leta={};bValue=1;Object.defineProperty(a,\"b\",{set:function(value){bValue=value;console.log(\"setted\");},get:function(){returnbValue;}});a.b;//1a.b=[];//setteda.b=[1,2,3];//setteda.b[1]=10;//无输出a.b.push(4);//无输出a.b.length=5;//无输出a.b;//[1,10,3,4,undefined];结论:defineProperty无法检测数组索引赋值,改变数组长度的变化;但是通过数组方法来操作可以检测到复制代码6.存在的问题不能监听数组索引赋值和改变长度的变化必须深层遍历嵌套的对象,因为defineProterty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择复制代码2.6.2proxy1.ES6出来的方法,实质是对对象做了一个拦截,并提供了13个处理方法2.两个参数:对象和行为函数lethandler={get(target,key,receiver){console.log(\"get\",key);returnReflect.get(target,key,receiver);},set(target,key,value,receiver){console.log(\"set\",key,value);returnReflect.set(target,key,value,receiver);}};letproxy=newProxy(obj,handler);proxy.name=\"李四\";proxy.age=24;复制代码3.问题和优点reflect对象没有构造函数可以监听数组索引赋值,改变数组长度的变化,是直接监听对象的变化,不用深层遍历2.6.3defineProterty和proxy的对比1.defineProterty是es5的标准,proxy是es6的标准;2.proxy可以监听到数组索引赋值,改变数组长度的变化;3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;3.利用defineProterty实现双向数据绑定(vue2.x采用的核心)4.利用proxy实现双向数据绑定(vue3.x会采用)3.数组数组基本上考察数组方法多一点,所以这里就单纯介绍常见的场景数组的方法,还有很多场景后续补充;本文主要从应用来讲数组api的一些骚操作;如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等；上面这些应用场景你可以用一行代码实现？3.1扁平化n维数组1.终极篇[1,[2,3]].flat(2)//[1,2,3][1,[2,3,[4,5]].flat(3)//[1,2,3,4,5][1,[2,3,[4,5]]].toString()//'1,2,3,4,5'[1[2,3,[4,5[...]].flat(Infinity)//[1,2,3,4...n]复制代码Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大2.开始篇functionflatten(arr){while(arr.some(item=>Array.isArray(item))){arr=[].concat(...arr);}returnarr;}flatten([1,[2,3]])//[1,2,3]flatten([1,[2,3,[4,5]])//[1,2,3,4,5]复制代码实质是利用递归和数组合并方法concat实现扁平3.2去重1.终极篇Array.from(newSet([1,2,3,3,4,4]))//[1,2,3,4][...newSet([1,2,3,3,4,4])]//[1,2,3,4]复制代码set是ES6新出来的一种一种定义不重复数组的数据类型Array.from是将类数组转化为数组...是扩展运算符,将set里面的值转化为字符串2.开始篇Array.prototype.distinct=nums=>{constmap={}constresult=[]for(constnofnums){if(!(ninmap)){map[n]=1result.push(n)}}returnresult}[1,2,3,3,4,4].distinct();//[1,2,3,4]复制代码取新数组存值,循环两个数组值相比较3.3排序1.终极篇[1,2,3,4].sort((a,b)=>a-b);//[1,2,3,4],默认是升序[1,2,3,4].sort((a,b)=>b-a);//[4,3,2,1]降序复制代码sort是js内置的排序方法,参数为一个函数2.开始篇冒泡排序:Array.prototype.bubleSort=function(){letarr=this,len=arr.length;for(letouter=len;outer>=2;outer--){for(letinner=0;inner<=outer-1;inner++){if(arr[inner]>arr[inner+1]){//升序[arr[inner],arr[inner+1]]=[arr[inner+1],arr[inner]];console.log([arr[inner],arr[inner+1]]);}}}returnarr;}[1,2,3,4].bubleSort()//[1,2,3,4]复制代码选择排序Array.prototype.selectSort=function(){letarr=this,len=arr.length;for(leti=0,len=arr.length;i<len;i++){for(letj=i,len=arr.length;j<len;j++){if(arr[i]>arr[j]){[arr[i],arr[j]]=[arr[j],arr[i]];}}}returnarr;}[1,2,3,4].selectSort()//[1,2,3,4]复制代码3.4最大值1.终极篇Math.max(...[1,2,3,4])//4Math.max.apply(this,[1,2,3,4])//4[1,2,3,4].reduce((prev,cur,curIndex,arr)=>{returnMath.max(prev,cur);},0)//4复制代码Math.max()是Math对象内置的方法,参数是字符串;reduce是ES5的数组api,参数有函数和默认初始值;函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)2.开始篇先排序再取值3.5求和1.终极篇[1,2,3,4].arr.reduce(function(prev,cur){returnprev+cur;},0)//10复制代码2.开始篇functionsum(arr){varlen=arr.length;if(len==0){return0;}elseif(len==1){returnarr[0];}else{returnarr[0]+sum(arr.slice(1));}}sum([1,2,3,4])//10复制代码利用slice截取改变数组,再利用递归求和3.6合并1.终极篇[1,2,3,4].concat([5,6])//[1,2,3,4,5,6][...[1,2,3,4],...[4,5]]//[1,2,3,4,5,6]letarrA=[1,2],arrB=[3,4]Array.prototype.push.apply(arrA,arrB))//arrA值为[1,2,3,4]复制代码2.开始篇letarr=[1,2,3,4];[5,6].map(item=>{arr.push(item)})//arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]复制代码3.7判断是否包含值1.终极篇[1,2,3].includes(4)//false[1,2,3].indexOf(4)//-1如果存在换回索引[1,2,3].find((item)=>item===3))//3如果数组中无值返回undefined[1,2,3].findIndex((item)=>item===3))//2如果数组中无值返回-1复制代码includes(),find(),findIndex()是ES6的api2.开始篇[1,2,3].some(item=>{returnitem===3})//true如果不包含返回false复制代码3.8类数组转化1.终极篇Array.prototype.slice.call(arguments)//arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments]复制代码类数组:表示有length属性,但是不具备数组的方法call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法Array.from是将类似数组或可迭代对象创建为数组...是将类数组扩展为字符串,再定义为数组2.开始篇Array.prototype.slice=function(start,end){varresult=newArray();start=start||0;end=end||this.length;//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键for(vari=start;i<end;i++){result.push(this[i]);}returnresult;}复制代码3.9每一项设置值1.终极篇[1,2,3].fill(false)//[false,false,false]复制代码fill是ES6的方法2.开始篇[1,2,3].map(()=>0)复制代码3.10每一项是否满足[1,2,3].every(item=>{returnitem>2})//false复制代码every是ES5的api,每一项满足返回true3.11有一项满足[1,2,3].some(item=>{returnitem>2})//true复制代码some是ES5的api,有一项满足返回true3.12.过滤数组[1,2,3].filter(item=>{returnitem>2})//[3]复制代码filter是ES5的api,返回满足添加的项的数组3.13对象和数组转化Object.keys({name:'张三',age:14})//['name','age']Object.values({name:'张三',age:14})//['张三',14]Object.entries({name:'张三',age:14})//[[name,'张三'],[age,14]]Object.fromEntries([name,'张三'],[age,14])//ES10的api,Chrome不支持,firebox输出{name:'张三',age:14}复制代码3.14对象数组[{count:1},{count:2},{count:3}].reduce((p,e)=>p+(e.count),0)复制代码4.数据结构篇数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。也是程序猿进阶的一个重要技能。手撸代码实现栈,队列,链表,字典,二叉树,动态规划和贪心算法4.1栈栈的特点：先进后出classStack{constructor(){this.items=[];}//入栈push(element){this.items.push(element);}//出栈pop(){returnthis.items.pop();}//末位getpeek(){returnthis.items[this.items.length-1];}//是否为空栈getisEmpty(){return!this.items.length;}//长度getsize(){returnthis.items.length;}//清空栈clear(){this.items=[];}}//实例化一个栈conststack=newStack();console.log(stack.isEmpty);//true//添加元素stack.push(5);stack.push(8);//读取属性再添加console.log(stack.peek);//8stack.push(11);console.log(stack.size);//3console.log(stack.isEmpty);//false复制代码4.2队列队列：先进先出classQueue{constructor(items){this.items=items||[];}enqueue(element){this.items.push(element);}dequeue(){returnthis.items.shift();}front(){returnthis.items[0];}clear(){this.items=[];}getsize(){returnthis.items.length;}getisEmpty(){return!this.items.length;}print(){console.log(this.items.toString());}}constqueue=newQueue();console.log(queue.isEmpty);//truequeue.enqueue(\"John\");queue.enqueue(\"Jack\");queue.enqueue(\"Camila\");console.log(queue.size);//3console.log(queue.isEmpty);//falsequeue.dequeue();queue.dequeue();复制代码4.3链表链表:存贮有序元素的集合;但是不同于数组,每个元素是一个存贮元素本身的节点和指向下一个元素引用组成要想访问链表中间的元素,需要从起点开始遍历找到所需元素classNode{constructor(element){this.element=element;this.next=null;}}//链表classLinkedList{constructor(){this.head=null;this.length=0;}//追加元素append(element){constnode=newNode(element);letcurrent=null;if(this.head===null){this.head=node;}else{current=this.head;while(current.next){current=current.next;}current.next=node;}this.length++;}//任意位置插入元素insert(position,element){if(position>=0&&position<=this.length){constnode=newNode(element);letcurrent=this.head;letprevious=null;letindex=0;if(position===0){this.head=node;}else{while(index++<position){previous=current;current=current.next;}node.next=current;previous.next=node;}this.length++;returntrue;}returnfalse;}//移除指定位置元素removeAt(position){//检查越界值if(position>-1&&position<length){letcurrent=this.head;letprevious=null;letindex=0;if(position===0){this.head=current.next;}else{while(index++<position){previous=current;current=current.next;}previous.next=current.next;}this.length--;returncurrent.element;}returnnull;}//寻找元素下标findIndex(element){letcurrent=this.head;letindex=-1;while(current){if(element===current.element){returnindex+1;}index++;current=current.next;}return-1;}//删除指定文档remove(element){constindex=this.findIndex(element);returnthis.removeAt(index);}isEmpty(){return!this.length;}size(){returnthis.length;}//转为字符串toString(){letcurrent=this.head;letstring=\"\";while(current){string+=`${current.element}`;current=current.next;}returnstring;}}constlinkedList=newLinkedList();console.log(linkedList);linkedList.append(2);linkedList.append(6);linkedList.append(24);linkedList.append(152);linkedList.insert(3,18);console.log(linkedList);console.log(linkedList.findIndex(24));复制代码4.4字典字典：类似对象，以key，value存贮值classDictionary{constructor(){this.items={};}set(key,value){this.items[key]=value;}get(key){returnthis.items[key];}remove(key){deletethis.items[key];}getkeys(){returnObject.keys(this.items);}getvalues(){/*也可以使用ES7中的values方法returnObject.values(this.items)*///在这里我们通过循环生成一个数组并输出returnObject.keys(this.items).reduce((r,c,i)=>{r.push(this.items[c]);returnr;},[]);}}constdictionary=newDictionary();dictionary.set(\"Gandalf\",\"gandalf@email.com\");dictionary.set(\"John\",\"johnsnow@email.com\");dictionary.set(\"Tyrion\",\"tyrion@email.com\");console.log(dictionary);console.log(dictionary.keys);console.log(dictionary.values);console.log(dictionary.items);复制代码4.5二叉树特点：每个节点最多有两个子树的树结构classNodeTree{constructor(key){this.key=key;this.left=null;this.right=null;}}classBinarySearchTree{constructor(){this.root=null;}insert(key){constnewNode=newNodeTree(key);constinsertNode=(node,newNode)=>{if(newNode.key<node.key){if(node.left===null){node.left=newNode;}else{insertNode(node.left,newNode);}}else{if(node.right===null){node.right=newNode;}else{insertNode(node.right,newNode);}}};if(!this.root){this.root=newNode;}else{insertNode(this.root,newNode);}}//访问树节点的三种方式:中序,先序,后序inOrderTraverse(callback){constinOrderTraverseNode=(node,callback)=>{if(node!==null){inOrderTraverseNode(node.left,callback);callback(node.key);inOrderTraverseNode(node.right,callback);}};inOrderTraverseNode(this.root,callback);}min(node){constminNode=node=>{returnnode?(node.left?minNode(node.left):node):null;};returnminNode(node||this.root);}max(node){constmaxNode=node=>{returnnode?(node.right?maxNode(node.right):node):null;};returnmaxNode(node||this.root);}}consttree=newBinarySearchTree();tree.insert(11);tree.insert(7);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.inOrderTraverse(value=>{console.log(value);});console.log(tree.min());console.log(tree.max());复制代码5.算法篇5.1冒泡算法冒泡排序，选择排序，插入排序，此处不做赘述.5.2斐波那契特点：第三项等于前面两项之和functionfibonacci(num){if(num===1||num===2){return1}returnfibonacci(num-1)+fibonacci(num-2)}复制代码5.3动态规划特点：通过全局规划,将大问题分割成小问题来取最优解案例：最少硬币找零美国有以下面额(硬币）：d1=1,d2=5,d3=10,d4=25如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（1美分)classMinCoinChange{constructor(coins){this.coins=coinsthis.cache={}}makeChange(amount){if(!amount)return[]if(this.cache[amount])returnthis.cache[amount]letmin=[],newMin,newAmountthis.coins.forEach(coin=>{newAmount=amount-coinif(newAmount>=0){newMin=this.makeChange(newAmount)}if(newAmount>=0&&(newMin.length<min.length-1||!min.length)&&(newMin.length||!newAmount)){min=[coin].concat(newMin)}})return(this.cache[amount]=min)}}constrninCoinChange=newMinCoinChange([1,5,10,25])console.log(rninCoinChange.makeChange(36))//[1,10,25]constminCoinChange2=newMinCoinChange([1,3,4])console.log(minCoinChange2.makeChange(6))//[3,3]复制代码5.4贪心算法特点：通过最优解来解决问题用贪心算法来解决2.3中的案例classMinCoinChange2{constructor(coins){this.coins=coins}makeChange(amount){constchange=[]lettotal=0this.coins.sort((a,b)=>a<b).forEach(coin=>{if((total+coin)<=amount){change.push(coin)total+=coin}})returnchange}}constrninCoinChange2=newMinCoinChange2([1,5,10,25])console.log(rninCoinChange2.makeChange(36))复制代码6设计模式设计模式如果应用到项目中，可以实现代码的复用和解耦，提高代码质量。本文主要介绍14种设计模式写UI组件,封装框架必备6.1简单工厂模式1.定义：又叫静态工厂方法，就是创建对象，并赋予属性和方法2.应用：抽取类相同的属性和方法封装到对象上3.代码：letUserFactory=function(role){functionUser(opt){this.name=opt.name;this.viewPage=opt.viewPage;}switch(role){case'superAdmin':returnnewUser(superAdmin);break;case'admin':returnnewUser(admin);break;case'user':returnnewUser(user);break;default:thrownewError('参数错误,可选参数:superAdmin、admin、user')}}//调用letsuperAdmin=UserFactory('superAdmin');letadmin=UserFactory('admin')letnormalUser=UserFactory('user')//最后得到角色,可以调用复制代码6.2工厂方法模式1.定义：对产品类的抽象使其创建业务主要负责用于创建多类产品的实例2.应用:创建实例3.代码:varFactory=function(type,content){if(thisinstanceofFactory){vars=newthis[type](content);returns;}else{returnnewFactory(type,content);}}//工厂原型中设置创建类型数据对象的属性Factory.prototype={Java:function(content){console.log('Java值为',content);},PHP:function(content){console.log('PHP值为',content);},Python:function(content){console.log('Python值为',content);},}//测试用例Factory('Python','我是Python');复制代码6.3原型模式1.定义:设置函数的原型属性2.应用:实现继承3.代码:functionAnimal(name){//属性this.name=name||'Animal';//实例方法this.sleep=function(){console.log(this.name+'正在睡觉！');}}//原型方法Animal.prototype.eat=function(food){console.log(this.name+'正在吃：'+food);};functionCat(){}Cat.prototype=newAnimal();Cat.prototype.name='cat';//&emsp;TestCodevarcat=newCat();console.log(cat.name);//catconsole.log(cat.eat('fish'));//cat正在吃：fishundefinedconsole.log(cat.sleep());//cat正在睡觉！undefinedconsole.log(catinstanceofAnimal);//trueconsole.log(catinstanceofCat);//true复制代码6.4单例模式1.定义:只允许被实例化依次的类2.应用:提供一个命名空间3.代码:letsingleCase=function(name){this.name=name;};singleCase.prototype.getName=function(){returnthis.name;}//获取实例对象letgetInstance=(function(){varinstance=null;returnfunction(name){if(!instance){//相当于一个一次性阀门,只能实例化一次instance=newsingleCase(name);}returninstance;}})();//测试单体模式的实例,所以one===twoletone=getInstance(\"one\");lettwo=getInstance(\"two\");复制代码6.5外观模式1.定义:为子系统中的一组接口提供一个一致的界面2.应用:简化复杂接口3.代码:外观模式6.6适配器模式1.定义:将一个接口转换成客户端需要的接口而不需要去修改客户端代码，使得不兼容的代码可以一起工作2.应用:适配函数参数3.代码:适配器模式6.7装饰者模式1.定义:不改变原对象的基础上,给对象添加属性或方法2.代码letdecorator=function(input,fn){//获取事件源letinput=document.getElementById(input);//若事件源已经绑定事件if(typeofinput.onclick=='function'){//缓存事件源原有的回调函数letoldClickFn=input.onclick;//为事件源定义新事件input.onclick=function(){//事件源原有回调函数oldClickFn();//执行事件源新增回调函数fn();}}else{//未绑定绑定input.onclick=fn;}}//测试用例decorator('textInp',function(){console.log('文本框执行啦');})decorator('btn',function(){console.log('按钮执行啦');})复制代码6.8桥接模式1.定义:将抽象部分与它的实现部分分离，使它们都可以独立地变化2.代码桥接模式6.9模块方法模式1.定义:定义一个模板,供以后传不同参数调用2.代码:模块方法模式6.10.观察者模式1.作用:解决类与对象,对象与对象之间的耦合2.代码:letObserver=(function(){let_message={};return{//注册接口,//1.作用:将订阅者注册的消息推入到消息队列//2.参数:所以要传两个参数,消息类型和处理动作,//3.消息不存在重新创建,存在将消息推入到执行方法regist:function(type,fn){//如果消息不存在,创建if(typeof_message[type]==='undefined'){_message[type]=[fn];}else{//将消息推入到消息的执行动作_message[type].push(fn);}},//发布信息接口//1.作用:观察这发布消息将所有订阅的消息一次执行//2.参数:消息类型和动作执行传递参数//3.消息类型参数必须校验fire:function(type,args){//如果消息没有注册,则返回if(!_message[type])return;//定义消息信息varevents={type:type,//消息类型args:args||{}//消息携带数据},i=0,len=_message[type].length;//遍历消息for(;i=0;i--){//如果存在该动作在消息队列中移除_message[type][i]===fn&&_message[type].splice(i,1);}}}}})()//测试用例//1.订阅消息Observer.regist('test',function(e){console.log(e.type,e.args.msg);})//2.发布消息Observer.fire('test',{msg:'传递参数1'});Observer.fire('test',{msg:'传递参数2'});Observer.fire('test',{msg:'传递参数3'});复制代码6.11状态模式1.定义:一个对象状态改变会导致行为变化2.作用:解决复杂的if判断3.代码状态模式6.12策略模式1.定义:定义了一系列家族算法，并对每一种算法单独封装起来，让算法之间可以相互替换，独立于使用算法的客户2.代码策略模式6.13.访问模式1.定义:通过继承封装一些该数据类型不具备的属性,2.作用:让对象具备数组的操作方法3.代码:访问者模式6.14中介者模式1.定义:设置一个中间层,处理对象之间的交互2.代码:中介者模式7.HTTP1.1什么是HTTPHTTP是一个连接客户端，网关和服务器的一个协议。7.2特点支持客户/服务器模式：可以连接客户端和服务端；简单快速：请求只需传送请求方法，路径和请求主体；灵活：传输数据类型灵活；无连接：请求结束立即断开；无状态：无法记住上一次请求。7.3怎么解决无状态和无连接无状态：HTTP协议本身无法解决这个状态，只有通过cookie和session将状态做贮存，常见的场景是登录状态保持；无连接：可以通过自身属性Keep-Alive。7.4请求过程HTTP(S)请求地址→DNS解析→三次握手→发送请求→四次挥手三次握手过程图片来源CSDN）\">在这里插入图片描述四次挥手过（图片来源CSDN）\">在这里插入图片描述7.5HTTP0.9~3.0对比7.5.1HTTP0.9只允许客户端发送GET这一种请求；且不支持请求头，协议只支持纯文本；无状态性，每个访问独立处理，完成断开；无状态码。7.5.2HTTP1.0有身份认证，三次握手；请求与响应支持头域；请求头内容；属性名含义Accept可接受的MIME类型Accept-Encoding数据可解码的格式Accept-Language可接受语言Connection值keep-alive是长连接Host主机和端口Pragma是否缓存,指定no-cache返回刷新Referer页面路由If-Modified-Since值为时间响应头内容；属性名含义Connection值keep-alive是长连接Content-Type返回文档类型,常见的值有text/plain,text/html,text/jsonDate消息发送的时间Server服务器名字Last-Modified值为时间,s返回的最后修改时间Expires缓存过期时间,b和s时间做对比注意expires是响应头内容，返回一个固定的时间,缺陷是时间到了服务器要重新设置;请求头中如果有If-Modified-Since，服务器会将时间与last-modified对比，相同返回304;响应对象以一个响应状态行开始;响应对象不只限于超文本;支持GET、HEAD、POST方法;有状态码;支持长连接（但默认还是使用短连接）、缓存机制以及身份认证。7.5.3HTTP1.1请求头增加Cache-Control属性名含义Cache-Control在1.1引入的方法,指定请求和响应遵循的缓存机制,值有:public(b和s都缓存),private(b缓存),no-cache(不缓存),no-store(不缓存),max-age(缓存时间,s为单位),min-fresh(最小更新时间),max-age=3600If-None-Match上次请求响应头返回的etag值响应头增加Cache-Control，表示所有的缓存机制是否可以缓存及哪种类型etag返回的哈希值,第二次请求头携带去和服务器值对比注意Cache-Control的max-age返回是缓存的相对时间Cache-Control优先级比expires高缺点：不能第一时间拿到最新修改文件7.5.4HTTP2.0采用二进制格式传输;多路复用，其实就是将请求数据分成帧乱序发送到TCP中。TCP只能有一个steam，所以还是会阻塞;报头压缩;服务器推送主动向B端发送静态资源，避免往返延迟。7.5.5HTTP3.01.是基于QUIC协议，基于UDP2.特点:自定义连接机制：TCP以IP/端口标识,变化重新连接握手，UDP是一64位ID标识，是无连接；自定义重传机制：TCP使用序号和应答传输，QUIC是使用递增序号传输；无阻塞的多路复用：同一条QUIC可以创建多个steam。7.5.6HTTPS1.https是在http协议的基础上加了个SSL；2.主要包括\u0010：握手(凭证交换和验证)和记录协议(数据进行加密)。7.5.7缓存1.按协议分：协议层缓存和非http协议缓存：1.1协议层缓存：利用http协议头属性值设置；1.2非协议层缓存：利用meta标签的http-equiv属性值Expires,set-cookie。2.按缓存分：强缓存和协商缓存：2.1强缓存：利用cache-control和expires设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；2.2协商缓存：响应头返回etag或last-modified的哈希值，第二次请求头If-none-match或IF-modify-since携带上次哈希值，一致则返回304。3.协商缓存对比：etag优先级高于last-modified；4.etag精度高，last-modified精度是s，1s内etag修改多少次都会被记录；last-modified性能好，etag要得到hash值。5.浏览器读取缓存流程：会先判断强缓存；再判断协商缓存etag(last-modified)是否存在；存在利用属性If-None-match(If-Modified-since)携带值；请求服务器,服务器对比etag(last-modified)，生效返回304。F5刷新会忽略强缓存不会忽略协商缓存，ctrl+f5都失效7.5.8状态码序列详情1XX(通知)2XX(成功)200(成功)、201(服务器创建)、202(服务器接收未处理)、203(非授权信息)、204(未返回内容)、205(重置内容)、206(部分内容)3XX(重定向)301(永久移动)、302(临时移动)、303(查看其他位置)、304(未修改)、305(使用代理)、307(临时重定向)4XX(客户端错误)400(错误请求)、401(未授权)、403(禁止)、404(未找到)、405(方法禁用)、406(不接受)、407（需要代理授权）5XX(服务器错误)500(服务器异常)、501（尚未实施）、502（错误网关）、503（服务不可用）、504（网关超时）、505（HTTP版本不受支持）7.5.9浏览器请求分析\">7.5.10总结协议版本内容http0.9只允许客户端发送GET这一种请求;且不支持请求头,协议只支持纯文本;无状态性,每个访问独立处理,完成断开;无状态码http1.0解决0.9的缺点,增加If-modify-since(last-modify)和expires缓存属性http1.x增加cache-control和If-none-match(etag)缓存属性http2.0采用二进制格式传输;多路复用;报头压缩;服务器推送http3.0采用QUIC协议,自定义连接机制;自定义重传机制;无阻塞的多路复用缓存类型特性强缓存通过If-modify-since(last-modify)、expires和cache-control设置，属性值是时间，所以在时间内不用请求协商缓存通过If-none-match(etag)设置，etag属性是哈希值，所以要请求和服务器值对比8.总结这只是JS原生从初级到高级的梳理;原创码字不易,欢迎star!",
      "id": "6gbcmzcjjjc0",
      "author": "取舍🍂",
      "title": "JS 原生面经从初级到高级【近1.5W字】"
    },
    {
      "content": "最近手有点痒琢磨着做个啥,朝思暮想还是写个KTV点歌系统,模拟了一下KTV开户的思路,7天累死我了,不过技术点还挺多的,希望你可以看完（〜^㉨^)〜用Node(Express)教你写KTV点歌系统，包括前台内容和后台管理系统，整合Express框架和Mongodb数据库服务器开发；教你用Vue.JS，ElementUI和iViewUI写出超漂亮的页面,随心点歌随心听作者原创文章,转载前请留言或联系作者!!!思维导图技术栈后端：Express+Mongodb+jsonwebtoken等等前端：Vue.JS+ElementUI+iViewUI+Axios等等功能介绍本项目分前台开发,后台开发和服务器开发用户听歌需要登录(路由守卫)用户需要到管理员申请账号和密码用户登录听歌(风格点歌,语种点歌,明星点歌,热门歌曲等等...)剩余时长30分钟提醒,到时间自动下机管理员对歌曲的增删改查管理员给用户开户,可以选择上机的时间管理员查看订单,删除订单,搜索订单管理员收藏歌曲,推荐到ktv推荐歌曲等等...项目设计结构--服务器基本架构ktv-select_music-system├──README.md├──index.js--后台文件入口├──test.http--测试文件├──api--路由文件│├──admin.js--配置管理员的操作|├──music.js--配置歌曲信息|├──user.js--配置用户的相关操作|└──safecode.js--配置安全码├──config--配置|├──Date.js--配置日期格式化插件|├──delNoUse.js--封装闲置删除闲置资源方法|├──http.js--配置跨域|├──isBadAccount.js--封装账户是否合法|├──newaccount.js--封装随机开户方法|├──passport.js--验证token是否合法|├──uploadImg.js--封装上传图片方法|└──uploadMusic.js--封装上传歌曲方法├──ktv-admin--后台管理系统界面├──ktv-client--前台用户点歌项目界面├──dbModel|└──**--Mongodb数据库的一些模型├──mongodb|└──mongodb.js--配置Mongodb,链接数据库├──secret|├──mongodbURI.js--Mongodb地址|└──jwtkey.js--token的私钥├──static--资源存放处|├──music--歌曲上传目标文件夹|├──poster--歌曲海报上传目标文件夹└──└──view--配置404文件复制代码--后台管理系统架构ktv-admin├──README.md├──public|├──index.html--vue挂载页面|└──**--你可以在这里链接少量静态资源├──src--开发文件夹|├──App.vue--Vue挂载根页面|├──main.js--Vue程序入口文件,挂载各种组件|├──router.js--Vue路由配置文件|├──store.js--Vuex的状态管理文件|├──assets--静态资源文件夹|├──components--公共组件||└──nav.vue--后台导航栏|├──plugins--插件||├──axios.js--配置跨域,拦截器等等||├──Date.js--格式化日期||└──Date.js--加载动画Loading|├──stores--状态管理文件夹||└──adminStore.js--管理员状态|├──views--页面文件夹||├──404.vue--404页面||├──adminlikes.vue--管理员处理ktv收藏歌曲||├──allorders.vue--订单管理||├──Home.vue--后台根页面||├──Index.vue--后台首页||├──managemusic.vue--音乐管理||├──user_service.vue--给用户开户||└──login.vue--后台登录└──babel.config.js--babel配置复制代码--前台用户听歌架构ktv-client├──README.md├──public|├──index.html--vue挂载页面|└──**--你可以在这里链接少量静态资源├──src--开发文件夹|├──App.vue--Vue挂载根页面|├──main.js--Vue程序入口文件,挂载各种组件|├──router.js--Vue路由配置文件|├──store.js--Vuex的状态管理文件|├──assets--静态资源文件夹|├──components--公共组件||├──bottomNav.vue--底部音乐控制区域||└──topNav.vue--顶部信息区域|├──config--配置||├──addSong.js--封装选取歌曲方法||├──isBadAccount.js--验证账户合法性||├──isLogin.js--是否登录||├──nextSong.js--封装下一首歌曲方法||└──prevSong.js--封装上一首歌曲方法|├──plugins--插件||├──axios.js--配置跨域,拦截器等等||└──wsmLoading.js--加载动画Loading|├──stores--状态管理文件夹||└──song.js--存储歌曲信息|├──views--页面文件夹||├──404.vue--404页面||├──abc.vue--拼音点歌||├──artist.vue--明星点歌||├──Home.vue--后台根页面||├──Index.vue--后台首页||├──hot.vue--热播歌曲||├──ktvlikes.vue--ktv推荐歌曲||├──selected.vue--已选歌曲||├──style.vue--风格点歌||└──language.vue--语种点歌├──babel.config.js--babel配置└──vue.config.js--vue配置复制代码项目启动介绍首先首先不要改变服务器端口,否则报错.你需要在装有Node和Vue的环境中测试，如果其中一个没有请先下载(Node下载,Vue下载).首先在最外层文件夹下载依赖:npminstall下载后端依赖,接着进入ktv-client,npminstall下载用户前端依赖.接着进入ktv-admin,npminstall下载管理员前端依赖.以上工作完成后,使用命令npmrunserver或者nodeindex命令启动Node服务器，启动成功会显示:Serverisrunningonport[8633].MongodbisConnected.Pleasehaveagreatcoding.进入ktv-client,打开命令板,使用命令npmrunclient启动前台用户项目,启动成功后用浏览器访问http://localhost:xxxx进入ktv-admin,打开命令板,使用命令npmrunadmin启动后台管理系统项目,启动成功后用浏览器访问http://localhost:xxxx本例中将Mongodb部署在本地电脑上，如果你仔细阅读了这篇文档，启动项目应该是很容易的。如果你把Mongodb部署在其他地方，请自行修改secret/mongodbURI.js配置文件信息。项目启动成功,最好用chrome浏览器打开,美化了滚动条接着注册管理员账号admin.js最下面有个注册接口//管理员注册router.post(\"/account/register\",(req,res)=>{constemail=req.body.email;Admin.findOne({email}).then(hasOne=>{if(hasOne){returnreq.status(422).json({status:\"422\",result:\"邮箱被占用\"});}else{constusername=req.body.username;constpassword=req.body.password;constidentity=req.body.identity?req.body.identity:null;constdate=newDate().format(\"yyyy/MM/ddHH:mm:ss\");constnewAdmin=newAdmin({email,username,password,identity,date});newAdmin.save().then(()=>{res.json({status:\"200\",result:\"注册成功\"})}).catch(err=>{console.log(err);res.status(500).json({status:\"500\",result:\"未知错误,注册失败\"})})}})})复制代码然后用postman注册或者其他工具\">技术攻关Date方法由于脑袋不好使的原因加上js没有元素格式化日期的方法,就瞎掰一个(值得学习)Date.js/****@author:Mr_Wei*@version:1.0.0*@description:格式化日期*@Date:2019/10/1609:32**/Date.prototype.format=function(format){varo={\"M+\":this.getMonth()+1,//月份\"d+\":this.getDate(),//日\"H+\":this.getHours(),//小时\"m+\":this.getMinutes(),//分\"s+\":this.getSeconds(),//秒\"q+\":Math.floor((this.getMonth()+3)/3),//季度\"f+\":this.getMilliseconds()//毫秒};if(/(y+)/.test(format))format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4-RegExp.$1.length));for(varkino)if(newRegExp(\"(\"+k+\")\").test(format))format=format.replace(RegExp.$1,(RegExp.$1.length==1)?(o[k]):((\"00\"+o[k]).substr((\"\"+o[k]).length)));returnformat;}exportdefaultDate.prototype.format然后我们使用其格式日期require(Date);//constnow=newDate().format(\"yyyy/MM/ddHH:mm:ss.S\");constnow=newDate().format(\"yyyy/MM/ddHH:mm:ss\");复制代码验证码(svg-captcha)svg-captcha验证码的运用,防止暴力破解密码,加强安全性.详细的文档地址：svg-captcha使用验证码//后台生成验证码router.get(\"/getCaptcha\",(req,res)=>{varcaptcha=svgCaptcha.create({//翻转颜色inverse:false,//字体大小fontSize:38,//噪声线条数noise:3,//宽度width:80,//高度height:32,});//保存到session,忽略大小写req.session=captcha.text.toLowerCase();console.log(req.session);//0xtg生成的验证码//保存到cookie方便前端调用验证res.cookie('captcha',req.session);res.setHeader('Content-Type','image/svg+xml');res.send(String(captcha.data));res.end();})//前台获取验证码--HTML\"80\"style=\"background:#EEE9E9;margin-left:30px;\"ref=\"captcha\"height=\"32\"src=\"http://localhost:3001/api/user/getCaptcha\"@click=\"refreshCaptcha\">--js//获取验证码cookiegetCookie(cname){varname=cname+\"=\";varca=document.cookie.split(';');for(vari=0;iif(c.indexOf(name)==0)returnc.substring(name.length,c.length);}return\"\";},//刷新验证码refreshCaptcha(){this.$refs.captcha.src=\"http://localhost:3001/api/user/getCaptcha?d=\"+Math.random();},最后用填写的验证码进行对比复制代码\">\">上传歌曲或图片formidable来处理文件上传信息,用起来方便,很友好,如果你没有接触过文件操作,赶紧收藏起来封装歌曲方法uploadMusic.js/****@author:Mr_Wei*@version:1.0.0*@description:封装上传音乐方法*@Date:2019/10/1608:35**/constfs=require('fs');constpath=require('path');constformidable=require('formidable');//文件处理库constformatTime=require('silly-datetime');//格式化数据module.exports=(req,res)=>{letform=newformidable.IncomingForm();//创建上传表单form.encoding='utf-8';//设置编码格式form.uploadDir=path.join(__dirname,'../static/music');//设置上传目录(这个目录必须先创建好)form.keepExtensions=true;//保留文件后缀名form.maxFieldsSize=20*1024*1024;//设置文件大小/*格式化form数据*/form.parse(req,(err,fields,files)=>{letfile=files.file;/*获取异常*/if(err){returnres.status(500).json({'status':500,result:'服务器内部错误'});}if(file.size>form.maxFieldsSize){fs.unlink(file.path);returnres.status(412).json({'status':412,result:'音频不能超过20M'});}/*存储后缀名*/letextName='';switch(file.type){case'audio/mp3':extName='mp3';break;}if(extName.length==0){fs.unlink(file.path);returnres.status(412).json({'status':412,result:'只支持mp3格式音频'});}/*拼接新的文件名*/lettime=formatTime.format(newDate(),'YYYYMMDDHHmmss');letnum=Math.floor(Math.random()*8999+10000);letsongName=`${time}_${num}.${extName}`;letnewPath=form.uploadDir+'/'+songName;/*更改名字和路径*/fs.rename(file.path,newPath,(err)=>{if(err){returnres.status(500).json({'status':500,result:'音频上传失败'});}else{returnres.send({'status':200,'msg':'音频上传成功',result:{src:songName}});}})})};复制代码\">\">Vue、ElementUI分页使用关于ElementUI分页详细请见：ElementUI的Pagination分页学习上图--html'paginations.total>0':page-sizes=\"paginations.page_sizes\":page-size=\"paginations.page_size\":layout=\"paginations.layout\":total=\"paginations.total\":current-page.sync='paginations.page_index'@current-change='handleCurrentChange'@size-change='handleSizeChange'>--jsdata(){return{allUsers:[],//用来存储最终信息,被显示的dom点调用allTableData:[],//用户承接分页设置的数据paginations:{//分页组件信息page_index:1,//当前位于哪页total:0,//总数page_size:5,//1页显示多少条page_sizes:[5,10,15,20],//每页显示多少条layout:\"total,sizes,prev,pager,next,jumper\"//翻页属性},}},methods:{//获取当前页handleCurrentChange(page){letsortnum=this.paginations.page_size*(page-1);lettable=this.allTableData.filter((item,index)=>{returnindex>=sortnum;});//设置默认分页数据this.getAllUsers=table.filter((item,index)=>{returnindex<this.paginations.page_size;});this.getAllUsers=table.filter((item,index)=>{returnindex<this.paginations.page_size;});},//切换sizehandleSizeChange(page_size){this.paginations.page_index=1;this.paginations.page_size=page_size;this.getAllUsers=this.allTableData.filter((item,index)=>{returnindex<page_size;});},//总页数setPaginations(){this.paginations.total=this.allTableData.length;this.paginations.page_index=1;this.paginations.page_size=5;//设置默认分页数据this.getAllUsers=this.allTableData.filter((item,index)=>{returnindex<this.paginations.page_size;});},}复制代码\">没了吗?对,分页就是这么简单!你学会了吗?有些前端开发的同学总是对分页比较陌生,学会这个,让你不再产生烦恼!token和自定义验证合法性jsonwebtoken是对用户信息加密成不可逆向破解的token.关于passport-jwt，是用来对用户请求时所带的token信息进行过期验证,如果超过签证的合法时间,则会请前台发出token失效的信息,提示用户重新获取合法的token信息,否则无法继续请求加密的信息；用法-passport-jwtconstkey=require(\"../config/keys\").KEYORSECRET;constJwtStrategy=require('passport-jwt').Strategy,ExtractJwt=require('passport-jwt').ExtractJwt;varopts={}opts.jwtFromRequest=ExtractJwt.fromAuthHeaderAsBearerToken();opts.secretOrKey=key;module.exports=passport=>{passport.use(newJwtStrategy(opts,(jwt_payload,done)=>{UserInfo.findById(jwt_payload.id).then(user=>{if(user){returndone(null,user);}else{returndone(null,false);//oryoucouldcreateanewaccount}})}));}//设置token//规则construle={id:String(userinfo._id),username:userinfo.username,email:userinfo.email,date:user.date,signdate:userinfo.signdate,signcount:userinfo.signcount,avatar:userinfo.avatar,phone:userinfo.phone};//签证加密//jwt.sign(规则,key(私钥),{配置:比如过期时长},(err,token){响应程序})jwt.sign(rule,key,{expiresIn:7200},(err,token)=>{if(err)throwerr;res.json({\"token\":\"Bearer\"+token})})自定义验证方法/****@author:Mr_Wei*@version:1.0.0*@description:判断是否过期用户*@Date:2019/10/1912:19**/constUserOrOrders=require(\"../dbModel/user\");module.exports=asyncparams=>{constflag=awaitnewPromise((resolve)=>{if(params){constaccount=params.account;UserOrOrders.findOne({account}).then(user=>{if(user){if(newDate().getTime()>newDate(user.endTime).getTime()){console.log(\"过期用户\");//处理returnresolve(false);}else{console.log(\"合法用户\");returnresolve(true);}}else{returnresolve(false);}})}else{console.log(\"不合法用户\");returnresolve(false);}})returnflag;}使用://测试isBadAccount(params)方法router.post(\"/test\",passport.authenticate(\"jwt\",{session:false}),async(req,res)=>{//console.log(req.user)if(awaitisBadAccount(req.user)){//dosomethingres.send(\"OK\");}else{res.status(401).json({status:\"401\",result:\"帐号过期,请联系管理员\"})}})复制代码\">详细的文档地址：Passport-Jwt合法验证,token加密截图后台管理系统\">\">\">\">\">\">\">\">前台点歌界面\">\">\">\">\">\">源码在这里以上代码均已上传githubgithub.com/1046224544/…联系如果大家有兴趣，欢迎star.欢迎大家加入我的前端交流群：866068198，一起交流学习前端技术。博主目前一直在自学Node中，技术有限，如果可以，会尽力给大家提供一些帮助，或是一些学习方法.群二维码\">其他Node-vue-iView开发类似博客的综合性网站juejin.im/post/5da2a8…最后Ifyouhavesomequestionsafteryouseethisarticle,youcancontactmeoryoucanfindsomeinfobyclickingtheselinks.juejin@wsm'sjuejinGitHub@1046224544Segmentfault@wsm如果对你有帮助,请赏个star~github地址",
      "id": "k47utnwj81c",
      "author": "voanit",
      "title": "7天撸完KTV点歌系统,含后台管理系统(完整版)"
    },
    {
      "content": "vueorreact？That'saquestion.前言近两年前端技术层出不穷，目前市面上已经有了很多供前端人员使用的开发框架，转眼19年已过大半，前端框架领域日趋成熟，实现了三足鼎立的局面，截止到10月22日，Angular，react和vue数据统计如下图所示:\">最近在学习使用框架的时候，分别使用vue和react开发了两个移动端产品，对这两个框架的学习曲线有了一些感悟，这两个都是现在比较热门的js框架，它俩在使用方式上和学习复杂度上还是有很大区别的，这里简单总结下两者的差异。主要从以下几个方面入手方面展开：框架的诞生设计思想编写语法脚手架构建工具数据绑定虚拟DOM指令性能优化原生渲染nativessr服务端渲染生命周期函数销毁组件状态集管理工具诞生vuevue由尤雨溪开发，由独立团队维护，现在大部分的子项目都交给团队成员打理，Vue核心库依然主要由尤雨溪亲自维护。vue近几年来特别的受关注，三年前的时候angularJS霸占前端JS框架市场很长时间，接着react框架横空出世，因为它有一个特性是虚拟DOM，从性能上碾轧angularJS，这个时候，vue1.0悄悄的问世了，它的优雅，轻便也吸引了一部分用户，开始受到关注，16年中旬，VUE2.0问世，不管从性能上，还是从成本上都隐隐超过了react，火的一塌糊涂，这个时候，angular开发团队也开发了angular2.0版本，并且更名为angular，吸收了react、vue的优点，加上angular本身的特点，也吸引到很多用户，目前已经迭代到8.0了。友情提示注意下vue的诞生时间，如果正好有小伙伴在面试，被问到你是从什么时候开始接触并且使用vue的，你要是回答用了5、6年了那场面就十分尴尬了。react起初facebook在建设instagram（图片分享）的时候，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。React起源于Facebook的内部项目，因为该公司对市场上所有JavaScriptMVC框架，都不满意，就决定自己写一套，用来架设Instagram的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。设计思想vuevue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计。这里我们需要明确一个概念，什么是渐进式框架。在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。reactreact主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以手动实现，比如借助onChange和setState来实现一个双向的数据流。而vue是基于可变数据的，支持双向绑定，它提供了v-model这样的指令来实现文本框的数据流双向绑定。编写语法vuevue推荐的做法是webpack+vue-loader的单文件组件格式，vue保留了html、css、js分离的写法，使得现有的前端开发者在开发的时候能保持原有的习惯，更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css。其中标签还提供了一个可选的scoped属性，它会为组件内CSS指定作用域，用它来控制仅对当前组件有效还是全局生效。模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。同时vue也支持JSX语法，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。react用过react的开发者可能知道，react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是JSX+inlinestyle,也就是把HTML和CSS全都写进JavaScript了,即'allinjs'。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。在react中，所有的组件的渲染功能都依靠JSX。你可以在render()中编写类似XML的语法，它最终会被编译成原生JavaScript。不仅仅是HTML可以用JSX来表达，现在的潮流也越来越多地将CSS也纳入到JavaScript中来处理。JSX是基于JS之上的一套额外语法，学习使用起来有一定的成本。构建工具vuevue提供了CLI脚手架，可以帮助你非常容易地构建项目。全局安装之后，我们就可以用vuecreate命令创建一个新的项目，vue的CLI跟其他CLI不同之处在于，有多个可选模板，有简单的也有复杂的，可以让用户自定义选择需要安装的模块，还可以将你的选择保存成模板，便于后续使用。极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。reactReact在这方面也提供了create-react-app，但是现在还存在一些局限性：它不允许在项目生成时进行任何配置，而VueCLI运行于可升级的运行时依赖之上，该运行时可以通过插件进行扩展。它只提供一个构建单页面应用的默认选项，而Vue提供了各种用途的模板。它不能用用户自建的预设配置构建项目，这对企业环境下预先建立约定是特别有用的。而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。数据绑定vuevue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。Vue采用数据劫持&发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作。reactreact是单向数据流，react中属性是不允许更改的，状态是允许更改的。react中组件不允许通过this.state这种方式直接更改组件的状态。自身设置的状态，可以通过setState来进行更改。在setState中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受prevState和props。通过调用this.setState去更新this.state,不能直接操作this.state，请把它当成不可变的。调用setState更新this.state，它不是马上就会生效的，它是异步的。所以不要认为调用完setState后可以立马获取到最新的值。多个顺序执行的setState不是同步的一个接着一个的执行，会加入一个异步队列，然后最后一起执行，即批处理。setState是异步的，导致获取dom可能拿的还是之前的内容，所以我们需要在setState第二个参数（回调函数）中获取更新后的新的内容。diff算法vuevue中diff算法实现流程在内存中构建虚拟dom树将内存中虚拟dom树渲染成真实dom结构数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。会将对比出来的差异进行重新渲染reactreact中diff算法实现流程DOM结构发生改变-----直接卸载并重新createDOM结构一样-----不会卸载,但是会update变化的内容所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点（其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。指令指令(Directives)是带有v-前缀的特殊特性，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。vuevue中提供很多内部指令供我们使用，它可以让我们进行一些模板的操作，例如有时候，我们的data中的存放的数据不是个简单的数字或者字符串，而是数组Array类型，这个时候，我们要把数组的元素展示在视图上，就需要用到vue提供的v-for指令，来实现列表的渲染。react因为react中没有v-for指令，所以循环渲染的时候需要用到map()方法来渲染视图，并且将符合条件的元素放入一个新数组返回。性能优化vuevue中的每个组件内部自动实现了shouldComponentUpdate的优化，在vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。而在react中我们需要手动去优化其性能，但是当数据特别多的时候vue中的watcher也会特别多，从而造成页面卡顿，所以一般数据比较多的大型项目会倾向于使用react。在react官网中，官方也建议我们使用React来构建快速响应的大型Web应用程序。react当props或state发生改变的时候会触发shouldComponentUpdate生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；如果它返回false，则不会触发重新渲染的过程。有的时候我们希望它在更新之前，和之前的状态进行一个对比，这个时候我们就需要重写shouldComponentUpdate来避免不必要的dom操作，对比当前的props或state和更新之后的nextProps或nextState，返回true时，组件更新；返回false，则不会更新，节省性能。shouldComponentUpdate(nextProps,nextState){if(this.props.a!==nextProps.a){returntrue;}if(this.state.b!==nextState.b){returntrue;}returnfalse;}复制代码我们也可以创建一个继承React.PureComponent的React组件，它自带shouldComponentUpdate，可以对props进行浅比较，发现更新之后的props与当前的props一样，就不会进行render了。classTestextendsReact.PureComponent{constructor(props){super(props);}render(){returnhello...{this.props.a}}}由于React.PureComponent进行的是浅比较，也就是说它只会对比原对象的值是否相同，当我们的props或state为数组或者对象这种引用类型的时候，我们修改它的数值，由于数据引用指针没有发生改变，所以组件也是不会重新渲染的。这个时候我们就需要进行深拷贝，创建一个新的对象或数组，将原对象的各项属性的\"值\"（数组的所有元素）拷贝过来，是\"值\"而不仅仅是\"引用地址\"。我们可以使用slice()方法：ew_state.todos=new_state.todos.slice();或者引入immutable库来实现数据不可变。原生渲染nativenative指的是使用原生API来开发App，比如ios使用OC语言，android使用java。vuevue和Weex进行官方合作，weex是阿里巴巴发起的跨平台用户界面开发框架，它的思想是多个平台，只写一套代码，weex允许你使用vue语法开发不仅仅可以运行在浏览器端，还能被用于开发iOS和Android上的原生应用的组件。即只需要编写一份代码，即可运行在Web、iOS、Android上。weex相对来说上手比较简单，安装vue-cli之后就可以使用，学习门槛低，但是它的社区目前还处于成长期，reactnative的社区非常成熟活跃，有非常丰富的组件可供扩展。reactreactnative是Facebook在2015年3月在F8开发者大会上开源的跨平台UI框架，需针对iOS、Android不同编写2份代码，使用reactnative需要按照文档安装配置很多依赖的工具，相对比较麻烦。weex的思想是多个平台，只写一套代码，而react-native的思想是多个平台可以写多套代码，但其使用的是同一套语言框架。weex的目标在于抹平各个平台的差异性，从而简化应用开发。而react-native承认了各个平台之间的差异，退而求其次，在语言和框架层面对平台进行抽象，从方法论的角度去解决多平台开发的问题。ssr服务端渲染服务端渲染核心在于方便seo优化，后端先调用数据库，获得数据之后，将数据和页面元素进行拼装，组合成完整的html页面，再直接返回给浏览器，以便用户浏览。vue2016年10月25日，zeit.co背后的团队对外发布了Next.js，一个React的服务端渲染应用框架。几小时后，与Next.js异曲同工，一个基于Vue.js的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。服务端渲染支持流式渲染，因为HTTP请求也是流式，Vue的服务端渲染结果可以直接pipe到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。基于Vue.js自动代码分层服务端渲染强大的路由功能，支持异步数据静态文件服务ES2015+语法支持打包和压缩JS和CSSHTML头部标签管理本地开发支持热加载集成ESLint支持各种样式预处理器：SASS、LESS、Stylus等等支持HTTP/2推送reactNext是一个React框架，允许使用React构建SSR和静态web应用服务器渲染，获取数据非常简单无需学习新框架，支持静态导出。支持CSS-in-JS库自动代码拆分，加快页面加载速度，不加载不必要的代码基于Webpack的开发环境，支持模块热更新（HMR）支持Babel和Webpack自定义配置服务器、路由和next插件。能够部署在任何能运行node的平台内置页面搜索引擎优化（SEO）处理在生产环境下，打包文件体积更小，运行速度更快生命周期vue【初始化阶段（4个）】（1）beforeCreate此钩子函数不能获取到数据，dom元素也没有渲染出来，此钩子函数不会用来做什么事情。（2）created此钩子函数，数据已经挂载了，但是dom节点还是没有渲染出来，在这个钩子函数里面，如果同步更改数据的话，不会影响运行中钩子函数的执行。可以用来发送ajax请求，也可以做一些初始化事件的相关操作。（3）beforeMount代表dom节点马上要被渲染出来了，但是还没有真正的渲染出来，此钩子函数跟created钩子函数基本一样，也可以做一些初始化数据的配置。（4）mounted是生命周期初始化阶段的最后一个钩子函数，数据已经挂载完毕了，真实dom也可以获取到了。【运行中阶段（2个）】（5）beforeUpdate运行中钩子函数beforeUpdate默认是不会执行的，当数据更改的时候，才会执行。数据更新的时候，先调用beforeUpdate，然后数据更新引发视图渲染完成之后，再会执行updated。运行时beforeUpdate这个钩子函数获取的数据还是更新之前的数据（获取的是更新前的dom内容），在这个钩子函数里面，千万不能对数据进行更改，会造成死循环。（6）updated这个钩子函数获取的数据是更新后的数据，生成新的虚拟dom，跟上一次的虚拟dom结构进行比较，比较出来差异（diff算法）后再渲染真实dom，当数据引发dom重新渲染的时候，在updated钩子函数里面就可以获取最新的真实dom了。【销毁阶段（2个）】（7）beforeDestroy切换路由的时候，组件就会被销毁了，销毁之前执行beforeDestroy。在这个钩子函数里面，我们可以做一些善后的操作，例如可以清空一下全局的定时器（created钩子函数绑定的初始化阶段的事件）、清除事件绑定。（8）destoryed组件销毁后执行destroyed，销毁后组件的双向数据绑定、事件监听watcher相关的都被移除掉了，但是组件的真实dom结构还是存在在页面中的。添加keep-alive标签后会增加active和deactive这两个生命周期函数，初始化操作放在actived里面，一旦切换组件，因为组件没有被销毁，所以它不会执行销毁阶段的钩子函数，所以移除操作需要放在deactived里面，在里面进行一些善后操作，这个时候created钩子函数只会执行一次，销毁的钩子函数一直没有执行。\">react【初始化阶段（5个）】：（1）getDefaultProps：实例化组件之后，组件的getDefaultProps钩子函数会执行这个钩子函数的目的是为组件的实例挂载默认的属性这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。（2）getInitialState：为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态。（3）componentWillMount：执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行。（4）render：渲染domrender()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。如果shouldComponentUpdate()返回false，render()不会被调用。（5）componentDidMount：相当于Vue里的mounted,多用于操作真实dom【运行中阶段（5个）】当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行（1）componentWillReceiveProps(nextProps,nextState)当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行。初始化props时候不会主动执行当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态。（2）接下来就会执行shouldComponentUpdate(nextProps,nextState),这个函数的作用：当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true。接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新如果shouldComponentUpdate()返回false，componentWillUpdate,render和componentDidUpdate不会被调用。（3）componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环相当于Vue中的beforeUpdate（4）render，重新渲染dom（5）componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated【销毁阶段】当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎相当于Vue里的beforeDestroy，所以说一般会做一些善后的事情，例如使定时器无效，取消网络请求或清理在componentDidMount中创建的任何监听。\">销毁组件vuevue在调用$destroy方法的时候就会执行beforeDestroy生命周期函数，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed生命周期函数中处理。reactreact执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，也就是说当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁，所以根本不需要其他的钩子函数了。react销毁组件的时候，会将组件的dom结构也移除，vue则不然，在调用destory方法销毁组件的时候，组件的dom结构还是存在于页面中的，this.$destory组件结构还是存在的，只是移除了事件监听，所以这就是为什么vue中有destroyed，而react却没有componentDidUnmount。状态集管理工具vuevuex是一个专门为vue构建的状态集管理工具，vue和react都是基于组件化开发的，项目中包含很多的组件，组件都会有组件嵌套，想让组件中的数据被其他组件也可以访问到就需要使用到Vuex。vuex的流程将需要共享的状态挂载到state上：this.$store.state来调用创建store，将状态挂载到state上，在根实例里面配置store，之后我们在组件中就可以通过this.$store.state来使用state中管理的数据，但是这样使用时，当state的数据更改的时候，vue组件并不会重新渲染，所以我们要通过计算属性computed来使用，但是当我们使用多个数据的时候这种写法比较麻烦，vuex提供了mapState辅助函数，帮助我们在组件中获取并使用vuex的store中保存的状态。我们通过getters来创建状态：通过this.$store.getters来调用可以根据某一个状态派生出一个新状态，vuex也提供了mapGetters辅助函数来帮助我们在组件中使用getters里的状态。使用mutations来更改state：通过this.$store.commit来调用我们不能直接在组件中更改state，而是需要使用mutations来更改，mutations也是一个纯对象，里面包含很多更改state的方法，这些方法的形参接收到state，在函数体里更改，这时，组件用到的数据也会更改，实现响应式。vuex提供了mapMutations方法来帮助我们在组件中调用mutations的方法。使用actions来处理异步操作：this.$store.dispatch来调用Actions类似于mutations，不同在于：Actions提交的是mutations，而不是直接变更状态。Actions可以包含任意异步操作。也就是说，如果有这样的需求：在一个异步操作处理之后，更改状态，我们在组件中应该先调用actions，来进行异步动作，然后由actions调用mutations来更改数据。在组件中通过this.$store.dispatch方法调用actions的方法，当然也可以使用mapMutations来辅助使用。react2015年Redux出现，将Flux与函数式编程结合一起，很短时间内就成为了最热门的前端架构。它的出现主要是为解决react中组件之间的通信问题。建议把数据放入到redux中管理，目的就是方便数据统一，好管理。项目一旦出现问题，可以直接定位问题点。组件扩展的时候，后续涉及到传递的问题。本来的话，组件使用自己的数据，但是后来公用组件，还需要考虑如何值传递，在redux中可以存储至少5G以上的数据。redux的流程\">创建store：从redux工具中取出createStore去生成一个store。创建一个reducer，然后将其传入到createStore中辅助store的创建。reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态。想要给store创建默认状态其实就是给reducer一个参数创建默认值。组件通过调用store.getState方法来使用store中的state，挂载在了自己的状态上。组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducerreducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态，这个时候store的数据就会发生改变，reducer返回什么状态，store.getState就可以获取什么状态。我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态。小结vue和react的核心都是专注于轻量级的视图层，虽然只是解决一个很小的问题，但是它们庞大的生态圈提供了丰富的配套工具，一开始它并不会给你提供全套的配置方案，将所有的功能都一次性给你打包好，它只会给你提供一些简单的核心功能，当你需要做一个更复杂的应用时，再增添相应的工具。例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。框架的存在就是为了帮助我们应对不同的项目复杂度，当我们面对一个大型、复杂的开发项目时，使用太简陋的工具会极大的降低开发人员的生产力，影响工作效率，框架的诞生就是在这些工程中提取一些重复的并且已经受过验证的模式，抽象到一个已经帮你设计好的API封装当中，帮助我们去应对不同复杂度的问题。所以在开发的过程中，选择一个合适的框架就会事半功倍。但是，框架本身也有复杂度，有些框架会让人一时不知如何上手。当你接到一个并不复杂的需求，却使用了很复杂的框架，那么就相当于杀鸡用牛刀，会遇到工具复杂度所带来的副作用，不仅会失去工具本身所带来优势，还会增加各种问题，例如学习成本、上手成本，以及实际开发效率等。所以并不是说做得少的框架就不如做的做的框架，每个框架都有各自的优势和劣势，并不能找到完全符合需求的框架，最重要的适合当前项目，目前两大框架的生态圈一片繁荣，react社区是当前最活跃的，最快的时候三天更新一个版本，一个问题可能存在几十种不同的解决方案，这就需要我们前端人员去在不同的功能之间做取舍，以后前端框架的发展方向应该是小而精、灵活以及开放的，核心功能+生态附加库可以帮我们更加灵活的构建项目，为了跟上前进的脚步，就需要不停的吸收最新的内容，这也是从事前端开发领域的一大乐趣，希望大家都能在学习中获得长足的进步。\">彩蛋以上为本期介绍，您可以关注我的公众号前端之阶，关注更多前端知识，获取前端大群，里面很多知名互联网前端朋友，前端技术更新太快，不能被落伍淘汰，共同学习，共同进步！\">",
      "id": "1x24sitqn91c",
      "author": "全栈者",
      "title": "前端框架用vue还是react？清晰对比两者差异"
    },
    {
      "content": "axios是Vue官方推荐的一个HTTP库，用axios官方简介来介绍它，就是：Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中。作为一个优秀的HTTP库，axios打败了曾经由Vue官方团队维护的vue-resource，获得了Vue作者尤小右的大力推荐，成为了Vue项目中HTTP库的最佳选择。虽然，axios是个优秀的HTTP库，但是，直接在项目中使用并不是那么方便，所以，我们需要对其进行一定程度上的配置封装，减少重复代码，方便调用。下面，我们就来聊聊Vue中axios的封装。开始其实，网上关于axios封装的代码不少，但是大部分都是在入口文件（main.js）中进行axios全局对象属性定义的形式进行配置，类似于如下代码：axios.defaults.timeout=10000复制代码该方案有两个不足，首先，axios封装代码耦合进入入口文件，不方便后期维护；其次，使用axios全局对象属性定义的方式进行配置，代码过于零散。针对问题一，我使用了Vue源码结构中的一大核心思想——将功能拆分为文件，方便后期的维护。单独创建一个http.js或者http.ts文件，在文件中引入axios并对其进行封装配置，最后将其导出并挂载到Vue的原型上即可。此时，每次修改axios配置，只需要修改对应的文件即可，不会影响到不相关的功能。针对问题二，采用axios官方推荐的，通过配置项创建axios实例的方式进行配置封装。代码如下：//http.jsimportaxiosfrom'axios'//创建axios实例constservice=axios.create({//配置项})复制代码根据环境设置baseURLbaseURL属性是请求地址前缀，将自动加在url前面，除非url是个绝对地址。正常情况下，在开发环境下和生产模式下有着不同的baseURL，所以，我们需要根据不同的环境切换不同的baseURL。在开发模式下，由于有着devServer的存在，需要根据固定的url前缀进行请求地址重写，所以，在开发环境下，将baseURL设为某个固定的值，比如：/apis。在生产模式下，根据Java模块的请求前缀的不同，可以设置不同的baseURL。具体代码如下：//根据process.env.NODE_ENV区分状态，切换不同的baseURLconstservice=axios.create({baseURL:process.env.NODE_ENV==='production'?`/java`:'/apis',})复制代码统一设置请求头在这里和大家聊一个问题，什么是封装？在我看来，封装是通过更少的调用代码覆盖更多的调用场景。由于，大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，所以，在这里，我采用的方案是，将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置。代码如下：constservice=axios.create({...headers:{get:{'Content-Type':'application/x-www-form-urlencoded;charset=utf-8'//在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来},post:{'Content-Type':'application/json;charset=utf-8'//在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来}},})复制代码跨域、超时、响应码处理axios中，提供是否允许跨域的属性——withCredentials，以及配置超时时间的属性——timeout，通过这两个属性，可以轻松处理跨域和超时的问题。下面，我们来说说响应码处理：axios提供了validateStatus属性，用于定义对于给定的HTTP响应状态码是resolve或rejectpromise。所以，正常设置的情况下，我们会将状态码为2系列或者304的请求设为resolve状态，其余为reject状态。结果就是，我们可以在业务代码里，使用catch统一捕获响应错误的请求，从而进行统一处理。但是，由于我在代码里面使用了async-await，而众所周知，async-await捕获catch的方式极为麻烦，所以，在此处，我选择将所有响应都设为resolve状态，统一在then处理。此部分代码如下：constservice=axios.create({//跨域请求时是否需要使用凭证withCredentials:true,//请求30s超时timeout:30000,validateStatus:function(){//使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常returntrue},})复制代码请求、响应处理在不使用axios的情况下，每次请求或者接受响应，都需要将请求或者响应序列化。而在axios中，transformRequest允许在向服务器发送请求前，修改请求数据；transformResponse在传递给then/catch前，允许修改响应数据。通过这两个钩子，可以省去大量重复的序列化代码。代码如下：constservice=axios.create({//在向服务器发送请求前，序列化请求数据transformRequest:[function(data){data=JSON.stringify(data)returndata}],//在传递给then/catch前，修改响应数据transformResponse:[function(data){if(typeofdata==='string'&&data.startsWith('{')){data=JSON.parse(data)}returndata}]})复制代码拦截器拦截器，分为请求拦截器以及响应拦截器，分别在请求或响应被then或catch处理前拦截它们。之前提到过，由于async-await中catch难以处理的问题，所以将出错的情况也作为resolve状态进行处理。但这带来了一个问题，请求或响应出错的情况下，结果没有数据协议中定义的msg字段（消息）。所以，我们需要在出错的时候，手动生成一个符合返回格式的返回数据。由于，在业务中，没有需要在请求拦截器中做额外处理的需求，所以，请求拦截器的resolve状态，只需直接返回就可以了。请求拦截器代码如下：//请求拦截器service.interceptors.request.use((config)=>{returnconfig},(error)=>{//错误抛到业务代码error.data={}error.data.msg='服务器异常，请联系管理员！'returnPromise.resolve(error)})复制代码再来聊聊响应拦截器，还是之前的那个问题，除了请求或响应错误，还有一种情况也会导致返回的消息体不符合协议规范，那就是状态码不为2系列或304时。此时，我们还是需要做一样的处理——手动生成一个符合返回格式的返回数据。但是，有一点不一样，我们还需要根据不同的状态码生成不同的提示信息，以方便处理上线后的问题。响应拦截器代码如下：//根据不同的状态码，生成不同的提示信息constshowStatus=(status)=>{letmessage=''//这一坨代码可以使用策略模式进行优化switch(status){case400:message='请求错误(400)'breakcase401:message='未授权，请重新登录(401)'breakcase403:message='拒绝访问(403)'breakcase404:message='请求出错(404)'breakcase408:message='请求超时(408)'breakcase500:message='服务器错误(500)'breakcase501:message='服务未实现(501)'breakcase502:message='网络错误(502)'breakcase503:message='服务不可用(503)'breakcase504:message='网络超时(504)'breakcase505:message='HTTP版本不受支持(505)'breakdefault:message=`连接出错(${status})!`}return`${message}，请检查网络或联系管理员！`}//响应拦截器service.interceptors.response.use((response)=>{conststatus=response.statusletmsg=''if(status<200||status>=300){//处理http错误，抛到业务代码msg=showStatus(status)if(typeofresponse.data==='string'){response.data={msg}}else{response.data.msg=msg}}returnresponse},(error)=>{//错误抛到业务代码error.data={}error.data.msg='请求超时或服务器异常，请检查网络或联系管理员！'returnPromise.resolve(error)})复制代码tips1：友情提示，上面那一坨switch-case代码，可以使用策略模式进行优化~tips2：如果有一些业务相关的需求，可以加在拦截器中，比如：loading、鉴权等~支持TypeScript由于前段时间，我在部门内推了TypeScript，为了满足自己的强迫症，将所有js文件改写为了ts文件。由于axios本身有TypeScript相关的支持，所以只需要把对应的类型导入，然后赋值即可。完整代码//http.tsimportaxios,{AxiosRequestConfig,AxiosResponse}from'axios'constshowStatus=(status:number)=>{letmessage=''switch(status){case400:message='请求错误(400)'breakcase401:message='未授权，请重新登录(401)'breakcase403:message='拒绝访问(403)'breakcase404:message='请求出错(404)'breakcase408:message='请求超时(408)'breakcase500:message='服务器错误(500)'breakcase501:message='服务未实现(501)'breakcase502:message='网络错误(502)'breakcase503:message='服务不可用(503)'breakcase504:message='网络超时(504)'breakcase505:message='HTTP版本不受支持(505)'breakdefault:message=`连接出错(${status})!`}return`${message}，请检查网络或联系管理员！`}constservice=axios.create({//联调baseURL:process.env.NODE_ENV==='production'?`/`:'/apis',headers:{get:{'Content-Type':'application/x-www-form-urlencoded;charset=utf-8'},post:{'Content-Type':'application/json;charset=utf-8'}},//是否跨站点访问控制请求withCredentials:true,timeout:30000,transformRequest:[(data)=>{data=JSON.stringify(data)returndata}],validateStatus(){//使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常returntrue},transformResponse:[(data)=>{if(typeofdata==='string'&&data.startsWith('{')){data=JSON.parse(data)}returndata}]})//请求拦截器service.interceptors.request.use((config:AxiosRequestConfig)=>{returnconfig},(error)=>{//错误抛到业务代码error.data={}error.data.msg='服务器异常，请联系管理员！'returnPromise.resolve(error)})//响应拦截器service.interceptors.response.use((response:AxiosResponse)=>{conststatus=response.statusletmsg=''if(status<200||status>=300){//处理http错误，抛到业务代码msg=showStatus(status)if(typeofresponse.data==='string'){response.data={msg}}else{response.data.msg=msg}}returnresponse},(error)=>{//错误抛到业务代码error.data={}error.data.msg='请求超时或服务器异常，请检查网络或联系管理员！'returnPromise.resolve(error)})exportdefaultservice复制代码",
      "id": "2wzr45m3kgi0",
      "author": "云音乐前端技术团队",
      "title": "聊聊 Vue 中 axios 的封装"
    },
    {
      "content": "笔者在刚进入阿里的时候，其实连灰度是什么也不知道，但是灰度这个概念在大厂非常普遍，只要有一定用户量的应用都会涉及到灰度发布，所以准备进大厂的同学，灰度发布这个概念一定要了解一下。一.灰度发布是什么？灰度发布，又被称之为金丝雀发布，是指某次新发布功能特性和旧功能特性之间能够以平滑过渡的方式呈现给用户，就像金丝雀的羽毛一样多种颜色平滑渐变。举个例子，某个已上线处于运行中的系统需要一次新的功能迭代，但是由于功能变动较大，所以发布需要考虑用户的使用反馈以及代码可能存在一些未知的异常，这时候则需要将新的功能逐步地一批一批的推送给用户。在这个逐步放量的过程中，可以根据用户接受度（用户投诉多不多）和观察本次功能是否存在上线前未发现的异常，来决定是否继续发布推送新功能，如果新功能反馈较差或者存在功能异常问题，则停止放量或者回滚到之前稳定的版本，及时修改问题。这样便避免一次推送情况下，如果出现问题则造成线上问题突然上升造成阻塞用户使用的问题。二.灰度发布的优点1.提前收集用户使用意见，及时完善产品功能2.控制未知异常只出现在小范围内，不影响大多数用户3.发现产品是否存在外在问题（如合规），可及时回滚至已旧版本三.前端灰度发布的要素1.放量规则如果逐步推送新功能，则必须有一种规则让用户按照某些特征分成不同的群体，这个规则可以是年龄，城市，或者用户注册时的id。例如，用户注册时有一个从0自增的序号位，当灰度放量时可以以该序号为维度，从小到大的放量，直至百分百完成。一个完善的系统在设计之初一定会考虑到灰度方案，如果你仔细观察用户的uid在注册的时候一定有一个序号位，像身份证号里第十五位是从0-9的序号位，一般的用户UID会留两位作为自增序号位，灰度时这两位一般被作为灰度特征。2.资源新旧版本能明确的标识出要给用户展示两种页面形态，可以是以前端静态版本号的形式，如每次发布资源后，静态资源的版本号链接改变一下，这时候灰度则其实是两个不同资源请求链接逐步从旧到新的过程。四.灰度实现原理下面是灰度的实现基本原理，最关键的还是判断灰度用户这一步操作，可以在请求发出去前进行判断，然后直接请求对应的资源，也可以请求到了服务端后，服务端先区别出用户是否属于灰度名单内，再返回对应资源内容，具体还要看前端应用是怎样的形式部署的，服务端渲染或者是客户端渲染均有关系。\">五.前端灰度发布的几种方式1.服务端渲染应用服务端渲染应用会在返回客户端之前将静态模板渲染好，知道这个是非常重要的，这意味着前端灰度这个过程要在用户的请求返回之前就完成，在客户端不处理任何灰度相关的内容。如下图：\">简单描述一下，这里用户首先发起请求后，服务器并不会直接组装静态资源，而是先去灰度规则里获取名单，然后将灰度名单拿到进行判断处理来决定渲染那一套模板资源给到客户端，最终给处于灰度名单里的用户展示新版本页面，而非名单内的用户继续使用旧版本的页面内容，如需要放量时，直接在灰度规则里进行修改即可。看看下面代码示例//服务端代码//静态模板constmodel1=()=>{return`<!DOCTYPEhtml>我是A界面`}constmodel2=()=>{return`<!DOCTYPEhtml>我是B界面`}constisPass=getRule(req.uid)//查询规则if(isPass){//在白名单res.render(model2)}else{res.render(model1)}...复制代码上面的代码中，有A，B两个版本的界面，用户请求的资源在返回之前先通过getRule获取灰度规则，确定了是否在白名单里，然后决定返回那一套模板内容。2.前后端半分离的应用这里前后端半分离的应用是指在有一部分前端应用的html文件依旧在服务端上，但是实际上却在客户端渲染的，相信大家见的比较多，例如下面的这段代码。<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\"></head><body><divid=\"react-content\"></div></body><scriptsrc=\"http://cdn.com/1.0.1/my.js\"></script></html>复制代码当我们使用react或者vue的时候，最后将代码打包到一个JavaScript文件里，在一个html文件中加载使用，而这个html文件则会被放到一个服务端系统里，当用户请求到资源时，将这段html返回给客户端，客户端拿到内容后加载在http://cdn.com/1.0.1/my.js的网络资源，然后本地渲染。这里注意一下，我们每次打包的资源都会有一个版本号，比如上面的版本是1.0.1，这里在cdn上的存贮路径也是1.0.1/my.js，使用路径的唯一性来区别与其他版本不一致，当然也可以在文件名上加版本号，如/my_1.0.1.js，只要能识别出资源的唯一性均是可以的。下面来一段伪代码看看这里灰度又该怎么做。//服务端代码constisPass=getRule(req.uid)//查询规则letversion=1.0.1;//旧版本号if(isPass){//在白名单version=2.0.0}//静态模板constmodel=version=>{return`<!DOCTYPEhtml>`}res.render(model(version))//返回带版本号的模板复制代码这段代码中，因为两次迭代需求，前端开发者将前端资源打包成了两个资源包，分别上传到CDN的不同位置处，以版本号作为标识来确定新旧内容。当用户的请求被接收到后，先通过getRule获取灰度规则来确定给当前用户展示哪一个版本号的资源，然后返回带着资源版本的模板内容，客户端接收到该模板之后，再加载对应的版本号资源，从而达到灰度要求。3.客户端渲染的前端应用目前来说最常见的一种部署类型，前端开发完成后，直接打包至CDN上，然后利用nginx来请求到静态资源，这时候CDN服务器并不会去做灰度判断相关的操作，即这时候不能让后端通过一段获取灰度逻辑来控制版本，而此时前端数据请求都是异步ajax的方式，那灰度又该怎么做呢？第一种思路：我们可以在前端代码里写两套内容，在页面渲染之前发起异步获取灰度规则的请求，将结果拿到后在客户端决定渲染那一套页面，从而达到灰度的要求。看看下面的伪代码：//客户端端代码//组件constcomponent1=()=>{return(<div>我是A组件</div>)}constcomponent2=()=>{return(<div>我是B组件</div>)}constisPass=$.ajax('/getRule?uid')//查询规则...render(){if(isPass){//在白名单returnmodel2()}else{returnmodel1()}}...复制代码上面的这段客户端代码即可完成用户灰度，但是有一个问题，当后期需求增多的时候前端代码将非常庞大，而且每次的新需求发布的时候势必要去测试回归旧的版本是否被改动了，将维护两套内容，随着应用体积变大维护将变得非常累。第二种思路：如果我们继续保持版本号来区分每次的迭代，只是在渲染前获取到正确的版本资源来渲染是不是就可以解决上面的问题呢？看看下面的伪代码：//客户端端代码constsyncLoadJs=function(version,fn){constoScript=document.createElement('script');oScript.setAttribute('src',`https://cdn.com/{version}/my.js`);oScript.setAttribute('type','text/javascript');oScript.onload=fn;oScript.onerror=function(){window.location.href='/error.htm'};document.body.appendChild(oScript);},...constisPass=$.ajax('/getRule?uid')//查询规则letversion=1.0.1;//旧版本号if(isPass){//在白名单version=2.0.0}syncLoadJs(version,function(){ReactDOM.render());//客户端获取完资源后进行渲染})...复制代码这一种方式则是在客户端渲染之前先进行异步获取名单来决定资源版本，在拿到资源版本之后才会进行页面渲染工作。但是这里存在一个问题，每一个页面都需要去获取灰度规则，然后判断是否灰度，这个灰度请求将阻塞页面的，可能会造成较差的用户体验，所以我们可以考虑使用客户端的localStrage来存储这个用户是否为灰度用户，而不是每次请求资源时都发请求去判断是否为灰度用户，然后定期的更新localStrage内存储的值，取代大量的请求造成的体验问题。如上内容均为自己总结，难免会有错误或者认识偏差，如有问题，希望大家留言指正，以免误人，若有什么问题请留言，会尽力回答之。如果对你有帮助不要忘了分享给你的朋友！也可以关注作者，查看历史文章并且关注最新动态，助你早日成为一名全栈工程师！往期精彩回顾北漂程序员的出路科普：身份证号为什么不会重复一个前端失业者的面试之旅\">",
      "id": "4npmq5buti80",
      "author": "前端小智",
      "title": "要进大厂？前端灰度发布必须要知道"
    },
    {
      "content": "本文将介绍一款全新的前端开发工具，希望它能给你的前端开发带来看起来和现在一样但其实又不那么一样的体验。你可能会说，大家都是秃头的成熟的前端程序员了，每一台电脑上都有几套自己辛辛苦苦装好的全家桶，为什么还要新换一个开发工具？对，盲生，你可能发现了华点。数一数你电脑上目前为前端本地开发安装了多少小工具、小插件？这其中仅仅是为代码开发阶段，就可能有本地服务器、远程调试工具、代理工具、浏览器插件等等。它们也许是你一个个尝试无数同款后最终确定安装的，也可能是被各类『震惊！超好用前端开发工具大全』安利的，并且其中不乏全局安装、全局配置的「重器」。\">试想现在你要换一台新电脑或者重装新系统了，你还得一个个把它们重新安装回来。况且大部分这样的工具是无法根据工程进行独立配置的，也就是说你在不同项目之间切换时还需要手动修改你的开发工具配置。这些都是一些强迫症患者如作者本人无法忍受的。总结一下平时搞开发的时候一些习以为常但仔细一想又挺麻烦的场景：你必须手动安装各类工具软件以丰富你的本地开发环境这样的本地开发环境无法拷贝或者很难拷贝，无法分享每种工具都要单独配置，且配置基本不是按照项目隔离的，切换项目时经常需要修改配置有时候你的需求并没有合适的工具来满足，自己写一个又太麻烦写一个项目要同时打开N种工具：本地服务器、mock服务器等经常还需要不断重启这些工具以刷新配置……基于以上以及一些其它痛点，便有了下文将介绍的server-x。什么是server-x如同它名字的前半部分，server，你可以简单地说，server-x（缩写为svrx）就是一个本地服务器，并且它还是一个功能丰富、使用便捷的轻量级服务器。先来看下最简单的使用场景：首先你需要安装svrx的CLI工具，npminstall-g@svrx/cli复制代码然后新建一个简单的页面，在项目根目录启动svrx，mkdirexample&&cdexampleecho'Hellosvrx!'>index.htmlsvrx复制代码访问http://localhost:8000即可看到你的前端页面。\">安装便捷，启动迅速，独立使用，除了node，不依赖任何别的环境。当然，这是任何一个独立的、基础的devserver都能做到的最必不可少的功能。除此之外还有什么？svrx还自带了诸如自动打开浏览器、监听代码变动自动刷新（livereload）、proxy等实用性非常强的功能。是的，你也可以说，部分devserver也是能做到的。svrx和其它本地服务器最大的区别，其实是它名字server-x的后半部分：x。我们都知道，x可以代表「未知和无限」，即svrx是一个有着无限可能的服务器。为什么说它有无限的可能？因为svrx最大的特点：它是一个插件平台。通过插件，理论上你的svrx确实可以拥有任意的功能。每一个小功能在这里就是一个独立的插件，你只需要声明就能使用它，就像这样：svrx--webpack--qrcode--markdown复制代码很清晰直观，没有冗余的配置，在你声明插件以后，svrx会自动帮你下载安装插件，然后直接启动。所以你可以说，svrx是一个聚合了众多功能插件的平台，它本身就是一个全家桶。不过不同的是，你丝毫不需要关心插件的安装过程。除了svrx的CLI，你无需安装其它任何工具。另外，所有插件都不是全局安装，而是直接安装到你工程的node_modules目录中。所以工程开发是真正独立隔离的，你可以自由给每一个项目定制一套开发环境，不用考虑安装卸载，完全不担心环境污染问题，同时系统也可以保持干净清爽。事实上，业内目前可用的本地devserver有很多，但像svrx这样，轻量易用的、具有完备插件机制的、完全不依赖工程环境的，几乎是没有的。接下来，我们通过创建一个简单的前端工程，继续探索一下使用svrx进行开发的全新体验，带你深入了解一些进阶用法和黑科技，这些才是svrx真正有趣的地方。创建工程及启动方便起见，我们选用前端常用的CreateReactApp进行示例工程创建（前面提到，svrx不依赖任何工程环境，选取CRA仅仅为了示例方便）。npminitreact-appsvrx-examplecdsvrx-example复制代码由于新工程默认使用webpack打包，想要启动这样的工程，我们需要使用插件svrx-plugin-webpack。这个插件的作用就是读取项目配置，调用webpack-dev-middleware，使你的webpack项目可以无缝接入到svrx服务中。不过由于新工程并没有暴露出webpack配置项，所以我们需要先在根目录创建一个webpack.config.js：//webpack.config.jsmodule.exports=require('react-scripts/config/webpack.config')('development');复制代码然后我们就可以顺利启动项目了：svrx--webpack复制代码浏览器会自动弹出http://localhost:8000/页面：\">这时可以尝试编辑下src/App.css，看看页面是不是实时变化了？\">进阶1：添加配置项默认地，svrx会在启动时自动开启一些内置的基础插件，如静态伺服（serve）、转发服务（proxy）、页面自动刷新（livereload）等。它们都有一些默认行为以保证用户可以快速启动svrx，当然，如果你需要对这些内置配置项做一些自定义修改，svrx也提供了两种方式。你可以在命令行启动svrx时传入参数进行配置：svrx--port3000--https--no-livereload复制代码也可以在你的工程目录下建立.svrxrc.js或svrx.config.js文件，将上面的命令行参数持久化下来：//.svrxrc.jsmodule.exports={port:3000,https:true,livereload:false};复制代码svrx的全部配置项及描述可以在官方文档-内置项中查看。进阶2：开始尝试使用其它插件除了内置插件以外，svrx还有很多独立插件，比如前面提到的svrx-plugin-webpack。在你需要别的开发功能（如远程调试、mock等）时，只需要简单地在svrx配置中声明这些独立功能插件的名字即可正常使用。正是这些独立插件，为svrx项目提供了丰富多彩的功能体验。下面先介绍几个好用的好玩的插件：localtunnel-把本地服务暴露出去试想你正紧张有序地在进行页面开发，这个时候你领导的消息弹了出来：让我看看你的页面写得怎么样了这个时候你怎么办？你是不是得先检查进度，把能用的代码先提交，然后你灵机一动，部署了一个本地服务，准备甩给你领导一串本机IP。但是你突然想起来，领导不是在出差吗？（太敬业了，还在时刻检查你的开发进度）领导访问不了内网啊。这时你只能慌忙找服务器再部署一个测试环境给领导，部署得还贼慢，领导飞机都要起飞了！这个时候，你就需要svrx的localtunnel插件了！它可以将你的本地服务暴露到localtunnel.me，从而方便地进行本地代码的测试和分享。你再也无需为了测试你的一点代码变动就专门部署一次测试服务了。启动localtunnel只需在之前的启动命令后添加声明即可：svrx--webpack--localtunnel复制代码上面的命令将会自动安装localtunnel插件并启动svrx，其他人（是的，你们甚至不需要在同一个内网）此时访问终端打印的https://*.localtunnel.me也将看到你的本地服务：\">并且，你的每次本地页面变动都可以被别人实时看到，再也不用担心领导突然检查作业了！\">weinre-远程调试移动端代码现在一般都是如何进行移动端代码调试的？你可能会说，“这题我会！”很简单，先在手机上打开设置里的开发者模式（可能要找一下），允许USB连接，再找一根USB连接线，把手机和电脑连接起来，然后你打开你电脑上的浏览器开发者工具，开启一些东西，找到远程设备，然后Inspect……万一有更简便的方法呢？你可以试试svrx的weinre插件，它用于方便地远程调试移动端的页面，而且是“无线”的。我们再次回到刚才的example工程，这次我们在启动命令后面添加两个新的插件：svrx--open=external--webpack--weinre--qrcode复制代码首先通过上面的命令快速安装weinre和二维码插件并启动svrx，此时试着拿手机访问启动好的项目页面，这里推荐配合qrcode二维码插件让手机轻松扫码访问页面地址:\">紧接着电脑打开weinre的调试器页面http://${your_ip}:8001（默认），找到手机的访问记录，就可以在调试器上对手机页面进行远程调试了。\">定制你的插件除了上述的，svrx还有很多有趣好用的插件，你可以在svrx的官网查询目前所有的插件，并从中挑选使用。通过不同插件的组合，你就可以自由定制你的开发环境啦！\">当然，如果没找到你想要的功能插件，你还可以尝试自己写一个。你可以用插件实现哪些功能呢？拿前面的qrcode二维码插件来说，为了把二维码显示到页面上，你可以往前端页面注入一些js脚本，css样式；也可以像webpack插件那样，往后端逻辑中注入一些koa风格的中间件，拦截请求做数据处理，比如这里的webpack-dev-middleware。有了强大的前后端注入能力，几乎所有的本地开发需求，都可以通过创建一个svrx插件来解决。而且插件的开发异常简单！刚刚介绍的一些插件的核心代码几乎都只有50行左右！此外，svrx还提供了快速创建插件的脚手架工具，可以去官方文档-如何写一个插件查看更多插件开发的细节，在这里就不赘述了。进阶3：可以热更新的快捷路由在前后端分离的开发场景中，前端经常会碰到需要进行数据mock的情况。于是你可能会经历：修改mock数据，重启mock服务器打开、关闭接口转发，重启修改工程代码，重启……就算你说现在的mock服务都很智能，不需要重启了，但是你还是需要在本地服务外手动再开启一个mock服务，要么就是狠一点，把mock数据写到工程代码里。太不优雅了！于是svrx的动态路由就派上用场了。是的，除了丰富的插件体系，svrx其实还有一个功能强大、使用便捷的动态路由功能。还是回到我们的example工程，你可以通过以下命令开启快速尝试：touchroute.js#createemptyroutingfilesvrx--webpack--routeroute.js复制代码在route.js中：get('/blog').to.json({title:'svrx'});复制代码此时打开/blog，你将看到{title:'svrx'}的json输出。有了这个路由功能，你将可以在不侵入项目代码的前提下快速直观地创建你的mock数据。并且它是支持hotreload的，即每次编辑route.js后，无需重启svrx服务，路由数据会自动更新。\">当然，除了用于本地开发数据mock外，svrx路由还可以做很多。下面是一些路由示例：get('/index.html').to.sendFile('./index.html');get('/blog').to.redirect('/user');get('/old/rewrite:path(.*)').to.rewrite('/svrx/{path}');get('/api(.*)').to.proxy('http://mock.server.com/');get('/blog').to.header({'X-Engine':'svrx'}).json({code:200});复制代码如你所见，svrx的路由语法非常简单，你可以清晰直观地阅读出每一条规则，比如发送文件、重定向、路由重写、proxy等等。并且除了官方提供的一些路由操作外，你也可以通过插件来对路由操作进行扩展。关于svrx路由的语法规则、扩展等详情可以参阅官方文档-路由的使用。写在最后一个渐进且易于使用的、插件化的前端开发平台。这是svrx的slogan，同时也非常准确地描述了svrx的定位：svrx是面向前端开发者的一个强大的本地devserver，它由本地服务、proxy、livereload等功能插件组成svrx有着丰富强大的插件系统，你可以自由使用或者定制想要的功能在致力于为前端开发者提供更为优雅便捷的本地开发体验的同时，svrx也为大家提供了一个可以快速进行自定义功能开发的平台。作为用户，你可以挑选合适的插件组合来满足你的本地服务需求，一键启动，省时省力，易拔插的功能设计，也不用担心环境污染。如果没有找到合适的插件，你可以变身开发者，自给自足，快速实现想要的功能。作为开发者，你还可以大开脑洞，通过你写的插件提升更多人的本地开发体验。之后，svrx也将继续推出更多优质功能或插件，持续为前端开发服务。Linkssvrx官网官方使用文档、API、插件查询Github-svrx核心源码、讨论交流、bugreport\">微信群超过一百人无法进群的话加微信：cyxu0825，加你入群\">",
      "id": "3maqpuunyhe0",
      "author": "西岚",
      "title": "Server-X：一款可能提升你十倍工作效率的工具"
    },
    {
      "content": "作者：DmitriPavlutin译者：前端小智来源：dmitripavlutin这几天自己的公众号无套路送现金200+，参与方式如下mp.weixin.qq.com/s/PTlWMG5Ke…为了保证的可读性，本文采用意译而非直译。在JS面试中，经常会看到一些简单而又沙雕的题目，这些题目包含一些陷阱，但这些在我们规范的编码下或者业务中基本不会出现。有些面试官就是这样，不专注于制定代码的标准和规范上，却用不规范的代码去检验别人是否细心。这魔幻的世界就是一个攀比优越感的，我能考你，我就是比你优越，真实。来看看这7个沙雕题目是哪些。1.偶然创建的全局变量面试官问在下面的代码中typeofa和typeofb结果各自是什么？（沙雕）functionfoo(){leta=b=0;a++;returna;}foo();typeofa;//=>???typeofb;//=>???复制代码答案这个代码的重点在第二行:leta=b=0。这个语句声明了一个局部变量a，但是它也声明了一个全局变量b。在foo()作用域或全局作用域中都没有声明变量b。因此JS引荐将b=0表达式解释为window.b=0。如下图所示，函数foo中的i都是一个偶然创建的全局变量：\">同样，在咱们的问题中，b是一个偶然创建的全局变量。在浏览器中，上面的代码相当于如下：functionfoo(){leta;window.b=0;a=window.b;a++;returna;}foo();typeofa;//=>'undefined'typeofwindow.b;//=>'number'复制代码typeofa是'undefined'。变量a仅在foo()作用域中声明，在外部作用域内不可用。typeofb结果是'number'。b是一个值为0的全局变量2.数组的length属性面试官问clothes[0]的值是什么？（沙雕）constclothes=['jacket','t-shirt'];clothes.length=0;clothes[0];//=>???复制代码答案数组对象的length属性具有一些特殊的行为：减少length属性的值的副作用是删除自己的数组元素，这些元素的数组索引位于新旧长度值之间。由于length属性行为，当JS执行clothes.length=0时，删除所有的clothes项。所以clothes[0]的值为undefined，因为clothes数组已被清空。3.考验眼力的魔幻题面试官问下面代码中numbers数组的内容是什么?注意for()后加了一个分号(;)，真是沙雕。constlength=4;constnumbers=[];for(vari=0;i<length;i++);{numbers.push(i+1);}numbers;//=>???复制代码答案上面代码中for()后加了一个分号(;)，加上分号，JS会认为该语句结束，所以for循环执行了4次空语句，当退出循环的时候，此时的i值为4。然后执行{numbers.push(i+1);}，所以最终numbers内容只有一个数字5。上面的代码相当于下面的代码constlength=4;constnumbers=[];vari;for(i=0;i<length;i++){//doesnothing}{//asimpleblocknumbers.push(i+1);}numbers;//=>[5]复制代码用不规范的代码去检验别人是否细心，我觉得很沙雕。4.自动分号插入面试官问arrayFromValue()返回什么值?（沙雕）functionarrayFromValue(items){return[items];}arrayFromValue(10);//=>???复制代码答案这里需要注意的return和[items]之间已经换行了，JS会在换行之间自动插入分号。所以上面等价下面的代码：functionarrayFromValue(items){return;[items];}arrayFromValue(10);//=>undefined复制代码return;在函数内部使该函数返回undefined，所以arrayFromValue(10)的值为undefined。5.被考烂的一个经典闭包问题面试官问下面的代码执行结果是什么？（能不能换个题）leti;for(i=0;i<3;i++){constlog=()=>{console.log(i);}setTimeout(log,100);}复制代码答案当你对JS基础不是很了解的时候，很容易给出0,1,2的答案，我第一次在学校遇到这个题目也是这个答案。执行这段代码的过程有两个阶段。阶段1for()迭代3次。在每次迭代时，都会创建一个新函数log()，该函数将捕获变量i。然后，setTimout()调度log()的执行。当for()循环完成时，变量i的值为3。log()是一个捕获变量i的闭包，该变量在for()循环的外部作用域中定义。重要的是要了解闭包在词法上捕获了变量i。阶段2第二阶段发生在100毫秒之后setTimeout()调用3个log()回调。log()读取变量i的当前值，即3。这就是为什么控制台输出为3，3和3的原因6.浮点运算面试官问下面的代码输出是什么？（能不能换个题）0.1+0.2===0.3//=>???复制代码答案首先，来看一下0.1+0.2的值0.1+0.2;//=>0.30000000000000004复制代码0.1和0.2的和不等于0.3，但略高于0.3。由于以二进制方式对浮点数进行编码，因此像浮点数相加之类的操作会产生舍入误差。因此，0.1+0.2===0.3是false。7.变量的提升面试官问如果在声明之前访问myVar和myConst会发生什么？（能不能换个题）myVar;//=>???myConst;//=>???varmyVar='value';constmyConst=3.14;复制代码答案提升和时间死区是影响JS变量生命周期的两个重要概念。\">在声明之前访问myVar的结果是undefined，因为使用var声明的变量会被提升且值为undefined。但是，在声明行之前访问myConst会引发ReferenceError。在代码行constmyConst=3.14之前，const变量处于临时死区。总结你有没有感觉上面的问题，有些是对面试毫无用处，特别是第3道题目。但是，还是有一小部分的面试中会被问到。当然，虽然都说是沙雕题目，但这些是可以评估你是否精通JS，还是有我们学习的知识的。在面试中，你还遇到哪些像这样的题目，欢迎留言讨论。代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log调试，这边顺便给大家推荐一个好用的BUG监控工具Fundebug。原文：dmitripavlutin.com/simple-but-…交流（欢迎加入群，群工作日都会发红包，互动讨论技术）阿里云最近在做活动，低至2折，有兴趣可以看看：promotion.aliyun.com/ntms/yunpar…干货系列文章汇总如下，觉得不错点个Star，欢迎加群互相学习。github.com/qq449245884…因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。\">每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励\">",
      "id": "5sxabtpsibo0",
      "author": "寒东设计师",
      "title": "7 个沙雕又带有陷阱的 JS 面试题"
    },
    {
      "content": "写在前言要知道在深圳上班是非常痛苦的事情，特别是我上班的科兴科技园这一块，去的人非常多，每天上班跟春运一样，如果我能换到以前的大冲上班那就幸福了，可惜，换不得。尤其是我这个站等车的多的一笔，上班公交挤的不行，车满的时候只有少部分人能硬挤上去。通常我只会用两个字来形容这种人：“公交怪”想当年我朋友瘦的像只猴还能上去，老子身高182体重72kg挤个公交，不成问题，反手一个阻挡，闷声发大财，前面的阿姨你快点阿姨，别磨磨唧唧的，快上去啊阿姨，嗯？你还想挤掉我？你能挤掉我？你能挤掉我！我当场！把车吃了！....咳咳，挤公交是不可能挤公交滴，因为今天我发现了一个可以定制路线的网约巴士公众号【深圳xxx】但是呢，票经常会被抢光，同时我还我发现，有时候会有人退票，这时候就有空余票了，关键是我不可能时时都在公众号上盯着，于是，我就写了一个抢票+短信通知的小工具获取接口信息查看页面结构这个就是订票页面，显示当前月的车票情况，根据图示，红色为已满，绿色为已购，灰色为不可选\">如果是可选就是白色的小方块，并且在下面显示余票，如下图所示：\">我们打算这么做，定时抓取返回的接口信息根据接口返回值判断是否有余票好，审查下源代码看下接口信息，等等，微信浏览器没办法审查源代码，于是使用chrome调试微信公众号网页页面首先面临个问题，如果直接copy公众号网页Url在chrome打开的话，就会显示这个画面，他被302重定向到了这个页面，所以是行不通的，只有获取OAuth2.0授权才能进去\">所以我们得先通过抓包工具，知道手机访问微信公众号网页的时候，需要带什么信息过去，这时候我们就得借助抓包工具，因为我电脑是Mac，用不了Fiddler，我用的是Charles花瓶，就是下面这位仁兄\">借助这个工具，我们只需3步就可以轻松搞定手机数据抓包：获取本机IP地址和端口设置代理手机上网依次执行上面两步获取本机IP地址和端口第一步，找到端口号，一般默认是8088，但是为了确认可以打开Proxy/ProxySetting看下，哦原来我之前设置成了8888\">然后找到Charles的help/LocalIPAddress，点击它就会看到自己的本机地址，找到本机地址记下来，然后进行下一步\">设置代理手机上网首先保证手机跟电脑连接的是同一个wifi，然后在wifi设置那里会有设置代理信息，比如我的猴米...不对，小米9手机！设置如下：输入上一步获取主机名，端口号就ok了\">输入完成，点击确定后。Charles就会弹出一个对话框，问你是否同意接入代理，点击确定allow就行了。用手机访问目标网页我们用手机访问微信公众号【深圳x出行】进入到抢票页面后，发现Charles已经成功抓包到了网页信息，当我们进入这个抢票页面的时候，他会发起两个请求，一个是获取document文档内容，一个post请求获取票务信息。仔细分析了下，大概明白了业务逻辑：整个项目技术站是java+jsp，传统写法，用户身份验证主要是cookie+session方案，前端这一块主要是使用jQuery。当用户进入页面的时候，会携带查询参数，如起始站点，时间，车次等信息和cookie请求document文档，也就是圈起来的这一块，\">\">而我们想要的核心内容：日历表，一开始是不显示的因为还要在请求一次第二次请求，携带cookie和以上的查询参数发起一个post请求，获取当月的车票信息，也就是日历表内容下面这个是请求当月票务信息，然而发现他返回的是一堆html节点好吧...估计是获取到之后直接append到div里面的，然后渲染生成日历表内容\">接着在手机上操作，选择两个日期，然后点击下单，发送购票请求，拉取购票接口，我们看下购票接口的请求和返回内容：\">看下request内容，根据字段的意思大概明白是线路，时间，以及车票金额，还有支付方式在看看返回的内容：返回一个json字符串数据，里面大概涵盖了下单的成功返回码，时间，id号等等信息\">记录所需要的信息内容根据上面的分析，总结下内容：整个项目用户身份验证是使用cookie和session方案，请求数据用的是formdata方式，请求字段啥的我们也都清楚，唯独有一点，就是请求余票的时候，返回的是html节点代码，而不是我们预期的json数据，这样就有个麻烦，我们没办法一目了然的明白他余票的时候是如何显示的所以我们只能通过chrome进行调试，才能得出他是如何判断余票的。我们找个记事本，记录下信息，记录的内容有：请求余票接口和购票接口的url地址cookie信息各自的request参数字段user-Agent信息各自的response返回内容设置chrome有以上信息后，我们就可以开始用chrome调试了，首先打开Moretools/Networkconditions\">把user-Agent填入到Custom里面\">Charles抓包本地请求因为我们要把获取到的cookie填入到chrome里面，以我们的用户身份去访问网页，所以我们需要在请求目标地址的时候，改包修改cookie首先我们需要开启macOSProxy，抓包我们的http请求\">打开chrome访问目标网址，我们可以看到Charles上已经抓包到了我们访问的目标url地址，然后给目标url地址打上断点，方便调试\">然后再次访问，这时候断点就生效了，弹出一个tab名为breakpoints，可以看到之所以我们还是不能访问到目标网址，是因为sessionId不对，所以我们把抓取到的cookie在填入到里面，点击execute\">这时候，能够正确跳到目标页面了。\">大概看了下他整体布局，和jQuery代码CSS代码，特别是日历表那一块审查了下元素发现：小方块的结构为：<tdclass=\"b\"><span>这里为日期</span><span>如果有余票则显示余票数量</span></td>复制代码td的样式名为a代表不可选样式名为e代表已满样式名为d代表已购样式名为b则是我们要找的，代表可选，也就是有余票到这一步，整个购票流程就清楚了到时候我们通过Node.js请求的时候，处理返回数据，用正则去判断是否有余票的class名b，有余票的话，在获取div里面的余票数量内容就Ok了Node.js请求目标接口分析需要开发的功能点写代码之前我们需要想好功能点，我们需要什么功能:请求余票接口定时请求任务有余票则自动请求购票接口下订单调用腾讯云短信api接口发送短信通知多个用户抢票功能抢某个日期的票首先mkdirticket创建名为ticket的文件夹，接着cdticket进入文件夹npminit一路瞎几把回车也无妨。下面开始安装依赖，根据上面的功能需求，我们大概需要：请求工具，这里看个人习惯，你也可以使用原生的http.request，我这里选择用的是axios，毕竟axios在node端底层也是调用http.requestcnpminstallaxios--save复制代码定时任务node-schedulecnpminstallnode-schedule--save复制代码node端选择dom节点工具cheeriocnpminstallcheerio--save复制代码腾讯发短信的依赖包qcloudsms_jscnpminstallqcloudsms_js复制代码热更新包，诺豆的妈妈，nodemon（其实不用也可以）cnpminstallnodemon--save-dev复制代码开发请求余票接口接着touchindex.js创建核心js文件，开始编码：首先引入所有依赖constaxios=require('axios')constquerystring=require(\"querystring\");//序列化对象，用qs也行，都一样letQcloudSms=require(\"qcloudsms_js\");letcheerio=require('cheerio');letschedule=require('node-schedule');复制代码然后我们先定义请求参数,来一个objletobj={data:{lineId:111130,//路线idvehTime:0722,//发车时间，startTime:0751,//预计上车时间onStationId:564492,//预定的站点idoffStationId:17990,//到站idonStationName:'宝安交通运输局③',//预定的站点名称offStationName:\"深港产学研基地\",//预定到站名称tradePrice:0,//总金额saleDates:'17',//车票日期beginDate:'',//订票时间，滞空，用于抓取到余票后填入数据},phoneNumber:123123123,//用户手机号，接收短信的手机号cookie:'JSESSIONID=TESTCOOKIE',//抓取到的cookieday:\"17\"//定17号的票，这个主要是用于抢指定日期的票，滞空则为抢当月所有余票}复制代码接着声明一个名为queryTicket的类，为啥要用类呢，因为基于第五个需求点，多个用户抢票的时候，我们分别new一下就行了，同时我们希望能够记录请求余票的次数，和当抢到票后自动停止查询余票得操作，所以给他加上个计数变量times和是否停止的变量，布尔值stop编写代码:classQueryTicket{/***CreatesaninstanceofQueryTicket.*@param{Object}{data,phoneNumber,cookie,day}*@paramdata{Object}请求余票接口的requery参数*@paramphoneNumber{Number}用户手机号，短信需要用到*@paramcookie{String}cookie信息*@paramsday{String}某日的票，如'18'*@memberofQueryTicket请求余票接口*/constructor({data,phoneNumber,cookie,day}){this.data=datathis.cookie=cookiethis.day=daythis.phoneNumber=phoneNumberthis.postData=querystring.stringify(data)this.times=0;//记录次数letstop=false//通过特定接口才能修改stop值，防止外部随意串改this.getStop=function(){//获取是否停止returnstop}this.setStop=function(ifStop){//设置是否停止stop=ifStop}}}复制代码下面开始定义原型方法，为了方便维护，我们把逻辑拆分成各个函数classQueryTicket{constructor({data,phoneNumber,cookie,day}){//constructor代码...}init(){}//初始化handleQueryTicket(){}//查询余票的逻辑requestTicket(){}//调用查询余票接口handleBuyTicket(){}//购票相关逻辑requestOrder(){}//调用购票接口handleInfoUser(){}//通知用户的逻辑sendMSg(){}//发短信接口}复制代码所有数据都是基于查询余票的操作，因此我们先开发这部分功能classQueryTicket{constructor({data,phoneNumber,cookie,day}){//constructor代码...}//初始化,因为涉及到异步请求，所以我们使用`asyncawait`asyncinit(){letticketList=awaitthis.handleQueryTicket()//返回查询到的余票数组}//查询余票的逻辑handleQueryTicket(){letticketList=[]//余票数组letres=awaitthis.requestTicket()this.times++//计数器，记录请求查询多少次letstr=res.data.replace(/\\\\/g,\"\")//格式化返回值let$=cheerio.load(`${str}`)//cheerio载入查询接口response的html节点数据letlist=$(\".main\").find(\".b\")//查找是否有余票的dom节点//如果没有余票，打印出请求多少次,然后返回，不执行下面的代码if(!list.length){console.log(`用户${this.phoneNumber}：无票，已进行${this.times}次`)return}//如果有余票list.each((idx,item)=>{letstr=$(item).html()//str这时格式是21&$x4F59;0//最后一个span的内容其实\"余0\"，也就是无票，只不过是被转码了而已//因此要在下一步对其进行格式化letarr=str.split(/|<\\/span>|\\&\\#x4F59\\;/).filter(item=>!!item===true)letdata={day:arr[0],ticketLeft:arr[1]}//如果是要抢指定日期的票if(this.day){//如果有指定日期的余票if(parseInt(data.day)===parseInt(data.day)){ticketList.push(data)}}else{//如果不是，则返回查询到的所有余票ticketList.push(data)}})returnticketList}//调用查询余票接口requestTicket(){returnaxios.post('http://weixin.xxxx.net/ebus/front/wxQueryController.do?BcTicketCalendar',this.postData,{headers:{'Content-Type':'application/x-www-form-urlencoded','User-Agent':\"Mozilla/5.0(iPhone;CPUiPhoneOS8_0likeMacOSX)AppleWebKit/600.1.4(KHTML,likeGecko)Mobile/12A365MicroMessenger/5.4.1NetType/WIFI\",\"Cookie\":this.cookie}})}handleBuyTicket(){}//购票相关逻辑requestOrder(){}//调用购票接口handleInfoUser(){}//通知用户的逻辑sendMSg(){}//发短信接口}复制代码来解释下那行正则，cheerio抓取到的dom是长这样的，第一个span内容是日期，第二个是余票数量\">所以我们要把它格式化变成这种数组，也就是ticketList\">开发购票功能首先我们在init方法里做个判断，如果有余票才去购票，没有余票购个毛classQueryTicket{constructor({data,phoneNumber,cookie,day}){//constructor代码...}//初始化asyncinit(){letticketList=awaitthis.handleQueryTicket()//如果有余票if(ticketList.length){//把余票传入购票逻辑方法，返回短信通知所需要的数据letresParse=awaitthis.handleBuyTicket(ticketList)}}//查询余票的逻辑asynchandleQueryTicket(){//查询余票代码...}//调用查询余票接口requestTicket(){//调用查询余票接口代码...}//购票相关逻辑asynchandleBuyTicket(ticketList){letyear=newDate().getFullYear()//年份，letmonth=newDate().getMonth()+1//月份，拼接购票日期用得上，因为余票接口只返回几号let{onStationName,//起始站点名offStationName,//结束站点名lineId,//线路idvehTime,//发车时间startTime,//预计上车时间onStationId,//上车的站台idoffStationId//到站的站台id}=this.data//初始化的数据letstation=`${onStationName}-${offStationName}`//站点，发短信时候用到:\"宝安交通局-深港产学研基地\"letdateStr=\"\";//车票日期lettickAmount=\"\"//总张数ticketList.forEach(item=>{dateStr=dateStr+`${year}-${month}-${item.day},`tickAmount=tickAmount+`${item.ticketLeft}张,`})letbuyTicket={lineId,//线路idvehTime,//发车时间startTime,//预计上车时间onStationId,//上车的站点idoffStationId,//目标站点idtradePrice:'5',//金额saleDates:dateStr.slice(0,-1),payType:'2'//支付方式，微信支付}//调用购票接口letdata=querystring.stringify(buyTicket)letres=awaitthis.requestOrder(data)//返回json数据，是否购票成功等等//把发短信所需要数据都要传入returnObject.assign({},JSON.parse(res.data),{queryParam:{dateStr,tickAmount,startTime,station}})}//购票相关逻辑//调用购票接口requestOrder(obj){returnaxios.post('http://weixin.xxxx.net/ebus/front/wxQueryController.do?BcTicketBuy',obj,{headers:{'Content-Type':'application/x-www-form-urlencoded','User-Agent':\"Mozilla/5.0(iPhone;CPUiPhoneOS8_0likeMacOSX)AppleWebKit/600.1.4(KHTML,likeGecko)Mobile/12A365MicroMessenger/5.4.1NetType/WIFI\",\"Cookie\":this.cookie}})}handleInfoUser(){}//通知用户的逻辑sendMSg(){}//发短信接口}复制代码到这里，查询余票，购票这两个核心操作已经完成。目前还剩下，如何通知用户是否购票成功。之前我尝试过使用qq邮箱的smtp服务，抢票成功后发送邮件通知，但是我觉得吧，并不好用，主要是我没有打开邮箱的习惯，没网也收不到，所以，并没有采纳这个方案。加上之前我注册过企业认证的公众号，腾讯云免费送了我1000条短信通知，而且短信也比较直观，所以我这里就安装腾讯云的SDK，部署了一套发短信的功能。腾讯云短信的相关内容其实看看文档就行了，我也是copy文档，注意看短信单发那部分cloud.tencent.com/document/pr…如果跟我一样有企业认证的话，看快速入门这里就行了，一步步跟着操作\">看下短信正文，{Number}这些里面的数字是变量。就是说短信的模板是固定的，但是里面有{Number}的内容可以自定义调用的时候，里面的数字对应着传过去的参数数组序号，{1}代表数组[0]参数，以此类推\">提交审核，审核一般很快就通过，也就是几十万毫秒吧\">\">开发通知功能classQueryTicket{constructor({data,phoneNumber,cookie,day}){//constructor代码...}//初始化asyncinit(){letticketList=awaitthis.handleQueryTicket()//如果有余票if(ticketList.length){//把余票传入购票逻辑方法，返回短信通知所需要的数据letresParse=awaitthis.handleBuyTicket(ticketList)//执行通知逻辑this.handleInfoUser(resParse)}}//查询余票的逻辑asynchandleQueryTicket(){//查询余票代码...}//调用查询余票接口requestTicket(){//调用查询余票接口代码...}//购票相关逻辑asynchandleBuyTicket(ticketList){//购票代码...}//调用购票接口requestOrder(obj){//购票接口请求代码...}//通知用户的逻辑asynchandleInfoUser(parseData){//获取上一步购票的response数据和我们拼接的数据let{returnCode,returnData:{main:{lineName,tradePrice}},queryParam:{dateStr,tickAmount,startTime,station}}=parseData//如果购票成功，则返回500if(returnCode===\"500\"){letres=awaitthis.sendMsg({dateStr,//日期tickAmount:tickAmount.slice(0,-1),//总张数station,//站点lineName,//巴士名称/路线名称tradePrice,//总价startTime,//出发时间phoneNumber:this.phoneNumber,//手机号})//如果发信成功，则不再进行抢票操作if(res.result===0&&res.errmsg===\"OK\"){this.setStop(true)}else{//失败不做任何操作console.log(res.errmsg)}}else{//失败不做任何操作console.log(resParse['returnInfo'])}}//发短信接口sendMSg(){let{dateStr,tickAmount,station,lineName,phoneNumber,startTime,tradePrice}=objletappid=140034324;//SDKAppID以1400开头//短信应用SDKAppKeyletappkey=\"asdfdsvajwienin23493nadsnzxc\";//短信模板ID，需要在短信控制台中申请lettemplateId=7839;//NOTE:这里的模板ID`7839`只是示例，真实的模板ID需要在短信控制台中申请//签名letsmsSign=\"测试短信\";//NOTE:签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名\"腾讯云\"只是示例，真实的签名需要在短信控制台申请//实例化QcloudSmsletqcloudsms=QcloudSms(appid,appkey);letssender=qcloudsms.SmsSingleSender();//这里的params就是短信里面可以自定义的内容，也就是填入{1}{2}..的内容letparams=[dateStr,station,lineName,startTime,tickAmount,tradePrice];//用promise来封装下异步操作returnnewPromise((resolve,reject)=>{ssender.sendWithParam(86,phoneNumber,templateId,params,smsSign,\"\",\"\",function(err,res,resData){if(err){reject(err)}else{resolve(resData)}});})}}复制代码如果发信成功，返回result:0\">到这里，大部分需求已经完成了，还剩下一个定时任务定时任务也声明一个类，这里我们用到的是schedule//定时任务classSetInter{constructor({timer,fn}){this.timer=timer//每几秒执行this.fn=fn//执行的回调this.rule=newschedule.RecurrenceRule();//实例化一个对象this.rule.second=this.setRule()//调用原型方法，schedule的语法而已this.init()}setRule(){letrule=[];leti=1;while(i<60){rule.push(i)i+=this.timer}returnrule//假设传入的timer为5，则表示定时任务每5秒执行一次//[1,6,11,16,21,26,31,36,41,46,51,56]}init(){schedule.scheduleJob(this.rule,()=>{this.fn()//定时调用传入的回调方法});}}复制代码多个用户抢票假设我们有两个用户要抢票，所以定义两个obj，实例化下QueryTicket类data:{//用户1lineId:111130,vehTime:0722,startTime:0751,onStationId:564492,offStationId:17990,onStationName:'宝安交通运输局③',offStationName:\"深港产学研基地\",tradePrice:0,saleDates:'',beginDate:'',},phoneNumber:123123123,cookie:'JSESSIONID=TESTCOOKIE',day:\"17\"}letobj2={//用户2data:{lineId:134423,vehTime:1820,startTime:1855,onStationId:4322,offStationId:53231,onStationName:'百度国际大厦',offStationName:\"裕安路口\",tradePrice:0,saleDates:'',beginDate:'',},phoneNumber:175932123124,cookie:'JSESSIONID=TESTCOOKIE',day:\"\"}letticket=newQueryTicket(obj)//用户1letticket2=newQueryTicket(obj2)//用户2newSetInter({timer:1,//每秒执行一次，建议5秒，不然怕被ip拉黑，我这里只是为了方便下面截图fn:function(){[ticket,ticket2].map(item=>{//同时进行两个用户的抢票if(!item.getStop()){//调用实例的原型方法，判断是否停止抢票，如果没有则继续抢item.init()}else{//如果抢到票了，则不继续抢票console.log('stop')}})}})复制代码nodeindex.js运行下，跑起来了\">如果他抢到票的话，我就会收到短信通知：\">打开手机，看下订单信息\">搞定，收工写在最后其实可以在此基础上还能添加更多功能，比如直接抓取登录接口获取cookie，指定路线抢票，还有错误处理啊啥的值得注意的是，请求接口不能太频繁，最好控制在5秒一次的频率，不然会给别人造成困扰，也容易被ip拉黑如果想把它做成一个完整的项目，建议使用ts加持，关于ts我推荐阅读这篇JD前端写的文章juejin.im/post/5d8efe…希望各位能有所收获特别声明本文只做为技术分享，文中代码仅做学习用途",
      "id": "2g8uw3xnbi4g",
      "author": "浪里行舟",
      "title": "Node.js 实现抢票小工具&短信通知提醒"
    },
    {
      "content": "目录JS说说js中的词法作用域什么是闭包说说js的垃圾回收(GC)说说你了解的设计模式Es6ES6模块与CommonJS模块的差异async函数实现原理Node说说浏览器和node中的事件循环（EventLoop）实现一个node中的EventEmiter实现一个node中util模块的promisify方法如何实现一个自定义流性能优化性能优化之dns-prefetch、prefetch、preload、defer、async说说react性能优化网络／浏览器说说浏览器渲染流程说说http2.0算法实现一个reduce方法实现一个promise.all方法，要求保留错误并且并发数为3不用递归函数求一个二叉树的高度js中求两个大数相加实现一个数组随机打乱算法给数字增加“逗号”分隔符说说js中的词法作用域js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如：varvalue=1;functionfoo(){console.log(value);}functionbar(){varvalue=2;foo();}bar();//1复制代码注意：with和eval可以修改词法作用域什么是闭包《深入浅出nodejs》中对闭包的定义：在js中，实现外部作用域访问内部作用域中变量的方法叫做“闭包”。说说js的垃圾回收(GC)v8的垃圾回收策略主要基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。新生代采用Scavenge算法Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色对换(又称反转)。该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。老生代采用Mark-Sweep和Mark-Compact老生代中对象存活时间较长，不适合Scavenge算法。Mark-Sweep是标记清除的意思。Scavenge是只复制存活对象，而Mark-Sweep是只清除死亡对象。该算法分为两个步骤：遍历堆中所有对象并标记活着的对象清除没有标记的对象Mark-Sweep存在一个问题，清除死亡对象后会造成内存空间不连续，如果这时候再分配一个大对象，所有的空间碎片都无法完成此次分配，就会造成提前触发gc。这时候v8会使用Mark-Compact算法。Mark-Copact是标记整理的意思。它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。因为存在整理过程，所以它的速度慢于Mark-Sweep，node中主要采用Mark-Sweep。IncrementalMarking为了避免出现Javascript应用逻辑与垃圾回收器看到的情况不一致，垃圾回收时应用逻辑会停下来。这种行为被成为全停顿(stop-the-world)。这对老生代影响较大。IncrementalMarking称为增量标记，也就是拆分为许多小的“步进”，每次做完一“步进”，就让Javascript执行一会儿，垃圾回收与应用逻辑交替执行。采用IncrementalMarking后，gc的最大停顿时间较少到原来的1/6左右。v8的内存限制64位系统最大约为1.4G32位系统最大约为0.7Gnode中查看内存使用量➜~node>process.memoryUsage()//node进程内存使用{rss:27054080,//进程常驻内存heapTotal:7684096,//已申请到的堆内存heapUsed:4850344,//当前使用的堆内存external:9978//堆外内存(不是通过v8分配的内存)>os.totalmem()//系统总内存17179869184>os.freemem()//系统闲置内存3239858176复制代码说说你了解的设计模式发布订阅模式在js中事件模型就相当于传统的发布订阅模式，具体实现参考实现一个node中的EventEmiter策略模式定义：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。策略模式实现表单校验conststrategies={isNoEmpty:function(value,errorMsg){if(value.trim()===''){returnerrorMsg}},maxLength:function(value,errorMsg,len){if(value.trim()>len){returnerrorMsg}}}classValidator{constructor(){this.catch=[];}add(value,rule,errorMsg,...others){this.catch.push(function(){returnstrategies[rule].apply(this,[value,errorMsg,...others]);});}start(){for(leti=0,validatorFunc;(validatorFunc=this.catch[i++]);){letmsg=validatorFunc();if(msg){returnmsg;}}}}//使用constvalidatorFunc=function(){constvalidator=newValidator();validator.add(username,'isNoEmpty','用户名不能为空');validator.add(password,'isNoEmpty','密码不能为空');constUSERNAME_LEN=PASSWORD_LEN=10;validator.add(username,'maxLength',`用户名不能超过${USERNAME_LEN}个字`,USERNAME_LEN);validator.add(password,'isNoEmpty',`密码不能为空${PASSWORD_LEN}个字`,PASSWORD_LEN);letmsg=validator.start();if(msg){returnmsg;}}复制代码命令模式应用场景：有时候我们要向某些对象发送请求，但不知道请求的接收者是谁，也不知道请求的操作是什么，此时希望以一种松耦合的方式来设计软件，使得请求的发送者和接收者能够消除彼此的耦合关系。命令模式实现动画classMoveCommand{constructor(reciever,pos){this.reciever=reciever;this.pos=pos;this.oldPos=null;}excute(){this.reciever.start(\"left\",this.pos,1000);this.reciever.getPos();}undo(){this.reciever.start(\"left\",this.oldPos,1000);}}复制代码ES6模块与CommonJS模块的差异CommonJS输出的是值的拷贝，ES6模块输出的是值的引用。也就是说CommonJS引用后改变模块内变量的值，其他引用模块不会改变，而ES6模块会改变。CommonJS是运行时加载，ES6模块是编译时输出接口。之所以Webpack的TreeShaking是基于ES6的，就是因为ES6在编译的时候就能确定依赖。因为使用babel-preset-2015这个预设默认是会把ES6模块编译为CommonJS的，所以想使用TreeShaking还需要手动修改这个预设。module:{rules:[{test:/\\.js$/,exclude:/(node_modules|bower_components)/,use:{loader:'babel-loader',options:{presets:[['babel-preset-es2015',{modules:false}]],}}}]}复制代码async函数实现原理async函数是基于generator实现，所以涉及到generator相关知识。在没有async函数之前，通常使用co库来执行generator，所以通过co我们也能模拟async的实现。functionAsyncfn(){returnco(function*(){//.....});}functionco(gen){returnnewPromise((resolve,reject)=>{constfn=gen();functionnext(data){let{value,done}=fn.next(data);if(done)returnresolve(value);Promise.resolve(value).then(res=>{next(res);},reject);}next();});}复制代码说说浏览器和node中的事件循环（EventLoop）浏览器\">如图：浏览器中相对简单，共有两个事件队列，当主线程空闲时会清空Microtaskqueue(微任务队列)依次执行TaskQueue(宏任务队列)中的回调函数，每执行完一个之后再清空Microtaskqueue。“当前执行栈”->“micro-task”->“taskqueue中取一个回调”->“micro-task”->...(不断消费taskqueue)->“micro-task”nodejsnode中机制和浏览器有一些差异。node中的taskqueue是分为几个阶段，清空micro-task是在一个阶段结束之后(浏览器中是每一个任务结束之后)，各个阶段如下：┌───────────────────────┐┌─>│timers│<—————执行setTimeout()、setInterval()的回调│└──────────┬────────────┘||<--执行所有NextTickQueue以及MicroTaskQueue的回调│┌──────────┴────────────┐││pendingcallbacks│<—————执行由上一个Tick延迟下来的I/O回调（待完善，可忽略）│└──────────┬────────────┘||<--执行所有NextTickQueue以及MicroTaskQueue的回调│┌──────────┴────────────┐││idle,prepare│<—————内部调用（可忽略）│└──────────┬────────────┘||<--执行所有NextTickQueue以及MicroTaskQueue的回调||┌───────────────┐│┌──────────┴────────────┐│incoming:│-(执行几乎所有的回调，除了closecallbacks以及timers调度的回调和setImmediate()调度的回调，在恰当的时机将会阻塞在此阶段)││poll│<─────┤connections,││└──────────┬────────────┘│data,etc.││|||||└───────────────┘||<--执行所有NextTickQueue以及MicroTaskQueue的回调|┌──────────┴────────────┐││check│<—————setImmediate()的回调将会在这个阶段执行│└──────────┬────────────┘||<--执行所有NextTickQueue以及MicroTaskQueue的回调│┌──────────┴────────────┐└──┤closecallbacks│<—————socket.on('close',...)└───────────────────────┘这里我们主要关注其中的3个阶段：timer、poll和check，其中poll队列相对复杂：轮询阶段有两个重要的功能：1、计算应该阻塞和轮询I/O的时间。2、然后，处理轮询队列里的事件。当事件循环进入轮询阶段且没有计划计时器时，将发生以下两种情况之一：1、如果轮询队列不是空的，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。2、如果轮询队列是空的，还有两件事发生：a、如果脚本已按setImmediate()排定，则事件循环将结束轮询阶段，并继续check阶段以执行这些计划脚本。b、如果脚本尚未按setImmediate()排定，则事件循环将等待回调添加到队列中，然后立即执行。一旦轮询队列为空，事件循环将检查已达到时间阈值的计时器。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。细节请参考TheNode.jsEventLoop,Timers,andprocess.nextTick()中文：Node.js事件循环，定时器和process.nextTick()通过程序理解浏览器和node中的差异setTimeout(()=>{console.log(\"timer1\");Promise.resolve().then(function(){console.log(\"promise1\");});},0);setTimeout(()=>{console.log(\"timer2\");Promise.resolve().then(function(){console.log(\"promise2\");});},0);复制代码在浏览器中的顺序是：timer1->promise1->timer2->pormise2node中顺序是：timer1->timer2->promise1->promise2这道题目很好的说明了node中的micro-task是在一个阶段的任务执行完之后才清空的。实现一个node中的EventEmiter简单实现：classEventsEmiter{constructor(){this.events={};}on(type,fn){constevents=this.events;if(!events[type]){events[type]=[fn];}else{events[type].push(fn);}}emit(type,...res){constevents=this.events;if(events[type]){events[type].forEach(fn=>fn.apply(this,res));}}remove(type,fn){constevents=this.events;if(events[type]){events[type]=events[type].filer(lisener=>lisener!==fn);}}}复制代码实现一个node中util模块的promisify方法letfs=require(\"fs\");letread=fs.readFile;functionpromisify(fn){returnfunction(...args){returnnewPromise((resolve,reject)=>{fn(...args,(err,data)=>{if(err){reject(err);}resolve(data);});});};}//回调用法//read(\"./test.json\",(err,data)=>{//if(err){//console.error(\"err\",err);//}//console.log(\"data\",data.toString());//});//promise用法letreadPromise=promisify(read);readPromise(\"./test.json\").then(res=>{console.log(\"data\",res.toString());});复制代码如何实现一个自定义流根据所创建的流类型，新的流类必须实现一个或多个特定的方法，如下图所示:用例类需实现的方法只读流Readable_read只写流Writable_write,_writev,_final可读可写流Duplex_read,_write,_writev,_final对写入的数据进行操作，然后读取结果Transform_transform,_flush,_final以双工流为例：const{Duplex}=require('stream');classMyduplexextendsDuplex{constructor(arr,opt){super(opt);this.arr=arrthis.index=0}//实现可读流部分_read(size){this.index++if(this.index===3){this.push(null)}else{this.push(this.index.toString())}}//实现可写流_write(chunk,encoding,callback){this.arr.push(chunk.toString())callback()}}复制代码更多内容可以参考我的另一篇文章：说说node中可读流和可写流和nodejs官网性能优化之dns-prefetch、prefetch、preload、defer、asyncdns-prefetch域名转化为ip是一个比较耗时的过程，dns-prefetch能让浏览器空闲的时候帮你做这件事。尤其大型网站会使用多域名，这时候更加需要dns预取。//来自百度首页\"dns-prefetch\"href=\"//m.baidu.com\">复制代码prefetchprefetch一般用来预加载可能使用的资源，一般是对用户行为的一种判断，浏览器会在空闲的时候加载prefetch的资源。\"prefetch\"href=\"http://www.example.com/\">复制代码preload和prefetch不同，prefecth通常是加载接下来可能用到的页面资源，而preload是加载当前页面要用的脚本、样式、字体、图片等资源。所以preload不是空闲时加载，它的优先级更强，并且会占用http请求数量。'preload'href='style.css'as=\"style\"onload=\"console.log('styleloaded')\"复制代码as值包括\"script\"\"style\"\"image\"\"media\"\"document\"onload方法是资源加载完成的回调函数defer和async//defer\"script.js\">//async\"script.js\">复制代码defer和async都是异步(并行)加载资源，不同点是async是加载完立即执行，而defer是加载完不执行，等到所有元素解析完再执行，也就是DOMContentLoaded事件触发之前。因为async加载的资源是加载完执行，所以它比不能保证顺序，而defer会按顺序执行脚本。说说react性能优化shouldComponentUpdate举例：下面是antd-design-mobile的Modal组件中对的内部蒙层组件的处理import*asReactfrom\"react\";exportinterfacelazyRenderProps{style:{};visible?:boolean;className?:string;}exportdefaultclassLazyRenderextendsReact.Component{shouldComponentUpdate(nextProps:lazyRenderProps){return!!nextProps.visible;}render(){constprops:any={...this.props};deleteprops.visible;return;}}复制代码immutable像上面这种只比较了一个visible属性，并且它是string类型，如果是一个object类型那么就不能直接比较了，这时候使用immutable库更好一些。immutable优势：性能更好更加安全immutable劣势：库比较大(压缩后大约16k)api和js不兼容解决方案：seamless-immutableseamless-immutable这个库没有完整实现PersistentDataStructure，而是使用了Object.defineProperty扩展了JS的Object和Array对象，所以保持了相同的Api，同时库的代码量更少，压缩后大约2k基于key的优化文档中已经强调，key需要保证在当前的作用域中唯一，不要使用当前循环的index(尤其在长列表中)。参考reactjs.org/docs/reconc…说说浏览器渲染流程浏览器的主进程：Browser进程负责下载资源创建销毁renderer进程负责将renderer进程生成的位图渲染到页面上与用户交互浏览器内核：renderer进程js引擎线程由一个主线程和多个webworder线程组成，webworker线程不能操作domGUI线程用于解析html生成DOM树，解析css生成CSSOM,布局layout、绘制paint。回流和重绘依赖该线程事件线程当事件触发时，该线程将事件的回调函数放入callbackqueue（任务队列）中，等待js引擎线程处理定时触发线程setTimeout和setInterval由该线程来记时，记时结束，将回调函数放入任务队列http请求线程每有一个http请求就开一个该线程，每当检测到状态变更就会产生一个状态变更事件，如果这个事件由对应的回掉函数，将这个函数放入任务队列任务队列轮询线程用于轮询监听任务队列流程获取html文件从上到下解析html并行请求资源(css资源不会阻塞html解析，但是会阻塞页面渲染。js资源会组织html解析）生成DOMtree和stylerules构建rendertree执行布局过程(layout、也叫回流)，确定元素在屏幕上的具体坐标绘制到屏幕上(paint)事件DOMContentLoaded当初始的HTML文档被完全加载和解析完成(script脚本执行完，所属的script脚本之前的样式表加载解析完成)之后，DOMContentLoaded事件被触发onload所有资源加载完成触发window的onload事件参考流程图：www.processon.com/view/5a6861…说说http2.0http2.0是对SPDY协议的一个升级版。和http1.0相比主要有以下特性：二进制分帧首部压缩多路复用请求优先级服务端推送(serverpush)详细可参考：HTTP----HTTP2.0新特性实现一个reduce方法注意边界条件：1、数组长度为0，并且reduce没有传入初始参数时，抛出错误。2、reduce有返回值。Array.prototype.myReduce=function(fn,initial){if(this.length===0&&!initial){thrownewError(\"noinitialandarrayisempty\");}letstart=1;letpre=this[0];if(initial){start=0;pre=initial;}for(leti=start;i<this.length;i++){letcurrent=this[i];pre=fn.call(this,pre,current,i);}returnpre;};复制代码实现一个promise.all方法，要求保留错误并且并发数为3标准的all方法是遇到错误会立即将promise置为失败态，并触发error回调。保留错误的定义为：promise遇到错误保存在返回的结果中。functionpromiseall(promises){returnnewPromise(resolve=>{letresult=[];letflag=0;lettaskQueue=promises.slice(0,3);//任务队列，初始为最大并发数3letothers=promises.slice(3);//排队的任务taskQueue.forEach((promise,i)=>{singleTaskRun(promise,i);});leti=3;//新的任务从索引3开始functionnext(){if(others.length===0){return;}constnewTask=others.shift();singleTaskRun(newTask,i++);}functionsingleTaskRun(promise,i){promise.then(res=>{check();result[i]=res;next();}).catch(err=>{check();result[i]=err;next();});}functioncheck(){flag++;if(flag===promises.length){resolve(result);}}});}复制代码测试代码：letp1=newPromise((resolve,reject)=>{setTimeout(()=>{resolve(\"1\");},1000);});letp2=newPromise((resolve,reject)=>{setTimeout(()=>{resolve(\"2\");},1500);});letp3=newPromise((resolve,reject)=>{setTimeout(()=>{resolve(\"3\");},2000);});letp4=newPromise((resolve,reject)=>{setTimeout(()=>{resolve(\"4\");},2500);});letp_e=newPromise((resolve,reject)=>{//thrownewError(\"出错\");reject(\"错误\");});letp5=newPromise((resolve,reject)=>{setTimeout(()=>{resolve(\"5\");},5000);});letall=promiseall([p_e,p1,p3,p2,p4,p5]);all.then(data=>{console.log(\"data\",data);//['错误','1','3','2','4','5']});复制代码不用递归函数求一个二叉树的高度先看一下递归的实现(二叉树的深度优先遍历)：functiongetBinaryTreeHeigth(node){letmaxDeep=0;functionnext(n,deep){deep++;if(n.l){letnewDeep=next(n.l,deep);if(newDeep>maxDeep){maxDeep=newDeep;}}if(n.r){letnewDeep=next(n.r,deep);if(newDeep>maxDeep){maxDeep=newDeep;}}returndeep;}next(node,0);returnmaxDeep;}functionNode(v,l,r){this.v=v;this.l=l;this.r=r;}复制代码非递归的实现(二叉树的广度优先遍历)：functiongetBinaryTreeHeigth(node){if(!node){return0;}constqueue=[node];letdeep=0;while(queue.length){deep++;for(leti=0;i<queue.length;i++){constcur=queue.pop();if(cur.l){queue.unshift(cur.l);}if(cur.r){queue.unshift(cur.r);}}}returndeep;}functionNode(v,l,r){this.v=v;this.l=l;this.r=r;}复制代码js中求两个大数相加给定两个以字符串形式表示的非负整数num1和num2,返回它们的和，仍用字符串表示。输入：num1='1234',num2='987'输出：'2221'functionbigIntAdd(str1,str2){letresult=[];letary1=str1.split(\"\");letary2=str2.split(\"\");letflag=false;//是否进位while(ary1.length||ary2.length){letresult_c=sigle_pos_add(ary1.pop(),ary2.pop());if(flag){result_c=result_c+1;}result.unshift(result_c%10);if(result_c>=10){flag=true;}else{flag=false;}}returnresult.join(\"\");}functionsigle_pos_add(str1_c,str2_c){letl=(r=0);if(str1_c){l=Number(str1_c);}if(str2_c){r=Number(str2_c);}returnl+r;}复制代码测试代码：conststr1=\"1234\";conststr2=\"987654321\";conststr3=\"4566786445677555\";conststr4=\"987\";console.log(bigIntAdd(str1,str4))//'2221'console.log(bigIntAdd(str2,str3))//'4566787433331876'复制代码实现一个数组随机打乱算法functiondisOrder(ary){for(leti=0;i<ary.length;i++){letrandomIndex=Math.floor(Math.random()*ary.length);swap(ary,i,randomIndex);}}functionswap(ary,a,b){lettemp=ary[a];ary[a]=ary[b];ary[b]=temp;}letary=[1,2,3,4,5,6,7,8,9,10,11,12];disOrder(ary);console.log(ary);复制代码给数字增加“逗号”分隔输入：'\"123456789.012\"'输出：123,456,789.012正则解法：functionparseNumber(num){if(!num)return\"\";returnnum.replace(/(\\d)(?=(\\d{3})+\\.)/g,\"$1,\");}复制代码非正则：functionformatNumber(num){if(!num)return\"\";let[int,float]=num.split(\".\");letintArr=int.split(\"\");letresult=[];leti=0;while(intArr.length){if(i!==0&&i%3===0){result.unshift(intArr.pop()+\",\");}else{result.unshift(intArr.pop());}i++;}returnresult.join(\"\")+\".\"+(float?float:\"\");}复制代码",
      "id": "ntcanx4h85c",
      "author": "dragonet",
      "title": "金九银十面试笔记"
    },
    {
      "content": "前言HTTP/2相比于HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。虽然HTTP/2提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3就是为了解决HTTP/2所存在的一些问题而被推出来的。想阅读更多优质文章请猛戳GitHub博客一、HTTP/1.1发明以来发生了哪些变化？如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了2100K。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了100个。正如下图所示，从2011年以来,传输数据大小与平均请求资源数量不断持续增长，并没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。HTTP/1.1自从1997年发布以来，我们已经使用HTTP/1.x相当长一段时间了，但是随着近十年互联网的爆炸式发展，从当初网页内容以文本为主,到现在以富媒体（如图片、声音、视频）为主,而且对页面内容实时性高要求的应用越来越多(比如聊天、视频直播),于是当时协议规定的某些特性，已经无法满足现代网络的需求了。二、HTTP/1.1的缺陷1.高延迟--带来页面加载速度的降低虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。网络延迟问题主要由于队头阻塞(Head-Of-LineBlocking),导致带宽无法被充分利用。\">队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:将同一页面的资源分散到不同域名下，提升连接上限。Chrome有个机制，对于同一个域名，默认允许同时建立6个TCP持久连接，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。.icon1{background:url(data:image/png;base64,)no-repeat;}.icon2{background:url(data:image/png;base64,)no-repeat;}复制代码拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。2.无状态特性--带来的巨大HTTP头部由于报文Header一般会携带\"UserAgent\"\"Cookie\"\"Accept\"\"Server\"等许多固定的头字段（如下图），多达几百字节甚至上千字节，但Body却经常只有几十字节（比如GET请求、204/301/304响应），成了不折不扣的“大头儿子”。Header里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。\">3.明文传输--带来的不安全性HTTP/1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。你有没有听说过\"免费WiFi陷阱”之类的新闻呢？黑客就是利用了HTTP明文传输的缺点，在公共场所架设一个WiFi热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个WiFi热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。4.不支持服务器推送消息三、SPDY协议与HTTP/2简介1.SPDY协议上面我们提到,由于HTTP/1.x的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到2009年，谷歌公开了自行研发的SPDY协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。\">HTTP/1.1有两个主要的缺点：安全不足和性能不高，由于背负着HTTP/1.x庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。如上图所示,SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。SPDY协议在Chrome浏览器上证明可行以后，就被当作HTTP/2的基础，主要特性都在HTTP/2之中得到继承。2.HTTP/2简介2015年，HTTP/2发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。HTTP/2由两个规范（Specification）组成：HypertextTransferProtocolversion2-RFC7540HPACK-HeaderCompressionforHTTP/2-RFC7541四、HTTP/2新特性1.二进制传输HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header压缩。我们先来介绍二进制传输,HTTP/2采用二进制格式传输数据，而非HTTP/1.x里纯文本形式的报文，二进制协议解析起来更高效。HTTP/2将请求和响应数据分割为更小的帧，并且它们采用二进制编码。它把TCP协议的部分特性挪到了应用层，把原来的\"Header+Body\"的消息\"打散\"为数个小片的二进制\"帧\"(Frame),用\"HEADERS\"帧存放头数据、\"DATA\"帧存放实体数据。HTP/2数据分帧后\"Header+Body\"的报文结构就完全消失了，协议看到的只是一个个的\"碎片\"。\">HTTP/2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。2.Header压缩HTTP/2并没有使用传统的压缩算法，而是开发了专门的\"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说:在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值例如下图中的两个请求，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销\">3.多路复用在HTTP/2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个TCP连接都需要慢慢提升传输速度。大家可以通过该链接直观感受下HTTP/2比HTTP/1到底快了多少。\">在HTTP/2中，有了二进制分帧之后，HTTP/2不再依赖TCP链接去实现多流并行了，在HTTP/2中,同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。这一特性，使性能有了极大提升：同个域名只需要占用一个TCP连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。并行交错地发送多个请求/响应，请求/响应之间互不影响。在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级，数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。\">如上图所示，多路复用的技术可以只通过一个TCP连接就可以传输所有的请求数据。4.ServerPushHTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为\"服务器推送\"（ServerPush，也叫Cachepush）例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\">另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。5.提高安全性出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以“事实上”的HTTP/2是加密的。也就是说，互联网上通常所能见到的HTTP/2都是使用\"https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2\"表示加密的HTTP/2，“h2c”表示明文的HTTP/2。\">六、HTTP/3新特性1.HTTP/2的缺点虽然HTTP/2解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的TCP协议造成的。HTTP/2的缺点主要有以下几点：TCP以及TCP+TLS建立连接的延时HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，这样就需要有两个握手延迟过程：①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。总之，在传输数据之前，我们需要花掉3～4个RTT。TCP的队头阻塞并没有彻底解决上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2的表现反倒不如HTTP/1了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个TCP都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于HTTP/1.1来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的TCP连接还可以正常传输数据。\">读到这里，可能就会有人考虑为什么不直接去修改TCP协议？其实这已经是一件不可能完成的任务了。因为TCP存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。2.HTTP/3简介Google在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于UDP协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTPoverQUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。\">QUIC虽然基于UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。3.QUIC新功能上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流\"是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：实现了类似TCP的流量控制、传输可靠性的功能。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。实现了快速握手功能。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT建连可以说是QUIC相比HTTP2最大的性能优势。集成了TLS加密功能。目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。多路复用，彻底解决TCP中队头阻塞的问题和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。\">七、总结HTTP/1.1有两个主要的缺点：安全不足和性能不高。HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS\"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；QUIC基于UDP实现，是HTTP/3中的底层支撑协议，该协议基于UDP，又取了TCP中的精华，实现了即快又可靠的协议欢迎关注公众号：前端工匠，你的成长我们一起见证！给大家推荐一个好用的BUG监控工具Fundebug，欢迎免费试用！\">参考文章珠峰架构课(强烈推荐)透视HTTP协议Web协议详解与抓包实战浏览器工作原理与实践HTTP2讲解一文读懂HTTP/2特性科普：QUIC协议原理分析HTTP2简介和基于HTTP2的Web优化",
      "id": "6lkp3re3nm80",
      "author": "黄轶",
      "title": "解密HTTP/2与HTTP/3 的新特性"
    },
    {
      "content": "前言自己也只是一个前端的小白，因为公司大佬都比较忙，面试这种事就落到了我这小白身上，第一次叫我去的时候我是百般拒绝的，因为自己还是有自知之明的，但是别人实在抽不开身，没办法只能去了，他们开玩笑说就按你这水平来就行了，啥时候你问不住了就让他来复试就行。前前后后也面了一些人，加上自己面试时候整理的一些问题，写了这篇文章，感谢拨冗翻阅拙作,敬请斧正。下面进入正文，本文会列举一些平时面试时问到的问题和答案，并说明我在当时问到这个问题时所期望对方的回答：vue生命周期（钩子函数）问题请说一下vue的生命周期函数（钩子函数）。问题描述首先关于生命周期函数，一般我的第一个问题就是这个，我认为是每个使用vue的都要清楚的，如果这个问题答的问题很大其实我都不太想继续往下进行了。即使英语不标准（我就是不标准的人，并不是说这是个问题）也要去把关键点说清楚，哪个地方有ed哪个地方没有ed其实是很关键的，或者可以手写下来，因为常用的就是created和mounted所以前4个可以清楚的手写出来并不难，后面4个不去详细说明都没事。（我自己工作中基本没用过后面4个）在哪个周期能够首次拿到data数据和在哪个周期能够首次拿到mounted中的dom元素，如果没有说到这个问题，我一般会一直往下问，直到他说出来这两个答案。期望答案beforeCreate、created（此时需说明可以在created中首次拿到data中定义的数据）、beforeMount、mounted（此时需说明dom树渲染结束，可访问dom结构）、beforeUpdate、updated、beforeDestroy、destroyedcomputed中的getter和setter问题说一下computed中的getter和setter。问题描述很多情况，我问到这个问题的时候对方的回答都是vue的getter和setter、订阅者模式之类的回答，我就会直接说问的并不是这个，而是computed，直接让对方说computed平时怎么使用，很多时候得到的回答是computed的默认方式，只使用了其中的getter，就会继续追问如果想要再把这个值设置回去要怎么做，当然一般会让问到这个程度的这个问题他都答不上来了。期望答案<!--直接复制的官网示例-->computed:{fullName:{//getterget:function(){returnthis.firstName+''+this.lastName},//setterset:function(newValue){varnames=newValue.split('')this.firstName=names[0]this.lastName=names[names.length-1]}}}复制代码watch监听对象问题如何watch监听一个对象内部的变化。问题描述这个问题我感觉是一个不应该不会的问题，可是我遇到的人大部分都没有给出我所期望的答案，有些人会说直接监听obj，好一点的会说直接点出来监听obj.key，但是很少有人回答deep，开始我还会去问immediate，但是太多人不知道了，所以后来我就只问监听对象了，只有回答出deep的才会去问immediate的作用。期望答案如果只是监听obj内的某一个属性变化，可以直接obj.key进行监听。watch:{'obj.question':function(newQuestion,oldQuestion){this.answer='Waitingforyoutostoptyping...'this.debouncedGetAnswer()}}复制代码如果对整个obj深层监听watch:{obj:{handler:function(newQuestion,oldQuestion){this.answer='Waitingforyoutostoptyping...'this.debouncedGetAnswer()},deep:true,immediate:true}}复制代码immediate的作用：当值第一次进行绑定的时候并不会触发watch监听，使用immediate则可以在最初绑定的时候执行。v-for循环key的作用问题v-for循环时为什么要加key。问题描述问这个问题时，好多人再先回答的都是页面有警告，编辑器有提示，我会直接说不考虑报错和提示的问题，或者会问如果不加key的话，页面会不会出现什么异常情况。有的人会说是一个标识，标识他的唯一性，我会继续追问为什么要标识唯一性呢，不加又怎么样？期望答案vue的dom渲染是虚拟dom，数据发生变化时，diff算法会只比较更改的部分，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。举例说明：有一个列表我们现在在中间插入了一个元素，diff算法会默认复用之前的列表并在最后追加一个，如果列表存在选中一类的状态则会随着复用出现绑定错误的情况而不是跟着原元素，key的作用就可以给他一个标识，让状态跟着数据渲染。（这一块是我自己的一个大概理解，表述不太清楚，具体的可以去查一下文档，本文就不具体描述此问题了。）$nextTick问题$nextTick用过吗，有什么作用。问题描述问到这个问题时，很多人都会说到可以处理异步，而往下追问为什么要用nextTick，他解决了什么问题，不用他会怎么样的时候就很多人说不上来了。期望答案在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。(官网解释)解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。//修改数据vm.msg='Hello'//DOM还没有更新Vue.nextTick(function(){//DOM更新了})//作为一个Promise使用(2.1.0起新增，详见接下来的提示)Vue.nextTick().then(function(){//DOM更新了})复制代码$set问题vue中的$set用过吗，为什么要用它，解决了什么问题问题描述这个问题知道的人就基本都能说出来，但是不知道的就是一点不了解，有的还会说到es6的set结构期望答案向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为Vue无法探测普通的新增属性(比如this.myObject.newProperty='hi')（官方示例）我自己的理解就是，在vue中对一个对象内部进行一些修改时，vue没有监听到变化无法触发视图的更新，此时来使用$set来触发更新，使视图更新为最新的数据。组件间的传值问题说一下组件间的传值方式，你知道的所有方式都说一下问题描述这个问题其实就是想看官方文档有没有具体看过，因为很多传值方式官方文档上有描述，但是项目中用的相对较少。基本都能回答上来，父传子：props；子传父：$emit；兄弟：eventbus；vuex；有一些会说到sessionStorage和localStorage、路由传参（这个答案其实并不是我想要问的，不过也可以实现一定的传值）以下传值方式的具体使用方式本文不具体描述了，这个链接是对这几种组件传值的具体介绍。你不知道的vue组件传值方式期望答案provide/inject这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。Vue.observable让一个对象可响应。Vue内部会用它来处理data函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：conststate=Vue.observable({count:0})constDemo={render(h){returnh('button',{on:{click:()=>{state.count++}}},`countis:${state.count}`)}}复制代码$attrs包含了父作用域中不作为prop被识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v-bind=\"$attrs\"传入内部组件——在创建高级别的组件时非常有用。$listeners包含了父作用域中的(不含.native修饰器的)v-on事件监听器。它可以通过v-on=\"$listeners\"传入内部组件——在创建更高层次的组件时非常有用。props$emiteventbusvuex$parent/$children/ref",
      "id": "4675zheoffc0",
      "author": "RetroAstro",
      "title": "面试时面试官想要听到什么答案（关于一些vue的问题）"
    },
    {
      "content": "前言2018年6月我在慕课网发布了Vue.js2.x的源码解析课程《Vue.js源码全方位深入解析》，同时也开源了课程配套电子书。时隔一年多，Vue官方也开源了Vue.js3.x，那么在不久的将来，我也会系统化地做Vue.js3.x的源码分析，同时更新我的这门课程视频以及电子书。Vue.js3.x源码刚开源不久，很多人都非常兴奋，我也不例外。我写下这篇文章作为Vue.js3.x源码解析课程的先导片，和大家聊聊我对Vue.js源码的一些感悟。聊聊Vue.js3.xVue.js3.x目前的状态Vue.js3.x目前处于Pre-Alpha的状态，从Vue官方的Roadmap来看，2019年Q3结束前开源Vue3.x的源码，Q4除了继续完善Vue.js核心源码之外，还要补齐周边的生态建设：如vue-router、vuex、vue-cli、VueDevtools、JSX等，在Q4结束前才会发布Alpha版本。但是Alpha版本也只是内部测试版本，之后还要经历Beta对外测试版本，RC候选发布版本、最后才会到正式的Realase版本，所以距离大家在生产环境投入使用还有很长的时间。那么这段时间，对于Vue.js3.x我可以做哪些事情呢。Vue.jsRFCVue.js官方设立RFC的初衷是为了让Vue.js本身的开发流程更加规范化，当有一个新功能的想法出现，会先发布一份RFC的提案，由社区在一起讨论，当提案通过后再去开发实现。Vue.js3.x在开发之前也发布了多份RFC提案，其中讨论比较多的是Vue.js3.x关于组件的写法，由最初的Class-API提案被废弃到之后热烈讨论的Function-basedcomponentAPI，再到最后确认的基于Function-basedcomponentAPI修订的CompositionAPI，经历了很长一段的时间，期间社区出现了不少反对的声音，比如“和React更像了，为啥我不直接用React”、“ClassAPI更好”、“Vue.js变得一点都不简单了”等等，官方都做了很好的回应，因此学习Vue.js3.x，你应该先去学习这份RFC。通过这份RFC的学习，你会大致了解Vue.js3.x组件的写法、详细设计、甚至是一些”缺点“。Vue.js3.x摒弃了2.xOptionsAPI，拥抱了CompositionAPI，为了更好的逻辑复用、代码组织以及更好的类型推导。Vue.js3.x尝鲜Vue.js3.x源码已经开放，虽然没有发布，但是我们可以clone下来，安装好相关依赖，构建一份打包后的代码为自己所用。在阅读完CompositionAPI的RFC后，我们已经对Vue.js3.x组件的写法有了一定了解，并且2.x的大部分feature3.x都已经支持，我们用3.x写一个简单的demo问题应该不大。我前段时间就基于Vue3.x写了一个todomvc的demo，感兴趣的同学可以去GitHubclone下来跑跑看看。在写demo的时候我还遇到了v-model实现的坑，对源码一番调试后大致定位了原因，不过由于牵涉到核心的改动会比较多，所以我和尤大反馈了一下（微信提issue），官方很快就修复了这个问题。Vue.js3.x源码Vue.js3.x源码放出来的第二天，社区就有出来源码分析的文章，不过看了好几篇都是在分析Reactive相关的API，给人的错觉好像Vue只有响应式一样，甚至还有某些培训机构也跟着蹭起了热度。有些文章写的还是很不错的，比如我记得掘金有一篇是教大家从单测看起，确实是一个很好的学习源码的思路，但还有几篇也未免有蹭热度之嫌。对我而言，除了Reactive，我更愿意去关注Setup函数的初始化逻辑、Compile过程的优化、Render写法的变化、以及Patch过程的优化。Vue.js3.x源码采用了monorepo的管理方式，采用TypeScript编写，对于Vue.js的开发者而言，这种方式是更易于维护源码的。如果你想学习Vue.js3.x的源码，首先你得学会TypeScript。对于大部分人而言，现在去看Vue.js3.x的源码还为时过早了，主要是你现在还用不到，我之前在掘金发布过一篇文章来聊聊源码学习，现在还不是学习Vue.js3.x源码的好时机。但是如果你是一个对技术非常有热情的人，在早期去学习Vue.js3.x源码，甚至去参与Vue.js3.x的开发共建，对自己的技术提升还是有很大帮助的。Vue.js2.x源码过时了吗Vue.js3.x源码开放了，很多小伙伴不免担心，我现在学习Vue.js2.x的源码过时了吗？成熟稳定的Vue.js2.xVue.js2.x从16年底发布距今已接近3年，有无数大厂已经使用Vue.js重构和开发项目，Vue.js2.x的npm下载量每月有90多万，JsdelivrCDN每月有5亿次引用，ChromeDevTools每周有90万的活跃用户。如此庞大的用户量足以说明Vue.js是一个非常靠谱和成熟的框架，另外官网对Issue、PullRequest的响应也是比较快的，除了高达97%的单元测试之外，官方还尝试做了一些回归测试。我们知道Vue.js是一个渐进式框架，除了官方提供的一些生态插件vue-router、vuex、vue-cli之外，社区还有非常多的优秀的轮子如element-ui、cube-ui、vue-lazyload、vue-i18n等，这些插件能很好地辅助我们平时的业务开发。升级的成本Vue.js2.x->Vue.js3.x升级还是有一定的成本的，虽然说官方会出一个保留OptionsAPI的写法的版本，但是未免还会有一些breakingchange的，比如手写render函数部分语法就已经发生了改变，模板写法也会发生一些变化。未来应该会出一个代码升级的指南，甚至会用工具帮我们做一部分工作，但是大规模的产线项目做核心框架升级，还是有相当大的成本和风险的。如果你的业务代码升级到Vue.js3.x，也就意味着你依赖的生态插件也需要升级到Vue.js3.x，比如element-ui这种大型项目，升级起来也是有相当大的工作量的，所以你需要先等到你依赖的生态插件升级到Vue.js3.x并且稳定后，你才能考虑在你的业务中做框架升级。Vue.js1.x->Vue.js2.x的升级似乎没有那么麻烦，那是因为Vue.js1.x的时候用户规模还很小，生态也没有起来，甚至很多公司直接上手的Vue.js2.x，并没有历史包袱。痛点Vue.js1.x->Vue.js2.x的升级变化还是很明显的，虚拟DOM在Vue.js2.x中得以实现，它让服务端渲染、跨端渲染成为可能。我们来看一下Vue.js3.x的设计目标：更小、更快、加强TypeScript支持、加强API设计一致性、提升自身可维护性、开放更多的底层功能。对大部分用户而言，更小更快是一个吸引点，对于TypeScript用户而言，加强TypeScript支持是一个吸引点，但是这些能解决开发中的痛点么？除非Vue.js3.x能解决Vue.js2.x开发中的痛点（比如我这个项目有性能瓶颈，性能的提升能帮助我解决这个性能瓶颈），否则重构的成本和它来带来的收益就是一个需要权衡的问题。另外考虑到Vue.js3.x用了一些ES6的新特性如Proxy，在浏览器兼容性这块也是需要考虑的。老板通常是不会允许你做这种纯技术重构的，如果你想用Vue.js3.x做重构，一定要抓到痛点，把重构的收益和老板说清楚。虽然老项目用Vue.js3.x重构会有很大的成本和风险，我们也可以在一些非核心的新项目中去尝试新技术，当然这一切也是需要等待Vue.js3.x正式发布以及依赖的Vue插件都更新支持Vue.js3.x才可以。结论Vue.js3.x想全面替代Vue.js2.x需要有相当长的路要走，未来相当长一段时间Vue.js2.x仍然是主流，Vue.js2.x的源码学习并没有过时，如果你是一个Vue.js2.x的使用者，就应该去学习Vue.js2.x的源码。我应该学习源码吗很多人都有困惑，我会使用不就行了吗，为什么还要学习源码呢？学习源码的好处学习是为了更好的工作，工作中难免会遇到一些问题，学习源码最直接的好处是能帮你直接定位问题的根本原因，从而帮助你解决问题。很多人抱怨加班多，不妨问问自己，有多少时间是在写业务，多少时间是在写（找）bug。快速定位问题解决bug，可以有效地提升你的工作效率，很可能就不用加班了，甚至会多出学习的时间，形成一个良性循环。学习源码可以很好地巩固基础，修炼内功，提升技术。前端几乎都会学习JS的基础知识，如类型、变量、函数、作用域、闭包、原型链、eventloop等知识，但很多人很难把这些知识在实践中运用自如，主要原因还是实践的少了，大部分时间都在写业务的胶水代码。学习Vue.js这类框架的源码，会不断去巩固这些知识点，如果你源码看熟练了，那么你的JS基础就会更扎实。学习源码有助于你更好地理解所用的技术栈，更熟练地在工作中运用。比如你深入学习了Vue.js的核心源码，你会理解Vue.js框架产生的意义、Vue.js的职责边界、数据驱动的本质；你还会知道如何实现的组件化，在什么生命周期应该做什么事情，如何编写Vue.js的插件，如何和其它第三方JS库深度结合。你再也不会问“如何用Vue实现XXX”的傻问题了。学习源码可以让我们站在巨人的肩膀上，Vue.js这么优秀，尤大也是参考了很多其他优秀源码的实现，比如Vue.js2.xVirtualDOM部分参考了snabbdom，Vue.js3.xReactive的实现参考了MeteorTracker和salesforce/observable-membrane等。我们在阅读的源码的时候，也可以把源码中的优秀的设计思想、代码实现吸纳到我们平时的开发工作中。学习源码还有一个偏功利的作用，应付面试。越来越多的公司在面试环节会考察候选人对所用技术栈实现原理的考察，主要目的还是考察候选人的技术能力以及技术热情和追求，因为通常对技术热爱的人通常都会保持技术好奇，乐于探究所用到的技术栈的实现原理。但是往往以这个目的去学习源码的同学是学不好的，对源码的理解很浅，甚至出现了死记硬背的情况。所以学习好源码可以帮助我们在面试中应答自如，但是我们不应该为了面试去学习源码。学源码的时机通常我们去学习一个技术栈的源码的时机是在我们对他的使用已经很熟练的情况，比如你是一个Vue.js的一年以上经验的使用者，那么你已经可以去学习它的源码了，这时候你的学习应该是系统化地学习。当你工作中使用某一个新框架的时候遇到一个奇怪的问题，通过查阅文档也未能解决，这个时候你也可以去看源码，当然这个时候并不需要系统地去学习，只需要把和你问题相关的源码理解了，找到问题即可。当然想达到这一步就需要你有快速阅读源码定位问题的能力，这个能力也是在你不断去阅读大量优秀源码过程中锻炼的。学不动了怎么办源码学习的好处我们已经介绍了很多，但是源码学习的本身是枯燥的，抽象的，它没有直观酷炫的效果，学习起来费脑子，是很多人直呼学不动的原因。其实学不动的主要原因还是因为没掌握好的学习方法，好的方法能让你事半功倍，正如我在来聊聊源码学习文章中提到的几个方法，全盘了解、问题驱动、主线优先、参与共建、阅读技巧、辅助资料。除了这些方法，根据我源码课程中一些学的不错的同学的经验，自己在学习的过程中多记笔记，多在课程问答区提问，甚至最后自己产出源码分析系列文章，都能非常好的辅助学习源码。其实做这些事情都是不断在帮助自己建立自信和成就感，激发学习兴趣，把无趣的事情变得有趣和有意义。课程后续计划源码课程会等待Vue.js3.x发布正式版本且稳定后会开始准备重新录制，仍然是电子书和视频的方式。重新录制的源码课程不仅仅会讲清楚源码实现流程，还会多加入一些使用场景、设计原因的分析。翻新课程是在原课程的基础上增加Vue.js3.x的章节，已购买课程的同学可以继续学习，无需购买新课程。先学会用再学原理，因此在Vue.js3.x正式发布后，我会优先重新录制《Vue2.0开发企业级移动端音乐WebApp》课程，同样是免费升级喔。音乐课程+源码课程的重新录制，是我明年的主要计划，暂无计划出新课程了。除了版本的升级，我会像《Vue.js2.5+cube-ui重构饿了么App》升级课程那样尽量往课程中加入一些新东西的，敬请期待~",
      "id": "6p4srivrerw0",
      "author": "JessicaC",
      "title": "Vue.js 3.x 源码解析先导"
    },
    {
      "content": "原文地址：medium.com/react-in-de…原文作者：JulianBurr在本篇文章中，我不想太深入解释有关ReactSuspense的实现细节和它内部的工作原理，因为已经有很多优秀的博客文章、视频和讨论做过这些事情了。相反，我更愿意把重点放在Suspense将会如何影响在应用开发时我们对加载状态和架构应用的思考。Suspense简要介绍鉴于有些人可能没有听说过Suspense或者根本不了解它，因此我会先给出一个关于Suspense的简要总结。在去年冰岛举行的JSConf大会上，DanAbramov介绍了Suspense。在解决React应用中有关异步数据获取的难题时，Suspense被称作是对开发者体验极大改进的API。这是件很令人兴奋的事情，因为每个正在构建动态web应用的开发者都知道这是一个主要痛点，并且也是带来巨大样版代码的原因之一。Suspense同样会改变我们对加载状态的思考方式，它不应该与加载组件或者数据源耦合，而应以UI关注点存在。我们的应用应该在用户体验中显示有意义的spinner。Suspense通过解耦以下关注点帮助我们实现这一点：Suspense并不关心你暂停（多少次）的原因，因此一个简单的spinner就能和代码分割、数据加载、图片加载等场景组合在一起。无论下面的树需要什么。如果网络速度足够快，甚至可以不显示spinner。Suspense不仅在数据加载时有用，它甚至可以被应用到任何异步数据流中去。例如代码分割或图片加载。React.lazy结合Suspense组件在React最新稳定版本中已经可以使用，这允许我们进行动态导入的代码分割，而无需手动处理加载状态。包含数据加载功能在内的完整SuspenseAPI将会在今年之内发布，不过你可以通过alpha版本提前使用它。Suspense的设计思想是让组件具有“暂停”渲染的能力，例如，组件需要从外部资源中加载额外数据时。等到数据都加载完成，React才会尝试重新渲染组件。React使用Promise来实现该功能。组件能在render方法调用时抛出Promise（或者任何在组件渲染时调用的方法，例如，新的静态方法getDerivedStateFromProps）。React会捕获Promise并沿着组件树往上寻找最近的Suspense组件，并且它会充当一种边界。Suspense组件接收一个名为fallback的prop，只要它的子树中有任何组件处于暂停状态，fallback中的组件就会立即被渲染。React还会跟踪抛出的Promise。组件中的Promise一旦resolve，React就会尝试去继续渲染该组件。因为我们假定由于Promise已经被resolve，这也就意味着暂停的组件已经具有正确渲染所需的全部数据。为此，我们使用某种形式的缓存来存储数据。该缓存取决于每次渲染时数据是否可用（如果可用就会像从变量中取值一样读取它），若数据没有准备好，则会触发fetch然后抛出Promise以便React捕获。如上所述，这并不是数据加载所独有的，任何可以使用Promise来描述的异步操作都可以充分利用Suspense，显然代码分割是一个非常明显且流行的例子。Suspense的核心概念与错误边界非常相似。而错误边界在React16中被介绍为能够在应用的任何地方捕捉未捕获的异常，同样的它通过在树中放置组件（在这种情况下为任何带有componentDidCatch生命周期方法的组件）来处理从该组件下面抛出的所有异常。无独有偶，Suspense组件捕获任何由子组件抛出的Promise，不同的是我们并不需要一个特定的组件来充当边界，因为Suspense组件自己就是，它可以让我们定义fallback来决定后备的渲染组件。\">这样的功能显著地简化了我们对应用中加载状态的思考方式并且让我们作为开发者的心智模型与UX和UI设计师更加一致。设计师通常并不会考虑数据源，而是更多的考虑用户界面或应用程序的逻辑组织和信息层次结构。你知道还有谁不在意数据源吗？答案是用户。没有人会喜欢成千上万个加载时的spinner，并且其中的一些只会闪烁几毫秒，当数据加载完成时，页面内容将会上下跳动。为什么Suspense被称作是巨大的突破呢？问题为了理解Suspense为什么能逆转游戏规则，让我们先来看看目前我们是如何处理应用中的数据加载。最原始的方法就是在局部状态中储存所有需要的信息，代码可能会像下面这样：classDynamicDataextendsComponent{state={loading:true,error:null,data:null};componentDidMount(){fetchData(this.props.id).then((data)=>{this.setState({loading:false,data});}).catch((error)=>{this.setState({loading:false,error:error.message});});}componentDidUpdate(prevProps){if(this.props.id!==prevProps.id){this.setState({loading:true},()=>{fetchData(this.props.id).then((data)=>{this.setState({loading:false,data});}).catch((error)=>{this.setState({loading:false,error:error.message});});});}}render(){const{loading,error,data}=this.state;returnloading?(<p>Loading...</p>):error?(<p>Error:{error}</p>):(<p>Dataloaded🎉</p>);}}复制代码这看起来很啰嗦，是吧？我们在组件mount时加载数据并储存到局部状态中。此外，我们还通过局部状态来跟踪错误和加载状态。这看起来很熟悉不是吗？即使你没有在使用state而是某种抽象，但很可能仍有很多加载三元组分散在你的应用程序中。我并不认为这种方法本身是错误的（它可以满足简单用例的需求，并且我们可以很容易地优化它，例如先将请求数据的逻辑分离到新的方法中），虽然它不能很好地扩展，但开发者体验肯定会变得更好。为了具体阐述，我列出了此种方法存在的某些问题：1.👎丑陋的三元组→糟糕的DX在render方法中加载和错误状态通过三元组定义，这使我们的代码变得不必要的复杂化。我们不是在描述render函数，而是在描述组件树。2.👎样板代码→糟糕的DX为了管理所有的状态我们不得不写很多样板代码：在mount时请求数据，成功时更新loading状态和存储数据到state或者失败时存储错误信息。我们会为每个需要外部数据的组件重复上面所有的步骤。3.👎受限数据和加载状态→糟糕的DX&UX我们会发现状态的处理和存储全都在一个组件内，这也就意味着应用中将会存在其他很多需要加载数据的spinner，如果我们有依赖于相同数据的不同组件，此时就会产生很多不必要的API调用代码。这回到了我之前提出的观点，使加载状态依赖于数据源的心智模型似乎并不正确。通过这种方法我们发现加载状态与数据加载以及组件强耦合在一起，这限制了我们只能在组件内处理问题（或者使用hack解决它），而不能够在更广泛的应用场景中使用它。4.👎重新获取数据→糟糕的DX改变id后则需要重新获取数据的逻辑是种很冗余的实现。我们既要在componentDidMount中初始化数据还要额外的在componentDidUpdate中检查id是否改变。5.👎闪烁的spinner→糟糕的DX如果用户的网速足够快，显示只出现几毫秒的spinner比什么也不显示要糟糕的多，这让你的应用变得笨拙且缓慢。因此感知性能才是关键。现在你知道这种模式的不足之处了吗？对于许多人来说这并不令人感到惊讶，但对于我而言，实际上并没有说明开发人员和用户体验的具体情况。因此，既然我们明确了问题所在，那么该如何解决它们呢？用Context改进在很长的一段时间内Redux一直是上述问题的解决方案。但随着React16版本新的”ContextAPI“发布，我们又有了另一个很好的工具帮助我们在全局定义和暴露数据，同时能够在深嵌套的组件树中轻松访问它们。因此为了简单起见，我们将在这里使用后者。首先，我们将原本储存在组件state中的所有数据转换到contextprovider中去，以方便其他组件共享该数据。我们也可以通过provider暴露加载数据的方法，这样我们的组件只需触发该方法然后通过contextconsumer读取加载后的数据。最近的React16.6版本发布的contextType使得它更加优雅，不那么繁琐。provider还可用作缓存形式，如果数据已经存在或者被其他组件触发即正在加载中，此时便可以避免多次不必要的网络请求。constDataContext=React.createContext();classDataContextProviderextendsComponent{//我们想在该provider中储存多种数据//因此我们用唯一的key作为每个数据集对象的键名//加载状态state={data:{},fetch:this.fetch.bind(this)};fetch(key){if(this.state[key]&&(this.state[key].data||this.state[key].loading)){//数据要么已经加载完成，要么正在加载中，因此没有必要再次请求数据return;}this.setState({[key]:{loading:true,error:null,data:null}},()=>{fetchData(key).then((data)=>{this.setState({[key]:{loading:false,data}});}).catch((e)=>{this.setState({[key]:{loading:false,error:e.message}});});});}render(){return<DataContext.Providervalue={this.state}{...this.props}/>;}}classDynamicDataextendsComponent{staticcontextType=DataContext;componentDidMount(){this.context.fetch(this.props.id);}componentDidUpdate(prevProps){if(this.props.id!==prevProps.id){this.context.fetch(this.props.id);}}render(){const{id}=this.props;const{data}=this.context;constidData=data[id];returnidData.loading?(<p>Loading...</p>):idData.error?(<p>Error:{idData.error}</p>):(<p>Dataloaded🎉</p>);}}复制代码我们甚至可以尝试着删除组件中的三元组代码。让我们把loadingspinner放在组件树更往上的地方，使它作用于不止一个组件。因为现在我们拥有在context中的loadingstate，所以将loadingspinner放在我们想要显示的地方会变得异常的容易，难道不是吗？但这仍然有问题，因为只有AsyncData组件开始渲染才会第一时间触发数据加载方法。当然，我们可以把数据加载方法提升到树中更往上的地方，而不是在此组件内触发，但这并没有真正解决问题，而只是把它移到了别处。这样做同样会影响代码的可读性与可维护性，突然间AsyncData组件会依赖于其他组件来为其进行数据的加载。这样的依赖既不清晰也不正确。理想情况下，你应该让组件尽可能的独立工作，这样一来你就可以把它们放在任何位置，而不必依赖其周围组件树中特定位置的其他组件。但至少我们成功的将数据和加载状态集中在一个地方，这称得上是一种进步。既然我们可以将provider放置在任何地方，我们便可以随时随地使用这些数据和功能，这意味着其他组件也可以利用它（而不再使用冗余的代码）并且可以重用已加载的数据，从而消除了不必要的API调用。为了更好的理解这一点，让我们再看看最初所面临的问题：1.👎丑陋的三元组并没有改变，我们所能做的只是将三元组移到别处，但这并不能解决DX问题2.👍样板代码我们移除了之前需要的所有样板代码。我们只需要触发数据加载方法然后从context中读取数据和loadingstate，由此我们减少了许多重复代码，剩下的则是可读性和可维护性高的代码。3.👍受限数据和加载状态现在我们拥有了在应用中任何地方都可以被读取的全局状态。因此我们大大改善了此种情况，但是却不能解决所有的问题：loadingstate仍然和数据源耦合在一起，如果我们想根据加载各自数据的多个组件显示相应的加载状态，我们仍需明确地知道是哪一个数据源然后手动检查单独的loadingstate。4.👎重新获取数据没有解决该问题。5.👎闪烁的spinner同样的也没有解决该问题。我想我们都同意这是一个可靠的改进，但它仍然留下了一些没有解决的问题。Suspense出场我们该如何使用Suspense来做的更好呢？首先，我们可以先去除context，数据处理和缓存将会由cacheprovider完成，它可以是任何东西。Context、localStorage和普通的对象（甚至是Redux如果你需要的话）等等。所有的这些provider只是帮助我们存储请求后的数据。在每次数据请求中，它会首先检查是否有缓存。如果有则直接读取，若没有则进行数据请求同时抛出Promise，在Promiseresolve之前，它将后备的信息储存在用于缓存的任何内容中，一旦React组件触发重渲染，此时一切都是可用的。显然，若考虑到缓存失效和SSR的问题，在使用更复杂的用例时情况也会变得更加复杂，但这是它的一般要点。这样难解决的缓存问题也是为什么数据加载形式的Suspense没有加入到当前React稳定版本的原因之一。如果你对此十分好奇，你可以提前使用试验性的react-cache包，但是它并不稳定并且在将来肯定会有巨大的改版。除此之外，我们可以删除所有的loadingstate三元组。更重要的是，Suspense在组件渲染时将会条件性地加载数据，如果数据没有缓存则会暂停渲染组件，而不是在mount与update时加载数据。这可能看起来像一个反模式（毕竟我们被告知不要这样做），但考虑到如果数据已经在缓存中，provider就会直接返回它然后渲染就能继续进行下去了。importcreateResourcefrom'./magical-cache-provider';constdataResource=createResource((id)=>fetchData(id));classDynamicDataextendsComponent{render(){constdata=dataResource.read(this.props.id);return<p>Dataloaded🎉</p>;}}复制代码终于我们可以放置边界组件并且在数据加载时渲染我们先前定义的fallback组件。我们可以将Suspense组件放置到任何地方，就像之前解释过的一样，这些边界组件能够捕获其所有子组件中冒泡上来的Promise。classAppextendsComponent{render(){return(<Suspensefallback={<p>Loading...</p>}><DeepNesting><ThereMightBeSeveralAsyncComponentsHere/></DeepNesting></Suspense>);}}//我们可以具体地使用多个边界组件。//它们不需要知道哪个组件被暂停渲染//或是为什么，它们只是捕获任何冒泡上来的Promise//然后按预期处理。classAppextendsComponent{render(){return(<Suspensefallback={<p>Loading...</p>}><DeepNesting><MaybeSomeAsycComponent/><Suspensefallback={<p>Loadingcontent...</p>}><ThereMightBeSeveralAsyncComponentsHere/></Suspense><Suspensefallback={<p>Loadingfooter...</p>}><DeeplyNestedFooterTree/></Suspense></DeepNesting></Suspense>);}}复制代码我认为这无疑会使代码变得更加清晰，逻辑上的数据流从上到下变得更加易读。现在来看看哪些问题被解决了呢？1.❤️丑陋的三元组fallback组件由边界组件负责渲染，这使得代码更容易遵循且更加直观。loadingstate变成了UI关注点并且与数据加载解耦。2.❤️样板代码我们通过删除在组件生命周期方法中触发数据加载的代码更完美地解决了这个问题。并且还预见到未来能够充当cacheprovider的库，只要你想更改存储的解决方案，就可以随时切换它们。3.❤️受限数据和加载状态现在我们拥有了因loadingstate存在的明确的边界组件，因此我们并不关心数据加载方法是在哪被触发或是为什么被触发。只要边界组件中的任何组件被暂停，loadingstate就会被立即渲染出来。4.❤️重新获取数据既然我们能够在render方法中直接读取数据源，因此只要传入的id不同React就能自动触发并重新加载数据，而我们则不需要做任何事情。cacheprovider帮我们做到了。5.👎闪烁的spinner这仍然是个未解决的问题。🤔这些便是巨大的改进，但我们仍有一个问题没有解决......然而，既然我们在使用Suspense，那么React还有另一个技巧来帮助我们使用它。终极方案：并发模式并发模式，之前也被叫做异步React，它是另一个即将发布的新特性，可以让React一次处理多个任务，并根据定义的优先级在它们之间切换，有效地允许React进行多个任务。AndrewClark在2018ReactConf上做了很棒的演讲，其中包含了一个它对用户影响的完美示例。在这里我并不想深入太多，因为已经有一篇文章讲解的十分详细。然而，将并发模式添加到我们的应用中，Suspense则会拥有通过组件上的prop来控制的新功能。如果我们传入一个maxDuration属性，边界组件就会推迟显示spinner直到超过设定的时间，这样一来便避免了spinner不必要的闪烁。与此同时，它还能确保spinner显示的最短时间，从根本上解决了相同的问题并且让用户体验尽可能的友好。//不需要这行代码ReactDOM.render(<App/>,document.getElementById('root'));//我们只需通过这行代码就可以切换到并发模式ReactDOM.createRoot(document.getElementById(‘root’)).render(<App/>);复制代码要明确的是，这并不能使数据加载的更快，但对于用户来说却是这样的，并且用户体验会得到显著改善。此外，并发模式并不是Suspense所必须的。就像我们之前看到的一样，在没有并发模式的情况下Suspense同样能够很好地工作并且解决了许多问题。并发模式更像是锦上添花，不是必要的但如果有则会更好。",
      "id": "2wrhcyxvq4c0",
      "author": "_Dreams",
      "title": "[译] 为什么 React Suspense 将会逆转 Web 应用开发的游戏规则 ？"
    },
    {
      "content": "原文地址：WhatReplacesJavaScript原文作者：MatthewMacDonald译文出自：掘金翻译计划本文永久链接：github.com/xitu/gold-m…译者：cyz980908校对者：江五渣,Chorer什么将会替代JavaScript呢？JavaScript正在蓬勃发展。但由于WebAssembly的出现，它的衰落可能只是一个时间问题。有些编程语言很受欢迎。而有些只是被开发人员被迫接受。对于许多程序员来说，JavaScript就是后者中的一个例子，每个前端开发人员都需要学习和理解这种语言，但是却没有人喜欢它。十年前，JavaScript还没有统治世界的迹象。其他的平台，像Java，Flash和Silverlight也依然在被我们使用。以上三个平台都需要运行在一个浏览器插件中，且三者都用一种不同的用户界面替换了HTML。这种方法使它们在功能特性方面远远领先于JavaScript——例如，早在\\元素、CSS动画或HTMLcanvas之前，我们就能使用它们添加视频、动画和绘图。但这也意味着它们的衰落。当移动浏览爆炸式增长，HTML转向拥抱移动浏览器时，这些平台也已过时。讽刺的是，就在JavaScript征服世界的同时，一颗小小的种子被播下。它将在未来的某个时候，宣告JavaScript的终结。这颗种子就是一种叫asm.js的实验技术。但是介绍它之前，我们还是退一步来审视当下的形势。转码：目前的做法自从我们有了JavaScript，开发人员就一直试图避开它。一种早期的方法是使用插件将代码从浏览器中取出。（该方法失败。）另一种想法是开发可以转换代码的开发工具，将用另一种更受欢迎的语言编写的代码转换成JavaScript。这样，开发人员就可以如愿地让代码到处运行，同时又能避免弄脏双手。把一种语言转换成另一种语言的过程叫做转码，但这个过程并非一帆风顺。高级语言有不同的特性、语法和习惯用法，你不能单纯直接地映射到另一个等价的结构上。就算你可以，这也是有潜在危险的。如果社区停止开发你最喜欢的转码器怎么办？或者如果转码器引入了自己的bug怎么办？如果要插入Angular，React或Vue这样的JavaScript框架怎么办？如果你在团队中不使用相同的语言开发，你又将如何与团队合作呢？如同许多开发案例一样，一个工具的好坏取决于它背后的社区。\">如今，转码器已经是再常见不过了，但它们的用途往往只有一种——处理向后兼容性。开发人员都是尽可能使用最新的JavaScript版本，然后使用类似Babel之类的转码器将他们的代码转换成同等的（但不那么优雅的）旧版本JavaScript代码，这样代码就可以兼容所有的运行环境。或者更好的是，他们使用TypeScript（一种添加了强类型、泛型和不可为空类型等特性的现代化JavaScript）并将TypeScript转换成JavaScript。无论哪种方式，你都是在JavaScript这片小花园里打转。Asm.js：一块垫脚石一种新的可能性的曙光来自于2013年，Mozilla的开发人员做的一个独特实验——asm.js。他们那时正在寻找一种在浏览器中运行高性能代码的方法。但与插件不同的是，asm.js并没有试图与浏览器为邻。相反，它的目标是直达JavaScript虚拟机。从本质上讲，asm.js是一种简洁、优化的JavaScript语法。它比普通的JavaScript运行得更快，因为它避开了语言中缓慢的动态部分。但是，意识到这一点的web浏览器也可以应用其他方法优化，从而大大提高性能。换句话说，asm.js遵循了黄金法则——不要破坏web，同时还提供了未来改进的方法。Firefox团队借助asm.js和一款叫做Emscripten的转换工具，把用C++构建的实时3D游戏放到了web浏览器中，只需要JavaScript和一颗初心便可畅玩。\">asm.js最重要的部分是它迫使开发人员重新思考JavaScript的作用。Asm.js代码是JavaScript代码，但这不意味着程序员应该手动编写和操作asm.js代码。相反，asm.js代码应该由自动化过程（一个转码器）构建，并直接提供给浏览器。JavaScript是中间的媒介，而不是最终传递的信息。WebAssembly：一项新的技术尽管asm.js实验产生了一些耀眼的演示，但它在很大程度上被工作的开发人员忽略了。对他们来说，这只是另一项有趣的新兴技术。但随着WebAssembly的诞生，这一切都改变了。WebAssembly既是asm.js的接班人，同时又是一项截然不同的技术。它是一种紧凑的二进制代码格式。与asm.js一样，WebAssembly代码也被输入到JavaScript执行环境中。它们俩具有相同的沙箱和相同的运行时环境。与asm.js一样，WebAssembly的编译方式使得更进一步的效率提升成为可能。但是现在的效率就已经比以前快多了了，浏览器可以完全跳过JavaScript解析阶段。对于一个普通的逻辑位来说（例如，耗时的计算），WebAssembly的速度远远快于常规的JavaScript，几乎与本机编译的代码一样快。\">如果你想知道WASM写起来是什么样的，那么你可以想象一下你有这样一个C函数：intfactorial(intn){if(n==0)return1;elsereturnn*factorial(n-1);}复制代码它将被编译成如下所示的WASM代码：get_local0i64.eqzif(resulti64)i64.const1elseget_local0get_local0i64.const1i64.subcall0i64.mulend复制代码当通过网络发送时，WASM代码被进一步压缩成二进制编码。WebAssembly的定位是编译器。你永远不会手写它。（但是，如果你想进行深入的探索，你当然可以去做。）WebAssembly首次出现在2015年。今天，桌面和移动设备上的四大浏览器完全支持它（Chrome，Edge，Safari和Firefox）。它在InternetExplorer中不受支持，尽管将WebAssembly代码转换为asm.js可以实现向后兼容。（性能将会受到影响，拜托请让IE消失吧！）WebAssembly和网站开发的未来WebAssembly开箱即用，为开发人员提供了一种通常使用C++编写优化代码例程的方法。这是个强大的功能，但是使用范围有限。如果你需要提高复杂计算的性能，这将很有用。（例如，fastq.bio使用WebAssembly加快了他们的DNA测序计算。）如果你需要移植高性能游戏或编写在浏览器中运行的模拟器，那么WebAssembly你值得拥有。如果这就是WebAssembly的全部功能，那就太没意思了——它也将不会有取代JavaScript的希望。WebAssembly还为其他框架开发人员提供了一条小路，使得框架开发人员可以将其平台压缩到JavaScript环境中。事情在这里发生了有趣的转变。WebAssembly不能是脱离JavaScript的，因为它被锁定在JavaScript运行环境中。实际上，WebAssembly至少需要与一些普通的JavaScript代码一起运行，因为它无法直接访问页面。这意味着，如果不经过JavaScript层，它就无法操纵DOM或接收事件。这听起来像是一个要突破原则的限制。但是，聪明的开发人员已经找到了在WebAssembly中偷偷搬运运行环境的方法。例如，Microsoft的Blazor框架，下载一个小型.NET的运行环境作为编译后的WASM文件。这个运行环境处理JavaScript的互操作，并提供基本服务（如垃圾收集）和更高级的功能（布局、路由和用户界面小部件）。换句话说，Blazor使用了一个存在于另一个虚拟机中的虚拟机。这既可以说是一个令人费解的悖论，也可以说是一种创建在浏览器中运行的非JavaScript应用程序框架的聪明方法。Blazor并不是唯一一个由WebAssembly支持的实验。以Pyodide为例，它的目标是将Python放到浏览器中，并提供用于数据分析的高级数学工具包。这就是未来。WebAssembly一开始只是为了满足C++、Rust的需求，但很快就被用于创建一些更有野心的实验。不久后，它将会带来那些非JavaScript框架与基于JavaScript的标准框架（如Angular、React和Vue）同台竞技的机会。而且WebAssembly仍在迅速发展。它目前的实现是一个最小可行性的产品——仅能够在一些重要的场景中发挥作用，而不是在web上开发的通用方法。随着WebAssembly的逐步普及，这个现象将得到改善。例如，如果像Blazor这样的平台流行起来，WebAssembly可能会支持直接访问DOM。现在，浏览器制造商们已经在计划添加垃圾回收和多线程的机制，有了WebAssembly，运行环境这些细节他们也不需要自己实现。如果你认为这条WebAssembly的发展之路看起来漫长而且令人怀疑，那么想想JavaScript的例子吧。首先，我们看到，如果有些事情JavaScript可以做到，那么它就会被完成。然后，我们了解到，如果浏览器频繁做某件事，那么浏览器会让它工作得更高效更好，等等。所以说，如果WebAssembly流行了，它将进入一个良性循环的发展过程，并且很容易超越JavaScript的固有优势。人们常说，WebAssembly不是用来替代JavaScript的。但这适用于之前的每一个发生革命性改变的的平台。JavaScript不是用来取代浏览器嵌入Java的。Web应用程序也不是为了取代桌面应用程序而设计的。但一旦它们可以，它们就会替代。如果发现译文存在错误或其他需要改进的地方，欢迎到掘金翻译计划对译文进行修改并PR，也可获得相应奖励积分。文章开头的本文永久链接即为本文在GitHub上的MarkDown链接。掘金翻译计划是一个翻译优质互联网技术文章的社区，文章来源为掘金上的英文分享文章。内容覆盖Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注掘金翻译计划、官方微博、知乎专栏。",
      "id": "6arv2fu58ok0",
      "author": "xiangzhihong",
      "title": "[译] 什么将会替代 JavaScript 呢？"
    },
    {
      "content": "前言在平时的H5移动端开发时，我们难免会遇到各种各样的坑点，这篇文章就带着大家来看看怎么解决，文章较长，建议收藏方便以后查阅！前方高能！canvas在retina屏模糊只需要将画笔根据像素比缩放即可run(canvasEl){constcanvas=canvasEl;constctx=canvas.getContext('2d');constdevicePixelRatio=window.devicePixelRatio||1;constbackingStorePixelRatio=ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||ctx.backingStorePixelRatio||1;constratio=devicePixelRatio/backingStorePixelRatio;if(devicePixelRatio!==backingStorePixelRatio){constoldWidth=canvas.width;constoldHeight=canvas.height;canvas.width=oldWidth*ratio;canvas.height=oldHeight*ratio;canvas.style.width=`${oldWidth}px`;canvas.style.height=`${oldHeight}px`;ctx.scale(ratio,ratio);}},复制代码用同等比例的图片在PC机上很清楚,但是手机上很模糊,原因是什么呢?经研究发现是devicePixelRatio作怪,因为手机分辨率太小,如果按照分辨率来显示网页字会非常小,所以苹果就把iPhone4的960640分辨率在网页里只显示了480320,这样devicePixelRatio＝2;现在android比较乱,有1.5/2/3等,想让图片在手机里显示更为清晰必须使用2x的背景图来代替img标签(一般情况都是用2倍),例如一个div的宽高是100100,背景图必须得200200,然后background-size:contain;,这样显示出来的图片就比较清晰了;代码如下:background:url(../images/icon/all.png)no-repeatcentercenter;-webkit-background-size:50px50px;background-size:50px50px;display:inline-block;width:100%;height:50px;复制代码启动或禁用自动识别页面中的电话号码;<metaname=\"format-detection\"content=\"telephone=no\">复制代码默认情况下设备会自动识别任何可能是电话号码的字符串,设置telephone=no可以禁用这项功能,设置不识别邮箱和地址也同理h5网站input设置为type=number的问题h5网页input的type设置为number一般会产生三个问题:问题1:maxlength属性不好用\"number\"oninput=\"checkTextLength(this,10)\"><scripttype=\"text/javascript\">functioncheckTextLength(obj,length){if(obj.value.length>length){obj.value=obj.value.substr(0,length);}}</script>复制代码问题2:form提交的时候默认取整<inputtype=\"number\"step=\"0.01\"/>//input中type=number一般会自动生成一个上下箭头,点击上箭头默认增加一个step,点击下箭头默认会减少一个step;number中默认step是1,也就是step=0.01可以允许输入2位小数,并且点击上下箭头分别增加0.01和减少0.01;step和min一起使用时数值必须在min和max之间复制代码问题3:部分安卓手机出现样式问题去除input默认样式的方法:input,textarea{border:0;-webkit-appearance:none;//可同时屏蔽输入框怪异的内阴影,解决iOS下无法修改按钮样式,测试还发现,加了此属性后,iOS下默认还是有圆角的,不过可以用border-radius属性修改}复制代码select下拉选择设置问题问题1:右对齐实现设置如下属性selectoption{direction:rtl;}复制代码问题2:禁用select默认箭头::-ms-expand修改表单控件下拉箭头,设置隐藏并使用背景图片来修饰select::-ms-expand{display:none;}复制代码移动端HTML5audioautoplay失效问题由于自动播放网页中的音频或视频会给用户带来困扰或不必要的流量消耗,所以苹果系统和安卓系统通常都会禁止自动播放和使用JS的触发播放,必须由用户来触发才播放;解决方法思路:先通过用户touchstart触碰触发播放并暂停(让音频开始加载),后面用JS再操作就没问题了;解决代码:document.addEventListener('touchstart',function(){document.getElementsByTagName('audio')[0].play();document.getElementsByTagName('audio')[0].pause();});复制代码CSS动画页面闪白,动画卡顿,图片错乱的问题1.尽可能地使用合成属性transform和opacity来设计CSS3动画,不使用position的left和top来定位2.开启硬件加速-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);复制代码浮动子元素撑开父元素盒子高度(BFC)解决方法如下：1.父元素设置为overflow:hidden;2.父元素设置为display:inline-block;等这里两种方法都是通过设置css属性将浮动元素的父元素变成BFC(块级格式化上下文)元素,使子元素高度可以撑开父元素;不过最好使用方法1,因为inline-block元素本身会自带一些宽高度撑开其本身往返缓存问题点击浏览器的回退有时候不会自动执行js,特别是在mobilesafari中;这与往返缓存(bfcache)有关系,解决方法:window.onunload=function(){};复制代码定位的坑在IOS下fixed定位在软键盘顶起时会失效，所以我们在开发时统一使用absolute代替audio元素和video元素在ios和andriod中播放问题<audiosrc=\"music/bg.mp3\"autoplayloopcontrols>你的浏览器还不支持哦</audio>//音频,写法一<audiocontrols=\"controls\">//音频,写法二<sourcesrc=\"music/bg.ogg\"type=\"audio/ogg\"></source><sourcesrc=\"music/bg.mp3\"type=\"audio/mpeg\"></source>//优先播放音乐bg.ogg,不支持在播放bg.mp3</audio>复制代码ios系统手机无法自动播放音频/视频这个是苹果系统限制默认不允许自动播放音频/视频,需要点一下触发play()事件才能播放;那么我们可以在页面onload后触发播放事件:document.getElementById('music').play();复制代码到这里一般都可以播放音乐了,如果还不行很有可能是微信的限制问题3:微信的限制如果是微信的限制,这时需要调用微信接口,页面先引入:\"http://res.wx.qq.com/open/js/jweixin-1.0.0.js\">复制代码然后JS写入微信事件:document.addEventListener(\"WeixinJSBridgeReady\",function(){document.getElementById('music').play();},false);复制代码小结:1.audio元素的autoplay属性在IOS及Android上无法使用,在PC端正常2.audio元素没有设置controls时,在IOS及Android会占据空间大小,而在PC端Chrome是不会占据任何空间问题4:Safari浏览器自动播放document.addEventListener('touchstart',function(){audio.play();},false);复制代码ios系统不支持动画暂停样式(animation-play-state)H5页面一般都会有BGM,也会提供一个旋转的音乐图标供用户开启关闭音乐;我们希望当用户点击音乐按钮时图标停止旋转,再点图标顺着之前停止的位置继续跑动画;animation-play-state是最简便的方式,然而ios不支持目前的解决方案是:音乐图标负责跑动画,图标父级元素负责记录停止时的转动值ios防止长按页面元素被选中解决:加入样式可禁止用户进行复制,ios和一般的安卓都可以解决-webkit-touch-callout:none;//系统默认菜单被禁用;可以实现页面因为长按弹出各种操作窗口-webkit-user-select:none;//webkit浏览器-khtml-user-select:none;//早期浏览器-moz-user-select:none;//火狐-ms-user-select:none;//IE10user-select:none;复制代码添加完这段代码后在IOS上会有问题,这时发现input框无法正在输入内容了;造成这个原因是-webkit-user-select:none;这个属性,解决方法就是在css文件中同时设置一下input的属性,如下:input{-webkit-user-select:auto;//webkit浏览器}复制代码html5碰到上下拉动滚动条时卡顿/慢怎么解决首先你可能会给页面的html和body增加了height:100%,然后就可能造成IOS上页面滑动的卡顿问题。解决方案是：1.让html和body固定100%（或者100vh），2.然后再在内部放一个height:100%的div，设置overflow-y:auto;和-webkit-overflow-scrolling:touch;overflow-x:auto在iOS有兼容问题，解决方法:.scroll-box{/*模态框之类的div不能放在这个容器中,否则关闭模态框有时候关闭不了*/height:100%;overflow-y:auto;-webkit-overflow-scrolling:touch;overflow-scrolling:touch;}复制代码点击元素产生背景或边框怎么去掉a,button,input,textarea{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-modify:read-write-plaintext-only;//-webkit-user-modify有个副作用,就是输入法不再能够输入多个字符}或a,button,input,textarea{-webkit-tap-highlight-color:rgba(0,0,0,0);}浏览器后退不刷新这种情况是以前遇到的,这里也说下;主要会发生在webview里多一点,当点击后退时页面以缓存形式出现,而不是刷新后的,很多情况下这不是你预期的效果,解决方法是用js:window.onpageshow=function(evt){if(evt.persisted){document.body.style.display=\"none\";location.reload();}};复制代码onpageshow每次页面加载都会触发,无论是从缓存中加载还是正常加载,这是他和onload的区别;persisted判断页面是否从缓存中读出input的placeholder文本位置偏上的情况input的placeholder会出现文本位置偏上的情况:PC端设置line-height等于height能够对齐,而移动端仍然是偏上,解决方案时是设置cssline-height:normal;transition清除闪屏-webkit-transform-style:preserve-3d;//设置内嵌的元素在3D空间如何呈现：保留3D-webkit-backface-visibility:hidden;//设置进行转换的元素的背面在面对用户时是否可见：隐藏-webkit-perspective:1000;复制代码解决active伪类失效<bodyontouchstart></body>复制代码顶部状态栏背景色apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行;语法:\"apple-mobile-web-app-capable\"content=\"yes\">//content设置为yesWeb应用会以全屏模式\"apple-mobile-web-app-status-bar-style\"content=\"black\"/>复制代码说明:除非你先使用apple-mobile-web-app-capable指定全屏模式,否则这个meta标签不会起任何作用;如果content设置为default,则状态栏正常显示;如果设置为blank,则状态栏会有一个黑色的背景;如果设置为blank-translucent,则状态栏显示为黑色半透明;如果设置为default或blank,则页面显示在状态栏的下方,即状态栏占据上方部分;页面占据下方部分，二者没有遮挡对方或被遮挡;如果设置为blank-translucent,则页面会充满屏幕,其中页面顶部会被状态栏遮盖住(会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px);默认值是default。ios专区IOS中对input键盘事件keyup/keydown/keypress等支持不好的问题经查发现,IOS的输入法(不管是第三方还是自带)能检测到英文或数字的keyup,但检测不到中文的keyup,在输入中文后需要点回退键才开始搜索;解决办法是用html5的oninput事件去代替keyup,通过如下代码达到类似keyup的效果;1.修改了input:checkbox或input:radio元素的选择中状态,checked属性发生变化2.修改了input:text或textarea元素的值,value属性发生变化3.修改了select元素的选中项,selectedIndex属性发生变化统一使用input监听type=\"text\"id=\"testInput\">type=\"text/javascript\">document.getElementById('testInput').addEventListener('input',function(e){varvalue=e.target.value;//e.target指向事件执行时鼠标所点击区域的那个元素;初学者会认为当前事件所绑定的元素就是鼠标所点击的那个元素,这时就要看看时间绑定的元素内部有没有子元素,如果有e.target指向这个子元素,如果没有e.target和this都指向事件所绑定的元素});复制代码IOS键盘字母输入,默认首字母大写的解决方案设置如下属性\"off\"autocorrect=\"off\"/>复制代码//input的三个属性autocomplete:默认为on,代表是否让浏览器自动记录输入的值,可以在input中加入autocomplete=\"off\"来关闭记录,保密输入内容;autocapitalize:自动大小写;autocorrect:纠错关于iOS与OSX端字体的优化(横竖屏会出现字体加粗不一致等)问题iOS浏览器横屏时会重置字体大小,设置text-size-adjust为none可以解决iOS上的问题,但桌面版Safari的字体缩放功能会失效,因此最佳方案是将text-size-adjust为100%-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%;复制代码某些情况下非可点击元素如(label,span)监听click事件,ios下不会触发针对此种情况只需对不触发click事件的元素添加一行css代码即可cursor:pointer;复制代码ios对时间date()的支持不一样vardate=newDate(\"2019/10/21\");复制代码调试发现2019/10/21等同2019-10-2100:00:00,也就是说ios默认就是从0开始计算的,我们不需要设置后面的时分秒为00:00:00iOS(safari)标签绑定点击事件无效iOS(safari)有时候某个标签绑定点击事件无效,加上空的onclick=\"\"就好了,如:ios中location.href跳转页面空白在location.href外套一层setTimeout就解决了！setTimeout(()=>{window.location.href='www.juejin.im'},0);复制代码键盘弹起下落时的bug解决方法在App.vue的created钩子里统一处理即可created(){this.handleFocusOut();this.handleResize();},methods:{handleFocusOut(){//input焦点失焦后，ios键盘收起，但没有触发windowresize，导致实际页面dom仍然被键盘顶上去--错位document.addEventListener('focusout',()=>{document.body.scrollTop=0;});},//监听resize事件（键盘弹起触发），然后将inputtextarea元素滑动到可视区域，并将特定元素隐藏handleResize(){constclientHeight=document.documentElement.clientHeight;window.addEventListener('resize',()=>{//判断当前active的元素是否为input或textareaif(document.activeElement.tagName==='INPUT'||document.activeElement.tagName==='TEXTAREA'){setTimeout(()=>{//原生方法，滚动至需要显示的位置document.activeElement.scrollIntoView();},0);}//解决键盘弹起后fixed定位元素被顶起问题constbodyHeight=document.documentElement.clientHeight;constele=document.getElementById('fixed-bottom');if(ele){if(clientHeight>bodyHeight){ele.style.display='none';}else{ele.style.display='block';}}});}}复制代码总结路漫漫其修远兮,在兼容的道路上渐行渐远",
      "id": "6e2ew3h9nio0",
      "author": "lio-mengxiang",
      "title": "移动端H5页面开发坑点指南"
    }
  ],
  "searchArticleDetailList": [],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5da14778f265da5bb628e590",
      "k": "juejin",
      "id": "svegcnmtq3k",
      "author": "神三元",
      "title": "写给新手前端的各种文件上传攻略，从小图片到大文件断点续传",
      "time": "7天前",
      "detail": "写在前面今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。这篇文章比较基础，在国庆期间的业余时间写的，这几天又完善了下，力求把更多的前端所涉及到的关于文件上传的各种场景和应用都涵盖了,若有疏漏和问题还请留言斧正和补充。自测读不读以下是本文所涉及到的知识点，breakorcontinue?文件上传原理最原始的文件上传使用koa2作为服务端写一个文件上传接口单文..."
    },
    {
      "url": "https://juejin.im/post/5dac5d82e51d45249850cd20",
      "k": "juejin",
      "id": "232y8b6b3dr4",
      "author": "荒山",
      "title": "(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)",
      "time": "3天前",
      "detail": "笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！第一篇:JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在JS中，存在着7种原始值，分别是：booleannullundefinednumberstringsymbolbigint引用数据类型:对象Object（包含..."
    },
    {
      "url": "https://juejin.im/post/5dadc6045188255a270a0f85",
      "k": "juejin",
      "id": "h7ju32v00vk",
      "author": "火狼1",
      "title": "这可能是最通俗的 React Fiber(时间分片) 打开方式",
      "time": "2天前",
      "detail": "写一篇关于ReactFiber的文章，这个Flag立了很久，这也是今年的目标之一。最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。我会以最通俗的方式将它讲透,因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!\">一年一度的React春晚:ReactConf即将到来，不知道今年会不会有什么惊喜，去年是ReactHooks，前年是ReactFiber...我得赶在ReactConf之前发布这篇文章:😲ReactFiber已经..."
    },
    {
      "url": "https://juejin.im/post/5daeefc8e51d4524f007fb15",
      "k": "juejin",
      "id": "6gbcmzcjjjc0",
      "author": "取舍🍂",
      "title": "JS 原生面经从初级到高级【近1.5W字】",
      "time": "1天前",
      "detail": "前言是时候撸一波JS基础啦,撸熟了,银十速拿offer;本文不从传统的问答方式梳理,而是从知识维度梳理,以便形成知识网络;包括函数,数组,对象,数据结构,算法,设计模式和http.1.函数1.1函数的3种定义方法1.1.1函数声明//ES5functiongetSum(){}function(){}//匿名函数//ES6()=>{}//如果{}内容只有一行{}和return关键字可省,复制代码1.1.2函数表达式(函数字面量)//ES5varsum=function(){}//ES6letsum..."
    },
    {
      "url": "https://juejin.im/post/5dac3b4351882576534d33d7",
      "k": "juejin",
      "id": "k47utnwj81c",
      "author": "voanit",
      "title": "7天撸完KTV点歌系统,含后台管理系统(完整版)",
      "time": "3天前",
      "detail": "最近手有点痒琢磨着做个啥,朝思暮想还是写个KTV点歌系统,模拟了一下KTV开户的思路,7天累死我了,不过技术点还挺多的,希望你可以看完（〜^㉨^)〜用Node(Express)教你写KTV点歌系统，包括前台内容和后台管理系统，整合Express框架和Mongodb数据库服务器开发；教你用Vue.JS，ElementUI和iViewUI写出超漂亮的页面,随心点歌随心听作者原创文章,转载前请留言或联系作者!!!思维导图技术栈后端：Express+Mongodb+jsonwebtoken等等前端：Vu..."
    },
    {
      "url": "https://juejin.im/post/5dad09be518825393e52d1bd",
      "k": "juejin",
      "id": "1x24sitqn91c",
      "author": "全栈者",
      "title": "前端框架用vue还是react？清晰对比两者差异",
      "time": "2天前",
      "detail": "vueorreact？That'saquestion.前言近两年前端技术层出不穷，目前市面上已经有了很多供前端人员使用的开发框架，转眼19年已过大半，前端框架领域日趋成熟，实现了三足鼎立的局面，截止到10月22日，Angular，react和vue数据统计如下图所示:\">最近在学习使用框架的时候，分别使用vue和react开发了两个移动端产品，对这两个框架的学习曲线有了一些感悟，这两个都是现在比较热门的js框架，它俩在使用方式上和学习复杂度上还是有很大区别的，这里简单总结下两者的差异。主要从以下..."
    },
    {
      "url": "https://juejin.im/post/5da90c3e6fb9a04e031c0413",
      "k": "juejin",
      "id": "2wzr45m3kgi0",
      "author": "云音乐前端技术团队",
      "title": "聊聊 Vue 中 axios 的封装",
      "time": "6天前",
      "detail": "axios是Vue官方推荐的一个HTTP库，用axios官方简介来介绍它，就是：Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中。作为一个优秀的HTTP库，axios打败了曾经由Vue官方团队维护的vue-resource，获得了Vue作者尤小右的大力推荐，成为了Vue项目中HTTP库的最佳选择。虽然，axios是个优秀的HTTP库，但是，直接在项目中使用并不是那么方便，所以，我们需要对其进行一定程度上的配置封装，减少重复代码，方便调用。下面，我们就来聊聊Vue中..."
    },
    {
      "url": "https://juejin.im/post/5da88d795188252f051e2b47",
      "k": "juejin",
      "id": "4npmq5buti80",
      "author": "前端小智",
      "title": "要进大厂？前端灰度发布必须要知道",
      "time": "6天前",
      "detail": "笔者在刚进入阿里的时候，其实连灰度是什么也不知道，但是灰度这个概念在大厂非常普遍，只要有一定用户量的应用都会涉及到灰度发布，所以准备进大厂的同学，灰度发布这个概念一定要了解一下。一.灰度发布是什么？灰度发布，又被称之为金丝雀发布，是指某次新发布功能特性和旧功能特性之间能够以平滑过渡的方式呈现给用户，就像金丝雀的羽毛一样多种颜色平滑渐变。举个例子，某个已上线处于运行中的系统需要一次新的功能迭代，但是由于功能变动较大，所以发布需要考虑用户的使用反馈以及代码可能存在一些未知的异常，这时候则需要将新的功..."
    },
    {
      "url": "https://juejin.im/post/5dad208ef265da5b7d692340",
      "k": "juejin",
      "id": "3maqpuunyhe0",
      "author": "西岚",
      "title": "Server-X：一款可能提升你十倍工作效率的工具",
      "time": "3天前",
      "detail": "本文将介绍一款全新的前端开发工具，希望它能给你的前端开发带来看起来和现在一样但其实又不那么一样的体验。你可能会说，大家都是秃头的成熟的前端程序员了，每一台电脑上都有几套自己辛辛苦苦装好的全家桶，为什么还要新换一个开发工具？对，盲生，你可能发现了华点。数一数你电脑上目前为前端本地开发安装了多少小工具、小插件？这其中仅仅是为代码开发阶段，就可能有本地服务器、远程调试工具、代理工具、浏览器插件等等。它们也许是你一个个尝试无数同款后最终确定安装的，也可能是被各类『震惊！超好用前端开发工具大全』安利的，并..."
    },
    {
      "url": "https://juejin.im/post/5dacf37ef265da5b926bdc9a",
      "k": "juejin",
      "id": "5sxabtpsibo0",
      "author": "寒东设计师",
      "title": "7 个沙雕又带有陷阱的 JS 面试题",
      "time": "3天前",
      "detail": "作者：DmitriPavlutin译者：前端小智来源：dmitripavlutin这几天自己的公众号无套路送现金200+，参与方式如下mp.weixin.qq.com/s/PTlWMG5Ke…为了保证的可读性，本文采用意译而非直译。在JS面试中，经常会看到一些简单而又沙雕的题目，这些题目包含一些陷阱，但这些在我们规范的编码下或者业务中基本不会出现。有些面试官就是这样，不专注于制定代码的标准和规范上，却用不规范的代码去检验别人是否细心。这魔幻的世界就是一个攀比优越感的，我能考你，我就是比你优越，真..."
    },
    {
      "url": "https://juejin.im/post/5dadd0236fb9a04de04d968e",
      "k": "juejin",
      "id": "2g8uw3xnbi4g",
      "author": "浪里行舟",
      "title": "Node.js 实现抢票小工具&短信通知提醒",
      "time": "1天前",
      "detail": "写在前言要知道在深圳上班是非常痛苦的事情，特别是我上班的科兴科技园这一块，去的人非常多，每天上班跟春运一样，如果我能换到以前的大冲上班那就幸福了，可惜，换不得。尤其是我这个站等车的多的一笔，上班公交挤的不行，车满的时候只有少部分人能硬挤上去。通常我只会用两个字来形容这种人：“公交怪”想当年我朋友瘦的像只猴还能上去，老子身高182体重72kg挤个公交，不成问题，反手一个阻挡，闷声发大财，前面的阿姨你快点阿姨，别磨磨唧唧的，快上去啊阿姨，嗯？你还想挤掉我？你能挤掉我？你能挤掉我！我当场！把车吃了！...."
    },
    {
      "url": "https://juejin.im/post/5d89ac2ff265da03c34c3cd2",
      "k": "juejin",
      "id": "ntcanx4h85c",
      "author": "dragonet",
      "title": "金九银十面试笔记",
      "time": "5天前",
      "detail": "目录JS说说js中的词法作用域什么是闭包说说js的垃圾回收(GC)说说你了解的设计模式Es6ES6模块与CommonJS模块的差异async函数实现原理Node说说浏览器和node中的事件循环（EventLoop）实现一个node中的EventEmiter实现一个node中util模块的promisify方法如何实现一个自定义流性能优化性能优化之dns-prefetch、prefetch、preload、defer、async说说react性能优化网络／浏览器说说浏览器渲染流程说说http2.0..."
    },
    {
      "url": "https://juejin.im/post/5d9abde7e51d4578110dc77f",
      "k": "juejin",
      "id": "6lkp3re3nm80",
      "author": "黄轶",
      "title": "解密HTTP/2与HTTP/3 的新特性",
      "time": "7天前",
      "detail": "前言HTTP/2相比于HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。虽然HTTP/2提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3就是为了解决HTTP/2所存在的一些问题而被推出来的。想阅读更多优质文章请猛戳GitHub博客一、HTTP/1.1发明以来发生了哪些变化？如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。近年来加载..."
    },
    {
      "url": "https://juejin.im/post/5dac07675188253d706643f4",
      "k": "juejin",
      "id": "4675zheoffc0",
      "author": "RetroAstro",
      "title": "面试时面试官想要听到什么答案（关于一些vue的问题）",
      "time": "1天前",
      "detail": "前言自己也只是一个前端的小白，因为公司大佬都比较忙，面试这种事就落到了我这小白身上，第一次叫我去的时候我是百般拒绝的，因为自己还是有自知之明的，但是别人实在抽不开身，没办法只能去了，他们开玩笑说就按你这水平来就行了，啥时候你问不住了就让他来复试就行。前前后后也面了一些人，加上自己面试时候整理的一些问题，写了这篇文章，感谢拨冗翻阅拙作,敬请斧正。下面进入正文，本文会列举一些平时面试时问到的问题和答案，并说明我在当时问到这个问题时所期望对方的回答：vue生命周期（钩子函数）问题请说一下vue的生命周..."
    },
    {
      "url": "https://juejin.im/post/5dafe42451882576534d3858",
      "k": "juejin",
      "id": "6p4srivrerw0",
      "author": "JessicaC",
      "title": "Vue.js 3.x 源码解析先导",
      "time": "23小时前",
      "detail": "前言2018年6月我在慕课网发布了Vue.js2.x的源码解析课程《Vue.js源码全方位深入解析》，同时也开源了课程配套电子书。时隔一年多，Vue官方也开源了Vue.js3.x，那么在不久的将来，我也会系统化地做Vue.js3.x的源码分析，同时更新我的这门课程视频以及电子书。Vue.js3.x源码刚开源不久，很多人都非常兴奋，我也不例外。我写下这篇文章作为Vue.js3.x源码解析课程的先导片，和大家聊聊我对Vue.js源码的一些感悟。聊聊Vue.js3.xVue.js3.x目前的状态Vue..."
    },
    {
      "url": "https://juejin.im/post/5da9458ae51d4524a43077d2",
      "k": "juejin",
      "id": "2wrhcyxvq4c0",
      "author": "_Dreams",
      "title": "[译] 为什么 React Suspense 将会逆转 Web 应用开发的游戏规则 ？",
      "time": "5天前",
      "detail": "原文地址：medium.com/react-in-de…原文作者：JulianBurr在本篇文章中，我不想太深入解释有关ReactSuspense的实现细节和它内部的工作原理，因为已经有很多优秀的博客文章、视频和讨论做过这些事情了。相反，我更愿意把重点放在Suspense将会如何影响在应用开发时我们对加载状态和架构应用的思考。Suspense简要介绍鉴于有些人可能没有听说过Suspense或者根本不了解它，因此我会先给出一个关于Suspense的简要总结。在去年冰岛举行的JSConf大会上，Da..."
    },
    {
      "url": "https://juejin.im/post/5daa897c6fb9a04e3902f4e6",
      "k": "juejin",
      "id": "6arv2fu58ok0",
      "author": "xiangzhihong",
      "title": "[译] 什么将会替代 JavaScript 呢？",
      "time": "4天前",
      "detail": "原文地址：WhatReplacesJavaScript原文作者：MatthewMacDonald译文出自：掘金翻译计划本文永久链接：github.com/xitu/gold-m…译者：cyz980908校对者：江五渣,Chorer什么将会替代JavaScript呢？JavaScript正在蓬勃发展。但由于WebAssembly的出现，它的衰落可能只是一个时间问题。有些编程语言很受欢迎。而有些只是被开发人员被迫接受。对于许多程序员来说，JavaScript就是后者中的一个例子，每个前端开发人员都需..."
    },
    {
      "url": "https://juejin.im/post/5dafc3df5188257a63539c64",
      "k": "juejin",
      "id": "6e2ew3h9nio0",
      "author": "lio-mengxiang",
      "title": "移动端H5页面开发坑点指南",
      "time": "23小时前",
      "detail": "前言在平时的H5移动端开发时，我们难免会遇到各种各样的坑点，这篇文章就带着大家来看看怎么解决，文章较长，建议收藏方便以后查阅！前方高能！canvas在retina屏模糊只需要将画笔根据像素比缩放即可run(canvasEl){constcanvas=canvasEl;constctx=canvas.getContext('2d');constdevicePixelRatio=window.devicePixelRatio||1;constbackingStorePixelRatio=ctx.we..."
    }
  ]
}