{
  "searchResList": [
    {
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "k": "juejin",
      "id": "5g2zxxr5ods0",
      "author": "sing1ee",
      "title": "Node入门 » 一本全面的Node.js教程",
      "time": "3年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>劝了别人无数次，让别人喝了鸡汤，帮别人填坑，自己却掉了坑</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">1.前言</h2>\n<p>在前端学习里面，很多人都是注重学习代码（html，css，js）。或者是一些框架，库（jquery，vue，react）,或者是各种工具（webpack，gulp）。在以往的文章里面，或者自己和别人交谈，都有建议过别人多练，不要闷头就写代码，多深入了解当中的原理，学习..."
    },
    {
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "k": "juejin",
      "id": "4q42z5xe10u0",
      "author": "有赞技术",
      "title": "Node 在有赞的实践",
      "time": "1年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p></p><figure><img atr=\"iPhone\" style class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2017/2/27/a880a658267c6f9dd572e123855ba9a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"htt..."
    },
    {
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "k": "juejin",
      "id": "5i9rpf0nsqk0",
      "author": "jsliang",
      "title": "Node - 从0基础到实战企业官网",
      "time": "10月前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<div data-note-content class=\"show-content\">\n                    <p><strong>editText默认的属性里面是没有金额类型的，所以要实现这个功能我们就必须自己动手丰衣足食。</strong></p>\n                    <h3 data-id=\"heading-0\">一.EditText只允许输入数字、小数点。</h3>\n                    <p>首先要知道金额有两部分构成，整数部分..."
    },
    {
      "url": "https://www.jianshu.com/p/f3e10a011381",
      "k": "jianshu",
      "id": "1w0tcl55n2w0",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "time": "\n            4 个月前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "<p>(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1..."
    },
    {
      "url": "https://www.jianshu.com/p/f8b105bb2b13",
      "k": "jianshu",
      "id": "2tka21f8v9u0",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "time": "\n            1 年前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "<p>呃呃呃额额</p>..."
    },
    {
      "url": "https://juejin.im/post/5b2f4790e51d45589e7bd63d",
      "k": "juejin",
      "id": "ic495dxv4m8",
      "author": "守候i",
      "title": "[杂谈]了解一些额外知识，让前端开发锦上添花",
      "time": "1年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/58b39488128fe1006ce40bde",
      "k": "juejin",
      "id": "1kc9x25z6g4g",
      "author": "jkpang",
      "title": "iOS与macOS中一款优雅的数字/金额增减动效控件(支付宝内金额增加效果)",
      "time": "2年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/entry/59b886186fb9a00a402dcc51",
      "k": "juejin",
      "id": "2rfrtkuuc8y0",
      "author": "994866755",
      "title": "Android EditText 输入金额类型",
      "time": "2年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://www.jianshu.com/p/9dfd42422fb7",
      "k": "jianshu",
      "id": "1z9w03w4yfz4",
      "author": "大王叫我来巡山_e04b",
      "title": "呃呃呃额额的",
      "time": "\n            2 年前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article"
    },
    {
      "url": "https://www.jianshu.com/p/a08751d64e5c",
      "k": "jianshu",
      "id": "3fbgmt4wy100",
      "author": "宇宙肉丸",
      "title": "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyywbn阿鲁科目他爸爸巴巴爸爸Babe呃呃呃额额的呃呃呃额额的得得得得得得的呃呃呃额额的呃呃呃额额的呃呃呃额额的呃呃呃额额的呃呃呃额额的",
      "time": "\n            2 年前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article"
    }
  ],
  "hotArticleDetailList": [
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-2\">2.css3的新特性</h4>\n<blockquote>\n<p>transtion\ntransition-property 规定设置过渡效果的 CSS 属性的名称。</p>\n</blockquote>\n<blockquote>\n<p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p>\n</blockquote>\n<blockquote>\n<p>transition-timing-function 规定速度效果的速度曲线。</p>\n</blockquote>\n<blockquote>\n<p>transition-delay 定义过渡效果何时开始。</p>\n</blockquote>\n<blockquote>\n<p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p>\n</blockquote>\n<blockquote>\n<p>ainimation实现动画效果主要由两部分组成：</p>\n</blockquote>\n<blockquote>\n<p>通过类似Flash动画中的帧来声明一个动画；</p>\n</blockquote>\n<blockquote>\n<p>在animation属性中调用关键帧声明的动画。</p>\n</blockquote>\n<blockquote>\n<p>translate 3D建模效果</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-3\">3.img中alt和title的区别</h4>\n<blockquote>\n<p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。</p>\n</blockquote>\n<blockquote>\n<p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-4\">4.用纯CSS创建一个三角形</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n    div {\n        width: 0;\n        height: 0;\n        border-top: 40px solid transparent;\n        border-left: 40px solid transparent;\n        border-right: 40px solid transparent;\n        border-bottom: 40px solid <span class=\"hljs-comment\">#ff0000;</span>\n    }\n    </style>\n</head>\n<body>\n  <div></div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-5\">5.如何理解CSS的盒子模型？</h4>\n<blockquote>\n<p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p>\n</blockquote>\n<blockquote>\n<p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-6\">6.如何让一个div水平居中</h4>\n<blockquote>\n<p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p>\n</blockquote>\n<blockquote>\n<p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-7\">7.如何让一个div水平垂直居中</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">div {\nposition: relative / fixed; /* 相对定位或绝对定位均可 */\nwidth:500px;\nheight:300px;\ntop: 50%;\nleft: 50%;\nmargin-top:-150px;\nmargin-left:-250px;\n 外边距为自身宽高的一半 */\nbackground-color: pink; /* 方便看效果 */\n }\n\n.container {\ndisplay: flex;\nalign-items: center; /* 垂直居中 */\njustify-content: center; /* 水平居中 */\n \n}\n.container div {\nwidth: 100px; /* 可省 */\nheight: 100px; /* 可省 */\nbackground-color: pink; /* 方便看效果 */\n}  \n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-8\">8.如何清除浮动？</h4>\n<blockquote>\n<p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式\n{clear:both;height:0;overflow:hidden;}</p>\n</blockquote>\n<blockquote>\n<p>给浮动元素父级设置高度</p>\n</blockquote>\n<blockquote>\n<p>父级同时浮动（需要给父级同级元素添加浮动）</p>\n</blockquote>\n<blockquote>\n<p>父级设置成inline-block，其margin: 0 auto居中方式失效</p>\n</blockquote>\n<blockquote>\n<p>给父级添加overflow:hidden 清除浮动方法</p>\n</blockquote>\n<blockquote>\n<p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">float_div:after{\ncontent:<span class=\"hljs-string\">\".\"</span>;\nclear:both;\ndisplay:block;\nheight:0;\noverflow:hidden;\nvisibility:hidden;\n}\n.float_div{\nzoom:1\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-9\">9.css3实现三栏布局，左右固定，中间自适应</h4>\n<blockquote>\n<p>圣杯布局/双飞翼布局</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .middle,\n        .left,\n        .right {\n            position: relative;\n            <span class=\"hljs-built_in\">float</span>: left;\n            min-height: 130px;\n        }\n        .container {\n            padding: 0 220px 0 200px;\n            overflow: hidden;\n        }\n        .left {\n            margin-left: -100%;\n            left: -200px;\n            width: 200px;\n            background: red;\n        }\n        .right {\n            margin-left: -220px;\n            right: -220px;\n            width: 220px;\n            background: green;\n        }\n        .middle {\n            width: 100%;\n            background: blue;\n            word-break: <span class=\"hljs-built_in\">break</span>-all;\n        }\n    </style>\n</head>\n<body>\n    <div class=<span class=\"hljs-string\">'container'</span>>\n        <div class=<span class=\"hljs-string\">'middle'</span>></div>\n        <div class=<span class=\"hljs-string\">'left'</span>></div>\n        <div class=<span class=\"hljs-string\">'right'</span>></div>\n    </div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">10.display:none 和 visibility: hidden的区别</h4>\n<blockquote>\n<p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>\n</blockquote>\n<blockquote>\n<p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-11\">11.CSS中 link 和@import 的区别是？</h4>\n<blockquote>\n<p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p>\n</blockquote>\n<blockquote>\n<p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p>\n</blockquote>\n<blockquote>\n<p>link方式的样式的权重 高于@import的权重.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-12\">12.position的absolute与fixed共同点与不同点</h4>\n<blockquote>\n<p>共同点：\n改变行内元素的呈现方式，display被置为block\n让元素脱离普通流，不占据空间\n默认会覆盖到非定位元素上</p>\n</blockquote>\n<blockquote>\n<p>不同点：\nabsolute的”根元素“是可以设置的\nfixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-13\">13..transition和animation的区别</h4>\n<blockquote>\n<p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</p>\n</blockquote>\n<blockquote>\n<p>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始\nanimation  指定要绑定到选择器的关键帧的名称</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-14\">14.CSS优先级</h4>\n<pre><code class=\"copyable\">不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性\n\t1.属性后面加!import 会覆盖页面内任何位置定义的元素样式\n\t2.作为style属性写在元素内的样式\n\t3.id选择器\n\t4.类选择器\n\t5.标签选择器\n\t6.通配符选择器（*）\n\t7.浏览器自定义或继承\n**同一级别：后写的会覆盖先写的**\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-15\">15.雪碧图：</h4>\n<pre><code class=\"copyable\">        多个图片集成在一个图片中的图\n\t使用雪碧图可以减少网络请求的次数，加快允许的速度\n\t通过background-position，去定位图片在屏幕的哪个位置\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-16\">二、JS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-17\">1.typeof和instance of 检测数据类型有什么区别？</h4>\n<blockquote>\n<p>相同点：\n都常用来判断一个变量是否为空，或者是什么类型的。</p>\n</blockquote>\n<blockquote>\n<p>不同点：\ntypeof\t\t返回值是一个字符串，用来说明变量的数据类型\ninstanceof        用于判断一个变量是否属于某个对象的实例.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-18\">16.使元素消失的方法</h4>\n<pre><code class=\"copyable\">visibility:hidden、display:none、z-index=-1、opacity：0\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发\n2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-19\">.谈一谈深克隆和浅克隆？</h4>\n<blockquote>\n<p>浅克隆:\n只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p>\n</blockquote>\n<blockquote>\n<p>深克隆：\n创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\nJSON.parse、JSON.stringify()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-20\">3.es6的新特性都有哪些？</h4>\n<blockquote>\n<p>let定义块级作用域变量\n没有变量的提升，必须先声明后使用\nlet声明的变量，不能与前面的let，var，conset声明的变量重名</p>\n</blockquote>\n<blockquote>\n<p>const 定义只读变量\nconst声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改\nconst声明变量也是一个块级作用域变量\nconst声明的变量没有“变量的提升”，必须先声明后使用\nconst声明的变量不能与前面的let， var ， const声明的变量重\nconst定义的对象\\数组中的属性值可以修改,基础数据类型不可以</p>\n</blockquote>\n<blockquote>\n<p>ES6可以给形参函数设置默认值</p>\n</blockquote>\n<blockquote>\n<p>在数组之前加上三个点（...）展开运算符</p>\n</blockquote>\n<blockquote>\n<p>数组的解构赋值、对象的解构赋值</p>\n</blockquote>\n<blockquote>\n<p>箭头函数的特点\n箭头函数相当于匿名函数，是不能作为构造函数的，不能被new\n箭头函数没有arguments实参集合,取而代之用...剩余运算符解决\n箭头函数没有自己的this。他的this是继承当前上下文中的this\n箭头函数没有函数原型\n箭头函数不能当做Generator函数，不能使用yield关键字\n不能使用call、apply、bind改变箭头函数中this指向\nSet数据结构，数组去重</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-21\">4.==和===区别是什么？</h4>\n<blockquote>\n<p>=赋值</p>\n</blockquote>\n<blockquote>\n<p>==返回一个布尔值；相等返回true，不相等返回false；\n允许不同数据类型之间的比较；\n如果是不同类型的数据进行，会默认进行数据类型之间的转换；\n如果是对象数据类型的比较，比较的是空间地址</p>\n</blockquote>\n<blockquote>\n<p>=== 只要数据类型不一样，就返回false；</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-22\">5.常见的设计模式有哪些？</h4>\n<pre><code class=\"copyable\">1、js工厂模式\n2、js构造函数模式\n3、js原型模式\n4、构造函数+原型的js混合模式\n5、构造函数+原型的动态原型模式\n6、观察者模式\n7、发布订阅模式\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-23\">6.call bind apply 的区别？</h4>\n<blockquote>\n<p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p>\n</blockquote>\n<blockquote>\n<p>call()和apply()的区别就在于，两者之间的参数。</p>\n</blockquote>\n<blockquote>\n<p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p>\n</blockquote>\n<blockquote>\n<p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。\nbind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是\t直接执行该函数。他的参数和call()相同。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-24\">7.js继承方式有哪些？</h4>\n<blockquote>\n<p>原型链继承\n核心： 将父类的实例作为子类的原型</p>\n</blockquote>\n<blockquote>\n<p>构造继承\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>\n</blockquote>\n<blockquote>\n<p>实例继承\n核心：为父类实例添加新特性，作为子类实例返回</p>\n</blockquote>\n<blockquote>\n<p>拷贝继承</p>\n</blockquote>\n<blockquote>\n<p>组合继承\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现\t函数复用</p>\n</blockquote>\n<blockquote>\n<p>寄生组合继承\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实\t例方法/属性，避免的组合继承的缺点</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-25\">8.你怎样看待闭包？</h4>\n<blockquote>\n<p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-26\">9.你是如何理解原型和原型链的？</h4>\n<blockquote>\n<p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-27\">10.浏览器渲染的主要流程是什么?</h4>\n<blockquote>\n<p>将html代码按照深度优先遍历来生成DOM树。\ncss文件下载完后也会进行渲染，生成相应的CSSOM。\n当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。\n接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。\n最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-28\">11.从输入url地址到页面相应都发生了什么？</h4>\n<pre><code class=\"copyable\">1、浏览器的地址栏输入URL并按下回车。\n2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。\n4、根据IP建立TCP连接（三次握手）。\n5、HTTP发起请求。\n6、服务器处理请求，浏览器接收HTTP响应。\n7、渲染页面，构建DOM树。\n8、关闭TCP连接（四次挥手）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-29\">12.session、cookie、localStorage的区别</h4>\n<blockquote>\n<p>相同点\n都是保存在浏览器端，且同源的。</p>\n</blockquote>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li>\n<li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>\n<li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。\n存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>\n<li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>\n<li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li>\n<li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-30\">13.js中跨域方法</h4>\n<blockquote>\n<p>同源策略（协议+端口号+域名要相同）</p>\n</blockquote>\n<blockquote>\n<p>1、jsonp跨域(只能解决get）\n原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p>\n<blockquote>\n<p>步骤：\n1).去创建一个script标签\n2).script的src属性设置接口地址\n3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据\n4).通过定义函数名去接受返回的数据</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>2、document.domain 基础域名相同 子域名不同</p>\n</blockquote>\n<blockquote>\n<p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p>\n</blockquote>\n<blockquote>\n<p>4、服务器设置对CORS的支持\n原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>\n</blockquote>\n<blockquote>\n<p>5、利用h5新特性window.postMessage()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-31\">14.前端有哪些页面优化方法?</h4>\n<ul>\n<li>减少 HTTP请求数</li>\n<li>从设计实现层面简化页面</li>\n<li>合理设置 HTTP缓存</li>\n<li>资源合并与压缩</li>\n<li>合并 CSS图片，减少请求数的又一个好办法。</li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li>\n<li>多图片网页使用图片懒加载。</li>\n<li>在js中尽量减少闭包的使用</li>\n<li>尽量合并css和js文件</li>\n<li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li>\n<li>减少对DOM的操作</li>\n<li>在JS中避免“嵌套循环”和 “死循环”</li>\n<li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-32\">15.Ajax的四个步骤</h4>\n<blockquote>\n<p>1.创建ajax实例</p>\n</blockquote>\n<blockquote>\n<p>2.执行open 确定要访问的链接 以及同步异步</p>\n</blockquote>\n<blockquote>\n<p>3.监听请求状态</p>\n</blockquote>\n<blockquote>\n<p>4.发送请求</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-33\">16.数组去重的方法</h4>\n<blockquote>\n<p>ES6的set对象\n先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> unique(arr){\n    var arr2 = arr.sort();\n    var res = [arr2[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr2.length;i++){\n        <span class=\"hljs-keyword\">if</span>(arr2[i] !== res[res.length-1]){\n        res.push(arr2[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> res;\n}\n利用下标查询\n <span class=\"hljs-keyword\">function</span> unique(arr){\n    var newArr = [arr[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr.length;i++){\n        <span class=\"hljs-keyword\">if</span>(newArr.indexOf(arr[i]) == -1){\n        newArr.push(arr[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> newArr;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-34\">17.ajax中get和post请求的区别</h4>\n<ul>\n<li>get 一般用于获取数据</li>\n<li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li>\n<li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li>\n<li>get安全性较低</li>\n<li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li>\n<li>post 一般用于发送数据</li>\n<li>post传递参数，需要把参数放进请求体中，发送给服务器；</li>\n<li>post请求参数放进了请求体中，对大小没有要求；</li>\n<li>post安全性比较高；</li>\n<li>post请求不会走缓存；</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-35\">18.ajax的状态码</h4>\n<blockquote>\n<p>2开头</p>\n</blockquote>\n<ul>\n<li>200 : 代表请求成功；</li>\n</ul>\n<blockquote>\n<p>3开头</p>\n</blockquote>\n<ul>\n<li>301 : 永久重定向；</li>\n<li>302: 临时转移</li>\n<li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li>\n<li>307:临时重定向</li>\n</ul>\n<blockquote>\n<p>以4开头的都是客户端的问题；</p>\n</blockquote>\n<ul>\n<li>400 :数据/格式错误</li>\n<li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li>\n<li>404 : 路径错误，找不到文件</li>\n</ul>\n<blockquote>\n<p>以5开头都是服务端的问题</p>\n</blockquote>\n<ul>\n<li>500 : 服务器的问题</li>\n<li>503: 超负荷；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-36\">19.移动端的兼容问题</h4>\n<ul>\n<li>给移动端添加点击事件会有300S的延迟\n如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟\n一般在移动端用ontouchstart、ontouchmove、ontouchend</li>\n<li>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上\n尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。\n用fastclick，<a target=\"_blank\" href=\"https://github.com/ftlabs/fastclick\" rel=\"nofollow noopener noreferrer\">github.com/ftlabs/fast…</a>\n用preventDefault阻止a标签的click\n消除 IE10 里面的那个叉号\ninput:-ms-clear{display:none;}</li>\n<li>设置缓存\n手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</li>\n</ul>\n\n<ul>\n<li>圆角BUG\n某些Android手机圆角失效\nbackground-clip: padding-box;\n防止手机中网页放大和缩小\n这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</li>\n</ul>\n\n<ul>\n<li>设置用户截止缩放，一般写视口的时候就已经写好了。</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-37\">20.JS中同步和异步,以及js的事件流</h4>\n<blockquote>\n<p>同步：在同一时间内做一件事情</p>\n</blockquote>\n<blockquote>\n<p>异步：在同一时间内做多个事情\nJS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-38\">21.JS中常见的异步任务</h4>\n<blockquote>\n<p>定时器、ajax、事件绑定、回调函数、async await、promise</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-39\">22.TCP的三次握手和四次挥手</h4>\n<blockquote>\n<p>三次握手</p>\n</blockquote>\n<ul>\n<li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li>\n<li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li>\n<li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li>\n</ul>\n<blockquote>\n<p>四次挥手</p>\n</blockquote>\n<ul>\n<li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li>\n<li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li>\n<li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li>\n<li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-40\">23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4>\n<blockquote>\n<blockquote>\n<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-41\">24.DOM diff原理</h4>\n<blockquote>\n<ul>\n<li>如果元素类型发生变化，直接替换</li>\n<li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-42\">25.作用域</h4>\n<blockquote>\n<p>全局作用域</p>\n</blockquote>\n<ul>\n<li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域\n一个页面只有一个全局作用域，全局作用域下有一个window对象\nwindow是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下）\n如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值\n如果变量只被var过，那么存储值是undefined\n在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li>\n</ul>\n<blockquote>\n<p>私有作用域</p>\n</blockquote>\n<ul>\n<li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域）\n私有作用域在全局作用域中形成，具有包含的关系；\n在一个全局作用域中，可以有很多个私有作用域\n在私有作用域下定义的变量都是私有变量\n形参也是私有变量\n函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li>\n</ul>\n<blockquote>\n<p>块级作用域</p>\n</blockquote>\n<ul>\n<li>es6中新引入的一种作用域\n在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域\nvar obj = {} //对象的大括号不是块级作用域\n块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错）\n作用域链</li>\n</ul>\n<blockquote>\n<p>上级作用域</p>\n</blockquote>\n<ul>\n<li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系\n作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链\n当前作用域没有的，则会继续向上一级作用域查找\n当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-43\">26.Promise处理异步</h4>\n<blockquote>\n<p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式”\nnew Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)==\nPromise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行\nPromise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法)\nthen()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject\najax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-44\">27.map和forEach的区别</h4>\n<blockquote>\n<p>相同点</p>\n</blockquote>\n<ul>\n<li>都是循环遍历数组中的每一项\nforEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个\n匿名函数中的this都是指向window\n只能遍历数组</li>\n</ul>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。)\nmap()方法不会改变原始数组\nmap()方法不会对空数组进行检测\nforEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-45\">28.async await函数</h4>\n<blockquote>\n<p>async/await函数是异步代码的新方式</p>\n</blockquote>\n<blockquote>\n<p>async/await是基于promise实现的</p>\n</blockquote>\n<blockquote>\n<p>async/await使异步代码更像同步代码</p>\n</blockquote>\n<blockquote>\n<p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p>\n</blockquote>\n<blockquote>\n<p>默认返回一个promise实例，不能被改变</p>\n</blockquote>\n<blockquote>\n<p>await下面的代码是异步，后面的代码是同步的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-46\">29.this指向</h4>\n<blockquote>\n<ul>\n<li>全局作用域下的this指向window</li>\n<li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li>\n<li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li>\n<li>自执行函数中的this永远指向window</li>\n<li>定时器中函数的this指向window</li>\n<li>构造函数中的this指向当前的实例</li>\n<li>call、apply、bind可以改变函数的this指向</li>\n<li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-47\">30.原型</h4>\n<blockquote>\n<blockquote>\n<p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象\nprototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类\n所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-48\">31.异步回调（如何解决回调地狱）</h4>\n<pre><code class=\"copyable\">promise、generator、async/await\n\npromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理\n\t  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱\n\t  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）\n\t  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败\n\t\tpromise.all() 里面状态都改变，那就会输出，得到一个数组\n\t\tpromise.race() 里面只有一个状态变为rejected或者fulfilled即输出\n\t\tpromis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-49\">32.前端事件流</h4>\n<pre><code class=\"copyable\">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。\n      3、冒泡阶段：事件又传播回文档\n   阻止冒泡事件event.stopPropagation()\n\t  function stopBubble(e) {\n    \t\tif (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器\n      \t\te.stopPropagation()\n    \t\t} else {\n      \t\twindow.event.cancelBubble = true //IE方式阻止冒泡\n    \t      }\n  \t\t   }\n   阻止默认行为event.preventDefault()\n function stopDefault(e) {\n    if (e && e.preventDefault) {\n      e.preventDefault()\n    } else {\n      // IE浏览器阻止函数器默认动作的行为\n      window.event.returnValue = false\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-50\">33.事件如何先捕获后冒泡？</h4>\n<blockquote>\n<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，\n对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>\n</blockquote>\n<ul>\n<li>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter\n焦点事件：blur focus\nUI事件：scroll resize</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-51\">34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4>\n<pre><code class=\"copyable\">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。\n对于引用类型：除function，都返回object   null返回object。</p>\n</blockquote>\n<blockquote>\n<p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p>\n</blockquote>\n<blockquote>\n<p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>\n</blockquote>\n<blockquote>\n<p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p>\n</blockquote>\n<blockquote>\n<p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-52\">35.setTimeout 和 setInterval的机制</h4>\n<pre><code class=\"copyable\">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的\n待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-53\">36.splice和slice、map和forEach、 filter()、reduce()的区别</h4>\n<pre><code class=\"copyable\"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，\n 包含从start到end（不包含该元素）的数组方法\n\t注意：该方法不会更新原数组，而是返回一个子数组\n 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）\n\tsplice(index, howmany,item1,...itemx)\n\t\t·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置\n\t\t·howmany参数：必须，要删除的数量，\n\t\t·item1..itemx:可选，向数组添加新项目\n3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据\n4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素\n5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值\n6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-54\">VUE问题</h1>\n<h4 class=\"heading\" data-id=\"heading-55\">1.聊聊对vue的理解</h4>\n<blockquote>\n<p>vue是一个渐进式的JS框架。他易用，灵活，高效；\n可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用；\n他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-56\">2.V-model的原理是什么？</h4>\n<blockquote>\n<p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。\n数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。\n在数据变动时作你想做的事</p>\n<ul>\n<li>原理\n通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新\n在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-57\">3.谈谈对生命周期的理解</h4>\n<ul>\n<li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li>\n<li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li>\n<li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li>\n<li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li>\n<li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li>\n<li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li>\n<li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li>\n<li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-58\">4.VUE和REACT有什么区别？</h4>\n<blockquote>\n<p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p>\n</blockquote>\n<blockquote>\n<p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-59\">5.vuex的流程</h4>\n<pre><code class=\"copyable\">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。\nmutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中\n通过mapGetter来动态获取state中的值\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-60\">6.vuex有哪几种状态和属性</h4>\n<blockquote>\n<ul>\n<li>state中保存着共有数据，数据是响应式的</li>\n<li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li>\n<li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li>\n<li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li>\n<li>modules：模块化vuex</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-61\">7.vue路由的两种模式</h4>\n<blockquote>\n<ul>\n<li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算）\nhash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li>\n<li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li>\n</ul>\n<p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-62\">8.vue中 key 值的作用</h4>\n<blockquote>\n<p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。\n如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>\n</blockquote>\n<blockquote>\n<p>key的作用主要是为了高效的更新虚拟DOM。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-63\">9<code>$route</code>和<code>$router</code>的区别</h4>\n<blockquote>\n<ul>\n<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>\n<li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-64\">10.vue-router守卫</h4>\n<blockquote>\n<ul>\n<li>导航守卫 router.beforeEach 全局前置守卫</li>\n</ul>\n</blockquote>\n<ul>\n<li>to: Route: 即将要进入的目标（路由对象）</li>\n<li>from: Route: 当前导航正要离开的路由</li>\n<li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）\n执行效果依赖 next 方法的调用参数。</li>\n<li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li>\n<li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// main.js 入口文件\n    import router from <span class=\"hljs-string\">'./router'</span>; // 引入路由\n    router.beforeEach((to, from, next) => { \n      next();\n    });\n    router.beforeResolve((to, from, next) => {\n      next();\n    });\n    router.afterEach((to, from) => {\n      console.log(<span class=\"hljs-string\">'afterEach 全局后置钩子'</span>);\n    });\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const router = new VueRouter({\n  routes: [\n    {\n      path: <span class=\"hljs-string\">'/foo'</span>,\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开\n    // 可以访问组件实例 `this`\n    // 比如还未保存草稿，或者在用户离开前，\n    将<span class=\"hljs-built_in\">set</span>Interval销毁，防止离开之后，定时器还在调用。\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-65\">11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4>\n<blockquote>\n<p>请求后台资源的模块。</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">$ npm install axios -S装好\n<span class=\"copy-code-btn\">复制代码</span></code></pre><blockquote>\n<p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。\njs中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-66\">12.vue修饰符</h4>\n<ul>\n<li>stop：阻止事件的冒泡</li>\n<li>prevent：阻止事件的默认行为</li>\n<li>once：只触发一次</li>\n<li>self：只触发自己的事件行为时，才会执行</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-67\">13.vue项目中的性能优化</h4>\n<blockquote>\n<p>1.不要在模板里面写过多表达式</p>\n</blockquote>\n<blockquote>\n<p>2.循环调用子组件时添加key</p>\n</blockquote>\n<blockquote>\n<p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p>\n</blockquote>\n<blockquote>\n<p>4.尽量少用float，可以用flex</p>\n</blockquote>\n<blockquote>\n<p>5.按需加载，可以用require或者import()按需加载需要的组件</p>\n</blockquote>\n<blockquote>\n<p>6.路由懒加载</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-68\">14.vue.extend和vue.component</h4>\n<blockquote>\n<ul>\n<li>extend\n是构造一个组件的语法器。\n然后这个组件你可以作用到Vue.component这个全局注册方法里\n还可以在任意vue模板里使用组件。\n也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li>\n<li>Vue.component\n你可以创建 ，也可以取组件。</li>\n</ul>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-69\">常见的兼容问题</h3>\n<blockquote>\n<p>png24位的图片在iE6浏览器上出现背景\n解决方案是做成PNG8.也可以引用一段脚本处理.</p>\n</blockquote>\n<blockquote>\n<p>浏览器默认的margin和padding不同。\n解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>\n</blockquote>\n<blockquote>\n<p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>\n</blockquote>\n<blockquote>\n<p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-70\">React问题</h1>\n<h4 class=\"heading\" data-id=\"heading-71\">1.react和vue的区别</h4>\n<pre><code class=\"copyable\">   =>  相同点：\n\t1.数据驱动页面，提供响应式的试图组件\n\t2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n\t3.数据流动单向，都支持服务器的渲染SSR\n\t4.都有支持native的方法，react有React native， vue有wexx\n=>  不同点：\n\t1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n\t2.数据渲染：大规模的数据渲染，react更快\n\t3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n\t4.开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\t\t    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-72\">2.redux中的reducer（纯函数）</h4>\n<pre><code class=\"copyable\">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）\n更新state(这个state可以理解为上下累加器的结果）\n每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),\n进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-73\">3.react的refs</h4>\n<pre><code class=\"copyable\">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，\n它将接受地城dom元素或组件的已挂在实例，作为第一个参数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-74\">4.react中的keys</h4>\n<pre><code class=\"copyable\">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-75\">5.React的生命周期</h4>\n<pre><code class=\"copyable\">三个状态：Mounting(已插入真实的DOM）\n\t  Updating(正在被重新渲染)\n\t  Unmounting(已移除真实的DOM)\ncomponentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，\ncomponentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-76\">6.React子组件向父组件传值</h4>\n<pre><code class=\"copyable\">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-77\">7.为什么虚拟DOM会提高性能 <a target=\"_blank\" href=\"https://www.zhihu.com/question/29504639?sort=created\" rel=\"nofollow noopener noreferrer\">www.zhihu.com/question/29…</a></h4>\n<pre><code class=\"copyable\">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能\n具体实现步骤：\n\t·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中\n        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异\n\t·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-78\">8.diff算法</h4>\n<pre><code class=\"copyable\">1.把树形结构按照层级分解，只比较同级元素\n2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记\n3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面\nVritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用\nreact只会匹配相同的class的component（这里的class指的是组件的名字）\n合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制\n4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-79\">9.简述下flux的思想</h4>\n<pre><code class=\"copyable\">flux的最大特点，就是数据的‘单向流动’\n1.用户访问View\n2.View发出用户的Action\n3.Dispatcher收到Action,要求state进行相应的更新\n4.store更新后，发出一个‘change’事件后，更新页面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-80\">10.reac性能优化是哪个周期函</h4>\n<pre><code class=\"copyable\">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，\n如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-81\">11.react怎么划分业务组件和技术组件</h4>\n<pre><code class=\"copyable\">根据组件的职责通常把组件分为UI组件和容器组件\nUI组件负责UI的呈现，容器组件负责管理数据和逻辑\n两者通过React-redux提供connect方法联系起来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-82\">12.setState</h4>\n<pre><code class=\"copyable\">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列\n而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值\t\n那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误\n\n同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state\n\n同步更新state:\n\tsetState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。\n\t第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行\n\t也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步\n\n例子：componentDidMount() {\n\n\tfetch('https://test.com')\n    \n\t.then((res) => res.json())\n    \n\t.then(\n    (data) => {\nthis.setState({ data:data });\n\t\t\tStatusBar.setNetworkActivityIndicatorVisible(false);\n        }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-83\">性能优化</h1>\n<h4 class=\"heading\" data-id=\"heading-84\">一、webpack打包文件体积过大？（最终打包为一个js文件）</h4>\n<pre><code class=\"copyable\">1.异步加载模块\n2.提取第三库\n3.代码压缩\n4.去除不必要的插件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-85\">二、如何优化webpack构建的性能</h4>\n<pre><code class=\"copyable\">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积\n\t\t 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理\n\t\t 3.对一些组件库采用按需加载，避免无用的代码\n二、减少目录检索范围\n\t\t ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度\n\t\n三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-86\">三、移动端的性能优化</h4>\n<pre><code class=\"copyable\">  1、首屏加载和按需加载，懒加载\n  2、资源预加载\n  3、图片压缩处理，使用base64内嵌图片\n  4、合理缓存dom对象\n  5、使用touchstart代替click（click 300毫秒的延迟）\n  6、利用transform:translateZ(0)，开启硬件GUP加速\n  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明\n  8、使用viewport固定屏幕渲染，加速页面渲染内容\n  9、尽量使用事件代理，避免直接事件绑定\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-87\">四、Vue的SPA 如何优化加载速度</h4>\n<pre><code class=\"copyable\">1.减少入口文件体积\n2.静态资源本地缓存\n3.开启Gzip压缩\n4.使用SSR,nuxt.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-88\">五、移动端300ms延迟</h4>\n<pre><code class=\"copyable\">由来：\n300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，\n当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作\n因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕\n       \n解决方案：1.禁用缩放，设置meta标签 user-scalable=no\n\t  2.fastclick.js\n\t\t原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即\n\t\t      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉\nfastclick.js还可以解决穿透问题\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-89\">六、页面的重构；</h4>\n<blockquote>\n<p>在不改变外部行为的前提下，简化结构、添加可读性</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-90\">服务器端</h1>\n<h4 class=\"heading\" data-id=\"heading-91\">一、状态码：</h4>\n<pre><code class=\"copyable\">  2XX（成功处理了请求状态）\n      200 服务器已经成功处理请求，并提供了请求的网页\n      201 用户新建或修改数据成功\n      202 一个请求已经进入后台\n      204 用户删除成功\n  3XX（每次请求使用的重定向不要超过5次）\n      304 网页上次请求没有更新，节省带宽和开销\n  4XX（表示请求可能出错，妨碍了服务器的处理）\n      400 服务器不理解请求的语法\n      401 用户没有权限（用户名，密码输入错误）\n      403 用户得到授权（401相反），但是访问被禁止\n      404 服务器找不到请求的网页，\n  5XX（表示服务器在处理请求的时候发生内部错误）\n      500 服务器遇到错误，无法完成请求\n      503 服务器目前无法使用（超载或停机维护）     \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-92\">二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4>\n<pre><code class=\"copyable\">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）\n2.304是\tHTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件\n3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A\n\t并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304\n\nlast-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间\n\t\t客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，\n\t\t询问该事件之后文件是否被修改，没修改返回304\n\n 有了Last-Modified，为什么还要用ETag？\n  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）\n  2、某些服务器不能精确的得到文件的最后修改时间\n  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get\n\nETag，为什么还要用Last-Modified？\n  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改\n  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。\n\n\nETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）\n  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-93\">三、get/post的区别</h4>\n<pre><code class=\"copyable\">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提交的数据放在http包的Body中\n2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制\n3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值\n4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-94\">四、http协议的理解</h4>\n<pre><code class=\"copyable\">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议\n2.基于TCP/IP通信协议来传递数据（HTML，图片资源）\n3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统\n4.http请求信息request：\n\t请求行（request line）、请求头部（header）,空行和请求数据四部分构成\n\n\t请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\t请求头部，用来说明服务器要使用的附加信息\n\t空行，请求头部后面的空行是必须的\n\t请求数据也叫主体，可以添加任意的其他数据。\n5.http相应信息Response\n\t状态行、消息报头、空行和响应正文\n\n\t状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成\n\t消息报头，用来说明客户端要使用的一些附加信息\n\t空行，消息报头后面的空行是必须的\n\t响应正文，服务器返回给客户端的文本信息。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-95\">五、http和https</h4>\n<pre><code class=\"copyable\">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密\nhttp：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-96\">六、http1.0 1.1 2.0的区别</h4>\n<pre><code class=\"copyable\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-97\">七、web缓存</h4>\n<pre><code class=\"copyable\">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本\n2.缓存的好处\n        （1）减少不必要的请求\n    （2）降低服务器的压力，减少服务器的消耗\n    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-98\">八、常见的web安全及防护原理</h4>\n<pre><code class=\"copyable\">1.sql注入原理：通郭sql命令插入到web表单递交或者输入活命，达到欺骗服务器执行的恶意sql命令\n\t\t防范：1.对用户输入进行校验\n\t\t       2.不适用动态拼接sql\n2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。\n\t\t        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息\n\t\t\t防范：1.尽量采用post而不使用get提交表单\n\t\t\t      2.避免cookie中泄漏用户的隐式\n3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求\n\t\t\t举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据\n\t\t\t防范：在客服端页面增加伪随机数，通过验证码\nXSS和CSRF的区别：\n   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包\n   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-99\">九、CDN（内容分发网络）</h4>\n<pre><code class=\"copyable\">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。\n2.关键技术：内容存储和分发技术中\n3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术\n\t    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-100\">十、TCP三次握手\t(客服端和服务器端都需要确认各自可收发）</h4>\n<pre><code class=\"copyable\">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。\n第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段\n第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段\n第三次握手： 服务器端确认客服端收到了自己发送的报文段\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-101\">十一、从输入url到获取页面的完整过程  <a target=\"_blank\" href=\"https://blog.csdn.net/samjustin1/article/details/52650520\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/samjustin1/…</a></h4>\n<pre><code class=\"copyable\">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存\n2.浏览器与服务器建立tcp链接（三次握手）\n3.浏览器向服务器发送http请求(请求和传输数据）\n4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器\n5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤\n6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-102\">十二、浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print</h4>\n<pre><code class=\"copyable\">流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树\n概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树\n      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）\n      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置\n      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点\n\n重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上\n\t触发重绘的条件：改变元素外观属性。如：color，background-color等\n\t重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观\n注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局\n\n重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。\n\t每个页面都需要一次回流，就是页面第一次渲染的时候\n\n重排一定会影响重绘，但是重绘不一定会影响重排\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-103\">十三、为什么css放在顶部而js写在后面</h4>\n<pre><code class=\"copyable\">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了\n2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。\n3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验\n\n但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-104\">十四、存储方式与传输方式</h4>\n<pre><code class=\"copyable\">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m\n2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响\n3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）\n4.localStroage: h5的本地存储，数据永久保存在客服端\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-105\">cookie，sessionStorage，localStorage</h4>\n<p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上\n实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象\nsession存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据\n2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id\nsessionStorage，localStorage仅在本地保存\n3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB\n4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭\nsessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储）\nlocalStorage始终有效</p>\n<p>SessionStorage和localStorage区别：\n1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中）\n并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存\n2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p>\n<h4 class=\"heading\" data-id=\"heading-106\">token、cookie、session三者的理解？？？！！！</h4>\n<pre><code class=\"copyable\">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）\n    用户身份的验证方式    \n\n2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名\n    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）\n\n3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）\n    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-107\">基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4>\n<pre><code class=\"copyable\">  1、用户通过用户名和密码发送请求\n  2、服务器端验证\n  3、服务器端返回一个带签名的token，给客户端\n  4、客户端储存token，并且每次用于发送请求\n  5、服务器验证token并且返回数据\n  每一次请求都需要token\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-108\">cookie与session区别</h4>\n<pre><code class=\"copyable\">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。\n  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-109\">session与token区别</h4>\n<pre><code class=\"copyable\">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App\n  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，\n     token不能转移到其他的App，也不能转到其他用户上。（适用于App）\n  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-110\">Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4>\n<pre><code class=\"copyable\">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）\n  2、安全性问题。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-111\">设计模式</h1>\n<blockquote>\n<p>一、观察者模式：<a target=\"_blank\" href=\"https://juejin.im/post/5a14e9edf265da4312808d86\" rel>juejin.im/post/5a14e9…</a>   <a target=\"_blank\" href=\"https://juejin.im/post/5af05d406fb9a07a9e4d2799\" rel>juejin.im/post/5af05d…</a>\n在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系\n简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p>\n</blockquote>\n<blockquote>\n<p>二、发布-订阅者  有一个信息中介，过滤 耦合性低\n它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p>\n</blockquote>\n<ul>\n<li>-两者的区别：\n1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信\n2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。\n3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（）\n4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-112\">数据结构和算法</h1>\n<h4 class=\"heading\" data-id=\"heading-113\">一、两个栈实现一个队列，两个队列实现一个栈 <a target=\"_blank\" href=\"https://www.cnblogs.com/MrListening/p/5697459.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/MrListening…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-114\">二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a target=\"_blank\" href=\"https://juejin.im/post/5a27c6946fb9a04509096248\" rel>juejin.im/post/5a27c6…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-115\">三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a target=\"_blank\" href=\"https://juejin.im/post/5a2ff8c651882533d0230a85\" rel>juejin.im/post/5a2ff8…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-116\">四、十大排序</h4>\n<pre><code class=\"copyable\">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。\n  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个\n\t    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n\t    3.针对所有的元素重复以上的步骤，除了最后一个\n\t    4.重复步骤1-3，直到排序完成。\n2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾\n  实现过程：\n\n3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入\n  实现过程：1.从第一个元素开始，该元素可以认为已经被排序\n\t    2.取出下一个元素，在已排序的元素序列中冲后向前扫描\n\t    3.如果该元素（以排序）大于新元素，将元素向后移一位\n\t    4.在取出一个元素，比较之前的，直到找到自己合适的位置\n\n4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序\n\n1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现\n  实现过程：1.从数组中挑出一个元素，成为一个基准\n\t    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）\n\t\t这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。\n\t    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序\n算法实现： function quickSort (arr) {\n\t\tif （arr.length <= 1） {return arr}\n\t\tvar destIndex = Math.floor(arr.length/2)\n\t\tvar left = [], right = [];\n\t\tvar dest = arr.splice(destIndex,1)[0];\n\t\tfor (var i =0;i<arr.length;i++){\n\t\t\tif (arr[i]<dest) {\n\t\t\tleft.push(arr[i])\n\t\t\t} else {\n\t\t\tright.push(arr[i]) }\n\t\treturn quickSort(left).concat([dest],quickSort(right)\n\t\t\t\n\n2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。\n  实现过程：1.\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-117\">五、数组去重 <a target=\"_blank\" href=\"https://juejin.im/post/5aed6110518825671b026bed#heading-6\" rel>juejin.im/post/5aed61…</a></h4>\n<pre><code class=\"copyable\">1.双重循环\n2.indexOf\n3.数组排序去重 最快你Olong\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-118\">六、字符串</h4>\n<pre><code class=\"copyable\">判断回文字符串：（递归的思想）\n\t1.字符串分隔，倒转，聚合[...obj].reverse().join('')\n\t2.字符串头部和尾部，逐次向中间检测 \n\t\t实现：function isPalindrome(line) {\n\t\t\tline += '';\n\t\t\tfor (var i=0,j=line.length-1;i<j;i++,j--) {\n\t\t\t\tif (line.chartAt(i) !== line.chartAt(j) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t3.递归\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-119\">七、二分查找（有序数组的查找）</h4>\n<pre><code class=\"copyable\"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数\n (1) 一开始,数据范围覆盖整个数组。\n (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。\n (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T\n代码实现：function binarySearch (data, dest, start, end){\n\t\tvar end = end || data.length-1;\n\t\tvar start = start || 0;\n\t\tvar m = Math.floor((start+end)/2);\n\t\tif (dest<data[m]){\n\t\t\treturn binarySearch(data, dest, 0, m-1)\n\t\t} else {\n\t\t\treturn binarySearch(data, dest, m+1, end)\n\t\t}}\n\t\treturn false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-120\">手写代码</h1>\n<h4 class=\"heading\" data-id=\"heading-121\">一、动手实现一个bind（原理通过apply，call）</h4>\n<pre><code class=\"copyable\">一句话概括：1.bind()返回一个新函数，并不会立即执行。\n\t    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数\n\t    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Function.prototype.bind = <span class=\"hljs-keyword\">function</span> (obj, arg) {\n   var arg = Array.prototype.slice.call(arguments, 1);\n   var context = this;\n   var bound = <span class=\"hljs-keyword\">function</span> (newArg) {\n   arg = arg.concat(Array.prototype.slice.call(newArg);\n   <span class=\"hljs-built_in\">return</span> context.apply(obj, arg)\n}\n  var F =  <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {}  // 在new一个<span class=\"hljs-built_in\">bind</span>会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程\n  F.prototype = context.prototype;\n  bound.prototype =  new F();\n  <span class=\"hljs-built_in\">return</span> bound;\n}\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-122\">二、 AJAX （异步的javascript和xml）</h4>\n<pre><code class=\"copyable\">ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。\n优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载\n      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带\n劣势：不支持back。对搜索引擎的支持比较弱；不容易调试\t\n怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，\n解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> getData(url) {\n    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象\n    xhr.open(<span class=\"hljs-string\">'get'</span>, url, <span class=\"hljs-literal\">true</span>)  // 设置一个http请求，设置请求的方式，url以及验证身份\n    xhr.send() //发送一个http请求\n    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  //设置一个http请求状态的函数\n      <span class=\"hljs-keyword\">if</span> (xhr.readyState == 4 && xhr.status ==200) {\n        console.log(xhr.responseText)  // 获取异步调用返回的数据\n      }\n    }\n  }\n  Promise(getData(url)).resolve(data => data)\n\n\t AJAX状态码：0 - （未初始化）还没有调用send()方法\n\t\t     1 - （载入）已调用send方法，正在发送请求\n\t\t     2 - （载入完成呢）send()方法执行完成\n\t\t     3 - （交互）正在解析相应内容\n\t\t     4 - （完成）响应内容解析完成，可以在客户端调用了\n```\n\n<span class=\"hljs-comment\">#### 三、函数节流（throttle）</span>\n```\n <span class=\"hljs-keyword\">function</span> throttle (func, <span class=\"hljs-built_in\">wait</span>) {\n        var timeout;\n        var previous = 0;\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n            context = this;\n            args = arguments;\n            <span class=\"hljs-keyword\">if</span> (!timeout) {\n                timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                    timeout = null;\n                    func.apply(context,args)\n                }, <span class=\"hljs-built_in\">wait</span>);\n            }\n        }\n    }\n     \n}\n```\n\n<span class=\"hljs-comment\">#### 四、函数防抖（dobounce）</span>\n```\n <span class=\"hljs-keyword\">function</span> debounce (func, <span class=\"hljs-built_in\">wait</span>) {\n         var timeout;\n         <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n             var context = this;\n             var args = arguments;\n             clearTimeout(timeout);\n             timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                 func.apply(context,args)\n             }, <span class=\"hljs-built_in\">wait</span>);\n         }\n     }\n```\n\n<span class=\"hljs-comment\">#### 五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span>\n```    \n    Object.prototype.clone = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> e <span class=\"hljs-keyword\">in</span> this) { //遍历对象的属性 <span class=\"hljs-keyword\">in</span>  this[e]\n        newObject[e] = typeof this[e] === <span class=\"hljs-string\">'object'</span> ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型\n      }\n      <span class=\"hljs-built_in\">return</span> newObject\n    }\n```\n \n<span class=\"hljs-comment\">#### 六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab</span>\n```\nclass Promise {\n  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。\n    this.status = <span class=\"hljs-string\">'pending'</span>,\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功存放的数组\n    this.onResolvedCallbacks = [];\n     // 失败存放法数组\n     this.onRejectedCallbacks = [];\n    <span class=\"hljs-built_in\">let</span> resolve = (value) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'resolve'</span>;\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n\n    <span class=\"hljs-built_in\">let</span> reject = (reason) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'reject'</span>;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  } \n  <span class=\"hljs-keyword\">then</span> (onFullFilled,onRejected) {\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'resolved'</span>) {\n      onFullFilled(this.value)\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'rejectd'</span>) {\n      onRejected(this.reason);\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n      this.onResolvedCallbacks.push(()=>{\n        onFullFilled(this.value);\n      })\n      this.onRejectedCallbacks.push(()=> {\n          onRejected(this.reason);\n      })\n  }\n   \n  }\n}\n\nconst p = new Promise((resolve, reject) => {\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n      resolve(<span class=\"hljs-string\">'hello world'</span>)\n  }, 1000);\n})\np.then((data) =>{\n  console.log(data)\n},(err) =>{\n  console.log(err);\n})\n```\n\n<span class=\"hljs-comment\">#### 七、发布订阅者模式（观察者模式）</span>\n```\nvar event = {}; // 发布者\nevent.clientList = [] //发布者的缓存列表\n\nevent.listen = <span class=\"hljs-keyword\">function</span> (fn) {  // 增加订阅者函数\n  this.clientList.push(fn)\n}\n\nevent.trigger = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  // 发布信息\n  <span class=\"hljs-keyword\">for</span> (var i =0;i<this.clientList.length;i++) {\n    var fn = this.clientList[i];\n    fn.apply(this, arguments);\n  }\n}\n\nevent.listen (<span class=\"hljs-keyword\">function</span>(time) {\n  console.log(<span class=\"hljs-string\">'正式上班时间为：'</span> +time)\n})\nevent.trigger (<span class=\"hljs-string\">'2018/7'</span>)\n```\n\n<span class=\"hljs-comment\">#### 八、手动写一个node服务器</span>\n```\nconst http = require(<span class=\"hljs-string\">'http'</span>);\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\nconst server = http.createServer((req,res) => {\n\t<span class=\"hljs-keyword\">if</span> (reu.url == <span class=\"hljs-string\">'/'</span>) {\n\tconst indexFile = fs.createReadStream(<span class=\"hljs-string\">'./index.html'</span>)\n\treq.writeHead(200,{<span class=\"hljs-string\">'context-Type'</span>:<span class=\"hljs-string\">'text/html;charset = utf8})\n\tindexFile.pipe(res)\n}\nserver.listen(8080)\n```</span><span class=\"copy-code-btn\">复制代码</span></code></pre>",
      "id": "42ou4p218z40",
      "author": "第一名的小蝌蚪",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>灰色的天</p>\n<p>妳的脸</p>\n<p>说分手的语气斩钉截铁</p>\n<p>小蝌蚪：“能不走吗”</p>\n<p>女神：“不能”</p>\n<p>小蝌蚪：“那个男人有什么好”</p>\n<p>女神：“他说话好听，长得帅，还有钱”</p>\n<p>小蝌蚪：“我没房没车没存款，但我有一颗爱妳的心”</p>\n<p>高富帅出现：“我有房有车有存款，我也有一颗爱她的心”</p>\n<p>小蝌蚪：“我能跑十公里去为她买宵夜”</p>\n<p>高富帅：“我开兰博基尼去为她买宵夜”</p>\n<p>小蝌蚪：“我一分钟能敲5000行代码”</p>\n<p>高富帅：“你们公司的老板，是我爸”</p>\n<p>小蝌蚪：“这。。。”</p>\n<p>在金钱力量面前，一切言语都显得那么苍白无力</p>\n<p>小蝌蚪跪在地上，望着高富帅远去的尾灯，消失在地平线</p>\n<p>失恋第三十天，小蝌蚪上山拜佛</p>\n<p>小蝌蚪：“伟大的佛，为何我感情如此失败”</p>\n<p>佛曰：“因为你不够渣，一次只爱一个人，下次同时爱一百个试试？”</p>\n<p>小蝌蚪若有所悟</p>\n<p>小蝌蚪：“伟大的佛，那我如何才能成为江湖第一的渣男”</p>\n<p>佛说：“想要成为顶级渣男，你要闯过三关”</p>\n<p>佛：“第一关我们称之为<富婆>”</p>\n<p>佛：“一位顶级渣男，他需要有雄厚的资金来源，才能浪迹天涯，而富婆是这资金流的关键”</p>\n<h3 class=\"heading\" data-id=\"heading-0\">第一关<富婆></h3>\n<p>得到佛主的指点，小蝌蚪来到国际大酒店</p>\n<p>楼顶正举行富婆八十大寿生日宴</p>\n<p>富婆坐在轮椅上，望着舞池里的妹纸</p>\n<p>满眼都是自己十八岁的样子</p>\n<p>小蝌蚪出现：“女士，您好，我叫小蝌蚪”</p>\n<p>富婆：“有何贵干”</p>\n<p>小蝌蚪：“我想要得到妳的包养”</p>\n<p>富婆的假牙差点从嘴里喷了出来</p>\n<p>富婆：“我的包养，不是你想要，想要就能要”</p>\n<p>小蝌蚪就地表演了一段舌头碎大石</p>\n<p>富婆压制住内心的狂喜，说道：“这还不够，还差了点”</p>\n<p>小蝌蚪：“我一分钟能敲5000行代码，手速奇快”</p>\n<p>富婆大惊：“你就是我唯一的真爱~！”</p>\n<h3 class=\"heading\" data-id=\"heading-1\">第二关<渣女></h3>\n<p>成功拿下富婆后，来到第二关</p>\n<p>佛曰：“你需要撩到一个名叫 '夜魔' 的顶级渣女，通过她身上的《绝世婊技》，你才能悟出传说中的《渣男心经》”</p>\n<p>夜魔常年混迹于夜店</p>\n<p>斡旋在多名富二代之间</p>\n<p>夜魔的座右铭：“肾走多了，才明白走心的可贵”</p>\n<p>“渣男收割机”、“夜店王中王”、“叱咤级渣皇”</p>\n<p>都是她曾用的小名</p>\n<p>一位被她玩死的富二代</p>\n<p>去世前曾留下遗言：</p>\n<p>“</p>\n<p>别爱上她，相信我</p>\n<p>你只是寂寞的晚上</p>\n<p>她想要缠绵的</p>\n<p>小玩具</p>\n<p>”</p>\n<p>夜魔位列年度渣女榜榜首</p>\n<p>小蝌蚪的任务，猎杀夜魔</p>\n<p>凌晨一点，夜店</p>\n<p>小蝌蚪：“小姐姐，您好，我叫小蝌蚪”</p>\n<p>夜魔爱搭不理</p>\n<p>鲁迅说过：“在金钱面前，一切渣女都是纸老虎”</p>\n<p>小蝌蚪故意不经意间露出兰博基尼车钥匙（富婆八十大寿赠）</p>\n<p>夜魔大喜：“哥哥，请坐！”</p>\n<p>夜魔：“哥哥想喝点什么”</p>\n<p>小蝌蚪：“想喝点妳的酒窝”</p>\n<p>面对搭讪，夜魔故作脸红，假装羞涩</p>\n<p>让你觉得她是一个清纯走心的小姐姐</p>\n<p>夜魔：“我看哥哥挺有钱，哥哥职业是什么”</p>\n<p>小蝌蚪：“我的职业是职业渣男”</p>\n<p>一个低端富二代都是炫耀自己多有钱，爸爸多厉害</p>\n<p>但一个顶级富二代，从来都是说自己是渣男</p>\n<p>夜魔：“哥哥有喜欢的人吗”</p>\n<p>小蝌蚪：“有，她在别人的床上”</p>\n<p>小蝌蚪开始打感情牌，宣扬自己受过情伤</p>\n<p>唤母爱，博同情</p>\n<p>夜魔：“哥哥来找我什么事？”</p>\n<p>小蝌蚪：“想借用妳的美色和媚术，帮我攻破一个男人”</p>\n<p>夜魔：“谁？”</p>\n<p>小蝌蚪：“我”</p>\n<p>这是一个调情套路</p>\n<p>面对渣女，你要表现的比她更渣</p>\n<p>妳渣任妳渣，反正都没我渣</p>\n<p>小蝌蚪不再周旋，直接强攻</p>\n<p>小蝌蚪：“明人不说暗话，我想和妳结婚”</p>\n<p>夜魔是远近闻名的渣女，男人们只想和她暧昧</p>\n<p>面对突如其来的‘结婚’，开始手无足措</p>\n<p>小蝌蚪抓住时机，放大招</p>\n<p>谈笑间侧露价值180万的金表（富婆八十大寿赠）</p>\n<p>夜魔大惊</p>\n<p>菊花一紧，虎躯一震</p>\n<p>无数道圣光冲击她的天灵盖</p>\n<p>夜魔热泪盈眶</p>\n<p>满意的点了点头</p>\n<p>酒后三巡，意乱情迷之际</p>\n<p>小蝌蚪带她去找了妈妈</p>\n<p>深藏功与名</p>\n<h3 class=\"heading\" data-id=\"heading-2\">第三关：报复</h3>\n<p>最后一关</p>\n<p>佛曰：“第三关，报仇。报复当初甩掉你的女神和高富帅”</p>\n<p>“好的”，蝌蚪微笑，召唤出了夜魔</p>\n<p>晚八点，高档餐厅</p>\n<p>女神和高富帅在激情派对上亲亲我我</p>\n<p>夜魔出现，上台拿起话筒：</p>\n<p>“台下的小哥哥，请放下女朋友的手，你们被我包围了”</p>\n<p>现场一片哗然</p>\n<p>夜魔：“不是我针对谁，论美色，在座的各位，都是垃圾”</p>\n<p>所有人被夜魔的顶配神颜惊呆</p>\n<p>夜魔：“我会随机抽一个男人，明天和我一起起床”</p>\n<p>鲁迅说过：“我想和妳睡觉，是耍流氓。我想和妳起床，是徐志摩”</p>\n<p>男人们像疯狗一样欢呼和跪舔</p>\n<p>夜魔锁定目标</p>\n<p>径直走向高富帅：“小哥哥，你长得好像我下一任男朋友”</p>\n<p>高富帅惊慌失措：“我我我。。。已经。。。”</p>\n<p>夜魔强撩：“谈恋爱吗？二缺一”</p>\n<p>高富帅捂住心脏：“糟糕，是心动的感觉”</p>\n<p>一旁的女神暴怒：“我xx妳个xx，勾引我男人”</p>\n<p>夜魔一副柔弱装纯的样子：“我只是把他当哥哥～”</p>\n<p>女神继续：“我xx妳个xx”</p>\n<p>夜魔无辜的看着高富帅：“都怪我，害你女朋友生气了”</p>\n<p>高富帅沦陷：“不要理会那八婆”</p>\n<p>女神：“我xx妳个xx”</p>\n<p>夜魔：“她好凶，我好怕”</p>\n<p>高富帅：“不要怕，我的小心心，紫薯于妳”</p>\n<p>鲁迅说过：“渣女装纯，天下无敌”</p>\n<p>高富帅沦为了夜魔的裆下亡魂</p>\n<p>女神跪下，掩面痛哭</p>\n<p>这一切，都是小蝌蚪的精心策划</p>\n<p>佛主出现：“恭喜小蝌蚪，你成为了一位顶级渣男”</p>\n<p>小蝌蚪：“佛心四大皆空，贫僧尘念已结”</p>\n<p>佛曰：“我现赐予你法号——渣佛”</p>\n<p>佛曰：“希望你今后，随老衲去夜店降妖除魔，还人间一片净土”</p>\n<p>小蝌蚪：“哦咪陀佛”</p>\n<p>小蝌蚪终于成为了江湖第一的渣男</p>\n<p>手段虽然残忍</p>\n<p>但我们不要怪渣男渣</p>\n<p>因为每个渣男背后，都有一段刻骨铭心的虐恋</p>\n<p>每一位渣男，都曾是折翼的天使</p>\n<p>甩掉女神那天晚上</p>\n<p>小蝌蚪的肩膀上靠着富婆</p>\n<p>车里循环了一首歌：</p>\n<p>“</p>\n<p>i lost myself again</p>\n<p>我又一次迷失了自己</p>\n<p>but i still remember you</p>\n<p>脑海中的妳依然那么深刻</p>\n<p>don't come back</p>\n<p>别回头看我，那些伤还未愈合</p>\n<p>our love is six feet under</p>\n<p>我们的爱已深埋殆尽</p>\n<p>i can't help but wonder</p>\n<p>不能自己的我很想知道</p>\n<p>if our grave was watered by the rain</p>\n<p>滂沱大雨后，埋葬我们爱的地方</p>\n<p>would rose bloom</p>\n<p>是否会有玫瑰，悄然绽放</p>\n<p>————《six feet under》</p>\n<p>”</p>\n<h3 class=\"heading\" data-id=\"heading-3\">完</h3>\n<blockquote>\n<p>作者：第一名的小蝌蚪</p>\n</blockquote>\n<blockquote>\n<p>微信公众号：前端屌丝</p>\n</blockquote>\n<blockquote>\n<p>github： <a target=\"_blank\" href=\"https://github.com/airuikun/blog\" rel=\"nofollow noopener noreferrer\">github.com/airuikun/bl…</a></p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-4\">《 蝌蚪传记：200行代码实现前端无痕埋点 》</h2>\n<h3 class=\"heading\" data-id=\"heading-5\">背景</h3>\n<p>上次公开演讲结束后，很多小伙伴对无痕埋点很感兴趣</p>\n<p>那这次就讲讲前端无痕埋点的原理与实现吧。</p>\n<p>鲁迅说过：“一切不放源码的技术文章都是耍流氓”</p>\n<p>所以无痕埋点源码：<a target=\"_blank\" href=\"https://github.com/airuikun/smart-tracker\" rel=\"nofollow noopener noreferrer\">smart-tracker</a></p>\n<h3 class=\"heading\" data-id=\"heading-6\">什么是无痕埋点</h3>\n<p>简单来说，就是当引入无痕埋点的库以后</p>\n<p>用户在浏览器里所有行为和操作都会被自动记录下来</p>\n<p>并将信息发送到后端进行统计和分析</p>\n<p>传统的埋点形式，都是手动埋点</p>\n<p>在指定的元素上绑定事件</p>\n<p>将用户行为信息发送到服务端进行统计</p>\n<p>假设如果有一万个点需要前端狗去埋，惊喜不惊喜，意外不意外</p>\n<h3 class=\"heading\" data-id=\"heading-7\">我们为什么要做无痕埋点</h3>\n<p>提高工作效率，解放双手</p>\n<p>屌丝的双手得到解放以后</p>\n<p>就有更多的时间拿双手来取悦自己</p>\n<p>嘻嘻</p>\n<h3 class=\"heading\" data-id=\"heading-8\">无痕埋点原理</h3>\n<p>原理很简单，这里只讲click的无痕埋点原理</p>\n<p>当用户点击了页面上某一个元素</p>\n<p>我们要把当前元素到body之间整个dom的路径记录下来，作为这个元素的唯一标识，我们称之为domPath</p>\n<p>这个domPath不仅是这个元素唯一标识</p>\n<p>还可以通过document.querySelector(domPath)去唯一选择和定位到这个元素</p>\n<p>当用户点击一次这个元素，就会将埋点数据上传到服务器</p>\n<p>服务器上这个domPath对应的统计数据加一</p>\n<h3 class=\"heading\" data-id=\"heading-9\">无痕埋点代码实现</h3>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    <span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">'click'</span>,  (event) => {\n        <span class=\"hljs-keyword\">const</span> eventFix = getEvent(event);\n        <span class=\"hljs-keyword\">if</span> (!eventFix) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">this</span>._handleEvent(eventFix);\n    }, <span class=\"hljs-literal\">false</span>)\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>首先在document的body上监听和绑定全局click事件，捕获用户所有的点击事件。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> getDomPath = <span class=\"hljs-function\">(<span class=\"hljs-params\">element, useClass = <span class=\"hljs-literal\">false</span></span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (!(element <span class=\"hljs-keyword\">instanceof</span> HTMLElement)) {\n        <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'input is not a HTML element!'</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>;\n    }\n    <span class=\"hljs-keyword\">let</span> domPath = [];\n    <span class=\"hljs-keyword\">let</span> elem = element;\n    <span class=\"hljs-keyword\">while</span> (elem) {\n        <span class=\"hljs-keyword\">let</span> domDesc = getDomDesc(elem, useClass);\n        <span class=\"hljs-keyword\">if</span> (!domDesc) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        domPath.unshift(domDesc);\n        <span class=\"hljs-keyword\">if</span> (querySelector(domPath.join(<span class=\"hljs-string\">'>'</span>)) === element || domDesc.indexOf(<span class=\"hljs-string\">'body'</span>) >= <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        domPath.shift();\n        <span class=\"hljs-keyword\">const</span> children = elem.parentNode.children;\n        <span class=\"hljs-keyword\">if</span> (children.length > <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < children.length; i++) {\n                <span class=\"hljs-keyword\">if</span> (children[i] === elem) {\n                    domDesc += <span class=\"hljs-string\">`:nth-child(<span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>)`</span>;\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n        }\n        domPath.unshift(domDesc);\n        <span class=\"hljs-keyword\">if</span> (querySelector(domPath.join(<span class=\"hljs-string\">'>'</span>)) === element) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        elem = elem.parentNode;\n    }\n    <span class=\"hljs-keyword\">return</span> domPath.join(<span class=\"hljs-string\">'>'</span>);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这段代码是关键，获取元素唯一标识domPath</p>\n<p>getDomPath函数传入的是用户点击事件的target对象: getDomPath(event.target)。</p>\n<p>主要思路是找到当前元素event.target</p>\n<p>然后不断的去循环找它的父节点parentNode</p>\n<p>将父节点的tagName当做domPath路径上的节点</p>\n<p>如果当前元素有id，那就取消所有路径的循环，直接讲id赋值给domPath</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    <span class=\"hljs-keyword\">const</span> children = elem.parentNode.children;\n    <span class=\"hljs-keyword\">if</span> (children.length > <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < children.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (children[i] === elem) {\n                domDesc += <span class=\"hljs-string\">`:nth-child(<span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>)`</span>;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n    }\n    domPath.unshift(domDesc);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>getDomPath函数中的这段代码</p>\n<p>意思是在同一级上出现了多个相同tagName元素</p>\n<p>那我们要定位到这个event.target这个元素在这一级里的第几个</p>\n<p>假设这个div是同一级的第三个，那返回的就是div:nth-child(3)</p>\n<p>这样就可以在document.querySelector(domPath)里唯一定位到这个元素</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    _handleEvent(event) {\n        <span class=\"hljs-keyword\">const</span> domPath = getDomPath(event.target);\n        <span class=\"hljs-keyword\">const</span> rect = getBoundingClientRect(event.target);\n        <span class=\"hljs-keyword\">if</span> (rect.width == <span class=\"hljs-number\">0</span> || rect.height == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-built_in\">document</span>.documentElement || <span class=\"hljs-built_in\">document</span>.body.parentNode;\n        <span class=\"hljs-keyword\">const</span> scrollX = (t && <span class=\"hljs-keyword\">typeof</span> t.scrollLeft == <span class=\"hljs-string\">'number'</span> ? t : <span class=\"hljs-built_in\">document</span>.body).scrollLeft;\n        <span class=\"hljs-keyword\">const</span> scrollY = (t && <span class=\"hljs-keyword\">typeof</span> t.scrollTop == <span class=\"hljs-string\">'number'</span> ? t : <span class=\"hljs-built_in\">document</span>.body).scrollTop;\n        <span class=\"hljs-keyword\">const</span> pageX = event.pageX || event.clientX + scrollX;\n        <span class=\"hljs-keyword\">const</span> pageY = event.pageY || event.clientY + scrollY;\n        <span class=\"hljs-keyword\">const</span> data = {\n            <span class=\"hljs-attr\">domPath</span>: <span class=\"hljs-built_in\">encodeURIComponent</span>(domPath),\n            <span class=\"hljs-attr\">trackingType</span>: event.type,\n            <span class=\"hljs-attr\">offsetX</span>: ((pageX - rect.left - scrollX) / rect.width).toFixed(<span class=\"hljs-number\">6</span>),\n            <span class=\"hljs-attr\">offsetY</span>: ((pageY - rect.top - scrollY) / rect.height).toFixed(<span class=\"hljs-number\">6</span>),\n        };\n        <span class=\"hljs-keyword\">this</span>.send(data);\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这段代码就是得到用户点击某个元素的相对位置的横向位置和竖向位置比例</p>\n<p>得到这个位置的值，就可以反向从埋点数据中得到用户点击元素的具体位置</p>\n<p>因为是个比例值，所以在反向推导中还能自适应页面大小的改变</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    send(data = {}) {\n        <span class=\"hljs-keyword\">const</span> image = <span class=\"hljs-keyword\">new</span> Image(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);\n        image.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n            image = <span class=\"hljs-literal\">null</span>;\n        };\n        image.src = <span class=\"hljs-string\">`/?<span class=\"hljs-subst\">${stringify(data)}</span>`</span>;\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>得到了用户点击的位置信息和唯一标识domPath</p>\n<p>就可以将数据发送到服务端进行统计了</p>\n<p>用image的src，将数据进行传输</p>\n<p>用image的src有个好处就是轻量，并且还支持跨域</p>\n<p>打点基本上都用的这个方法进行发送数据</p>\n<h3 class=\"heading\" data-id=\"heading-10\">结尾</h3>\n<p>两个多月没写文章了，因为在忙着晋升</p>\n<p>这次晋升最大的感悟就是，如果你只一心专注业务，是很难晋升成功的</p>\n<p>需要在日常工作中做一些技术型需求</p>\n<p>而无痕埋点，是一个不错的选择</p>\n<p>但是这篇文章仅仅只是无痕埋点的一个简单实现</p>\n<p>对整个无痕埋点体系来说，这些只是冰山一角</p>\n<p>真正的无痕埋点，还需要做统计、分析、差量预测、标记策略、智能降噪、可视化无痕、无痕分桶、反向推导热力图、大数据中台等等\n涉及到前端、后端、运维、DBA和算法</p>\n<p>一起干下来，那你就是江湖顶级的前端渣男了</p>\n<p>以上就是文章的全部了，谢谢你能全部看完</p>\n<p>最后，祝你过上幸福快乐的生活</p>\n<blockquote>\n<p>作者：第一名的小蝌蚪</p>\n</blockquote>\n<blockquote>\n<p>微信公众号：前端屌丝</p>\n</blockquote>\n<blockquote>\n<p>github： <a target=\"_blank\" href=\"https://github.com/airuikun/blog\" rel=\"nofollow noopener noreferrer\">github.com/airuikun/bl…</a></p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-11\">往期文章</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/6\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：端口转发——夜店传说</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/5\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：git时光穿梭机——女神的侧颜</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/1\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：PNG图片压缩原理——屌丝的眼泪</a></li>\n</ul>\n",
      "id": "5dagssi80f80",
      "author": "云中桥",
      "title": "小蝌蚪传记：200行代码实现前端无痕埋点",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做<code>长列表</code>。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>\n<p>在<a target=\"_blank\" href=\"https://juejin.im/post/5d76f469f265da039a28aff7\" rel>高性能渲染十万条数据(时间分片)</a>一文中，提到了可以使用<code>时间分片</code>的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用<code>虚拟列表</code>的方式，来同时加载大量数据。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">为什么需要使用虚拟列表</h2>\n<p>假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"button\"</span>></span>button<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">br</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"container\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">ul</span>></span>  \n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'button'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// 记录任务开始时间</span>\n    <span class=\"hljs-keyword\">let</span> now = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-comment\">// 插入一万条数据</span>\n    <span class=\"hljs-keyword\">const</span> total = <span class=\"hljs-number\">10000</span>;\n    <span class=\"hljs-comment\">// 获取容器</span>\n    <span class=\"hljs-keyword\">let</span> ul = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'container'</span>);\n    <span class=\"hljs-comment\">// 将数据插入容器中</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < total; i++) {\n        <span class=\"hljs-keyword\">let</span> li = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'li'</span>);\n        li.innerText = ~~(<span class=\"hljs-built_in\">Math</span>.random() * total)\n        ul.appendChild(li);\n    }\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'JS运行时间：'</span>,<span class=\"hljs-built_in\">Date</span>.now() - now);\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=></span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'总运行时间：'</span>,<span class=\"hljs-built_in\">Date</span>.now() - now);\n    },<span class=\"hljs-number\">0</span>)\n\n    <span class=\"hljs-comment\">// print JS运行时间： 38</span>\n    <span class=\"hljs-comment\">// print 总运行时间： 957 </span>\n  })\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为<code>38ms</code>,但渲染完成后的总时间为<code>957ms</code>。</p>\n<p>简单说明一下，为何两次<code>console.log</code>的结果时间差异巨大，并且是如何简单来统计<code>JS运行时间</code>和<code>总渲染时间</code>：</p>\n<ul>\n<li>在 JS 的<code>Event Loop</code>中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</li>\n<li>第一个<code>console.log</code>的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li>\n<li>第二个<code>console.log</code>是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次<code>Event Loop</code>中执行的</li>\n</ul>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" rel>关于Event Loop的详细内容请参见这篇文章--></a></p>\n<p>然后，我们通过<code>Chrome</code>的<code>Performance</code>工具来详细的分析这段代码的性能瓶颈在哪里：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1518f6871e6c6?imageslim\" data-width=\"1280\" data-height=\"519\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"519\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>从<code>Performance</code>可以看出，代码从执行到渲染结束，共消耗了<code>960.8ms</code>,其中的主要时间消耗如下：</p>\n<ul>\n<li>Event(click) : <code>40.84ms</code></li>\n<li>Recalculate Style : <code>105.08ms</code></li>\n<li>Layout : <code>731.56ms</code></li>\n<li>Update Layer Tree : <code>58.87ms</code></li>\n<li>Paint : <code>15.32ms</code></li>\n</ul>\n<p>从这里我们可以看出，我们的代码的执行过程中，消耗时间最多的两个阶段是<code>Recalculate Style</code>和<code>Layout</code>。</p>\n<ul>\n<li><code>Recalculate Style</code>：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。</li>\n<li><code>Layout</code>：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。</li>\n</ul>\n<p>在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。</p>\n<p>那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在<code>Recalculate Style</code>和<code>Layout</code>阶段消耗大量的时间。</p>\n<p>而<code>虚拟列表</code>就是解决这一问题的一种实现。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">什么是虚拟列表</h2>\n<p><code>虚拟列表</code>其实是按需显示的一种实现，即只对<code>可见区域</code>进行渲染，对<code>非可见区域</code>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p>\n<p>假设有1万条记录需要同时渲染，我们屏幕的<code>可见区域</code>的高度为<code>500px</code>,而列表项的高度为<code>50px</code>，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e15195cf16a558?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"506\" data-height=\"642\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"506\" height=\"642\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕<code>可见区域</code>应该显示的列表项。</p>\n<p>假设滚动发生，滚动条距顶部的位置为<code>150px</code>,则我们可得知在<code>可见区域</code>内的列表项为<code>第4项</code>至`第13项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e15197c273cbd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"506\" data-height=\"677\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"506\" height=\"677\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">实现</h2>\n<p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载<code>可视区域</code>内需要的列表项，当滚动发生时，动态通过计算获得<code>可视区域</code>内的列表项，并将<code>非可视区域</code>内存在的列表项删除。</p>\n<ul>\n<li>计算当前<code>可视区域</code>起始数据索引(<code>startIndex</code>)</li>\n<li>计算当前<code>可视区域</code>结束数据索引(<code>endIndex</code>)</li>\n<li>计算当前<code>可视区域的</code>数据，并渲染到页面中</li>\n<li>计算<code>startIndex</code>对应的数据在整个列表中的偏移位置<code>startOffset</code>并设置到列表上</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1519a393dee2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"719\" data-height=\"677\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"719\" height=\"677\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>由于只是对<code>可视区域</code>内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-container\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-phantom\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list\"</span>></span>\n      <span class=\"hljs-comment\"><!-- item-1 --></span>\n      <span class=\"hljs-comment\"><!-- item-2 --></span>\n      <span class=\"hljs-comment\"><!-- ...... --></span>\n      <span class=\"hljs-comment\"><!-- item-n --></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><code>infinite-list-container</code> 为<code>可视区域</code>的容器</li>\n<li><code>infinite-list-phantom</code> 为容器内的占位，高度为总列表高度，用于形成滚动条</li>\n<li><code>infinite-list</code> 为列表项的<code>渲染区域</code></li>\n</ul>\n<p>接着，监听<code>infinite-list-container</code>的<code>scroll</code>事件，获取滚动位置<code>scrollTop</code></p>\n<ul>\n<li>假定<code>可视区域</code>高度固定，称之为<code>screenHeight</code></li>\n<li>假定<code>列表每项</code>高度固定，称之为<code>itemSize</code></li>\n<li>假定<code>列表数据</code>称之为<code>listData</code></li>\n<li>假定<code>当前滚动位置</code>称之为<code>scrollTop</code></li>\n</ul>\n<p>则可推算出：</p>\n<ul>\n<li>列表总高度<code>listHeight</code> = listData.length * itemSize</li>\n<li>可显示的列表项数<code>visibleCount</code> = Math.ceil(screenHeight / itemSize)</li>\n<li>数据的起始索引<code>startIndex</code> = Math.floor(scrollTop / itemSize)</li>\n<li>数据的结束索引<code>endIndex</code> = startIndex + visibleCount</li>\n<li>列表显示数据为<code>visibleData</code> = listData.slice(startIndex,endIndex)</li>\n</ul>\n<p>当滚动后，由于<code>渲染区域</code>相对于<code>可视区域</code>已经发生了偏移，此时我需要获取一个偏移量<code>startOffset</code>，通过样式控制将<code>渲染区域</code>偏移至<code>可视区域</code>中。</p>\n<ul>\n<li>偏移量<code>startOffset</code> = scrollTop - (scrollTop % itemSize);</li>\n</ul>\n<p>最终的<code>简易代码</code>如下：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"list\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-container\"</span> @<span class=\"hljs-attr\">scroll</span>=<span class=\"hljs-string\">\"scrollEvent($event)\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-phantom\"</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ height: listHeight + 'px' }\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list\"</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ transform: getTransform }\"</span>></span>\n      <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"items\"</span>\n        <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-item\"</span>\n        <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in visibleData\"</span>\n        <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>\n        <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ height: itemSize + 'px',lineHeight: itemSize + 'px' }\"</span>\n      ></span>{{ item.value }}<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">'VirtualList'</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-comment\">//所有列表数据</span>\n    listData:{\n      <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">default</span>:<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=></span>[]\n    },\n    <span class=\"hljs-comment\">//每项高度</span>\n    itemSize: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>:<span class=\"hljs-number\">200</span>\n    }\n  },\n  <span class=\"hljs-attr\">computed</span>:{\n    <span class=\"hljs-comment\">//列表总高度</span>\n    listHeight(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.listData.length * <span class=\"hljs-keyword\">this</span>.itemSize;\n    },\n    <span class=\"hljs-comment\">//可显示的列表项数</span>\n    visibleCount(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.ceil(<span class=\"hljs-keyword\">this</span>.screenHeight / <span class=\"hljs-keyword\">this</span>.itemSize)\n    },\n    <span class=\"hljs-comment\">//偏移量对应的style</span>\n    getTransform(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`translate3d(0,<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.startOffset}</span>px,0)`</span>;\n    },\n    <span class=\"hljs-comment\">//获取真实显示列表数据</span>\n    visibleData(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.listData.slice(<span class=\"hljs-keyword\">this</span>.start, <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.end,<span class=\"hljs-keyword\">this</span>.listData.length));\n    }\n  },\n  mounted() {\n    <span class=\"hljs-keyword\">this</span>.screenHeight = <span class=\"hljs-keyword\">this</span>.$el.clientHeight;\n    <span class=\"hljs-keyword\">this</span>.start = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.end = <span class=\"hljs-keyword\">this</span>.start + <span class=\"hljs-keyword\">this</span>.visibleCount;\n  },\n  data() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-comment\">//可视区域高度</span>\n      screenHeight:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//偏移量</span>\n      startOffset:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//起始索引</span>\n      start:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//结束索引</span>\n      end:<span class=\"hljs-literal\">null</span>,\n    };\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    scrollEvent() {\n      <span class=\"hljs-comment\">//当前滚动位置</span>\n      <span class=\"hljs-keyword\">let</span> scrollTop = <span class=\"hljs-keyword\">this</span>.$refs.list.scrollTop;\n      <span class=\"hljs-comment\">//此时的开始索引</span>\n      <span class=\"hljs-keyword\">this</span>.start = <span class=\"hljs-built_in\">Math</span>.floor(scrollTop / <span class=\"hljs-keyword\">this</span>.itemSize);\n      <span class=\"hljs-comment\">//此时的结束索引</span>\n      <span class=\"hljs-keyword\">this</span>.end = <span class=\"hljs-keyword\">this</span>.start + <span class=\"hljs-keyword\">this</span>.visibleCount;\n      <span class=\"hljs-comment\">//此时的偏移量</span>\n      <span class=\"hljs-keyword\">this</span>.startOffset = scrollTop - (scrollTop % <span class=\"hljs-keyword\">this</span>.itemSize);\n    }\n  }\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist-1-rp8pi\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151e017d7bba3?imageslim\" data-width=\"1270\" data-height=\"427\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1270\" height=\"427\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">列表项动态高度</h2>\n<p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p>\n<p>比如这种情况：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1519f1e121be9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"417\" data-height=\"702\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"417\" height=\"702\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>在虚拟列表中应用动态高度的解决方案一般有如下三种：</p>\n<blockquote>\n<p>1.对组件属性<code>itemSize</code>进行扩展，支持传递类型为<code>数字</code>、<code>数组</code>、<code>函数</code></p>\n</blockquote>\n<ul>\n<li>可以是一个固定值，如 100，此时列表项是固高的</li>\n<li>可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, ...]</li>\n<li>可以是一个根据列表项索引返回其高度的函数：(index: number): number</li>\n</ul>\n<p>这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。</p>\n<blockquote>\n<p>2.将列表项<code>渲染到屏幕外</code>，对其高度进行测量并缓存，然后再将其渲染至可视区域内。</p>\n</blockquote>\n<p>由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。</p>\n<blockquote>\n<p>3.以<code>预估高度</code>先行渲染，然后获取真实高度并缓存。</p>\n</blockquote>\n<p>这是我选择的实现方式，可以避免前两种方案的不足。</p>\n<p>接下来，来看如何简易的实现：</p>\n<p>定义组件属性<code>estimatedItemSize</code>,用于接收<code>预估高度</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">props: {\n  <span class=\"hljs-comment\">//预估高度</span>\n  estimatedItemSize:{\n    <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Number</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>定义<code>positions</code>，用于列表项渲染后存储<code>每一项的高度以及位置</code>信息，</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">this</span>.positions = [\n  <span class=\"hljs-comment\">// {</span>\n  <span class=\"hljs-comment\">//   top:0,</span>\n  <span class=\"hljs-comment\">//   bottom:100,</span>\n  <span class=\"hljs-comment\">//   height:100</span>\n  <span class=\"hljs-comment\">// }</span>\n];\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>并在初始时根据<code>estimatedItemSize</code>对<code>positions</code>进行初始化。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">initPositions(){\n  <span class=\"hljs-keyword\">this</span>.positions = <span class=\"hljs-keyword\">this</span>.listData.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item,index</span>)=></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      index,\n      <span class=\"hljs-attr\">height</span>:<span class=\"hljs-keyword\">this</span>.estimatedItemSize,\n      <span class=\"hljs-attr\">top</span>:index * <span class=\"hljs-keyword\">this</span>.estimatedItemSize,\n      <span class=\"hljs-attr\">bottom</span>:(index + <span class=\"hljs-number\">1</span>) * <span class=\"hljs-keyword\">this</span>.estimatedItemSize\n    }\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于列表项高度不定，并且我们维护了<code>positions</code>，用于记录每一项的位置，而<code>列表高度</code>实际就等于列表中最后一项的底部距离列表顶部的位置。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//列表总高度</span>\nlistHeight(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.positions[<span class=\"hljs-keyword\">this</span>.positions.length - <span class=\"hljs-number\">1</span>].bottom;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于需要在<code>渲染完成</code>后，获取列表每项的位置信息并缓存，所以使用钩子函数<code>updated</code>来实现：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">updated(){\n  <span class=\"hljs-keyword\">let</span> nodes = <span class=\"hljs-keyword\">this</span>.$refs.items;\n  nodes.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>)=></span>{\n    <span class=\"hljs-keyword\">let</span> rect = node.getBoundingClientRect();\n    <span class=\"hljs-keyword\">let</span> height = rect.height;\n    <span class=\"hljs-keyword\">let</span> index = +node.id.slice(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">let</span> oldHeight = <span class=\"hljs-keyword\">this</span>.positions[index].height;\n    <span class=\"hljs-keyword\">let</span> dValue = oldHeight - height;\n    <span class=\"hljs-comment\">//存在差值</span>\n    <span class=\"hljs-keyword\">if</span>(dValue){\n      <span class=\"hljs-keyword\">this</span>.positions[index].bottom = <span class=\"hljs-keyword\">this</span>.positions[index].bottom - dValue;\n      <span class=\"hljs-keyword\">this</span>.positions[index].height = height;\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k = index + <span class=\"hljs-number\">1</span>;k<<span class=\"hljs-keyword\">this</span>.positions.length; k++){\n        <span class=\"hljs-keyword\">this</span>.positions[k].top = <span class=\"hljs-keyword\">this</span>.positions[k<span class=\"hljs-number\">-1</span>].bottom;\n        <span class=\"hljs-keyword\">this</span>.positions[k].bottom = <span class=\"hljs-keyword\">this</span>.positions[k].bottom - dValue;\n      }\n    }\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>滚动后获取列表<code>开始索引</code>的方法修改为通过<code>缓存</code>获取：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//获取列表起始索引</span>\ngetStartIndex(scrollTop = <span class=\"hljs-number\">0</span>){\n  <span class=\"hljs-keyword\">let</span> item = <span class=\"hljs-keyword\">this</span>.positions.find(<span class=\"hljs-function\"><span class=\"hljs-params\">i</span> =></span> i && i.bottom > scrollTop);\n  <span class=\"hljs-keyword\">return</span> item.index;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于我们的缓存数据，本身就是有顺序的，所以获取<code>开始索引</code>的方法可以考虑通过<code>二分查找</code>的方式来降低检索次数：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//获取列表起始索引</span>\ngetStartIndex(scrollTop = <span class=\"hljs-number\">0</span>){\n  <span class=\"hljs-comment\">//二分法查找</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.binarySearch(<span class=\"hljs-keyword\">this</span>.positions,scrollTop)\n},\n<span class=\"hljs-comment\">//二分法查找</span>\nbinarySearch(list,value){\n  <span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> end = list.length - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> tempIndex = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">while</span>(start <= end){\n    <span class=\"hljs-keyword\">let</span> midIndex = <span class=\"hljs-built_in\">parseInt</span>((start + end)/<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">let</span> midValue = list[midIndex].bottom;\n    <span class=\"hljs-keyword\">if</span>(midValue === value){\n      <span class=\"hljs-keyword\">return</span> midIndex + <span class=\"hljs-number\">1</span>;\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(midValue < value){\n      start = midIndex + <span class=\"hljs-number\">1</span>;\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(midValue > value){\n      <span class=\"hljs-keyword\">if</span>(tempIndex === <span class=\"hljs-literal\">null</span> || tempIndex > midIndex){\n        tempIndex = midIndex;\n      }\n      end = end - <span class=\"hljs-number\">1</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> tempIndex;\n},\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>滚动后将<code>偏移量</code>的获取方式变更：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">scrollEvent() {\n  <span class=\"hljs-comment\">//...省略</span>\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.start >= <span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">this</span>.startOffset = <span class=\"hljs-keyword\">this</span>.positions[<span class=\"hljs-keyword\">this</span>.start - <span class=\"hljs-number\">1</span>].bottom\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">this</span>.startOffset = <span class=\"hljs-number\">0</span>;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>通过<a target=\"_blank\" href=\"https://github.com/marak/Faker.js/\" rel=\"nofollow noopener noreferrer\">faker.js</a> 来创建一些<code>随机数据</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span> data = [];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span>; id < <span class=\"hljs-number\">10000</span>; id++) {\n  data.push({\n    id,\n    <span class=\"hljs-attr\">value</span>: faker.lorem.sentences() <span class=\"hljs-comment\">// 长文本</span>\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist2-1bqk6\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151e96584b690?imageslim\" data-width=\"360\" data-height=\"655\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"360\" height=\"655\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>从演示效果上看，我们实现了基于<code>文字内容动态撑高列表项</code>情况下的<code>虚拟列表</code>，但是我们可能会发现，当滚动过快时，会出现短暂的<code>白屏现象</code>。</p>\n<p>为了使页面平滑滚动，我们还需要在<code>可见区域</code>的上方和下方渲染额外的项目，在滚动时给予一些<code>缓冲</code>，所以将屏幕分为三个区域：</p>\n<ul>\n<li>可视区域上方：<code>above</code></li>\n<li>可视区域：<code>screen</code></li>\n<li>可视区域下方：<code>below</code></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151a59317cae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"461\" data-height=\"493\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"461\" height=\"493\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>定义组件属性<code>bufferScale</code>,用于接收<code>缓冲区数据</code>与<code>可视区数据</code>的<code>比例</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">props: {\n  <span class=\"hljs-comment\">//缓冲区比例</span>\n  bufferScale:{\n    <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-attr\">default</span>:<span class=\"hljs-number\">1</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可视区上方渲染条数<code>aboveCount</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">aboveCount(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.start,<span class=\"hljs-keyword\">this</span>.bufferScale * <span class=\"hljs-keyword\">this</span>.visibleCount)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可视区下方渲染条数<code>belowCount</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">belowCount(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.listData.length - <span class=\"hljs-keyword\">this</span>.end,<span class=\"hljs-keyword\">this</span>.bufferScale * <span class=\"hljs-keyword\">this</span>.visibleCount);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>真实渲染数据<code>visibleData</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">visibleData(){\n  <span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-keyword\">this</span>.start - <span class=\"hljs-keyword\">this</span>.aboveCount;\n  <span class=\"hljs-keyword\">let</span> end = <span class=\"hljs-keyword\">this</span>.end + <span class=\"hljs-keyword\">this</span>.belowCount;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>._listData.slice(start, end);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist-3-i3h9v\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151ee0eb0fc89?imageslim\" data-width=\"360\" data-height=\"636\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"360\" height=\"636\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>基于这个方案，个人开发了一个基于Vue2.x的虚拟列表组件：<a target=\"_blank\" href=\"https://github.com/chenqf/vue-virtual-listview\" rel=\"nofollow noopener noreferrer\">vue-virtual-listview</a>,可<a target=\"_blank\" href=\"https://github.com/chenqf/vue-virtual-listview\" rel=\"nofollow noopener noreferrer\">点击查看完整代码</a>。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-5\">面向未来</h2>\n<p>在前文中我们使用<code>监听scroll事件</code>的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成<code>重复计算</code>的问题，从性能上来说无疑存在浪费的情况。</p>\n<p>可以使用<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\" rel=\"nofollow noopener noreferrer\">IntersectionObserver</a>替换监听scroll事件，<code>IntersectionObserver</code>可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且<code>IntersectionObserver</code>的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">遗留问题</h2>\n<p>我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。</p>\n<p>这种情况下，如果我们能监听列表项的大小变化就能获取其真正的高度了。我们可以使用<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\" rel=\"nofollow noopener noreferrer\">ResizeObserver</a>来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。</p>\n<p>不过遗憾的是，在撰写本文的时候，仅有少数<a target=\"_blank\" href=\"https://www.caniuse.com/#search=ResizeObserver\" rel=\"nofollow noopener noreferrer\">浏览器支持</a><code>ResizeObserver</code>。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">参考</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/dwqs/blog/issues/70\" rel=\"nofollow noopener noreferrer\">浅说虚拟列表的实现原理</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/dwqs/blog/issues/72\" rel=\"nofollow noopener noreferrer\">react-virtualized组件的虚拟列表实现</a></li>\n<li><a target=\"_blank\" href=\"https://itsze.ro/blog/2017/04/09/infinite-list-and-react.html\" rel=\"nofollow noopener noreferrer\">React和无限列表</a></li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/34585166\" rel=\"nofollow noopener noreferrer\">再谈前端虚拟列表的实现</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-8\">写在最后</h2>\n<ul>\n<li>文中如有错误，欢迎在评论区指正，如果这篇文章帮到了你，欢迎<code>点赞</code>和<code>关注</code></li>\n<li>本文同步首发与<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog\" rel=\"nofollow noopener noreferrer\">github</a>，可在<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog\" rel=\"nofollow noopener noreferrer\">github</a>中找到更多精品文章，欢迎<code>Watch</code> & <code>Star ★</code></li>\n<li>后续文章参见：<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog/blob/master/PLAN.md\" rel=\"nofollow noopener noreferrer\">计划</a></li>\n</ul>\n<blockquote>\n<p>欢迎关注微信公众号<code>【前端小黑屋】</code>，每周1-3篇精品优质文章推送，助你走上进阶之旅</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/10/16d18aa76b8ad582?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>同时欢迎加我好友，回复<code>加群</code>，拉你入群，和我一起学前端~</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb2f7ddf918f64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"268\" data-height=\"268\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"268\" height=\"268\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2zxb1dwpeok0",
      "author": "Void_0",
      "title": "「前端进阶」高性能渲染十万条数据(虚拟列表)",
      "baseClassName": "article-content"
    },
    {
      "content": "<h3 class=\"heading\" data-id=\"heading-0\">项目初衷</h3>\n<p>开发一个H5的通用架子，让前端同学开箱即用，迅速投入战斗。</p>\n<blockquote>\n<p>截止到2019-10-29 10:25，已经被fork了34次，如果您在使用过程中还希望能给我提<a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/issues\" rel=\"nofollow noopener noreferrer\">issue</a>,或者直接加我微信13216698987 ❤️ ❤️ ❤️</p>\n</blockquote>\n<hr>\n<ul>\n<li>扫码预览：\n<figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf63d281fabe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"260\" data-height=\"260\" src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf63d281fabe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><br>\n<strong>项目源码在文章结尾处，记得查收哦~</strong></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">主要功能</h3>\n<ol>\n<li>常用目录别名</li>\n<li>Vant/Rem适配</li>\n<li>scss支持、_mixin.scss、_variables.scss</li>\n<li>页面切换动画+keepAlive</li>\n<li>页面标题</li>\n<li>自动注册：自动注册路由表/自动注册Vuex/svg图标引入</li>\n<li>mock server</li>\n<li>axios封装、api管理</li>\n<li>用户鉴权</li>\n<li>vuex-loading</li>\n<li>vo-pages/dayjs/vconsole</li>\n<li>生产环境优化</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-2\">常用目录别名</h3>\n<p></p><figure><img alt=\"alias配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbbc7d2dc664?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"737\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"737\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-3\">Vant/Rem适配</h3>\n<p>按照Vant官网推荐自动按需引入组件，同样，Vant官网中也有对Rem适配的推荐配置，按照官网说明的使用。需要注意的是postcss的配置中，autoprefixer下的<code>browsers</code>需要替换成<code>overrideBrowserslist</code>，否则会有报错信息。具体如图<br>\n</p><figure><img alt=\"postcss配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaee5e8e497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"777\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"777\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">scss支持、_mixin.scss、_variables.scss</h3>\n<p>选择scss作为css预处理，并对mixin、variables、common.scss作全局引入。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">css: {\n    <span class=\"hljs-comment\">// 是否使用css分离插件 ExtractTextPlugin</span>\n    extract: !!IS_PRODUCTION,\n    <span class=\"hljs-comment\">// 开启 CSS source maps?</span>\n    sourceMap: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-comment\">// css预设器配置项</span>\n    <span class=\"hljs-comment\">// 启用 CSS modules for all css / pre-processor files.</span>\n    modules: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">loaderOptions</span>: {\n      <span class=\"hljs-attr\">sass</span>: {\n        <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'@import \"style/_mixin.scss\";@import \"style/_variables.scss\";@import \"style/common.scss\";'</span> <span class=\"hljs-comment\">// 全局引入</span>\n      }\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">页面切换动画+keepAlive</h3>\n<p>利用vuex存取/更新页面切换方向，配合vue的transition做页面切换动画，router设置keepAlive判断页面是否需要缓冲。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// vuex中</span>\nstate: {\n  <span class=\"hljs-attr\">direction</span>: <span class=\"hljs-string\">'forward'</span> <span class=\"hljs-comment\">// 页面切换方向</span>\n},\n<span class=\"hljs-attr\">mutations</span>: {\n  <span class=\"hljs-comment\">// 更新页面切换方向</span>\n  updateDirection (state, direction) {\n    state.direction = direction\n  }\n},\n<span class=\"hljs-comment\">// App.vue</span>\n<template>\n  <div id=\"app\">\n    <transition :name=\"transitionName\">\n      <keep-alive v-if=\"$route.meta.keepAlive\">\n        <router-view class=\"router\"></router-view>\n      </keep-alive>\n      <router-view class=\"router\" v-else></router-view>\n    </transition>\n  </div>\n</template>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">页面标题</h3>\n<p>在vue-router页面配置中添加meta的title信息，配合<code>vue-router</code>的<code>beforeEach</code>注册一个前置守卫用户获取到页面配置的title</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// get-page-title.js</span>\n<span class=\"hljs-keyword\">import</span> defaultSettings <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/settings'</span>\n\n<span class=\"hljs-keyword\">const</span> title = defaultSettings.title || <span class=\"hljs-string\">'H5Vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getPageTitle</span> (<span class=\"hljs-params\">pageTitle</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (pageTitle) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${pageTitle}</span> - <span class=\"hljs-subst\">${title}</span>`</span>\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${title}</span>`</span>\n}\n<span class=\"hljs-comment\">// permission.js</span>\nrouter.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =></span> {\n  <span class=\"hljs-comment\">// set page title</span>\n  <span class=\"hljs-built_in\">document</span>.title = getPageTitle(to.meta.title)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">自动注册</h3>\n<p>先来了解一下<code>require.context()</code>:</p>\n<blockquote>\n<p>你可以通过 <code>require.context()</code> 函数来创建自己的 context。</p>\n<p>可以给这个函数传入三个参数：一个要搜索的目录，一个标记表示是否还搜索其子目录， 以及一个匹配文件的正则表达式。</p>\n<p>webpack 会在构建中解析代码中的 <code>require.context()</code> 。</p>\n</blockquote>\n<p>上面的是官网原话，可能你跟我一样没太看懂，说白了，他可以用来导入模块。</p>\n<p>来看一下如何使用，我的router下的文件结构是这样的：<br></p>\n<p></p><figure><img alt=\"router-tree\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbae89d4fb5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"286\" data-height=\"220\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"286\" height=\"220\"></svg>\"><figcaption></figcaption></figure><br><p></p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 利用require.context()自动引入article.js和user.js</span>\n<span class=\"hljs-keyword\">const</span> routerContext = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">'./'</span>, <span class=\"hljs-literal\">true</span>, /\\.js$/)\nrouterContext.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =></span> {\n  <span class=\"hljs-comment\">// 如果是根目录的 index.js 、不处理</span>\n  <span class=\"hljs-keyword\">if</span> (route.startsWith(<span class=\"hljs-string\">'./index'</span>)) {\n    <span class=\"hljs-keyword\">return</span>\n  }\n  <span class=\"hljs-keyword\">const</span> routerModule = routerContext(route)\n  <span class=\"hljs-comment\">/**\n   * 兼容 import export 和 require module.export 两种规范\n   */</span>\n  routes = routes.concat(routerModule.default || routerModule)\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>需要额外注意的是，404页面需要在自动引入后向路由数组concat上去，否则会提前匹配到404页面。</p>\n<p>对于vuex也同样引入，记得把引入的vuex按照文件名注册为对应的模块中。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">mock server</h3>\n<p>Mock server部分可直接参看<a target=\"_blank\" href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/essentials/mock-api.html\" rel=\"nofollow noopener noreferrer\">vue-element-admin</a>的mock方案</p>\n<h3 class=\"heading\" data-id=\"heading-9\">axios封装</h3>\n<p>axios部分，配置了baseUrl、超时时间，利用拦截器对header添加了用户的Token，方便下一步的用户鉴权，并对错误做了Toast提示。具体错误的code需要视各业务而定，本项目只做为示例参考。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">用户鉴权</h3>\n<p>在<code>vue-router</code>的<code>beforeEach</code>中，添加用户鉴权功能。当用户登录后使用cookie持续化保存用户token，并赋值到vuex，后续可利用token获取用户信息。具体代码如下图：\n</p><figure><img alt=\"permission\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaebd72c9e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1055\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1055\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\">vuex-loading</h3>\n<p>在vuex3.1.0中对<a target=\"_blank\" href=\"https://vuex.vuejs.org/zh/api/#subscribe\" rel=\"nofollow noopener noreferrer\">vuex.subscribeAction</a>做了改动，使其拥有了before/after钩子函数。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// subscribeAction官网示例</span>\nstore.subscribeAction({\n  <span class=\"hljs-attr\">before</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, state</span>) =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`before action <span class=\"hljs-subst\">${action.type}</span>`</span>)\n  },\n  <span class=\"hljs-attr\">after</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, state</span>) =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`after action <span class=\"hljs-subst\">${action.type}</span>`</span>)\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>有了它，配合<code>vuex</code>的<a target=\"_blank\" href=\"https://vuex.vuejs.org/zh/guide/plugins.html\" rel=\"nofollow noopener noreferrer\">插件</a>功能，实现对应action的状态监听也不再是难题。</p>\n<p><a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/blob/master/src/utils/vuex-loading.js\" rel=\"nofollow noopener noreferrer\">点击查看具体实现代码</a></p>\n<blockquote>\n<p>参照自<a target=\"_blank\" href=\"https://juejin.im/post/5cdd2457f265da034e7eb2f9#heading-2\" rel>vue 在移动端体验上的优化解决方案</a></p>\n</blockquote>\n<pre><code class=\"hljs vue copyable\" lang=\"vue\">// 使用方法\ncomputed: {\n  ...mapState({\n    loading: state => state['@@loading'].effects['test/onePlusAction']\n  })\n}\n// 其中 test对应的是vuex中的模块名，onePlusAction对应模块内的actions\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>具体效果：<br></p><figure><img alt=\"loading\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaea0ae09cb?imageslim\" data-width=\"248\" data-height=\"248\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"248\" height=\"248\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-12\">列表页（vo-pages的使用）</h3>\n<p>列表页这里，使用了本人自己写的组件<code>vo-pages</code>，详细使用可查看<a target=\"_blank\" href=\"https://juejin.im/post/5d81da4551882556ba55e50e\" rel>一款易用、高可定制的vue翻页组件</a></p>\n<p>实现效果：<br></p>\n<p></p><figure><img alt=\"vo-pages\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaf99131ad2?imageslim\" data-width=\"719\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"719\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-13\">生产环境优化</h3>\n<p>上线前，得优化一下资源了，该项目做了如下几步操作</p>\n<ol>\n<li>通用库改用CDN</li>\n<li>关闭sourcemap防止源码泄露</li>\n<li>丑化html/css/js</li>\n<li>生成gzip</li>\n<li>移除掉debugger/console</li>\n<li>利用webpack-bundle-analyzer做资源分析，提供进一步优化的数据分析\n想对性能、资源了解更多的，推荐<a target=\"_blank\" href=\"https://juejin.im/post/5bd2b60e6fb9a05d27794c5e\" rel>Vue SPA 项目webpack打包优化指南</a>这篇文章。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-14\">更多</h3>\n<p>花了不少时间开发了这个项目，希望能提高您的H5开发效率。也欢迎大家跟我一起交流学习。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">相关链接</h3>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue\" rel=\"nofollow noopener noreferrer\">源码地址</a></li>\n<li><a target=\"_blank\" href=\"http://h5vue.cixi518.com\" rel=\"nofollow noopener noreferrer\">在线预览</a></li>\n<li>扫码预览：\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf6610401416?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"260\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"260\" height=\"260\"></svg>\"><figcaption></figcaption></figure><br></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-16\">文章参考</h3>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cbf32bc6fb9a03236393379\" rel>基于vue-cli3.0构建功能完善的移动端架子</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bd2b60e6fb9a05d27794c5e\" rel>Vue SPA 项目webpack打包优化指南</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cdd2457f265da034e7eb2f9\" rel>vue 在移动端体验上的优化解决方案</a></li>\n<li><a target=\"_blank\" href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/\" rel=\"nofollow noopener noreferrer\">vue-element-admin</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/59bb864b5188257e7a427c09\" rel>手摸手，带你优雅的使用 icon</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d81da4551882556ba55e50e\" rel>一款易用、高可定制的vue翻页组件</a></li>\n</ul>\n",
      "id": "3l7uk66lz100",
      "author": "voanit",
      "title": "基于vue+vant搭建H5通用架子",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>Visual Studio Code 是由微软开发的一款免费、跨平台的文本编辑器。由于其卓越的性能和丰富的功能，它很快就受到了大家的喜爱。</p>\n<p>就像大多数 IDE 一样，VSCode 也有一个扩展和主题市场，包含了数以千计质量不同的插件。下面我列出一些VSCode前端必备插件，并配有图文介绍，快来看看你是否都会使用呢？</p>\n<h2 class=\"heading\" data-id=\"heading-0\">VS Code 安装和汉化</h2>\n<p>下载地址：VS Code官网链接\n选择合适的版本，安装即可\n安装完成后如图\n</p><figure><img alt=\"VS Code初始安装完成\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005a3492d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"550\" data-height=\"166\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005a3492d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n如果需要汉化，ctrl + shift + x，打开插件商店，输入 chinese，然后选择第一个，点击 ‘install’\n<figure><img alt=\"中文插件\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005d90b4bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"831\" data-height=\"168\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005d90b4bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n安装完成后重启软件，显示如下，则汉化完成\n<figure><img alt=\"汉化完成\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080054c5f1d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"728\" data-height=\"83\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080054c5f1d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">插件</h2>\n<p>1.Open-In-Browser</p>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10800596613c2?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>2.Quokka</p>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080057c6e88b?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>3.Faker</p>\n<p>使用流行的 JavaScript 库 – Faker，能够帮你快速的插入用例数据。Faker 可以随机生成姓名、地址、图像、电话号码，或者经典的乱数假文段落，并且每个类别还包含了各种子类别，你可以根据自身的需求来使用这些数据。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10800590b1052?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>4.CSS Peek</p>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080075ea7a9c?imageslim\" data-width=\"639\" data-height=\"267\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"267\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>5.HTML Boilerplate</p>\n<p>通过使用 HTML模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801039a22f2?imageslim\" data-width=\"639\" data-height=\"348\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"348\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>6.Prettier</p>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080075f99516?imageslim\" data-width=\"640\" data-height=\"314\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"314\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>7.Color Info</p>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103b60128?imageslim\" data-width=\"640\" data-height=\"305\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"305\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>8.SVG Viewer</p>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103acda14?imageslim\" data-width=\"639\" data-height=\"323\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"323\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>9.TODO Highlight</p>\n<p>这个插件能够在你的代码中标记出所有的 TODO 注释，以便更容易追踪任何未完成的业务。在默认的情况下，它会查找 TODO 和 FIXME 关键字。当然，你也可以添加自定义表达式。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103cf7235?imageslim\" data-width=\"640\" data-height=\"316\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"316\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>10.Icon Fonts</p>\n<p>这是一个能够在项目中添加图标字体的插件。该插件支持超过 20 个热门的图标集，包括了 Font Awesome、Ionicons、Glyphicons 和 Material Design Icons。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080120fc1563?imageslim\" data-width=\"639\" data-height=\"289\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"289\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>11.Minify</p>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801210e39ca?imageslim\" data-width=\"640\" data-height=\"308\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"308\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>12.Change Case</p>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108013feee80a?imageslim\" data-width=\"639\" data-height=\"274\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"274\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>13.Regex Previewer</p>\n<p>这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801510e5376?imageslim\" data-width=\"640\" data-height=\"305\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"305\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>14.Language and Framework Packs</p>\n<p>VSCode 默认支持大量的主流编程语言，但如果你所使用的编程语言不包括在内，也可以通过下载扩展包来自动添加。同时，你还可以添加一些像 React Native 与 Vue 的相关 Web 开发插件包。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080143fa086f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"301\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"301\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>15.Themes</p>\n<p>当然，在众多的实用插件中，岂能少了漂亮的主题呢？你每天都会与你的 VSCode 编辑器进行“亲密的接触”，为何不把它打扮得更漂亮些呢？这里有一些帮助你更改侧边栏的配色方案，以及图标的相关主题，与大家分享：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801402b549f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"301\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"301\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>16.vscode-icons</p>\n<p>各种漂亮的图标\n</p><figure><img alt=\"vscode-icons\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801401948f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"958\" data-height=\"160\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"958\" height=\"160\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>17.filesize</p>\n<p>左下角显示文件大小的插件</p>\n<p></p><figure><img alt=\"filesize显示效果\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080165c6ee25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>18.GitLens</p>\n<p>能显示每一行代码的作者以及提交时间。</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080160eca1d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"928\" data-height=\"134\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"928\" height=\"134\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>19.Git history</p>\n<p>Git 历史</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080155c4e7f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"926\" data-height=\"118\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"926\" height=\"118\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>20.Vetur</p>\n<p>Vue多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。vscode官方钦定Vue插件，Vue开发者必备。</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108015c7cc81c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1085\" data-height=\"223\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1085\" height=\"223\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>21.React/Redux/react-router Snippets</p>\n<p>React/Redux/react-router语法智能提示</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018099d3c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1156\" data-height=\"298\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1156\" height=\"298\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>22.Path Intellisense</p>\n<p>自动提示文件路径，支持各种快速引入文件</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018084c8bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"480\" data-height=\"270\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"480\" height=\"270\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>23.JavaScript(ES6) code snippets</p>\n<p>ES6语法智能提示，以及快速输入，不仅仅支持.js，还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801ad124bfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1186\" data-height=\"294\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1186\" height=\"294\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>24.HTML Snippets</p>\n<p>智能提示HTML标签，以及标签含义</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018c29690a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"354\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"354\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018f0bd432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1260\" data-height=\"296\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1260\" height=\"296\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>25.HTML CSS Support\n  智能提示CSS类名以及id</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018cb9cc49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"415\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"415\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801b373eb76?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1196\" data-height=\"278\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1196\" height=\"278\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>26.Debugger for Chrome</p>\n<p>映射vscode上的断点到chrome上，方便调试</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801aec3c32e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1260\" data-height=\"302\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1260\" height=\"302\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>27.Auto Close Tag</p>\n<p>自动闭合HTML/XML标签</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801b382b84d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1162\" data-height=\"288\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1162\" height=\"288\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>28.Auto Rename Tag</p>\n<p>自动完成另一侧标签的同步修改</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801bd134ee0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"521\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"521\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>29.Markdown Preview Enhanced</p>\n<p>实时预览markdown，markdown使用者必备</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d3e35c98?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"265\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"265\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>30.markdownlint</p>\n<p>markdown语法纠错</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d62b2bd1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1158\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1158\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>31.fileheader</p>\n<p>  顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间，快捷键ctrl+alt+i在文件开头自动输入作者信息和修改信息等内容</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801ddd68910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"443\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"443\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>32.Vue VSCode Snippets\n  </p>\n<p>VUE代码自动补全插件</p>\n<p>33.VueHelper</p>\n<p>snippet代码片段</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d6cb9881?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"677\" data-height=\"459\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"677\" height=\"459\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>34.Document This(js 和typescript的注释模板)</p>\n<p>ctrl+alt+D，两次（注意：新版的vscode已经原生支持,在function上输入/** tab）<br>\n</p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108021b8100c9?imageslim\" data-width=\"1280\" data-height=\"970\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"970\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>35.Project Manager</p>\n<p>项目管理工具</p>\n<p>这两种方式对于需要经常切换项目时，比较耗时\n为解决这个问题，vscode提供了Project Manager插件管理，开发时常用的项目</p>\n<p>（1）command+ shift + p打开配置文件，\n输入 Project Manager: Edit Projects</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[\n\t{\n\t\t<span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"nuxtest\"</span>,\n\t\t<span class=\"hljs-string\">\"rootPath\"</span>: <span class=\"hljs-string\">\"/Users/tianer/WebstormProjects/sales-crm-web\"</span>,//添加你的本地项目\n\t\t<span class=\"hljs-string\">\"paths\"</span>: [],\n\t\t<span class=\"hljs-string\">\"group\"</span>: <span class=\"hljs-string\">\"\"</span>\n\t},\n\t{\n\t\t<span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"vuetest\"</span>,\n\t\t<span class=\"hljs-string\">\"rootPath\"</span>: <span class=\"hljs-string\">\"/Users/tianer/WebstormProjects/sales-crm-web\"</span>,//添加你的本地项目\n\t\t<span class=\"hljs-string\">\"paths\"</span>: [],\n\t\t<span class=\"hljs-string\">\"group\"</span>: <span class=\"hljs-string\">\"\"</span>\n\t}\n]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e119eb321797ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"689\" data-height=\"163\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"689\" height=\"163\"></svg>\"><figcaption></figcaption></figure>\n预览\n在左侧图标栏下就会有个小文件夹的选项，点击进去就可以切换项目了。<p></p>\n<p>paths里面可放子项目</p>\n<h2 class=\"heading\" data-id=\"heading-2\">结尾彩蛋</h2>\n<p>欢迎关注前端之阶公众号，获取更多前端知识，加入前端大群，与知名互联网大佬做朋友，开启共同学习新篇章！</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10ea3bf4d51a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4bymoe296qi0",
      "author": "前端小智",
      "title": "VSCode前端必备插件，有可能你装了却不知道如何使用？",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>作者：Duomly</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong>阿里云服务器很便宜火爆，今年比去年便宜，10.24~11.11购买是1年86元，3年229元，可以点击 下面链接进行参与：</strong>\n<a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBEDBE5CCBE365B176BB470C64C499DD647C88CF896EF535&userCode=pxuujn3r&share_source=copy_link\" rel=\"nofollow noopener noreferrer\">www.aliyun.com/1111/2019/g…</a></p>\n<hr>\n<p>数组是 JS 最常见的一种数据结构，咱们在开发中也经常用到,在这篇文章中,提供一些小技巧,帮助咱们提高开发效率。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">1. 删除数组的重复项</h2>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa852a1d1bf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"314\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa852a1d1bf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">2. 替换数组中的特定值</h2>\n<p>有时在创建代码时需要替换数组中的特定值，有一种很好的简短方法可以做到这一点，咱们可以使用<code>.splice(start、value to remove、valueToAdd)</code>，这些参数指定咱们希望从哪里开始修改、修改多少个值和替换新值。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa870084b618?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"261\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"261\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-2\">3. Array.from 达到 .map 的效果</h2>\n<p>咱们都知道 <code>.map()</code> 方法，<code>.from()</code> 方法也可以用来获得类似的效果且代码也很简洁。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa883dfc8695?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"429\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"429\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">4.置空数组</h2>\n<p>有时候我们需要清空数组，一个快捷的方法就是直接让数组的 <code>length</code> 属性为 <code>0</code>，就可以清空数组了。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa89a5b762dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"698\" data-height=\"774\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"774\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">5. 将数组转换为对象</h2>\n<p>有时候，出于某种目的，需要将数组转化成对象，一个简单快速的方法是就使用展开运算符号(<code>...</code>):</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8ac3dc7095?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"324\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"324\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-5\">6. 用数据填充数组</h2>\n<p>在某些情况下，当咱们创建一个数组并希望用一些数据来填充它，这时 <code>.fill()</code>方法可以帮助咱们。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8c58885093?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"225\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"225\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">7. 数组合并</h2>\n<p>使用展开操作符，也可以将多个数组合并起来。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8d766b8ec9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"257\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"257\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-7\">8.求两个数组的交集</h2>\n<p>求两个数组的交集在面试中也是有一定难度的正点，为了找到两个数组的交集，首先使用上面的方法确保所检查数组中的值不重复，接着使用<code>.filter</code> 方法和<code>.includes</code>方法。如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8ec0988182?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"266\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"266\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-8\">9.从数组中删除虚值</h2>\n<p>在 JS 中，虚值有 <code>false</code>, <code>0</code>，<code>''</code>， <code>null</code>, <code>NaN</code>, <code>undefined</code>。咱们可以 <code>.filter()</code> 方法来过滤这些虚值。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8fdc8fe989?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"298\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"298\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-9\">10. 从数组中获取随机值</h2>\n<p>有时我们需要从数组中随机选择一个值。一种方便的方法是可以根据数组长度获得一个随机索引，如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa9146b84abb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"248\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"248\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">11.反转数组</h2>\n<p>现在，咱们需要反转数组时，没有必要通过复杂的循环和函数来创建它，数组的 <code>reverse</code> 方法就可以做了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa925550abc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"206\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"206\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">12 lastIndexOf() 方法</h2>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa93994c0055?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"355\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"355\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-12\">13.对数组中的所有值求和</h2>\n<p>JS 面试中也经常用 <code>reduce</code> 方法来巧妙的解决问题</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa94e42554ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"418\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"418\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-13\">总结</h2>\n<p>在本文中，介绍了13个技巧，希望它们可以帮助编写简洁代码，如果你还有更好的办法，欢迎留言讨论。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a target=\"_blank\" href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noopener noreferrer\">Fundebug</a>。</strong></p>\n<p>原文：\n<a target=\"_blank\" href=\"https://dev.to/duomly/13-useful-javascript-array-tips-and-tricks-you-should-know-2jfo\" rel=\"nofollow noopener noreferrer\">dev.to/duomly/13-u…</a></p>\n<h2 class=\"heading\" data-id=\"heading-14\">交流</h2>\n<p>阿里云最近在做活动，低至2折，有兴趣可以看看：<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<p>干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noopener noreferrer\">github.com/qq449245884…</a></p>\n</blockquote>\n<p>因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。</p>\n<p></p><figure><img alt=\"clipboard.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df5ed14ee6d44b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/29/16d7c9e2a5bfb741?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"200\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"200\" height=\"260\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4jxr194oaqk0",
      "author": "极客James",
      "title": "13 个 JS 数组精简技巧，一起来看看",
      "baseClassName": "article-content"
    },
    {
      "content": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"712\" src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-0\">一、写在前面</h3>\n<p>各位掘友久等了,最近在写Vue全家桶+Vant从零开发搭建电商App实战项目,项目基本完结,后面会不定期分享出来,期待各位掘友的关注。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">二、注册登录</h3>\n<p>注册登录,几乎是所有电商App必备模块,正好今天想把这块知识拆出来,详尽的写下来了,用过掘金的小伙伴都知道,掘金PC端的登录界面非常的萌,当你输入账号的时候萌猫会很开心,输入密码的时候,萌猫会捂眼睛,看到这个可爱的设计,着实让我喜欢,所以我就借鉴了掘金的萌猫图写了个登录注册模块,以下是完整UI.</p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1004\" data-height=\"598\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"998\" data-height=\"600\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-2\">三、整体UI搭建思路</h3>\n<p>UI部分非常的简单,整体就是最外层一个大盒子放一张图片,里面放一张小盒子设备边框圆角,然后把萌猫定位到小盒子的顶部中间位置,然后借助Vant来完成相关输入框,按钮的搭建.</p>\n<h3 class=\"heading\" data-id=\"heading-3\">四、Vant 使用</h3>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/intro\" rel=\"nofollow noopener noreferrer\">Vant</a>是有赞开源的很适合做电商App的UI组件,用起来非常爽,我整个项目都采用Vant UI搭建,风格统一,使用简单方便.\n首先将Vant引入到项目中,建议创建一个单独的文件来管理Vant的组件引入模块,按需加载,原则是用哪个就加载哪个.</p>\n<p>注册登录的切换用到了Vant的标签页组件,快速的实现登录和注册页面的切换。</p>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/tab\" rel=\"nofollow noopener noreferrer\">Vant tab</a>按照文档来,非常的简单和好用。</p>\n<p>输入框用到了Vant的Field组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/field\" rel=\"nofollow noopener noreferrer\">Vant Field</a></p>\n<p>按钮用到了Vant的Button组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/button\" rel=\"nofollow noopener noreferrer\">Vant Button</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">五、萌猫切换</h3>\n<p>萌猫根据你所在的输入框不同切换不同的样式,其实就是三张图片的切换,要么一次把三张图片都加载到页面,然后通过<code>v-show</code>的方式来控制他们的显示,这种方式感觉有点麻烦,我采用数据驱动界面的方式,点击到哪个位置,就让<code>img</code>标签来加载哪张图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 改变萌猫\n    changeImage (index) {\n      <span class=\"hljs-keyword\">if</span> (index == 0) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/greeting.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (index == 1) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/blindfold.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/normal.png'</span>)\n      }\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">六、倒计时</h3>\n<p>倒计时其实就是个定时器,先设置好总时长,然后每秒减一,直到减到0,然后恢复按钮点击的状态.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> // 发送手机验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">sendVerifyCode</span></span> () {\n      Toast({\n        message: <span class=\"hljs-string\">'发送验证码'</span>,\n        duration: 800\n\n      });\n      this.countDown = 60;\n      this.timeIntervalID = <span class=\"hljs-built_in\">set</span>Interval(() => {\n        this.countDown--;\n        // 如果减到0 则清除定时器\n        <span class=\"hljs-keyword\">if</span> (this.countDown == 0) {\n          clearInterval(this.timeIntervalID);\n        }\n      }, 1000)\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">七、手机号码正则验证</h3>\n<p>通过计算属性来验证输入的手机号码是否正确,然后在合适的位置调用这个计算属性就可以</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> computed: {\n    // 手机号码正确验证\n    <span class=\"hljs-function\"><span class=\"hljs-title\">phoneNumVerify</span></span> () {\n      <span class=\"hljs-built_in\">return</span> /[1][3,4,5,6,7,8][0-9]{9}$/.test(this.tel_registered);\n    }\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">八、验证码模块</h3>\n<p>验证码其实就是<code>img</code>标签请求接口获取图片,当点击图片的时候再次请求获取最新的图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 切换验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">getCaptcha</span></span> () {\n      // 获取验证码的标签\n      <span class=\"hljs-built_in\">let</span> captchaEle = this.<span class=\"hljs-variable\">$refs</span>.captcha;\n      this.<span class=\"hljs-variable\">$set</span>(captchaEle, <span class=\"hljs-string\">'src'</span>, <span class=\"hljs-string\">'http://192.168.0.1/web/xlmc/api/captcha?time='</span> + new Date());\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">九、总结</h3>\n<p>注册登录仅仅是整个项目的一部分,先分享出来,后面会将整个完整的电商项目分享出来,希望大家能点赞加关注,你的点赞能让更多的人一起学习,一起进步😄</p>\n<h3 class=\"heading\" data-id=\"heading-9\">十、完整电商项目</h3>\n<h4 class=\"heading\" data-id=\"heading-10\">首页模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb781663eb60a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"596\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"596\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">分类模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7882d5b9fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1022\" data-height=\"582\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1022\" height=\"582\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-12\">吃什么模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7904fd0405a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"574\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"574\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-13\">购物车模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb79b80990194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1026\" data-height=\"592\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1026\" height=\"592\"></svg>\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7a53bb8f4f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"590\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"590\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">个人中心模块</h4>\n<div>\n<img alt=\"图片说明\" height=\"300px\" style=\"padding:5px\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb5f78e4fd55c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"526\" data-height=\"944\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"526\" height=\"944\"></svg>\">\n</div>\n<h3 class=\"heading\" data-id=\"heading-15\">往期分享链接</h3>\n<ul>\n<li>\n<p><strong>Vue甜小白系列专栏</strong>:</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d64f31ae51d4561db5e3a74\" rel>Vue从甜小白到皮大佬系列(一) Vue是个啥?</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d652fb351882505a87a976b\" rel>Vue从甜小白到皮大佬系列(二) v-指令</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6675716fb9a06b10273c1c\" rel>Vue从甜小白到皮大佬系列(三) 生命周期\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d673ad7f265da03934bf266\" rel>Vue从甜小白到皮大佬系列(四) 自定义指令\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d67eac7e51d453c12504e3a\" rel>Vue从甜小白到皮大佬系列(五) 组件\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d699e2b6fb9a06ae3727746\" rel>Vue从甜小白到皮大佬系列(六) 组件通信\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6e6f366fb9a06b32609021\" rel>Vue从甜小白到皮大佬系列(七) Vue Router\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6f5801f265da03da24b365\" rel>Vue从甜小白到皮大佬系列(八) Vuex</a></li>\n</ul>\n</li>\n<li>\n<p>每周一道算法题系列</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6bed3e6fb9a06af372d069\" rel>逆波兰表达式求值</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7505c7f265da03c61e775a\" rel>斐波那契数列</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7e48dbe51d4557dc774f3a\" rel>合并两个有序链表</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>最后感谢您的关注!</strong></p>\n<p><a target=\"_blank\" href=\"https://github.com/Geek-James/Blog\" rel=\"nofollow noopener noreferrer\">我的GitHub</a>,希望能得到你的小星星~</p>\n<blockquote>\n<p>希望我的分享对你能有帮助,有不正确的地方也希望得到您的勘误!本人将不胜感激,另外如果你想获取前端整期学习视频和资料扫一扫下面的二维码,回复<strong>学习</strong>即可,也希望在前端进阶的路上,我们一起成长,一起进步!</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/1/16ceae13d9c4953e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"300\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"300\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "58mvpog3e0g0",
      "author": "非著名程序猿",
      "title": "Vue登录注册-掘金可爱萌猫",
      "baseClassName": "article-content"
    },
    {
      "content": "<h3 class=\"heading\" data-id=\"heading-0\">1 前言</h3>\n<p>随着团队人数的增加，每个人的代码编写喜好不同，代码风格也迥然不同。如果有一个大家的统一的愿意遵守的代码规范，肯定事半功倍，提高效率，避免代码<code>Review</code>和<code>重构</code>。</p>\n<p>其中一部分规则参考了 腾讯<code>alloyteam</code>团队的代码规范，如有错误，请指出，将会非常感谢。</p>\n<p>坚持好的代码风格规范，从你我做起。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">2 命名规范</h3>\n<h4 class=\"heading\" data-id=\"heading-2\">1) 项目命名</h4>\n<p>全部采用小写方式， 以下划线分隔。</p>\n<p>例：<code>my_project_name</code></p>\n<h4 class=\"heading\" data-id=\"heading-3\">2 )目录命名</h4>\n<p>参照项目命名规则；</p>\n<p>有复数结构时，要采用复数命名法。</p>\n<p>例：<code>pages</code>, <code>assets</code>, <code>directives</code>, <code>components</code>, <code>mixins</code>, <code>utils</code></p>\n<h4 class=\"heading\" data-id=\"heading-4\">3)<code>javaScript</code> 文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>account_model.js</code></p>\n<h4 class=\"heading\" data-id=\"heading-5\">4)<code>CSS</code>,<code>less</code>文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>retina_sprites.less</code></p>\n<h4 class=\"heading\" data-id=\"heading-6\">5)HTML文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>error_report.html</code></p>\n<h4 class=\"heading\" data-id=\"heading-7\">6) 如果使用<code>Vue</code>或者<code>React</code>技术栈，组件<code>Component</code>命名</h4>\n<p>所有组件名字需要首字母大写，然后驼峰格式</p>\n<p>例：<code>CalendarList.vue</code></p>\n<h3 class=\"heading\" data-id=\"heading-8\">3 HTML</h3>\n<h4 class=\"heading\" data-id=\"heading-9\">1) 语法</h4>\n<ul>\n<li>缩进使用soft tab（4个空格）；</li>\n<li>嵌套的节点应该缩进；</li>\n<li>在属性上，使用双引号，不要使用单引号；</li>\n<li>属性名全小写，用中划线做分隔符；</li>\n<li>不要在自动闭合标签结尾处使用斜线（<a target=\"_blank\" href=\"http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag\" rel=\"nofollow noopener noreferrer\">HTML5 规范</a> 指出他们是可选的）；</li>\n<li>不要忽略可选的关闭标签;</li>\n</ul>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">title</span>></span>Page title<span class=\"hljs-tag\"></<span class=\"hljs-name\">title</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">body</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"images/company_logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Company\"</span> /></span>\n\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"hello-world\"</span>></span>Hello, world!<span class=\"hljs-tag\"></<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">body</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">2) HTML5 doctype</h4>\n<p>在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现；</p>\n<p>虽然doctype不区分大小写，但是按照惯例，doctype大写 （<a target=\"_blank\" href=\"http://stackoverflow.com/questions/15594877/is-there-any-benefits-to-use-uppercase-or-lowercase-letters-with-html5-tagname\" rel=\"nofollow noopener noreferrer\">关于html属性，大写还是小写</a>）。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n\t...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-11\">3) lang属性</h4>\n<p>根据HTML5规范：</p>\n<blockquote>\n<p>应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。</p>\n</blockquote>\n<p>更多关于 <code>lang</code> 属性的说明<a target=\"_blank\" href=\"http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element\" rel=\"nofollow noopener noreferrer\">在这里</a>；</p>\n<p>在sitepoint上可以查到<a target=\"_blank\" href=\"http://reference.sitepoint.com/html/lang-codes\" rel=\"nofollow noopener noreferrer\">语言列表</a>；</p>\n<p>但sitepoint只是给出了语言的大类，例如中文只给出了zh，但是没有区分香港，台湾，大陆。而微软给出了一份更加<a target=\"_blank\" href=\"http://msdn.microsoft.com/en-us/library/ms533052(v=vs.85).aspx\" rel=\"nofollow noopener noreferrer\">详细的语言列表</a>，其中细分了zh-cn, zh-hk, zh-tw。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en-us\"</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-12\">4) 字符编码</h4>\n<p>通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为'UTF-8'。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-13\">5) IE兼容模式</h4>\n<p>用 `` 标签可以指定页面应该用什么版本的IE来渲染；</p>\n<p>如果你想要了解更多，请点击<a target=\"_blank\" href=\"http://stackoverflow.com/questions/6771258/whats-the-difference-if-meta-http-equiv-x-ua-compatible-content-ie-edge-e\" rel=\"nofollow noopener noreferrer\">这里</a>；</p>\n<p>不同doctype在不同浏览器下会触发不同的渲染模式（<a target=\"_blank\" href=\"https://hsivonen.fi/doctype/\" rel=\"nofollow noopener noreferrer\">这篇文章</a>总结的很到位）。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"IE=Edge\"</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-14\">6) 引入CSS, JS</h4>\n<p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 <code>type</code>，因为 <code>text/css</code>和 <code>text/javascript</code> 分别是他们的默认值。</p>\n<p><strong>HTML5 规范链接</strong></p>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element\" rel=\"nofollow noopener noreferrer\">使用link</a></li>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element\" rel=\"nofollow noopener noreferrer\">使用style</a></li>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element\" rel=\"nofollow noopener noreferrer\">使用script</a></li>\n</ul>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-comment\"><!-- External CSS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"code_guide.css\"</span>></span>\n\n<span class=\"hljs-comment\"><!-- In-document CSS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"undefined\">\n    ...\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n\n<span class=\"hljs-comment\"><!-- External JS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"code_guide.js\"</span>></span><span class=\"undefined\"></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-comment\"><!-- In-document JS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span>></span><span class=\"undefined\">\n    ...\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-15\">7) 属性顺序</h4>\n<p>属性应该按照特定的顺序出现以保证易读性；</p>\n<ul>\n<li><code>class</code></li>\n<li><code>id</code></li>\n<li><code>name</code></li>\n<li><code>data-*</code></li>\n<li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code> , <code>max-length</code>, <code>max</code>, <code>min</code>, <code>pattern</code></li>\n<li><code>placeholder</code>, <code>title</code>, <code>alt</code></li>\n<li><code>aria-*</code>, <code>role</code></li>\n<li><code>required</code>, <code>readonly</code>, <code>disabled</code></li>\n</ul>\n<p><code>class</code>是为高可复用组件设计的，所以应处在第一位；</p>\n<p><code>id</code> 具体且应该尽量少使用，所以将它放在第二位。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">data-modal</span>=<span class=\"hljs-string\">\"toggle\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#\"</span>></span>Example link<span class=\"hljs-tag\"></<span class=\"hljs-name\">a</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"form-control\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-16\">8) boolean属性</h4>\n<p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p>\n<p>更多内容可以参考 <a target=\"_blank\" href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes\" rel=\"nofollow noopener noreferrer\">WhatWG section on boolean attributes</a>：</p>\n<blockquote>\n<p>boolean属性的存在表示取值为true，不存在则表示取值为false。</p>\n</blockquote>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">disabled</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">checked</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">select</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">selected</span>></span>1<span class=\"hljs-tag\"></<span class=\"hljs-name\">option</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">select</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-17\">9) JS生成标签</h4>\n<p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">10) 减少标签数量</h4>\n<p>在编写HTML代码时，需要尽量避免多余的父节点；</p>\n<p>很多时候，需要通过迭代和重构来使HTML变得更少。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-comment\"><!-- 不建议这么做 --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"avatar\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n\n<span class=\"hljs-comment\"><!-- 建议这么做 --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"avatar\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-19\">11) 实用高于完美</h4>\n<p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；</p>\n<p>任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p>\n<h3 class=\"heading\" data-id=\"heading-20\">4 css、less</h3>\n<h4 class=\"heading\" data-id=\"heading-21\">1) 缩进</h4>\n<p>使用soft tab（4个空格）</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">position</span>: absolute;\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">10px</span>;\n\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-22\">2)分号</h4>\n<p>每个属性声明末尾都要加分号。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">20px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">20px</span>;\n\n    <span class=\"hljs-attribute\">background-color</span>: red;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-23\">3)空格</h4>\n<p>以下几种情况不需要空格：</p>\n<ul>\n<li>属性名后</li>\n<li>多个规则的分隔符','前</li>\n<li><code>!important</code> '!'后</li>\n<li>属性值中'('后和')'前</li>\n<li>行末不要有多余的空格</li>\n</ul>\n<p>以下几种情况需要空格：</p>\n<ul>\n<li>属性值前</li>\n<li>选择器'>', '+', '~'前后</li>\n<li>'{'前</li>\n<li><code>!important</code> '!'前</li>\n<li><code>@else</code> 前后</li>\n<li>属性值中的','后</li>\n<li>注释'/<em>'后和'</em>/'前</li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color </span>:red! important;\n    <span class=\"hljs-attribute\">background-color</span>: rgba(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,.<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: red <span class=\"hljs-meta\">!important</span>;\n    <span class=\"hljs-attribute\">background-color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> ,\n<span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span>,\n<span class=\"hljs-selector-class\">.dialog</span> {\n\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span>><span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> > <span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-variable\">@debug:</span> true;\n\n<span class=\"hljs-selector-tag\">header</span> {\n  <span class=\"hljs-attribute\">background-color</span>: (yellow)when(<span class=\"hljs-variable\">@debug</span> = true);\n}\n\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-tag\">header</span> {\n  <span class=\"hljs-attribute\">background-color</span>: (yellow) when (<span class=\"hljs-variable\">@debug</span> = true);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-24\">4) 空行</h4>\n<p>以下几种情况需要空行：</p>\n<ul>\n<li>文件最后保留一个空行</li>\n<li>'}'后最好跟一个空行，包括scss中嵌套的规则</li>\n<li>属性之间需要适当的空行，具体见<a target=\"_blank\" href=\"http://alloyteam.github.io/CodeGuide/#css-declaration-order\" rel=\"nofollow noopener noreferrer\">属性声明顺序</a></li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n<span class=\"hljs-selector-class\">.dialog</span> {\n    <span class=\"hljs-attribute\">color</span>: red;\n    <span class=\"hljs-selector-tag\">&</span><span class=\"hljs-selector-pseudo\">:after</span> {\n        ...\n    }\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.dialog</span> {\n    <span class=\"hljs-attribute\">color</span>: red;\n\n    <span class=\"hljs-selector-tag\">&</span><span class=\"hljs-selector-pseudo\">:after</span> {\n        ...\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-25\">5) 注释</h4>\n<p>注释统一用'/* */'（scss中也不要用'//'），具体参照右边的写法；</p>\n<p>缩进与下一行代码保持一致；</p>\n<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* Modal header */</span>\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/*\n * Modal header\n */</span>\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    <span class=\"hljs-comment\">/* 50px */</span>\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n\n    <span class=\"hljs-attribute\">color</span>: red; <span class=\"hljs-comment\">/* color red */</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-26\">6) 引号</h4>\n<p>最外层统一使用双引号；</p>\n<p>url的内容要用引号；</p>\n<p>属性选择器中的属性值需要引号。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span><span class=\"hljs-selector-pseudo\">:after</span> {\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">\"\"</span>;\n    <span class=\"hljs-attribute\">background-image</span>: url(<span class=\"hljs-string\">\"logo.png\"</span>);\n}\n\n<span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-attr\">[data-type=\"single\"]</span> {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-27\">7)<code>命名</code></h4>\n<ul>\n<li>类名使用<code>小写字母</code>，以<code>中划线</code>分隔</li>\n<li>id采用<code>驼峰式</code>命名</li>\n<li><code>less</code>中的变量、函数以<code>中划线</code>分隔命名</li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* class */</span>\n<span class=\"hljs-selector-class\">.element-content</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* id */</span>\n<span class=\"hljs-selector-id\">#myDialog</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* 变量 */</span>\n<span class=\"hljs-variable\">@color-black:</span> <span class=\"hljs-number\">#000</span>;\n\n<span class=\"hljs-comment\">/* mixins */</span>\n<span class=\"hljs-selector-class\">.my-mixin</span>() {\n  <span class=\"hljs-attribute\">color</span>: black;\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-28\">8)<code>属性声明顺序</code></h4>\n<p>相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.declaration-order</span> {\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">float</span>: right;\n\n    <span class=\"hljs-attribute\">position</span>: absolute;\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">right</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">bottom</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">100</span>;\n\n    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#e5e5e5</span>;\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n\n    <span class=\"hljs-attribute\">font</span>: normal <span class=\"hljs-number\">13px</span> <span class=\"hljs-string\">\"Helvetica Neue\"</span>, sans-serif;\n    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">1.5</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f5f5f5</span>;\n\n    <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">1</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>书写顺序前后</code>为：</p>\n<p>（1）<code>定位属性</code>：position  display  float  left  top  right  bottom   overflow  clear   z-index</p>\n<p>（2）<code>自身属性</code>：width  height  padding  border  margin   background</p>\n<p>（3）<code>文字样式</code>：font-family   font-size   font-style   font-weight   font-varient   color</p>\n<p>（4）<code>文本属性</code>text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow</p>\n<p><strong>目的</strong>：减少浏览器reflow（回流），提升浏览器渲染dom的性能</p>\n<p><code>原理：浏览器的渲染流程为：</code></p>\n<p>1、解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构</p>\n<p>2、构建render树：DOM树和CSS树合并之后形成的render树。</p>\n<p>3、布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。</p>\n<p>4、绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。</p>\n<p>css样式解析到显示至浏览器屏幕上就发生在234步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第2步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。在解析过程中，一旦浏览器发现某个元素的定位变化影响DOM，则需要重新渲染。</p>\n<p>正确的书写顺序：</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.demo</span>{\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n\t<span class=\"hljs-attribute\">background-color</span>: red ;\n    \n\t<span class=\"hljs-attribute\">position</span>: absolute;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到它回流的影响而重新排位。最终导致③步骤花费的时间太久而影响到④步骤的显示，影响了用户体验。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">// 下面是推荐的属性的顺序</span>\n<span class=\"hljs-selector-attr\">[\n    [\n        \"display\",\n        \"visibility\",\n        \"float\",\n        \"clear\",\n        \"overflow\",\n        \"overflow-x\",\n        \"overflow-y\",\n        \"clip\",\n        \"zoom\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"table-layout\",\n        \"empty-cells\",\n        \"caption-side\",\n        \"border-spacing\",\n        \"border-collapse\",\n        \"list-style\",\n        \"list-style-position\",\n        \"list-style-type\",\n        \"list-style-image\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"-webkit-box-orient\",\n        \"-webkit-box-direction\",\n        \"-webkit-box-decoration-break\",\n        \"-webkit-box-pack\",\n        \"-webkit-box-align\",\n        \"-webkit-box-flex\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"position\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"z-index\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"margin\",\n        \"margin-top\",\n        \"margin-right\",\n        \"margin-bottom\",\n        \"margin-left\",\n        \"-webkit-box-sizing\",\n        \"-moz-box-sizing\",\n        \"box-sizing\",\n        \"border\",\n        \"border-width\",\n        \"border-style\",\n        \"border-color\",\n        \"border-top\",\n        \"border-top-width\",\n        \"border-top-style\",\n        \"border-top-color\",\n        \"border-right\",\n        \"border-right-width\",\n        \"border-right-style\",\n        \"border-right-color\",\n        \"border-bottom\",\n        \"border-bottom-width\",\n        \"border-bottom-style\",\n        \"border-bottom-color\",\n        \"border-left\",\n        \"border-left-width\",\n        \"border-left-style\",\n        \"border-left-color\",\n        \"-webkit-border-radius\",\n        \"-moz-border-radius\",\n        \"border-radius\",\n        \"-webkit-border-top-left-radius\",\n        \"-moz-border-radius-topleft\",\n        \"border-top-left-radius\",\n        \"-webkit-border-top-right-radius\",\n        \"-moz-border-radius-topright\",\n        \"border-top-right-radius\",\n        \"-webkit-border-bottom-right-radius\",\n        \"-moz-border-radius-bottomright\",\n        \"border-bottom-right-radius\",\n        \"-webkit-border-bottom-left-radius\",\n        \"-moz-border-radius-bottomleft\",\n        \"border-bottom-left-radius\",\n        \"-webkit-border-image\",\n        \"-moz-border-image\",\n        \"-o-border-image\",\n        \"border-image\",\n        \"-webkit-border-image-source\",\n        \"-moz-border-image-source\",\n        \"-o-border-image-source\",\n        \"border-image-source\",\n        \"-webkit-border-image-slice\",\n        \"-moz-border-image-slice\",\n        \"-o-border-image-slice\",\n        \"border-image-slice\",\n        \"-webkit-border-image-width\",\n        \"-moz-border-image-width\",\n        \"-o-border-image-width\",\n        \"border-image-width\",\n        \"-webkit-border-image-outset\",\n        \"-moz-border-image-outset\",\n        \"-o-border-image-outset\",\n        \"border-image-outset\",\n        \"-webkit-border-image-repeat\",\n        \"-moz-border-image-repeat\",\n        \"-o-border-image-repeat\",\n        \"border-image-repeat\",\n        \"padding\",\n        \"padding-top\",\n        \"padding-right\",\n        \"padding-bottom\",\n        \"padding-left\",\n        \"width\",\n        \"min-width\",\n        \"max-width\",\n        \"height\",\n        \"min-height\",\n        \"max-height\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"font\",\n        \"font-family\",\n        \"font-size\",\n        \"font-weight\",\n        \"font-style\",\n        \"font-variant\",\n        \"font-size-adjust\",\n        \"font-stretch\",\n        \"font-effect\",\n        \"font-emphasize\",\n        \"font-emphasize-position\",\n        \"font-emphasize-style\",\n        \"font-smooth\",\n        \"line-height\",\n        \"text-align\",\n        \"-webkit-text-align-last\",\n        \"-moz-text-align-last\",\n        \"-ms-text-align-last\",\n        \"text-align-last\",\n        \"vertical-align\",\n        \"white-space\",\n        \"text-decoration\",\n        \"text-emphasis\",\n        \"text-emphasis-color\",\n        \"text-emphasis-style\",\n        \"text-emphasis-position\",\n        \"text-indent\",\n        \"-ms-text-justify\",\n        \"text-justify\",\n        \"letter-spacing\",\n        \"word-spacing\",\n        \"-ms-writing-mode\",\n        \"text-outline\",\n        \"text-transform\",\n        \"text-wrap\",\n        \"-ms-text-overflow\",\n        \"text-overflow\",\n        \"text-overflow-ellipsis\",\n        \"text-overflow-mode\",\n        \"-ms-word-wrap\",\n        \"word-wrap\",\n        \"-ms-word-break\",\n        \"word-break\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"color\",\n        \"background\",\n        \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\",\n        \"background-color\",\n        \"background-image\",\n        \"background-repeat\",\n        \"background-attachment\",\n        \"background-position\",\n        \"-ms-background-position-x\",\n        \"background-position-x\",\n        \"-ms-background-position-y\",\n        \"background-position-y\",\n        \"-webkit-background-clip\",\n        \"-moz-background-clip\",\n        \"background-clip\",\n        \"background-origin\",\n        \"-webkit-background-size\",\n        \"-moz-background-size\",\n        \"-o-background-size\",\n        \"background-size\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"outline\",\n        \"outline-width\",\n        \"outline-style\",\n        \"outline-color\",\n        \"outline-offset\",\n        \"opacity\",\n        \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity\",\n        \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.Alpha\",\n        \"-ms-interpolation-mode\",\n        \"-webkit-box-shadow\",\n        \"-moz-box-shadow\",\n        \"box-shadow\",\n        \"filter:progid:DXImageTransform.Microsoft.gradient\",\n        \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.gradient\",\n        \"text-shadow\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"-webkit-transition\",\n        \"-moz-transition\",\n        \"-ms-transition\",\n        \"-o-transition\",\n        \"transition\",\n        \"-webkit-transition-delay\",\n        \"-moz-transition-delay\",\n        \"-ms-transition-delay\",\n        \"-o-transition-delay\",\n        \"transition-delay\",\n        \"-webkit-transition-timing-function\",\n        \"-moz-transition-timing-function\",\n        \"-ms-transition-timing-function\",\n        \"-o-transition-timing-function\",\n        \"transition-timing-function\",\n        \"-webkit-transition-duration\",\n        \"-moz-transition-duration\",\n        \"-ms-transition-duration\",\n        \"-o-transition-duration\",\n        \"transition-duration\",\n        \"-webkit-transition-property\",\n        \"-moz-transition-property\",\n        \"-ms-transition-property\",\n        \"-o-transition-property\",\n        \"transition-property\",\n        \"-webkit-transform\",\n        \"-moz-transform\",\n        \"-ms-transform\",\n        \"-o-transform\",\n        \"transform\",\n        \"-webkit-transform-origin\",\n        \"-moz-transform-origin\",\n        \"-ms-transform-origin\",\n        \"-o-transform-origin\",\n        \"transform-origin\",\n        \"-webkit-animation\",\n        \"-moz-animation\",\n        \"-ms-animation\",\n        \"-o-animation\",\n        \"animation\",\n        \"-webkit-animation-name\",\n        \"-moz-animation-name\",\n        \"-ms-animation-name\",\n        \"-o-animation-name\",\n        \"animation-name\",\n        \"-webkit-animation-duration\",\n        \"-moz-animation-duration\",\n        \"-ms-animation-duration\",\n        \"-o-animation-duration\",\n        \"animation-duration\",\n        \"-webkit-animation-play-state\",\n        \"-moz-animation-play-state\",\n        \"-ms-animation-play-state\",\n        \"-o-animation-play-state\",\n        \"animation-play-state\",\n        \"-webkit-animation-timing-function\",\n        \"-moz-animation-timing-function\",\n        \"-ms-animation-timing-function\",\n        \"-o-animation-timing-function\",\n        \"animation-timing-function\",\n        \"-webkit-animation-delay\",\n        \"-moz-animation-delay\",\n        \"-ms-animation-delay\",\n        \"-o-animation-delay\",\n        \"animation-delay\",\n        \"-webkit-animation-iteration-count\",\n        \"-moz-animation-iteration-count\",\n        \"-ms-animation-iteration-count\",\n        \"-o-animation-iteration-count\",\n        \"animation-iteration-count\",\n        \"-webkit-animation-direction\",\n        \"-moz-animation-direction\",\n        \"-ms-animation-direction\",\n        \"-o-animation-direction\",\n        \"animation-direction\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"content\",\n        \"quotes\",\n        \"counter-reset\",\n        \"counter-increment\",\n        \"resize\",\n        \"cursor\",\n        \"-webkit-user-select\",\n        \"-moz-user-select\",\n        \"-ms-user-select\",\n        \"user-select\",\n        \"nav-index\",\n        \"nav-up\",\n        \"nav-right\",\n        \"nav-down\",\n        \"nav-left\",\n        \"-moz-tab-size\",\n        \"-o-tab-size\",\n        \"tab-size\",\n        \"-webkit-hyphens\",\n        \"-moz-hyphens\",\n        \"hyphens\",\n        \"pointer-events\"\n    ]</span>\n]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-29\">9)颜色</h4>\n<p>颜色16进制用小写字母；</p>\n<p>颜色16进制尽量用简写。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ABCDEF</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#001122</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#abcdef</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#012</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-30\">10)属性简写</h4>\n<p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p>\n<p><code>margin</code> 和 <code>padding</code> 相反，需要使用简写；</p>\n<p>常见的属性简写包括：</p>\n<ul>\n<li><code>font</code></li>\n<li><code>background</code></li>\n<li><code>transition</code></li>\n<li><code>animation</code></li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">transition</span>: opacity <span class=\"hljs-number\">1s</span> linear <span class=\"hljs-number\">2s</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">transition-delay</span>: <span class=\"hljs-number\">2s</span>;\n    <span class=\"hljs-attribute\">transition-timing-function</span>: linear;\n    <span class=\"hljs-attribute\">transition-duration</span>: <span class=\"hljs-number\">1s</span>;\n    <span class=\"hljs-attribute\">transition-property</span>: opacity;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-31\">11)<code>媒体查询</code></h4>\n<p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.element-avatar</span>{\n    ...\n}\n\n<span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) {\n    <span class=\"hljs-selector-class\">.element</span> {\n        ...\n    }\n\n    <span class=\"hljs-selector-class\">.element-avatar</span> {\n        ...\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-32\">12)<code>Less相关</code></h4>\n<p>每个模块应该有一个单独的less, 然后每个最外层的父类 className 应该写在第一位，所有子Node的样式都写在里面，这样是为了避免命名冲突。比如</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">//out: false</span>\n<span class=\"hljs-selector-class\">.parent-name</span>{\n    \n    <span class=\"hljs-selector-class\">.child-name</span>{\n        ...\n    }\n    \n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>@import</code> 引入的文件不需要结尾的'.less'</p>\n<p><code>LESS嵌套最多不能超过5层</code>；</p>\n<p>不允许有空的规则；</p>\n<p>元素选择器用小写字母；</p>\n<p>去掉小数点前面的0；</p>\n<p>去掉数字中不必要的小数点和末尾的0；</p>\n<p>属性值'0'后面不要加单位；</p>\n<p>同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法；</p>\n<p>无前缀的标准属性应该写在有前缀的属性后面；</p>\n<p>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</p>\n<p>不要在一个文件里出现两个相同的规则；</p>\n<p>用 <code>border: 0;</code> 代替 <code>border: none;</code>；</p>\n<p><code>CSS选择器不要超过3层</code>；</p>\n<p>尽量少用<code>'*'</code>选择器。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-tag\">LI</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-tag\">li</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50.0px</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0px</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">-webkit-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">-moz-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n\n    <span class=\"hljs-attribute\">background</span>: linear-gradient(to bottom, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>: -webkit-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>: -moz-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">-webkit-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n       <span class=\"hljs-attribute\">-moz-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n\n    <span class=\"hljs-attribute\">background</span>: -webkit-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>:    -moz-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>:         linear-gradient(to bottom, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-33\">5 JavaScript</h3>\n<h4 class=\"heading\" data-id=\"heading-34\">1)缩进</h4>\n<p>使用soft tab（4个空格）。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>,\n    y = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">if</span> (x < y) {\n    x += <span class=\"hljs-number\">10</span>;\n} <span class=\"hljs-keyword\">else</span> {\n    x += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-35\">2)分号</h4>\n<p>以下几种情况后需加分号：</p>\n<ul>\n<li>变量声明</li>\n<li>表达式</li>\n<li>return</li>\n<li>throw</li>\n<li>break</li>\n<li>continue</li>\n<li>do-while</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">/* var declaration */</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">/* expression statement */</span>\nx++;\n\n<span class=\"hljs-comment\">/* do-while */</span>\n<span class=\"hljs-keyword\">do</span> {\n    x++;\n} <span class=\"hljs-keyword\">while</span> (x < <span class=\"hljs-number\">10</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-36\">3)空格</h4>\n<p>以下几种情况不需要空格：</p>\n<ul>\n<li>对象的属性名后</li>\n<li>前缀一元运算符后</li>\n<li>后缀一元运算符前</li>\n<li>函数调用括号前</li>\n<li>无论是函数声明还是函数表达式，'('前不要空格</li>\n<li>数组的'['后和']'前</li>\n<li>对象的'{'后和'}'前</li>\n<li>运算符'('后和')'前</li>\n</ul>\n<p>以下几种情况需要空格：</p>\n<ul>\n<li>二元运算符前后</li>\n<li>三元运算符'?:'前后</li>\n<li>代码块'{'前</li>\n<li>下列关键字前：<code>else</code>, <code>while</code>, <code>catch</code>, <code>finally</code></li>\n<li>下列关键字后：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>case</code>, <code>try</code>,<code>catch</code>, <code>finally</code>, <code>with</code>, <code>return</code>, <code>typeof</code></li>\n<li>单行注释'//'后（若单行注释和代码同行，则'//'前也需要），多行注释'*'后</li>\n<li>对象的属性值前</li>\n<li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格</li>\n<li>无论是函数声明还是函数表达式，'{'前一定要有空格</li>\n<li>函数的参数之间</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span> :<span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-comment\">// not good</span>\n++ x;\ny ++;\nz = x?<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// good</span>\n++x;\ny++;\nz = x ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ];\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = ( <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span> )*<span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = (<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-comment\">// no space before '(', one space before '{', one space between function parameters</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n\n<span class=\"hljs-comment\">// no space before '('</span>\ndoSomething(item);\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i<<span class=\"hljs-number\">6</span>;i++){\n    x++;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">6</span>; i++) {\n    x++;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-37\">4)空行</h4>\n<p>以下几种情况需要空行：</p>\n<ul>\n<li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）</li>\n<li>注释前（当注释在代码块的第一行时，则无需空行）</li>\n<li>代码块后（在函数调用、数组、对象中则无需空行）</li>\n<li>文件最后保留一个空行</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// need blank line after variable declaration</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// not need blank line when variable declaration is last expression in the current block</span>\n<span class=\"hljs-keyword\">if</span> (x >= <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">var</span> y = x + <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// need blank line before line comment</span>\na++;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">b</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// not need blank line when comment is first line of block</span>\n    <span class=\"hljs-keyword\">return</span> a;\n}\n\n<span class=\"hljs-comment\">// need blank line after blocks</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">2</span>; i++) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-keyword\">continue</span>;\n}\n\n<span class=\"hljs-keyword\">var</span> obj = {\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    },\n\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;\n    }\n};\n\n<span class=\"hljs-comment\">// not need blank line when in argument list, array, object</span>\nfunc(\n    <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-number\">3</span>\n);\n\n<span class=\"hljs-keyword\">var</span> foo = [\n    <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-number\">3</span>\n];\n\n<span class=\"hljs-keyword\">var</span> foo = {\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-38\">5)换行</h4>\n<p>换行的地方，行末必须有','或者运算符；</p>\n<p>以下几种情况不需要换行：</p>\n<ul>\n<li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li>\n<li>代码块'{'前</li>\n</ul>\n<p>以下几种情况需要换行：</p>\n<ul>\n<li>代码块'{'后和'}'前</li>\n<li>变量赋值后</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>\n    , <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n\nx = y\n    ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n\nx = y ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\nx = y ?\n    <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// no need line break with 'else', 'catch', 'finally'</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n    ...\n} <span class=\"hljs-keyword\">else</span> {\n    ...\n}\n\n<span class=\"hljs-keyword\">try</span> {\n    ...\n} <span class=\"hljs-keyword\">catch</span> (e) {\n    ...\n} <span class=\"hljs-keyword\">finally</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>)\n</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a, foo = <span class=\"hljs-number\">7</span>, b,\n    c, bar = <span class=\"hljs-number\">8</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a,\n    foo = <span class=\"hljs-number\">7</span>,\n    b, c, bar = <span class=\"hljs-number\">8</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-39\">6)单行注释</h4>\n<p>双斜线后，必须跟一个空格；</p>\n<p>缩进与下一行代码保持一致；</p>\n<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">if</span> (condition) {\n    <span class=\"hljs-comment\">// if you made it here, then all security checks passed</span>\n    allowed();\n}\n\n<span class=\"hljs-keyword\">var</span> zhangsan = <span class=\"hljs-string\">'zhangsan'</span>; <span class=\"hljs-comment\">// one space after code</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-40\">7)多行注释</h4>\n<p>最少三行, '*'后跟一个空格，具体参照右边的写法；</p>\n<p>建议在以下情况下使用：</p>\n<ul>\n<li>难于理解的代码段</li>\n<li>可能存在错误的代码段</li>\n<li>浏览器特殊的HACK代码</li>\n<li>业务逻辑强相关的代码</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">/*\n * one space after '*'\n */</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-41\">8)<code>文档注释</code></h4>\n<p>各类标签@param, @method等请参考<a target=\"_blank\" href=\"http://usejsdoc.org/\" rel=\"nofollow noopener noreferrer\">usejsdoc</a>和<a target=\"_blank\" href=\"http://yuri4ever.github.io/jsdoc/\" rel=\"nofollow noopener noreferrer\">JSDoc Guide</a>；</p>\n<p>建议在以下情况下使用：</p>\n<ul>\n<li>所有常量</li>\n<li>所有函数</li>\n<li>所有类</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * @func\n * @desc 一个带参数的函数\n * @param {string} a - 参数a\n * @param {number} b=1 - 参数b默认值为1\n * @param {string} c=1 - 参数c有两种支持的取值</br>1—表示x</br>2—表示xx\n * @param {object} d - 参数d为一个对象\n * @param {string} d.e - 参数d的e属性\n * @param {string} d.f - 参数d的f属性\n * @param {object[]} g - 参数g为一个对象数组\n * @param {string} g.h - 参数g数组中一项的h属性\n * @param {string} g.i - 参数g数组中一项的i属性\n * @param {string} [j] - 参数j是一个可选参数\n */\n<span class=\"hljs-keyword\">function</span> foo(a, b, c, d, g, j) {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-42\">9)引号</h4>\n<p>最外层统一使用单引号。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-string\">\"test\"</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-string\">'foo'</span>,\n    z = <span class=\"hljs-string\">'<div id=\"test\"></div>'</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-43\">10)变量命名</h4>\n<ul>\n<li>标准变量采用驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据）</li>\n<li>'ID'在变量名中全大写</li>\n<li>'URL'在变量名中全大写</li>\n<li>'Android'在变量名中大写第一个字母</li>\n<li>'iOS'在变量名中小写第一个，大写后两个字母</li>\n<li>常量全大写，用下划线连接</li>\n<li>构造函数，大写第一个字母</li>\n<li>jquery对象必须以'$'开头命名</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> thisIsMyName;\n\n<span class=\"hljs-keyword\">var</span> goodID;\n\n<span class=\"hljs-keyword\">var</span> reportURL;\n\n<span class=\"hljs-keyword\">var</span> AndroidVersion;\n\n<span class=\"hljs-keyword\">var</span> iOSVersion;\n\n<span class=\"hljs-keyword\">var</span> MAX_COUNT = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = name;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> body = $(<span class=\"hljs-string\">'body'</span>);\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> $body = $(<span class=\"hljs-string\">'body'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-44\">11)变量声明</h4>\n<p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var 声明，不允许出现两个连续的var声明。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomethingWithItems</span>(<span class=\"hljs-params\">items</span>) </span>{\n    <span class=\"hljs-comment\">// use one var</span>\n    <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-number\">10</span>,\n        result = value + <span class=\"hljs-number\">10</span>,\n        i,\n        len;\n\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>, len = items.length; i < len; i++) {\n        result += <span class=\"hljs-number\">10</span>;\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-45\">12)函数</h4>\n<p>无论是函数声明还是函数表达式，'('前不要空格，但'{'前一定要有空格；</p>\n<p>函数调用括号前不需要空格；</p>\n<p>立即执行函数外必须包一层括号；</p>\n<p>不要给inline function命名；</p>\n<p>参数之间用', '分隔，注意逗号后有一个空格。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// no space before '(', but one space before'{'</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomething</span>(<span class=\"hljs-params\">item</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n}\n\n<span class=\"hljs-comment\">// not good</span>\ndoSomething (item);\n\n<span class=\"hljs-comment\">// good</span>\ndoSomething(item);\n\n<span class=\"hljs-comment\">// requires parentheses around immediately invoked function expressions</span>\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n})();\n\n<span class=\"hljs-comment\">// not good</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">x</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n});\n\n<span class=\"hljs-comment\">// good</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n});\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}];\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}];\n\n<span class=\"hljs-comment\">// use ', ' between function parameters</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-46\">13)数组、对象</h4>\n<p>对象属性名不需要加引号；</p>\n<p>对象以缩进的形式书写，不要写在一行；</p>\n<p>数组、对象最后不要有逗号。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-string\">'b'</span>: <span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-keyword\">var</span> a = {<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>};\n\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>,\n};\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-47\">14)括号</h4>\n<p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>,<code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (condition)\n    doSomething();\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n    doSomething();\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-48\">15)null</h4>\n<p>适用场景：</p>\n<ul>\n<li>初始化一个将来可能被赋值为对象的变量</li>\n<li>与已经初始化的变量做比较</li>\n<li>作为一个参数为对象的函数的调用传参</li>\n<li>作为一个返回对象的函数的返回值</li>\n</ul>\n<p>不适用场景：</p>\n<ul>\n<li>不要用null来判断函数调用时有无传参</li>\n<li>不要与未初始化的变量做比较</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (b <span class=\"hljs-string\">`= null) {\n        // not mean b is not supply\n        ...\n    }\n}\n\nvar a;\n\nif (a `</span>= <span class=\"hljs-literal\">null</span>) {\n    ...\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-string\">`= null) {\n    ...\n}\n</span><span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-49\">16)undefined</h4>\n<p>永远不要直接使用undefined进行变量判断；</p>\n<p>使用typeof和字符串'undefined'对变量进行判断。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (person <span class=\"hljs-string\">`= undefined) {\n    ...\n}\n\n// good\nif (typeof person `</span>= <span class=\"hljs-string\">'undefined'</span>) {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-50\">17)jshint</h4>\n<p>用'<code>=', '!</code>'代替'`', '!='；</p>\n<p>for-in里一定要有hasOwnProperty的判断；</p>\n<p>不要在内置对象的原型上添加方法，如Array, Date；</p>\n<p>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</p>\n<p>变量不要先使用后声明；</p>\n<p>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</p>\n<p>不要在同个作用域下声明同名变量；</p>\n<p>不要在一些不需要的地方加括号，例：delete(a.b)；</p>\n<p>不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）；</p>\n<p>不要声明了变量却不使用；</p>\n<p>不要在应该做比较的地方做赋值；</p>\n<p>debugger不要出现在提交的代码里；</p>\n<p>数组中不要存在空元素；</p>\n<p>不要在循环内部声明函数；</p>\n<p>不要像这样使用构造函数，例：<code>new function () { ... }</code>, <code>new Object</code>；</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-string\">` 1) {\n    a++;\n}\n\n// good\nif (a `</span>= <span class=\"hljs-number\">1</span>) {\n    a++;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">for</span> (key <span class=\"hljs-keyword\">in</span> obj) {\n    <span class=\"hljs-keyword\">if</span> (obj.hasOwnProperty(key)) {\n        <span class=\"hljs-comment\">// be sure that obj[key] belongs to the object and was not inherited</span>\n        <span class=\"hljs-built_in\">console</span>.log(obj[key]);\n    }\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-built_in\">Array</span>.prototype.count = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;\n};\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">0</span>;\n    }\n\n    x += <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n\n    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">new</span> Person();\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> Person();\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">delete</span>(obj.attr);\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">delete</span> obj.attr;\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (a = <span class=\"hljs-number\">10</span>) {\n    a++;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, , , <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> nums = [];\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">10</span>; i++) {\n    (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{\n        nums[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) </span>{\n            <span class=\"hljs-keyword\">return</span> i + j;\n        };\n    }(i));\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> singleton = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> privateVar;\n\n    <span class=\"hljs-keyword\">this</span>.publicMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        privateVar = <span class=\"hljs-number\">1</span>;\n    };\n\n    <span class=\"hljs-keyword\">this</span>.publicMethod2 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        privateVar = <span class=\"hljs-number\">2</span>;\n    };\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-51\">18)杂项</h4>\n<p>不要混用tab和space；</p>\n<p>不要在一处使用多个tab或space；</p>\n<p>换行符统一用'LF'；</p>\n<p>对上下文this的引用只能使用'_this', 'that', 'self'其中一个来命名；</p>\n<p>行尾不要有空白字符；</p>\n<p>switch的falling through和no default的情况一定要有注释特别说明；</p>\n<p>不允许有空的代码块。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a   = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// not good</span>\n    <span class=\"hljs-keyword\">var</span> me = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">switch</span> (condition) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n        ...\n        break;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n        ...\n    <span class=\"hljs-comment\">// why fall through</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>\n        ...\n        break;\n    <span class=\"hljs-comment\">// why no default</span>\n}\n\n<span class=\"hljs-comment\">// not good with empty block</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>插件推荐：\n<code>EditorConfig for VS Code 生成.editorconfig文件</code></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">root = <span class=\"hljs-literal\">true</span>\n\n[*]\nindent_style = space\nindent_size = 4\ncharset = utf-8\ntrim_trailing_whitespace = <span class=\"hljs-literal\">true</span>\ninsert_final_newline = <span class=\"hljs-literal\">true</span>\n\n[*.md]\ntrim_trailing_whitespace = <span class=\"hljs-literal\">false</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>未完待续</p>\n",
      "id": "7cemnhisr380",
      "author": "前端劝退师",
      "title": "大前端团队代码规范",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>前段时间在研究前端异常监控/埋点平台的实现。</p>\n<p>在思考方案时，想到了浏览器自带的观察者以及页面生命周期API 。</p>\n<p>于是在翻查资料时意外发现，原来现代浏览器支持多达四种不同类型的观察者：</p>\n<ul>\n<li><code>Intersection Observer</code>，交叉观察者。</li>\n<li><code>Mutation Observer</code>，变动观察者。</li>\n<li><code>Resize Observer</code>，视图观察者。</li>\n<li><code>Performance Observer</code>，性能观察者\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16df977e0b2680a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"300\" data-height=\"300\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"300\" height=\"300\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IntersectionObserver</th>\n<th>MutationObserver</th>\n<th>ResizeObserver</th>\n<th>PerformanceObserver</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>观察一个元素是否在视窗可见</td>\n<td>观察DOM中的变化</td>\n<td>观察视口大小的变化</td>\n<td>监测性能度量事件</td>\n</tr>\n<tr>\n<td>方法</td>\n<td>observe() <br>disconnect() <br> takeRecords()</td>\n<td>observe() <br>disconnect() <br>takeRecords() <br>unobserve()</td>\n<td>observe() <br>disconnect() <br>unobserve()</td>\n<td>observe() <br>disconnect() <br>takeRecords()</td>\n</tr>\n<tr>\n<td>取代</td>\n<td>Dom Mutation events</td>\n<td>getBoundingClientRect() 返回元素的大小及其相对于可视窗口的位置  <br> <br> Scroll 和 Resize 事件</td>\n<td>Resize 事件</td>\n<td>Performance 接口</td>\n</tr>\n<tr>\n<td>用途</td>\n<td>1. 无限滚动 <br>2. 图片懒加载<br> 3. 兴趣埋点 <br> 4. 控制动画/视频执行（性能优化）</td>\n<td>1. 更高性能的数据绑定及响应<br> 2. 实现视觉差滚动  <br> 3. 图片预加载 <br> 4. 实现富文本编辑器</td>\n<td>1. 更智能的响应式布局（取代@media） <br>2. 响应式组件</td>\n<td>1. 更细颗粒的性能监控 <br>2. 分析性能对业务的影响（交互快/慢是否会影响销量）</td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-1\">1. <code>IntersectionObserver</code>：交叉观察者</h2>\n<blockquote>\n<p><code>IntersectionObserver</code>接口，提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态的方法，祖先元素与视窗(<code>viewport)</code>被称为根(<code>root</code>)</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 出现的意义</h3>\n<p>想要计算Web页面的元素的位置，非常依赖于<code>DOM</code>状态的显式查询。但这些查询是同步的，会导致昂贵的样式计算开销（重绘和回流），且不停轮询会导致大量的性能浪费。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df34ffa206ff4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"710\" data-height=\"379\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"710\" height=\"379\"></svg>\"><figcaption></figcaption></figure>\n于是便发展了以下的几种方案：<p></p>\n<ul>\n<li>构建DOM和数据的自定义预加载和延迟加载。</li>\n<li>实现了数据绑定的高性能滚动列表，该列表加载和呈现数据集的子集。</li>\n<li>通过<code>scroll</code>等事件或通过插件的形式，计算真实元素可见性。</li>\n</ul>\n<p>而它们都有几项共同特点：</p>\n<ol>\n<li>基本实现形式都是查询各个元素相对与某些元素（全局视口）的“被动查询”。</li>\n<li>信息可以异步传递（例如从另一个线程传递），且没有统一捕获错误的处理。</li>\n<li><code>web</code>平台支持匮乏，各有各家的处理。需要开发人员消耗大量精力兼容。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-3\">2. <code>IntersectionObserver</code>的优势</h3>\n<p><code>Intersection Observer API</code>通过为开发人员提供一种新方法来异步查询元素相对于其他元素或全局视口的位置，从而解决了上述问题:</p>\n<ul>\n<li><strong>异步处理</strong>消除了昂贵的<code>DOM</code>和样式查询，连续轮询以及使用自定义插件的需求。</li>\n<li>通过消除对这些方法的需求，可以使应用程序显着降低<code>CPU</code>，<code>GPU</code>和资源成本。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-4\">3. <code>IntersectionObserver</code>基本使用</h3>\n<p>使用<code>IntersectionObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调事件</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-5\">1.<strong>创建观察者</strong></h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const options = {\n    root: document.querySelector(<span class=\"hljs-string\">'.scrollContainer'</span>),\n    rootMargin: <span class=\"hljs-string\">'0px'</span>,\n    threshold: [0.3, 0.5, 0.8, 1] }\n    \nconst observer = new IntersectionObserver(handler, options)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这几个参数用大白话解释就是：</p>\n<ol>\n<li><code>root</code>：指定一个根元素</li>\n<li><code>rootMargin</code>：使用类似于设置CSS边距的语法来指定根边距（根元素的观察影响范围）\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df3610c9bf7742?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"710\" data-height=\"556\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"710\" height=\"556\"></svg>\"><figcaption></figcaption></figure></li>\n<li><code>threshold</code>：阈值，可以为数组。<code>[0.3]</code>意味着，当目标元素在根元素指定的元素内可见30%时，调用处理函数。</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-6\">2. <strong>定义回调事件</strong></h4>\n<p>当目标元素与根元素通过阈值相交时，就会触发回调函数。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> handler (entries, observer) { \n    entries.forEach(entry => { \n    // 每个成员都是一个IntersectionObserverEntry对象。\n    // 举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。\n    // entry.boundingClientRect \n    // entry.intersectionRatio \n    // entry.intersectionRect \n    // entry.isIntersecting \n    // entry.rootBounds \n    // entry.target \n    // entry.time \n    }); \n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>time 时间戳</li>\n<li>rootBounds 根元素的位置</li>\n<li>boundingClientRect 目标元素的位置信息</li>\n<li>intersectionRect 交叉部分的位置信息</li>\n<li>intersectionRatio 目标元素的可见比例，看下图示</li>\n<li>target。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df3f6a6b04daeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"886\" data-height=\"876\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"886\" height=\"876\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-7\">3. <strong>定义要观察的目标对象</strong></h4>\n<p>任何目标元素都可以通过调用<code>.observer(target)</code>方法来观察。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const target = document.querySelector(“.targetBox”); \nobserver.observe(target);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>此外，还有两个方法：</p>\n<p>停止对某目标的监听</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.unobserve(target)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>终止对所有目标的监听</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.disconnect()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">4. 例子1：图片懒加载</h3>\n<p><code>HTML</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-1.jpg\"</span>>\n<img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-2.jpg\"</span>>\n<img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-3.jpg\"</span>>\n<!-- more images -->\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>脚本：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new IntersectionObserver(\n(entries, observer) => { \nentries.forEach(entry => {\n    /* 替换属性 */\n    entry.target.src = entry.target.dataset.src;\n    observer.unobserve(entry.target);\n  });\n}, \n{rootMargin: <span class=\"hljs-string\">\"0px 0px -200px 0px\"</span>});\n\ndocument.querySelectorAll(<span class=\"hljs-string\">'img'</span>).forEach(img => { observer.observe(img) });\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>上述例子表示 仅在到达视口距离底部200px视加载图片。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">5. 例子2：兴趣埋点</h3>\n<p>关于兴趣埋点，一个比较通用的方案是：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d11ced1f265da1b7004b6f7#heading-8\" rel>来自：《超好用的API之IntersectionObserver》</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const boxList = [...document.querySelectorAll(<span class=\"hljs-string\">'.box'</span>)]\n\nvar io = new IntersectionObserver((entries) =>{\n  entries.forEach(item => {\n    // intersectionRatio === 1说明该元素完全暴露出来，符合业务需求\n    <span class=\"hljs-keyword\">if</span> (item.intersectionRatio === 1) {\n      // 。。。 埋点曝光代码\n      io.unobserve(item.target)\n    }\n  })\n}, {\n  root: null,\n  threshold: 1, // 阀值设为1，当只有比例达到1时才触发回调函数\n})\n\n// observe遍历监听所有box节点\nboxList.forEach(box => io.observe(box))\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>至于怎样评断用户是否感兴趣，记录方式就见仁见智了：</p>\n<ul>\n<li>位于屏幕中间，并停留时长大于2秒，计数一次。</li>\n<li>区域悬停，触发定时器记录时间。</li>\n<li><code>PC</code>端记录鼠标点击次数/悬停时间，移动端记录<code>touch</code>事件</li>\n</ul>\n<p>这里就不展开写了（我懒）。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">6. 控制动画/视频 执行</h3>\n<p>这里提供控制视频的版本</p>\n<p><code>HTML</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><video src=<span class=\"hljs-string\">\"OSRO-animation.mp4\"</span> controls=<span class=\"hljs-string\">\"\"</span>></video>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>js</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> video = document.querySelector(<span class=\"hljs-string\">'video'</span>);\n<span class=\"hljs-built_in\">let</span> isPaused = <span class=\"hljs-literal\">false</span>; /* Flag <span class=\"hljs-keyword\">for</span> auto-paused video */\n<span class=\"hljs-built_in\">let</span> observer = new IntersectionObserver((entries, observer) => { \n  entries.forEach(entry => {\n    <span class=\"hljs-keyword\">if</span>(entry.intersectionRatio!=1  && !video.paused){\n      video.pause(); isPaused = <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(isPaused) {video.play(); isPaused=<span class=\"hljs-literal\">false</span>}\n  });\n}, {threshold: 1});\nobserver.observe(video);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>效果：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df6bce3adeb937?imageslim\" data-width=\"504\" data-height=\"721\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"504\" height=\"721\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">2. <code>Mutation Observer</code>：变动观察者</h2>\n<blockquote>\n<p>接口提供了监视对<code>DOM</code>树所做更改的能力。它被设计为旧的<code>MutationEvents</code>功能的替代品，该功能是<code>DOM3 Events</code>规范的一部分。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 出现的意义</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df775ba854199d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"239\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"239\"></svg>\"><figcaption></figcaption></figure>\n归根究底，是<code>MutationEvents</code>的功能不尽人意：<p></p>\n<ol>\n<li>在<code>MDN</code>中也写到了，是被<code>DOM Event</code>承认在API上有缺陷，反对使用。</li>\n<li>核心缺陷是：性能问题和跨浏览器支持。</li>\n<li>为<code>DOM</code>添加 <code>mutation</code> 监听器极度降低进一步修改<code>DOM</code>文档的性能（慢1.5 - 7倍），此外, 移除监听器不会逆转的损害。</li>\n</ol>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6dd5f3f265da03c23eeff9\" rel>来自：《监听DOM加载完成及改变——MutationObserver应用》</a></p>\n</blockquote>\n<p><code>MutationEvents</code>的原理：通过绑定事件监听<code>DOM</code></p>\n<p>乍一看到感觉很正常，那列一下相关监听的事件：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">DOMAttributeNameChanged\nDOMCharacterDataModified\nDOMElementNameChanged\nDOMNodeInserted\nDOMNodeInsertedIntoDocument\nDOMNodeRemoved\nDOMNodeRemovedFromDocument\nDOMSubtreeModified\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>甭记，这么多事件，各内核各版本浏览器想兼容怕是要天荒地老。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. <code>MutationObserver</code>的优势</h3>\n<p>而<code>Mutation Observer</code>的优势在于：</p>\n<ul>\n<li><code>MutationEvents</code>事件是同步触发，也就是说，<code>DOM</code> 的变动立刻会触发相应的事件；</li>\n<li><code>Mutation Observer</code> 则是异步触发，<code>DOM</code> 的变动并不会马上触发，而是要等到当前所有 <code>DOM</code> 操作都结束才触发。</li>\n<li>可以通过配置项，监听目标<code>DOM</code>下子元素的变更记录</li>\n</ul>\n<p>简单讲：<code>异步万岁</code>!</p>\n<h3 class=\"heading\" data-id=\"heading-14\">3. <code>MutationObserver</code>基本使用</h3>\n<p>使用<code>MutationObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-15\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new MutationObserver(callback);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-16\">2. 定义回调函数</h4>\n<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> callback (mutations, observer) {\n  mutations.forEach(<span class=\"hljs-keyword\">function</span>(mutation) {\n    console.log(mutation);\n  });\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>其中每个<code>mutation</code>都对应一个<code>MutationRecord</code>对象，记录着<code>DOM</code>每次发生变化的变动记录</p>\n<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type</code></td>\n<td>观察的变动类型（<code>attribute</code>、<code>characterData</code>或者<code>childList</code>）</td>\n</tr>\n<tr>\n<td><code>target</code></td>\n<td>发生变动的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>addedNodes</code></td>\n<td>新增的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>removedNodes</code></td>\n<td>删除的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>previousSibling</code></td>\n<td>前一个同级节点，如果没有则返回<code>null</code></td>\n</tr>\n<tr>\n<td><code>nextSibling</code></td>\n<td>下一个同级节点，如果没有则返回<code>null</code></td>\n</tr>\n<tr>\n<td><code>attributeName</code></td>\n<td>发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性</td>\n</tr>\n<tr>\n<td><code>oldValue</code></td>\n<td>变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code></td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-17\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.observe(dom, options)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>启动监听，接收两个参数。</p>\n<ul>\n<li>第一参数：被观察的<code>DOM</code>节点。</li>\n<li>第二参数：配置需要观察的变动项<code>options</code>。</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">mutationObserver.observe(content, {\n    attributes: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标属性的改变\n    characterData: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标数据的改变(改变前的数据/值)\n    childList: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化\n    subtree: <span class=\"hljs-literal\">true</span>, // Boolean - 目标以及目标的后代改变都会观察\n    attributeOldValue: <span class=\"hljs-literal\">true</span>, // Boolean - 表示需要记录改变前的目标属性值\n    characterDataOldValue: <span class=\"hljs-literal\">true</span>, // Boolean - 设置了characterDataOldValue可以省略characterData设置\n    // attributeFilter: [<span class=\"hljs-string\">'src'</span>, <span class=\"hljs-string\">'class'</span>] // Array - 观察指定属性\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>优先级 ：</p>\n<ol>\n<li><code>attributeFilter/attributeOldValue</code> > <code>attributes</code></li>\n<li><code>characterDataOldValue</code> > <code>characterData</code></li>\n<li><code>attributes/characterData/childList</code>（或更高级特定项）至少有一项为true；</li>\n<li>特定项存在, 对应选项可以忽略或必须为<code>true</code></li>\n</ol>\n<p>此外，还有两个方法：</p>\n<p>停止观察。调用后不再触发观察器，解除订阅</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.disconnect()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>清除变动记录。即不再处理未处理的变动。该方法返回变动记录的数组，注意，该方法立即生效。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.takeRecords()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-18\">4. 例子1：<code>MutationObserver</code>监听文本变化</h3>\n<p>基本使用是：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const target = document.getElementById(<span class=\"hljs-string\">'target-id'</span>)\n\nconst observer = new MutationObserver(records => {\n  // 输入变更记录\n})\n\n// 开始观察\nobserver.observe(target, {\n  characterData: <span class=\"hljs-literal\">true</span>\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里可以有几种处理。</p>\n<ul>\n<li>聊天的气泡框彩蛋，检测文本中的指定字符串/表情包，触发类似微信聊天的表情落下动画。</li>\n<li>输入框的热点话题搜索，当输入“<code>#</code>”号时，启动搜索框预检文本或高亮话题。</li>\n</ul>\n<p>有个<code>Vue</code>的小型插件就是这么实现的：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/mitsuyacider/vue-hashtag-textarea\" rel=\"nofollow noopener noreferrer\">来自：《vue-hashtag-textarea》</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7e875c46f836?imageslim\" data-width=\"1280\" data-height=\"716\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"716\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-19\">5. 例子2: 色块小游戏脚本</h3>\n<p>这个实现也是秀得飞起：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://benhuang.info/2019/02/20/hacking-the-color-picker-game-mutationobserver/\" rel=\"nofollow noopener noreferrer\">Hacking the color picker game — MutationObserver</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f27f7224655?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"508\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"508\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>游戏的逻辑很简单，当中间的色块颜色改变时，在时间限制内于底下的选项选择跟它颜色一样的选项就得分。难的点在于越后面的关卡选项越多，而且选项颜色也越相近，例如：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f323c1b016c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"504\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"504\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其实原理非常简单，就是观察色块的<code>backgroundColor</code>（属性变化<code>attributes</code>)，然后触发点击事件<code>e.click()</code>。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var targetNode = document.querySelector(<span class=\"hljs-string\">'#kolor-kolor'</span>);\nvar config = { attributes: <span class=\"hljs-literal\">true</span> };\nvar callback = <span class=\"hljs-keyword\">function</span>(mutationsList, observer) {\n    <span class=\"hljs-keyword\">if</span> (mutationsList[0].type == <span class=\"hljs-string\">'attributes'</span>) {\n        console.log(<span class=\"hljs-string\">'attribute change!'</span>);\n        <span class=\"hljs-built_in\">let</span> ans = document.querySelector(<span class=\"hljs-string\">'#kolor-kolor'</span>).style.backgroundColor;\n        document.querySelectorAll(<span class=\"hljs-string\">'#kolor-options a'</span>).forEach( (e) => {\n            <span class=\"hljs-keyword\">if</span> (e.style.backgroundColor == ans) {\n                e.text = <span class=\"hljs-string\">'Ans!'</span>;\n                e.click()\n            }\n        })\n    }\n};\n\nvar observer = new MutationObserver(callback);\nobserver.observe(targetNode, config);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f942b6c5432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"769\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"769\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-20\">3. <code>ResizeObserver</code>，视图观察者</h2>\n<p><code>ResizeObserver API</code>是一个新的<code>JavaScript API</code>，与<code>IntersectionObserver API</code>非常相似，它们都允许我们去监听某个元素的变化。</p>\n<h3 class=\"heading\" data-id=\"heading-21\">1. 出现的意义</h3>\n<ul>\n<li>\n<p>开发过程当中经常遇到的一个问题就是如何监听一个 <code>div</code> 的尺寸变化。</p>\n</li>\n<li>\n<p>但众所周知，为了监听 <code>div</code> 的尺寸变化，都将侦听器附加到 <code>window</code> 中的 <code>resize</code> 事件。</p>\n</li>\n<li>\n<p>但这很容易导致性能问题，因为大量的触发事件。</p>\n</li>\n<li>\n<p>换句话说，使用\n<code>window.resize</code> 通常是浪费的，因为它告诉我们每个视窗大小的变化，而不仅仅是当一个元素的大小发生变化。</p>\n</li>\n<li>\n<p><strong>而且<code>resize</code>事件会在一秒内触发将近60次，很容易在改变窗口大小时导致性能问题</strong></p>\n</li>\n</ul>\n<p>比如说，你要调整一个元素的大小，那就需要在 <code>resize</code> 的回调函数 <code>callback()</code> 中调用 <code>getBoundingClientRect</code> 或 <code>getComputerStyle</code>。不过你要是不小心处理所有的读和写操作，就会导致布局混乱。比如下面这个小示例：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df805c03bd6059?imageslim\" data-width=\"960\" data-height=\"540\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"960\" height=\"540\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-22\">2. <code>ResizeObserver</code>的优势</h3>\n<p><code>ResizeObserver API</code> 的核心优势有两点：</p>\n<ul>\n<li>细颗粒度的<code>DOM</code>元素观察，而不是<code>window</code></li>\n<li>没有额外的性能开销，只会在绘制前或布局后触发调用</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-23\">3. <code>ResizeObserver</code>基本使用</h3>\n<p>使用<code>ResizeObserver API</code>同样也是三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-24\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new ResizeObserver(callback);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-25\">2. 定义回调函数</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const callback = entries => {\n    entries.forEach(entry => {\n        \n    })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>每一个<code>entry</code>都是一个对象，包含两个属性<code>contentRect</code>和<code>target</code>\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8340db8bb93f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"334\" data-height=\"228\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"334\" height=\"228\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>contentRect</code>都是一些位置信息：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bottom</code></td>\n<td><code>top + height</code>的值</td>\n</tr>\n<tr>\n<td><code>height</code></td>\n<td>元素本身的高度，不包含<code>padding</code>，<code>border</code>值</td>\n</tr>\n<tr>\n<td><code>left</code></td>\n<td><code>padding-left</code>的值</td>\n</tr>\n<tr>\n<td><code>right</code></td>\n<td><code>left + width</code>的值</td>\n</tr>\n<tr>\n<td><code>top</code></td>\n<td><code>padidng-top</code>的值</td>\n</tr>\n<tr>\n<td><code>width</code></td>\n<td>元素本身的宽度，不包含<code>padding</code>，<code>border</code>值</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>大小与<code>top</code>相同</td>\n</tr>\n<tr>\n<td><code>y</code></td>\n<td>大小与<code>left</code>相同</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-26\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.observe(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df84167c1a9737?imageslim\" data-width=\"858\" data-height=\"323\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"858\" height=\"323\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>unobserve</code>方法：取消单节点观察</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.unobserve(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>disconnect</code>方法：取消所有节点观察</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.disconnect(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-27\">4. 例子1：缩放渐变背景</h3>\n<p><code>html</code>：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><div class=<span class=\"hljs-string\">\"box\"</span>>\n    <h3 class=<span class=\"hljs-string\">\"info\"</span>></h3>\n</div>\n<div class=<span class=\"hljs-string\">\"box small\"</span>>\n    <h3 class=<span class=\"hljs-string\">\"info\"</span>></h3>\n</div>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>添加点样式：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">body {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    padding: 2vw;\n    box-sizing: border-box;\n}\n.box {\n    text-align: center;\n    height: 20vh;\n    border-radius: 8px;\n    box-shadow: 0 0 4px rgba(0,0,0,.25);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 1vw\n}\n.box h3 {\n    color: <span class=\"hljs-comment\">#fff;</span>\n    margin: 0;\n    font-size: 5vmin;\n    text-shadow: 0 0 10px rgba(0,0,0,0.4);\n}\n.box.small {\n    max-width: 550px;\n    margin: 1rem auto;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>JavaScript</code>代码：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const boxes = document.querySelectorAll(<span class=\"hljs-string\">'.box'</span>);\n<span class=\"hljs-built_in\">let</span> callbackFired = 0;\nconst myObserver = new ResizeObserver(entries => {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> entry of entries) {\n        callbackFired++\n        const infoEl = entry.target.querySelector(<span class=\"hljs-string\">'.info'</span>);\n        const width = Math.floor(entry.contentRect.width);\n        const height = Math.floor(entry.contentRect.height);\n        const angle = Math.floor(width / 360 * 100);\n        const gradient = `linear-gradient(<span class=\"hljs-variable\">${ angle }</span>deg, rgba(0,143,104,1) 50%, rgba(250,224,66,1) 50%)`;\n        entry.target.style.background = gradient;\n        infoEl.innerText = `\n        I<span class=\"hljs-string\">'m ${ width }px and ${ height }px tall\n        Callback fired: ${callbackFired}\n        `;\n    }\n});\nboxes.forEach(box => {\n    myObserver.observe(box);\n});\n</span><span class=\"copy-code-btn\">复制代码</span></code></pre><p>当你拖动浏览器窗口，改变其大小时，看到的效果如下：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df844ce8f85e45?imageslim\" data-width=\"738\" data-height=\"417\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"738\" height=\"417\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-28\">5. 例子2：响应式<code>Vue</code>组件</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df85acd889db3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"474\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"474\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>假设你要创建一个postItem组件，在大屏上是这样的显示效果</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8639cc511681?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"512\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"512\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>在手机上需要这样的效果：\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8640f1cc6ade?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"861\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"861\" height=\"1280\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p>简单的<code>@media</code>就可以实现:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">@media only screen and (max-width: 576px) {\n  .post__item {\n    flex-direction: column;\n  }\n  \n  .post__image {\n    flex: 0 auto;\n    height: auto;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>但这就很容易出现 当你在超过预期的屏幕（过大）查看页面时，会出现以下的布局：</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df85d633a4da85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"809\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"809\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong><code>@media</code>查询的最大问题是：</strong></p>\n<ul>\n<li>组件响应度取决于屏幕尺寸，而不是响应自身的尺寸。</li>\n</ul>\n<p>以下是指令版实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df87b077e12408?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"762\" data-height=\"624\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"762\" height=\"624\"></svg>\"><figcaption></figcaption></figure>\n使用：<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8785890f52e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"762\" data-height=\"437\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"762\" height=\"437\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>效果：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df86e5671e9e59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"814\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"814\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>这是<code>vue-responsive-components</code>库的具体实现代码，还有组件形式的实现，感兴趣的可以去看看。</p>\n<h2 class=\"heading\" data-id=\"heading-29\">4. <code>PerformanceObserver</code>：性能观察者</h2>\n<p><strong>这是一个浏览器和<code>Node.js</code> 里都存在的API，采用相同<code>W3C</code>的<code>Performance Timeline</code>规范</strong></p>\n<ul>\n<li>在浏览器中，我们可以使用 window 对象取得<code>window.performance</code>和 <code>window.PerformanceObserver</code> 。</li>\n<li>而在 <code>Node.js</code> 程序中需要<code>perf_hooks</code> 取得性能对象，如下：<pre><code class=\"hljs bash copyable\" lang=\"bash\">const { PerformanceObserver, performance } = require(<span class=\"hljs-string\">'perf_hooks'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-30\">1. 出现的意义</h3>\n<p>首先来看<code>Performance</code> 接口：</p>\n<ul>\n<li>\n<p>可以获取到当前页面中与性能相关的信息。它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing AP</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code>。</p>\n</li>\n<li>\n<p><code>Performance API</code> 是大家熟悉的一个接口，他记录着几种性能指数的庞大对象集合。</p>\n</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df910b6d854744?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1146\" data-height=\"438\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1146\" height=\"438\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol>\n<li>若想获得某项页面加载性能记录，就需要调用<code>performance.getEntries</code>或者<code>performance.getEntriesByName</code>来获得。</li>\n<li>而获得执行效率，也只能通过<code>performance.now</code>来计算。</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df918d6a33e2b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"912\" data-height=\"555\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"912\" height=\"555\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>为了解决上述的问题，在<code>Performance Timeline Level 2</code>中，除了扩展了<code>Performance</code>的基本定义以外，还增加了<code>PerformanceObserver</code>接口。</p>\n<h3 class=\"heading\" data-id=\"heading-31\">2. <code>PerformanceObserver</code>的优势</h3>\n<p><code>PerformanceObserver</code>是浏览器内部对<code>Performance</code>实现的观察者模式，也是现代浏览器支持的几个 <code>Observer</code> 之一。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5cb19aece51d456e4037727e#heading-3\" rel>来自：《你了解 Performance Timeline Level 2 吗？》</a></p>\n</blockquote>\n<p>它解决了以下3点问题：</p>\n<ul>\n<li>避免不知道性能事件啥时候会发生，需要重复轮训<code>timeline</code>获取记录。</li>\n<li>避免产生重复的逻辑去获取不同的性能数据指标</li>\n<li>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系。</li>\n</ul>\n<p><code>W3C</code>官网文档鼓励开发人员尽可能使用<code>PerformanceObserver</code>，而不是通过<code>Performance</code>获取性能参数及指标。</p>\n<h3 class=\"heading\" data-id=\"heading-32\">3. <code>PerformanceObserver</code>的使用</h3>\n<p>使用<code>PerformanceObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数事件</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-33\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new PerformanceObserver(callback); \n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-34\">2. 定义回调函数事件</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const callback = (list, observer) => {\n   const entries = list.getEntries();\n   entries.forEach((entry) => {\n    console.log(“Name: “ + entry.name + “, Type: “ + entry.entryType + “, Start: “ + entry.startTime + “, Duration: “ + entry.duration + “\\n”); });\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>其中每一个<code>list</code>都是一个完整的<code>PerformanceObserverEntryList</code>对象：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df9412061956d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1130\" data-height=\"310\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1130\" height=\"310\"></svg>\"><figcaption></figcaption></figure>\n包含三个方法<code>getEntries</code>、<code>getEntriesByType</code>、<code>getEntriesByName</code>：<p></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getEntries()</td>\n<td>返回一个列表，该列表包含一些用于承载各种性能数据的对象，不做任何过滤</td>\n</tr>\n<tr>\n<td>getEntriesByType()</td>\n<td>返回一个列表，该列表包含一些用于承载各种性能数据的对象，按类型过滤</td>\n</tr>\n<tr>\n<td>getEntriesByName()</td>\n<td>返回一个列表，，该列表包含一些用于承载各种性能数据的对象，按名称过滤</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-35\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.observe({entryTypes: [<span class=\"hljs-string\">\"entryTypes\"</span>]});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>observer.observe(...)</code>方法接受可以观察到的有效的入口类型。这些输入类型可能属于各种性能API，比如<code>User tming</code>或<code>Navigation Timing API</code>。有效的<code>entryType</code>值：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>别名</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>frame， navigation</td>\n<td>PerformanceFrameTiming， PerformanceNavigationTiming</td>\n<td>URL</td>\n<td>文件的地址。</td>\n</tr>\n<tr>\n<td>resource</td>\n<td>PerformanceResourceTiming</td>\n<td>URL</td>\n<td>所请求资源的解析URL。</td>\n</tr>\n<tr>\n<td>mark</td>\n<td>PerformanceMark</td>\n<td>DOMString</td>\n<td>通过调用创建标记时使用的名称performance.mark()。</td>\n</tr>\n<tr>\n<td>measure</td>\n<td>PerformanceMeasure</td>\n<td>DOMString</td>\n<td>通过调用创建度量时使用的名称performance.measure()。</td>\n</tr>\n<tr>\n<td>paint</td>\n<td>PerformancePaintTiming</td>\n<td>DOMString</td>\n<td>无论是'first-paint'或'first-contentful-paint'。</td>\n</tr>\n<tr>\n<td>longtask</td>\n<td>PerformanceLongTaskTiming</td>\n<td>DOMString</td>\n<td>报告长任务的实例</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-36\">4. 例子1：静态资源监控</h3>\n<blockquote>\n<p><a target=\"_blank\" href=\"http://www.zhanglongdream.com/2018/12/27/js/JavaScript/%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/\" rel=\"nofollow noopener noreferrer\">来自：《资源监控》</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> filterTime(a, b) {\n  <span class=\"hljs-built_in\">return</span> (a > 0 && b > 0 && (a - b) >= 0) ? (a - b) : undefined;\n}\n\n<span class=\"hljs-built_in\">let</span> resolvePerformanceTiming = (timing) => {\n  <span class=\"hljs-built_in\">let</span> o = {\n    initiatorType: timing.initiatorType,\n    name: timing.name,\n    duration: parseInt(timing.duration),\n    redirect: filterTime(timing.redirectEnd, timing.redirectStart), // 重定向\n    dns: filterTime(timing.domainLookupEnd, timing.domainLookupStart), // DNS解析\n    connect: filterTime(timing.connectEnd, timing.connectStart), // TCP建连\n    network: filterTime(timing.connectEnd, timing.startTime), // 网络总耗时\n\n    send: filterTime(timing.responseStart, timing.requestStart), // 发送开始到接受第一个返回\n    receive: filterTime(timing.responseEnd, timing.responseStart), // 接收总时间\n    request: filterTime(timing.responseEnd, timing.requestStart), // 总时间\n\n    ttfb: filterTime(timing.responseStart, timing.requestStart), // 首字节时间\n  };\n\n  <span class=\"hljs-built_in\">return</span> o;\n};\n\n<span class=\"hljs-built_in\">let</span> resolveEntries = (entries) => entries.map(item => resolvePerformanceTiming(item));\n\n<span class=\"hljs-built_in\">let</span> resources = {\n  init: (cb) => {\n    <span class=\"hljs-built_in\">let</span> performance = window.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance;\n    <span class=\"hljs-keyword\">if</span> (!performance || !performance.getEntries) {\n      <span class=\"hljs-built_in\">return</span> void 0;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (window.PerformanceObserver) {\n      <span class=\"hljs-built_in\">let</span> observer = new window.PerformanceObserver((list) => {\n        try {\n          <span class=\"hljs-built_in\">let</span> entries = list.getEntries();\n          cb(resolveEntries(entries));\n        } catch (e) {\n          console.error(e);\n        }\n      });\n      observer.observe({\n        entryTypes: [<span class=\"hljs-string\">'resource'</span>]\n      })\n    } <span class=\"hljs-keyword\">else</span> {\n        window.addEventListener(<span class=\"hljs-string\">'load'</span>, () => {\n        <span class=\"hljs-built_in\">let</span> entries = performance.getEntriesByType(<span class=\"hljs-string\">'resource'</span>);\n        cb(resolveEntries(entries));\n      });\n    }\n  },\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-37\">参考文章&总结</h2>\n<p>参考文章有点多：</p>\n<blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.zhanglongdream.com/2018/12/27/js/JavaScript/%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/\" rel=\"nofollow noopener noreferrer\">资源监控</a></li>\n<li><a target=\"_blank\" href=\"https://codeburst.io/media-queries-based-on-element-width-with-mutationobserver-cf2eff172787\" rel=\"nofollow noopener noreferrer\">Media Queries Based on Element Width with MutationObserver</a></li>\n<li><a target=\"_blank\" href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics?hl=zh-cn\" rel=\"nofollow noopener noreferrer\">以用户为中心的性能指标</a></li>\n<li><a target=\"_blank\" href=\"https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/\" rel=\"nofollow noopener noreferrer\">A Few Functional Uses for Intersection Observer to Know When an Element is in View</a></li>\n<li><a target=\"_blank\" href=\"https://css-tricks.com/getting-to-know-the-mutationobserver-api/\" rel=\"nofollow noopener noreferrer\">Getting To Know The MutationObserver API</a></li>\n<li><a target=\"_blank\" href=\"https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers\" rel=\"nofollow noopener noreferrer\">Different Types Of Observers Supported By Modern Browsers</a></li>\n<li><a target=\"_blank\" href=\"https://pawelgrzybek.com/the-resize-observer-explained/\" rel=\"nofollow noopener noreferrer\">THE RESIZE OBSERVER EXPLAINED</a></li>\n<li><a target=\"_blank\" href=\"https://alligator.io/js/resize-observer/\" rel=\"nofollow noopener noreferrer\">A Look at the Resize Observer JavaScript API</a>\n这四个观察者，都非常适合集成到监控系统。</li>\n</ul>\n</blockquote>\n<p>且都有对应的<code>Polyfills</code>版实现。</p>\n<p>网上的总结和文档都深浅不一，如果哪里有错误，欢迎指正。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16df9766165811f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"198\" data-height=\"189\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"198\" height=\"189\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-38\">❤️ 看完三件事</h2>\n<p>如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：</p>\n<ol>\n<li>点赞，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）</li>\n<li>关注公众号「前端劝退师」，不定期分享原创知识。</li>\n<li>也看看其它文章</li>\n</ol>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d9eea84e51d4577eb5d8510\" rel>Chrome Devtools 高级调试指南（新）</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7f80796fb9a06b24434d4e\" rel>90行代码，15个元素实现无限滚动</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d674313e51d4561c94b1000\" rel>「React Hooks」120行代码实现一个交互完整的拖拽上传组件</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d565015f265da03eb13c575\" rel>「React Hooks」160行代码实现动态炫酷的可视化图表 - 排行榜</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5faffbefaea2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"647\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"647\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p>也可以来我的<code>GitHub</code>博客里拿所有文章的源文件：</p>\n<p><strong>前端劝退指南</strong>：<a target=\"_blank\" href=\"https://github.com/roger-hiro/BlogFN\" rel=\"nofollow noopener noreferrer\">github.com/roger-hiro/…</a></p>\n",
      "id": "j3zela7ct0g",
      "author": "voanit",
      "title": "现代浏览器观察者 Observer API  指南（新）",
      "baseClassName": "article-content"
    },
    {
      "content": "<h1 data-id=\"heading-0\">程序员节起源</h1><p>程序员的工作我们都知道，编程嘛。但为什么程序员节要在1024呢？1024最早火起来是因为一个“不可描述”的论坛，那里的回帖机制是：新用户发过贴之后，过1024秒才能发一贴，如果没到1024秒就又发了一条，则帖子里只会显示1024。</p><p><br></p><p>久而久之，1024成为了在这个论坛中灌水的最常用词，再加上在计算机数学中，1024M=1GB，谐音为“一级棒”，引申为对帖子的肯定。<br></p><p>再后来，1024越来越火，而1024在程序员中被应用的最广泛的，慢慢的1024成了程序员的象征，而10月24日也就成了程序员日。</p><p><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd1ffbae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"372\" data-height=\"262\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd1ffbae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"></p><h1 data-id=\"heading-1\">程序员改变世界</h1><p>有人笑称：程序员们每天的工作就是写代码，他们堪称是世界上最苦逼的人群，刚刚毕业的时候还是浓密的黑头发，五年之后就成了秃顶。</p><p>但是，不少技术出身的大佬早已占据创业半边天：李彦宏、马化腾、周鸿祎、雷军……不管对他们怎么看，有一点不可否认——他们确确实实在用技术改变生活。</p><p>程序改变世界，至今已经有几十年了，但真正进入普罗大众的生活，应该是从2007年移动智能手机的应用开始，越来越多的人开始关注程序和程序员。</p><p>有调查显示，程序员是“十大猝死职业”之一。</p><p>昨天程序员圈子迅速扩散一个IT哥们猝死消息，多么的突然与惋惜！<br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd84170b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"523\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"523\" height=\"800\"></svg>\"></p><p><br></p><p>猝死的原因大多在于过度疲劳或者压力过大，程序员工作强度大，经常加班，心脏会经常出现心律不齐等症状，如果不重视这些症状，任其发展，就有可能出现猝死的状况。</p><p>所以程序员小哥哥小姐姐们，工作压力再大也要注意作息健康，身体是革命的本钱，工作这么多年，感觉颈椎已经落下病根了，直立久了就会酸痛难受，看来以后没事得多多抬头仰望天花板画“粪”字了...</p><h4 data-id=\"heading-2\">程序员的日常作息是规律的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb8008151d02d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"450\" data-height=\"216\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"450\" height=\"216\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb80081633e46?imageslim\" data-width=\"346\" data-height=\"194\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"346\" height=\"194\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800817fb7d2?imageslim\" data-width=\"400\" data-height=\"278\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"400\" height=\"278\"></svg>\"></p><p><br></p><h4 data-id=\"heading-3\">工作状态是淡定自若的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fdded8ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"504\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"504\" height=\"1280\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fe720952?imageslim\" data-width=\"380\" data-height=\"220\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"380\" height=\"220\"></svg>\"></p><p><b><br></b></p><p><br></p><p><br></p><h4 data-id=\"heading-4\">底线是非常明确的</h4><p><br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fed9806f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"535\" data-height=\"603\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"535\" height=\"603\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fee66a29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"600\" data-height=\"1250\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"600\" height=\"1250\"></svg>\"></p><h4 data-id=\"heading-5\">处理 Bug是信手拈来的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e315b1695c?imageslim\" data-width=\"256\" data-height=\"144\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"256\" height=\"144\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e316deee02?imageslim\" data-width=\"350\" data-height=\"204\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"350\" height=\"204\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb8008755ec43?imageslim\" data-width=\"248\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"248\" height=\"200\"></svg>\"></p><p><br></p><h4 data-id=\"heading-6\">电脑坏了是包修不过夜的</h4><p><br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb80087ac3dfb?imageslim\" data-width=\"240\" data-height=\"180\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"240\" height=\"180\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800a35e0614?imageslim\" data-width=\"320\" data-height=\"176\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"176\"></svg>\"></p><h4 data-id=\"heading-7\">地位是至高无上的</h4><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><h4 data-id=\"heading-8\">会「深度学习」</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e31f5b587d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"1280\"></svg>\"></p><h4 data-id=\"heading-9\">有巨大发展空间</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e320db4566?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"652\" data-height=\"197\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"652\" height=\"197\"></svg>\"></p><h4 data-id=\"heading-10\">因为有大把的时间</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800a6d1a3bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"440\" data-height=\"330\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"440\" height=\"330\"></svg>\"></p><h4 data-id=\"heading-11\">所以业余生活很丰富</h4><p><br></p><p><br></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800af4fe72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"690\" data-height=\"736\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"690\" height=\"736\"></svg>\"></p><p>段子讲到这里，也要明白，虽然面对屏幕中的数据世界，程序员也有着属于自己的方式默默地表达着他们的浪漫。<br></p><blockquote><p>世界上最遥远的距离，是我在 if 里，你在 else 里，似乎一直相伴又永远分离；世界上最痴心的等待，是我当 case，你是 switch，或许永远都选不上自己；世界上最真情的相依，是你在 try，我在 catch ，无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的 finally。<br></p></blockquote><p>在浮躁的世界里，程序员们固执地坚持自己对于知识、技术与创新追求，值得我们在这样的日子里向程序员们致敬。感谢你们，是你们真正改变了世界。</p><h2 data-id=\"heading-12\">祝福</h2><p>1024程序员节，愿所有程序员，身体健康，永无Bug！</p><h2 data-id=\"heading-13\"><b style>如果你是程序员，用一句话表述程序员生涯的苦逼。</b></h2><h2 data-id=\"heading-14\"><b style>欢迎留言评论。</b></h2><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e324175141?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1080\" data-height=\"536\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1080\" height=\"536\"></svg>\"></p><p><br></p><h2 data-id=\"heading-15\">结尾彩蛋</h2><p>欢迎关注前端之阶公众号，获取更多前端知识，加入前端大群，与知名互联网大佬做朋友，开启共同学习新篇章！</p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e3274e1715?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"></p><p><br></p>",
      "id": "wmziflvzylc",
      "author": "于是乎_",
      "title": "“1024”竟然火于“羞羞”论坛？程序员节敢不敢一起来吐槽",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>yarn 是在工作中离不开的工具，但在工作中，很多人基本只会使用 <code>yarn install</code>，而且会手动删除 <code>node-modules</code>，或删除 <code>yarn.lock</code> 文件等不规范操作。本文将从一些基础的知识点开始介绍，循序渐进的让你对 <code>Yarn</code> 有一个更深入的了解，来保证规范的使用yarn，避免一些隐藏bug的产生。<br>\n本文主要介绍以下知识：</p>\n<blockquote>\n<ol>\n<li>什么是registry</li>\n<li>依赖的版本含义及写法</li>\n<li>依赖类型及区别（<code>devDependences</code>，<code>devDependences</code>，<code>peerDependences</code>， <code>optionalDependencies</code>，<code>bundledDependencies</code>）</li>\n<li>缓存介绍</li>\n<li><code>yarn.lock</code> 文件作用及介绍</li>\n<li><code>yarn install</code> 安装依赖的过程</li>\n<li>依赖关系树的模块扁平化</li>\n<li>常用的 <code>yarn</code> 命令介绍</li>\n</ol>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">什么是registry</h2>\n<p><code>registry</code>是 模块仓库提供了一个查询服务，也就是我们常说的源。以yarn官方镜像源为例，它的查询服务网址是<code>https://registry.yarnpkg.com</code>。</p>\n<p>这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 <code>https://registry.npmjs.org/vue</code>，就会看到 vue 模块所有版本的信息。</p>\n<p>registry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。\n<code>https://registry.yarnpkg.com/vue/2.6.10</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/25/16e02889c4f2a501?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"564\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"564\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>上面返回的 JSON 对象里面，有一个dist.tarball属性，是该版本压缩包的网址。dist.shasum 属性相当于hash值，在lock和缓存时会使用到，下文会提到。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">dist: {\n  <span class=\"hljs-string\">\"shasum\"</span>: <span class=\"hljs-string\">\"a72b1a42a4d82a721ea438d1b6bf55e66195c637\"</span>,\n  <span class=\"hljs-string\">\"tarball\"</span>:<span class=\"hljs-string\">\"https://registry.npmjs.org/vue/-/vue-2.6.10.tgz\"</span>\n},\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>我们在执行 <code>yarn install</code> 时，就是向 <code>registry</code> 查询得到上面的压缩包地址进行下载的。<br>\n工作中，我们可能有需要修改镜像源的场景，比如修改成淘宝源或者自己公司的私有源。<br>\n查看和设置源，可以通过 yarn config 命令来完成<br>\n查看当前使用的镜像源</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config get registry\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>修改镜像源（以修改成淘宝源为例）</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org/\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-1\">依赖版本</h2>\n<p>yarn的包遵守 <code>semver</code>，即语义化版本。\nSemVer 是一套语义化版本控制的约定，定义的格式为</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">X.Y.Z（主版本号.次版本号.修订号）：\nX.主版本号：进行不向下兼容的修改时，递增主版本号\nY.次版本号: 做了向下兼容的新增功能或修改\nZ.修订号：做了向下兼容的问题修复\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>yarn</code> 中依赖版本范围的表示方法有以下几种：</p>\n<ol>\n<li>通过比较器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><2.0.0</td>\n<td style=\"text-align:center\">任何小于 2.0.0 的版本</td>\n</tr>\n<tr>\n<td><=3.1.4</td>\n<td style=\"text-align:center\">任何小于或等于 3.1.4 的版本</td>\n</tr>\n<tr>\n<td>>0.4.2</td>\n<td style=\"text-align:center\">任何大于 0.4.2 的版本</td>\n</tr>\n<tr>\n<td>>=2.7.1</td>\n<td style=\"text-align:center\">任何大于或等于 2.7.1 的版本</td>\n</tr>\n<tr>\n<td>=4.6.6</td>\n<td style=\"text-align:center\">任何等于 4.6.6 的版本</td>\n</tr>\n<tr>\n<td>>=2.0.0 <3.1.4</td>\n<td style=\"text-align:center\">交集，大于或等于 2.0.0 并小于 3.1.4</td>\n</tr>\n<tr>\n<td><2.0.0 || >3.1.4</td>\n<td style=\"text-align:center\">并集 小于 2.0.0 或者大于 3.1.4</td>\n</tr>\n</tbody>\n</table>\n<p>如果没有指定运算符，默认为 =</p>\n<ol start=\"2\">\n<li>通过连字符</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2.0.0 - 3.1.4</td>\n<td style=\"text-align:center\">>=2.0.0 <=3.1.4</td>\n</tr>\n<tr>\n<td>0.4 - 2</td>\n<td style=\"text-align:center\">>=0.4.0 <=2.0.0</td>\n</tr>\n</tbody>\n</table>\n<p>版本号中缺少的那些部分会用数字 0 填充。</p>\n<ol start=\"3\">\n<li>X范围<br>\n字符 X、x 或者 * 都可以作为通配符，用于填充部分或全部版本号。\n被省略的那部分版本号默认为 x 范围。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:center\">>=0.0.0 (任意版本)</td>\n</tr>\n<tr>\n<td>2.x</td>\n<td style=\"text-align:center\">>=2.0.0 <3.0.0（匹配主要版本）</td>\n</tr>\n<tr>\n<td>3.1.x</td>\n<td style=\"text-align:center\">> = 3.1.0 < 3.2.0（匹配主要和次要版本）</td>\n</tr>\n<tr>\n<td>``（空字符串）</td>\n<td style=\"text-align:center\">* 或 > = 0.0.0</td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">2.x.x 或 > = 2.0.0 < 3.0.0</td>\n</tr>\n<tr>\n<td>3.1</td>\n<td style=\"text-align:center\">3.1.x 或 > = 3.1.0 < 3.2.0</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>～ 字符范围<br>\n同时使用字符 ~ 和次版本号，表明允许 <code>修订号</code> 变更。同时使用字符 ~ 和主版本号，表明允许 <code>次版本</code> 号变更。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~3.1.4</td>\n<td style=\"text-align:center\">>=3.1.4 <3.2.0</td>\n</tr>\n<tr>\n<td>~3.1</td>\n<td style=\"text-align:center\">3.1.x 或 > = 3.1.0 < 3.2.0</td>\n</tr>\n<tr>\n<td>~3</td>\n<td style=\"text-align:center\">3.x 或 > = 3.0.0 < 4.0.0</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>^ 字符范围<br>\n字符 ^ 表明不会修改版本号中的第一个非零数字，3.1.4 里的 3 或者 0.4.2 里的 4。版本号中缺少的部分将被 0 填充，且在匹配时这些位置允许改变。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^3.1.4</td>\n<td style=\"text-align:center\">>=3.1.4 <4.0.0</td>\n</tr>\n<tr>\n<td>^0.4.2</td>\n<td style=\"text-align:center\">>=0.4.2 <0.5.0</td>\n</tr>\n<tr>\n<td>^0.0.2</td>\n<td style=\"text-align:center\">>=0.0.2 <0.0.3</td>\n</tr>\n</tbody>\n</table>\n<p>使用 <code>yarn add [package-name]</code> 命令安装依赖，默认使用的是 ^ 范围。<br>\n需要注意的是，如果一个比较器包含有预发布标签的版本，它将只匹配有相同 major.minor.patch 的版本。\n例如 <code>>=3.1.4-beta.2</code>，可以匹配 <code>3.1.4-beta.3</code>，但不会匹配 <code>3.1.5-beta.3</code> 版本。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">依赖类型</h2>\n<p><code>dependences</code> 代码运行时所需要的依赖，比如vue，vue-router。</p>\n<p><code>devDependences</code> 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖，比如babel，webpack。</p>\n<p><code>peerDependences</code> 同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围。<br>\n如果宿主环境没有对应版本的依赖，在安装依赖时会报出警告。<br>\n比如包 <code>eslint-plugin-import</code> 中有依赖：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <span class=\"hljs-string\">\"peerDependencies\"</span>: {\n    <span class=\"hljs-string\">\"eslint\"</span>: <span class=\"hljs-string\">\"2.x - 5.x\"</span>\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>在install时，如果宿主环境没有 <code>2.x-5.x</code> 版本的 <code>eslint</code>,cli就会抛出警告。但不会自动帮我们安装，仍然需要手动安装。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddf773d9a8aeef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"91\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"91\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>optionalDependencies</code> 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。<br>\n可选依赖适用于那些即便没有成功安装可选依赖，也有后备方案的情况。</p>\n<p><code>bundledDependencies</code> 打包依赖，在发布包时，这个数组里的包都会被打包打包到最终的发布包里，需要注意 <code>bundledDependencies</code> 中的包必须是在devDependencies或dependencies声明过的。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">缓存</h2>\n<p><code>yarn</code> 会将安装过的包缓存下来，这样再次安装相同包的时候，就不需要再去下载，而是直接从缓存文件中直接copy进来。</p>\n<p>可以通过命令 <code>yarn cache dir</code> 查看yarn的全局缓存目录。我的缓存目录在 <code>/Library/Caches/Yarn/v1</code> 下。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/19/16de476f6032c3c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1208\" data-height=\"1180\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1208\" height=\"1180\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>可以看出，<code>yarn</code> 会将不通版本解压后的包存放在不同目录下，目录以</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm-[package name]-[version]-[shasum]` \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>来命名。shasum 即上文中 <code>registry</code> 获取的 <code>dist.shasum</code>。</p>\n<p>我们可以通过命令查看已经缓存过的包。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn cache list    列出已缓存的每个包\n\nyarn cache list --pattern <pattern>  列出匹配指定模式的已缓存的包\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>例如执行 <code>yarn cache list --pattern vue</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/19/16de484ef6a6360d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"404\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"404\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">yarn.lock</h2>\n<p><code>yarn.lock</code> 中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的结果。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0dc3640b2a68b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"502\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"502\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>下面以@babel/code-frame为例，看看yarn.lock 中会记录哪些信息。</p>\n<ol>\n<li>第一行 <code>\"@babel/code-frame@7.0.0-beta.54\"</code>\n包的name和语义化版本号，这些都来自package.json中的定义。</li>\n<li><code>version</code> 字段，记录的是一个确切的版本。</li>\n<li><code>resolved</code> 字段记录的是包的URL地址。其中hash值，即上文的 <code>dist.shasum</code>。</li>\n<li><code>dependencies</code> 字段记录的是当前包的依赖，即当前包在 <code>package.json</code> 的 <code>dependencies</code> 字段中的所有依赖。</li>\n</ol>\n<p><code>Yarn</code> 在安装期间，只会使用当前项目的 <code>yarn.lock</code> 文件（即 顶级 <code>yarn.lock</code> 文件），会忽略任何依赖里面的 <code>yarn.lock</code> 文件。在顶级 <code>yarn.lock</code> 中包含需要锁定的整个依赖树里全部包版本的所有信息。</p>\n<p><code>yarn.lock</code>文件是在安装期间，由 <code>Yarn</code> 自动生成的，并且由yarn来管理，不应该手动去更改，更不应该删除yarn.lock文件，且要提交到版本控制系统中，以免因为不同机器安装的包版本不一致引发问题。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">Yarn install过程</h2>\n<p>首次执行 <code>yarn install</code> 安装，会按照 <code>package.json</code> 中的语义化版本，去向 <code>registry</code> 进行查询，并获取到符合版本规则的最新的依赖包进行下载，并构建构建依赖关系树。 比如在 <code>package.json</code> 中指定 vue 的版本为 <code>^2.0.0</code>，就会获取符合 <code>2.x.x</code>\n的最高版本的包。然后自动生成 <code>yarn.lock</code> 文件，并生成缓存。</p>\n<p>之后再执行 <code>yarn install</code>，会对比 <code>package.json</code> 中依赖版本范围和 <code>yarn.lock</code> 中版本号是否匹配。</p>\n<ol>\n<li>版本号匹配，会根据 <code>yarn.lock</code> 中的 <code>resolved</code> 字段去查看缓存， 如果有缓存，直接copy，没有缓存则按照 <code>resolved</code> 字段的url去下载包。</li>\n<li>版本号不匹配，根据 <code>package.json</code> 中的版本范围去 <code>registry</code> 查询，下载符合版本规则最新的包，并更新至 <code>yarn.lock</code> 中。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-6\">模块扁平化</h2>\n<p>上面提到，在安装依赖时，会解析依赖构建出依赖关系树。\n比如我项目的首层依赖(即当前项目的dependence和devDependences中的依赖，不包括依赖的依赖)中有A，B，C三个包，A 和 B包同时依赖了相同版本范围的D包。那么这部分的依赖关系树是这样的：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n│ └── D    \n├── B    \t\t\t\t\n│ └── D  \n├── C \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果按照这样的依赖关系树直接安装的话，D模块会在A包和B包的 <code>node_modules</code>中都安装，这样会导致模块冗余。</p>\n<p>为了保证依赖关系树中没有大量重复模块，yarn在安装时会做dedupe（去重）操作，它会遍历所有节点，逐个将模块放在根节点下面，也就是当前项目的 <code>node-modules</code> 中。当发现有相同的模块时，会判断当前模块指定的 <code>semver</code> 版本范围是否交集，如果有，则只保留兼容版本，如果没有则在当前的包的 <code>node-modules</code> 下安装。<br>\n所以上面的说的情况，最终安装完成是下面这样的，A，B，C，D包都会安装在第一层 <code>node-modules</code> 下。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n├── B    \t\t\t\t\n├── C \n├── D\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果A包和B包依赖的是不兼容的版本，假设A包依赖的是D@1版本的包，B包依赖的是D@2版本。则最终安装的结果如下：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n├── B    \n│ └── D@2 \n├── C \n├── D@1\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当代码中 <code>require</code> 或 <code>import</code> 某个模块时，会从当前 <code>package</code> 的 <code>node-modules</code> 里中开始找，找不到就到当前package的上一层 <code>node-modules</code> 里找，这样一直找到全局的node_modules。\n所以上面的安装的树结构，可以保证每个 <code>package</code> 都能获取到所需要版本的包。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">常用的yarn命令</h2>\n<ol>\n<li>yarn install 安装依赖</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn install / yarn  在本地 node_modules 目录安装 package.json 里列出的所有依赖\nyarn install --force 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）\nyarn install --modules-folder <path> 为 node_modules 目录指定另一位置，代替默认的 ./node_modules\nyarn install --no-lockfile 不读取或生成 yarn.lock 文件\nyarn install --production[=<span class=\"hljs-literal\">true</span>|<span class=\"hljs-literal\">false</span>] / --production / --prod 只安装 dependence下的包，不安装 devDependencies 的包\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>yarn add</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn add package-name 会安装 latest 最新版本。\nyarn add <package...>  安装包到dependencies中\nyarn add <package...> [--dev/-D]  用 --dev 或 -D 安装包到 devDependencies\nyarn add <package...> [--peer/-P]  用 --peer 或者 -P 安装包到 peerDependencies\nyarn add <package...> [--optional/-O] 用 --optional 或者 -O 安装包到 optionalDependencies \nyarn add <package...> [--exact/-E] 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版。\nyarn add <package...> [--tilde/-T]  用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0。\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>yarn config 管理配置文件</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config get <key> 查看配置key的值\nyarn config list 查看当前的配置\nyarn config delete <key> 从配置中删除配置key\nyarn config <span class=\"hljs-built_in\">set</span> <key> <value> [-g|--global] 设置配置项 key 的值为 value\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li>其他常用命令</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn list 查询当前工作文件夹所有的依赖\nyarn info <package> [<field>]  查看包信息，可以查看特定\nyarn remove <package...>  从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件。\nyarn <script> [<args>] 执行用户自定义的脚本\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li>详细日志模式\n运行yarn命令时，增加参数 <code>--verbose</code>，这对排查错误时很有帮助</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn <<span class=\"hljs-built_in\">command</span>> --verbose\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以打印出执行的详细信息(创建目录、复制文件或 HTTP 请求等)</p>\n<blockquote>\n<p>欢迎关注我的公众号「前端小苑」，我会定期在上面更新原创文章。</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/23/16d5d5f0591a7d2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"580\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"580\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "6cwrhcl51yc0",
      "author": "ikoala",
      "title": "前端工程师应该知道的yarn知识",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [
    {
      "content": "<blockquote>\n<p>劝了别人无数次，让别人喝了鸡汤，帮别人填坑，自己却掉了坑</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">1.前言</h2>\n<p>在前端学习里面，很多人都是注重学习代码（html，css，js）。或者是一些框架，库（jquery，vue，react）,或者是各种工具（webpack，gulp）。在以往的文章里面，或者自己和别人交谈，都有建议过别人多练，不要闷头就写代码，多深入了解当中的原理，学习其中的思想。但是除了代码方面的知识之外，还有哪一些是作为一个前端，应该扩展学习的呢？下面简单罗列和整理了一下最近学习的资源。如果大家还有其它的推荐，欢迎在评论区留言。</p>\n<blockquote>\n<p>下面的知识，可能不需要太过于深入，详细的掌握，但是必须要有所了解，这样在开发上遇到问题，解决问题的时候即使不是如虎添翼，也是锦上添花。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">2.http，https</h2>\n<p>前端而言，不可避免的要和接口打交道。除了和后台对接口，请求数据，渲染页面，之外。对http的请求，也是要有一个了解，比如http协议，请求方式，请求过程，结果状态码等。了解这些，对开发的时候可能遇到的问题，就可以大概知道问题是怎么产生的，更快的知道怎么解决，避免。</p>\n<h3 class=\"heading\" data-id=\"heading-2\">2-1.请求</h3>\n<p>首先一个请求，包含有请求头，请求行，请求正文。具体是怎样境，看下面的代码</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">axios({\n  method: <span class=\"hljs-string\">'post'</span>,\n  url: <span class=\"hljs-string\">'/user/12345'</span>,\n  headers:{\n    <span class=\"hljs-string\">'Content-Type'</span>:<span class=\"hljs-string\">'application/x-www-form-urlencoded'</span>  \n  },\n  data: {\n    firstName: <span class=\"hljs-string\">'Fred'</span>,\n    lastName: <span class=\"hljs-string\">'Flintstone'</span>\n  }\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如上所述</p>\n<p><code>method</code>和<code>url</code>就是这个请求的请求行（这里是请求行部分信息，其实请求行还包括http协议的版本等信息）。<code>headers</code>中的属性就是请求头，里面的属性，全部包含在请求的<strong>header</strong>里面，是服务端获取客户端版本，缓存等信息的一个途径。<code>data</code>对应的就是请求正文，也就是平常所说的参数。</p>\n<h3 class=\"heading\" data-id=\"heading-3\">2-2.响应</h3>\n<p>在请求发出去，并且响应已经回来的时候，就时候信息可分为响应行，响应头，响应正文。</p>\n<p><strong>响应行</strong></p>\n<p>引用看云的一个请求作为实例，如下代码就是这个请求的响应行，返回请求的http协议及版本，状态码，请求状态等描述信息。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Request URL:https://www.kancloud.cn/yunye/axios/comment?article_id=234845&page=1\nRequest Method:GET\nStatus Code:200 OK\nRemote Address:117.23.61.221:443\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><strong>响应头</strong></p>\n<p>响应头和请求头格式一致，返回版本，缓存等信息。</p>\n<p><strong>响应正文</strong></p>\n<p>平常接触最多的就是响应正文，也就是日常开发需要用到的数据。开发者拿到这些数据之后，再进行相应的处理。</p>\n<h3 class=\"heading\" data-id=\"heading-4\">2-3.关于https</h3>\n<p>关于 https 。下面可以先了解下 http 的缺点，https就是http基础上做的加密处理。</p>\n<p>1.通信使用明文不加密，内容可能被窃听\n2.不验证通信方身份，可能遭到伪装\n3.无法验证报文完整性，可能被篡改</p>\n<h3 class=\"heading\" data-id=\"heading-5\">2-4.相关资料</h3>\n<p>关于http与https就简单说到这里，详细的推荐看下下面的资料。</p>\n<p><a target=\"_blank\" href=\"http://www.runoob.com/http/http-tutorial.html\" rel=\"nofollow noopener noreferrer\">HTTP教程</a></p>\n<p><a target=\"_blank\" href=\"https://www.cnblogs.com/sunny-sl/p/6529830.html\" rel=\"nofollow noopener noreferrer\">HTTP协议【详解】——经典面试题</a></p>\n<p><a target=\"_blank\" href=\"https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA\" rel=\"nofollow noopener noreferrer\">一个故事讲完https</a></p>\n<h2 class=\"heading\" data-id=\"heading-6\">3.响应状态码</h2>\n<p>上面提到响应状态码，在这里也简单写下。在前端方面，请求接口可能会接触到各种情况，常见的有下面几个，应该怎么解决，就是具体问题，具体分析。</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>400</td>\n<td>参数错误</td>\n</tr>\n<tr>\n<td>403</td>\n<td>拒绝或者禁止访问（无权限访问）</td>\n</tr>\n<tr>\n<td>404</td>\n<td>地址不存在</td>\n</tr>\n<tr>\n<td>405</td>\n<td>客户端请求中的方法被禁止（一般是请求方式错误）</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器报错</td>\n</tr>\n<tr>\n<td>502</td>\n<td>请求超时，无效网关</td>\n</tr>\n<tr>\n<td>503</td>\n<td>服务器超载或者维护，无法响应</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-7\">3-1.参考资料</h3>\n<p>详细的状态码请参考下面内容。</p>\n<p><a target=\"_blank\" href=\"http://www.runoob.com/http/http-status-codes.html\" rel=\"nofollow noopener noreferrer\">HTTP状态码</a></p>\n<h2 class=\"heading\" data-id=\"heading-8\">4.前端方面的安全性</h2>\n<h3 class=\"heading\" data-id=\"heading-9\">4-1.XSS</h3>\n<p>XSS(Cross Site Scripting)是跨站脚本攻击，为了区分CSS，所以缩写为XSS。XSS攻击方式是往Web页面插入恶意的 JavaScript 代码，当用户浏览网页的时候，插入的代码就是被执行，从而达到攻击的目的。</p>\n<p>其中应用比较多的一个就是，在网页一些公用的交互区域。比如搜索的文本框，除了可以输入一些关键字，还可以输入一些 JavaScript 代码，一旦代码点击搜索，代码就会被执行，达到攻击的目的。如下例子</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><script>alert(document.cookie);</script>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>在文本框中输入以上代码，然后点击提交，就会把用户的cookie弹出来。</p>\n<p><strong>XSS防范</strong></p>\n<p>1.将重要的cookies标记为HTTP ONLY，让JavaScript代码无法调用，只有http能调用。或者将重要的信息保存在session里面。</p>\n<p>2.只允许用户输入我们期望的数据。如消费金额框只能输入数字和小数点。</p>\n<p>3.对数据进行加密处理。</p>\n<p>4.过滤或者移除特殊的HTML标签，过滤JavaScript代码等。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">4-2.CSRF</h3>\n<p>CSRF（Cross-site request forgery）是跨站请求伪造。XSS利用站点内的信任用户，与XSS不同，CSRF是通过伪装来自受信任用户，在受信任的网站进行请求，盗取信息。其实就是攻击者盗用了受害者的身份，以受害者的名义向网站发送恶意请求。</p>\n<p><strong>CSRF攻击的思想</strong></p>\n<p>引用<a target=\"_blank\" href=\"https://www.cnblogs.com/shytong/p/5308667.html\" rel=\"nofollow noopener noreferrer\">CSRF攻击原理及防御</a>的一张图进行解释。</p>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430af858ffd74f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1052\" data-height=\"593\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1052\" height=\"593\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>图片来自：<a target=\"_blank\" href=\"https://www.cnblogs.com/shytong/p/5308667.html\" rel=\"nofollow noopener noreferrer\">CSRF攻击原理及防御</a></p>\n<p>根据步骤，看了图，相信不难理解，就是在一个网站里面保留了cookie，然后访问了一些危险网站，然后被危险网站盗用了用户信息。</p>\n<p><strong>CSRF的防御</strong></p>\n<p>1.在表单里增加Hash值，以认证这确实是用户发送的请求，然后在服务器端进行Hash值验证。</p>\n<p>2.验证码：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串。</p>\n<p>3.修改，增加重要信息，比如密码，个人信息的操作，尽量使用post。避免使用get把信息暴露在url上面。</p>\n<h3 class=\"heading\" data-id=\"heading-11\">4-3.反爬虫</h3>\n<p>和之前的防护XSS和CSRF攻击目的不一样，反爬虫是为了防止网站重要的数据被别人拿走，比如电商的交易额，电影网站的票房统计，音乐网站的评论等。</p>\n<p><a target=\"_blank\" href=\"http://litten.me/2017/07/09/prevent-spiders/\" rel=\"nofollow noopener noreferrer\">反击爬虫，前端工程师的脑洞可以有多大？</a></p>\n<h2 class=\"heading\" data-id=\"heading-12\">5.渲染过程，原理</h2>\n<p>1.浏览器通过DNS对URL进行解析，找出对应的IP地址；</p>\n<p>2.向IP地址发起网络请求，进行http协议会话：客户端发送报头（请求报头），服务端回馈报头（响应报头）</p>\n<p>3.服务器根据请求，交给后台处理，处理完成后返回文件数据，浏览器接收文件数据（HTML、JS、CSS、图象等）；返回一个页面（根据页面上的外链的URL重新发送请求获取）</p>\n<p>4.浏览器接收文件完毕，对加载到的资源进行语法解析，以及相应的内部数据结构（网页渲染）</p>\n<h2 class=\"heading\" data-id=\"heading-13\">6.跨域</h2>\n<p>跨域这方面，平常接触的不多，我们这边遇到也是让后台允许跨域（跨域资源共享），但是这个跨域，也是一个绕不开的话题，受限于篇幅，下面简单进行讲解。</p>\n<h3 class=\"heading\" data-id=\"heading-14\">6-1.情形分析</h3>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>说明</th>\n<th>是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>http://www.example.com/a.js，http://www.example.com/lab/b.js</td>\n<td>同一域名，不同文件或路径</td>\n<td>允许</td>\n</tr>\n<tr>\n<td>http://www.example.com:8000/a.js，http://www.example.com/b.js</td>\n<td>同一域名，不同端口</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>http://www.example.com/a.js，https://www.example.com/b.js</td>\n<td>同一域名，不同协议</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>http://www.example.com/a.js，http://192.168.2xx.2x/b.js</td>\n<td>域名和域名对应相同ip</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>http://www.example.com/a.js，http://x.example.com/b.js，http://domain.com/c.js</td>\n<td>主域相同，子域不同</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td>http://www.example.com/a.js，http://www.demo.com/b.js</td>\n<td>不同域名</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-15\">6-2.解决方案</h3>\n<p>网上的针对跨域的解决方案有很多，大家参考着看就好。虽然罗列这么多，但是我只用过两种。</p>\n<p>1、 jsonp</p>\n<p>2、 document.domain + iframe</p>\n<p>3、 location.hash + iframe</p>\n<p>4、 window.name + iframe</p>\n<p>5、 postMessage</p>\n<p>6、 跨域资源共享（CORS）</p>\n<p>7、 nginx代理</p>\n<p>8、 nodejs中间件代理</p>\n<p>9、 WebSocket协议</p>\n<h3 class=\"heading\" data-id=\"heading-16\">6-3.参考资料</h3>\n<p><a target=\"_blank\" href=\"https://www.cnblogs.com/roam/p/7520433.html\" rel=\"nofollow noopener noreferrer\">前端常见跨域解决方案（全）</a></p>\n<p><a target=\"_blank\" href=\"http://web.jobbole.com/88519/\" rel=\"nofollow noopener noreferrer\">前端跨域知识总结</a></p>\n<h2 class=\"heading\" data-id=\"heading-17\">7.性能优化</h2>\n<p>这里只讲个大概，具体操作得靠自己自行问搜索引擎。</p>\n<h3 class=\"heading\" data-id=\"heading-18\">7-1.首屏优化</h3>\n<p>按需加载，非首屏图片使用预加载或懒加载，DNS，压缩代码，合并图片，减少请求等。</p>\n<h3 class=\"heading\" data-id=\"heading-19\">7-2.算法优化</h3>\n<p>减少沉余的代码，控制循环的次数，避免巨大函数等。</p>\n<h2 class=\"heading\" data-id=\"heading-20\">8.SEO</h2>\n<p>作为前端开发者，在SEO方面接触得应该不少。前端方面，注意SEO的点也不少。下面简单写下，在我开发的项目里面，也有几个项目是需要做SEO的，个人的建议如下几点：</p>\n<p><strong>8-1.meta标签</strong></p>\n<p>可定义关键词、网站描述</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">< meta name=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"关键词1，关键词2\"</span> />\n\n< meta name=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"描述词1，描述词2\"</span> />\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><strong>8-2.语义化html标签</strong></p>\n<p>一方面是，利用html标签，达到语义化的目的，比如列表使用ul，ol。表格使用table等，不建议什么元素都使用div。</p>\n<p>另一方面是尽可能使用html5提供的具有语义化的标签。</p>\n<p>以前写法</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><div class=<span class=\"hljs-string\">\"header\"</span>></div>\n<div class=<span class=\"hljs-string\">\"main\"</span>></div>\n<div class=<span class=\"hljs-string\">\"footer\"</span>></div>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>建议写法</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><header></header>\n<main></main>\n<footer></footer>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><strong>8-3.html嵌套级别不宜过多</strong></p>\n<p>这一点就是尽量使html做到扁平化，避免嵌套过多，但是这点相对而言，难度比较大。</p>\n<p><strong>8-4.img标签四大属性不能省</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><img src=<span class=\"hljs-string\">\"\"</span> alt=<span class=\"hljs-string\">\"图片描述\"</span> width=<span class=\"hljs-string\">\"\"</span> height=<span class=\"hljs-string\">\"\"</span>/>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>alt属性是为了让图片因网速慢、src引用错误、浏览器禁用图像、用户使用屏幕阅读器等情况，未成功显示时候，仍可以显示文本，让用户可大概知道这张图片大概是什么。</p>\n<p>width和height是为了防止因为图片无法显示，造成页面重新渲染，或者布局错乱。</p>\n<p><strong>8-5.h1-h6标签的使用</strong></p>\n<p>1.一个页面建议只出现一个h1标签，而且一般是放在网页log上面使用。</p>\n<p>2.h2标签一般用于详情页的主标题。详情页没有logo，标题使用h1。如有副标题，使用h3。</p>\n<p>3.h1-h6标签自带权重，如果只为了设置字体大小，或者区分样式，不适合使用h1-h6。</p>\n<p><strong>8-6.其它方面</strong></p>\n<p>关于SEO的其他方式，在网上看到有这样的方法，但是我自己在开发上面没尝试过这样做，这里就简单罗列下，大家参考下。</p>\n<p>避免 iframe 标签</p>\n<p>重要内容谨慎使用 display:none;</p>\n<p>a标签尽量添加title属性</p>\n<p>利用布局，把重要内容HTML代码放在最前</p>\n<p>使用”rel=nofollow”属性，集中网站权重</p>\n<blockquote>\n<p>最近一段时间很流行前后分离，以及单页应用。但关于前后分离和单页应用这个怎么做SEO现在不清楚（目前我了解的是没法做）。我们现在的做法就是需要做SEO的项目，前端只负责切图，然后后台铺数据，服务端渲染，不是前端渲染。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-21\">9.堆、栈？</h2>\n<p>栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放。</p>\n<p>基本类型：Undefined、Null、Boolean、Number 和 String，这5中基本数据类型可以直接访问，他们是按照值进行分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可以分配。</p>\n<p>如下例子</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> a=1;\n<span class=\"hljs-built_in\">let</span> b=a;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430e6837e0e4c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"390\" data-height=\"166\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"390\" height=\"166\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>如果修改了b</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">b=2;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430e69b4a54b1f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"373\" data-height=\"149\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"373\" height=\"149\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>虽然b一开始是通过a赋值，但是a和b是独立的储存在栈内存里面，修改其中一个，不会对另一个有任何影响。</p>\n<p>引用类型：即存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。</p>\n<p>如下例子</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> a={name:<span class=\"hljs-string\">'守候'</span>};\n<span class=\"hljs-built_in\">let</span> b=a;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430e6594479fc5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"456\" data-height=\"178\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"456\" height=\"178\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>如果修改了b</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">b.name=<span class=\"hljs-string\">'sh'</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430e66c98f5336?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"453\" data-height=\"183\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"453\" height=\"183\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>b通过a赋值，a和b就共用了一个堆内存，修改了a或者b，都直接修改了堆内存的值，就会对另一个产生影响。</p>\n<h2 class=\"heading\" data-id=\"heading-22\">10.响应式和自适应</h2>\n<p>关于这两个的概念，现在没怎么听说了。可能是因为现在主流的就是PC和手机是分开两个项目的原因，也可能是因为这两个概念更应该是设计图的工作。上一次和别人谈论这个问题，还是在一年前，那个时候我还是切图仔。</p>\n<p>但是关于这两个概念的区别，大家知道一下就好，下面看两张图片估计就差不多懂了。</p>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430ccc072b91f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"588\" data-height=\"347\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"588\" height=\"347\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430ccdc92a6827?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"589\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"589\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>图片来自：<a target=\"_blank\" href=\"http://www.zcool.com.cn/article/ZNDU1NzQ4.html\" rel=\"nofollow noopener noreferrer\">响应式和自适应有什么区别?</a>（这篇文章估计也是抄袭的，但是由于图片我也找不到出处了，就声明这个了）</p>\n<p>简单来说：</p>\n<p>自适应：一个网页，根据屏幕宽度的改变而改变。代码只有一套。在个别的屏幕上，排版这个比较丑，但是设计，开发成本低。</p>\n<p>响应式：一个网页，根据屏幕的宽度的改变而展示不同的效果，代码基本是两套以上。在所有屏幕上都展示很好的效果，但是设计，开发成本高。</p>\n<p>自适应实例：<a target=\"_blank\" href=\"http://m.ctrip.com/html5/\" rel=\"nofollow noopener noreferrer\">携程</a></p>\n<p>响应式实例：<a target=\"_blank\" href=\"http://segmentfault.com/\" rel=\"nofollow noopener noreferrer\">segmentfault</a></p>\n<h2 class=\"heading\" data-id=\"heading-23\">11.小结</h2>\n<p>之所以要发这么一片，总结这一些概念，是因为我和别人交谈的时候，遇到这些总是有一个是是而非的概念。所以最近就抽空看了下这些概念，也和大家分享下这一些知识。这些概念知识，可能只是了解一下，大概知道就好，有些可能要深入了解下，这个就看个人所需了。最后，如果大家还有什么要推荐的概念知识是比较重要，需要了解的，欢迎在评论区留言。</p>\n<p>-------------------------华丽的分割线--------------------</p>\n<p>想了解更多，关注关注我的微信公众号：守候书阁</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/6/24/16430faf385b3e2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"258\" data-height=\"258\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"258\" height=\"258\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "ic495dxv4m8",
      "author": "守候i",
      "title": "[杂谈]了解一些额外知识，让前端开发锦上添花",
      "baseClassName": "article-content"
    },
    {
      "content": "<p></p><figure><img atr=\"iPhone\" style class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2017/2/27/a880a658267c6f9dd572e123855ba9a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"https://user-gold-cdn.xitu.io/2017/2/27/a880a658267c6f9dd572e123855ba9a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption>iPhone</figcaption></figure> <figure><img atr=\"Mac.gif\" style class=\"lazyload inited\" data-src=\"https://lc-gold-cdn.xitu.io/63d41a4af7026a2848d2.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption>Mac.gif</figcaption></figure><p></p>\n<h1 id=\"-ppcounter-https-github-com-jkpang-ppcounter-\" data-id=\"heading-0\"><a href=\"https://github.com/jkpang/PPCounter\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PPCounter </a></h1>\n<h2 id=\"-\" data-id=\"heading-1\">前言</h2>\n<p>在新的项目中UI妹子设计出了一个类似于支付宝金额不断增加的动画,如下图: </p>\n<p></p><figure><img atr=\"动效图\" style class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2017/2/27/76925d28dea9e4d61967123a6357f783?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption>动效图</figcaption></figure><p></p>\n<p>然后就找度娘学习下了相关经验,受到这篇博客的启发:<a href=\"https://zsisme.gitbooks.io/ios-/content/chapter11/frame-timing.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ios核心动画高级技巧</a>,使用CADisplayLink定时器来做此动效的引擎(其实使用NSTimer和GCD定时器也可以做到,但使用CADisplayLink最佳)。</p>\n<h4 id=\"-\" data-id=\"heading-2\">现在我已经将此效果从项目中分拆出来,独立封装好了,调用一句代码就可以实现数字加减的动效 :</h4>\n<ul>\n<li>支持iOS/macOS双平台(pods版本v0.5.0, 2017.03.07更新)</li>\n<li>支持UILable/UIButton/自定义文本 控件的数字加减动画;</li>\n<li>支持一般文本属性以及富文本属性的字体显示;</li>\n<li>支持四种时间曲线函数动画:由慢到快再到慢、由慢到特别快、由快到慢、匀速;</li>\n<li>支持自定义的文本格式,例如:数字格式化千分位显示;</li>\n<li>支持CocoaPods导入</li>\n</ul>\n<h2 id=\"-\" data-id=\"heading-3\">代码部分</h2>\n<h3 id=\"1-1-uilabel\" data-id=\"heading-4\">1.1 设置一般字体属性UILabel</h3>\n<pre><code class=\"hljs objc copyable\">....\n[label pp_fromNumber:<span class=\"hljs-number\">0</span> toNumber:<span class=\"hljs-number\">100</span> duration:<span class=\"hljs-number\">1.5</span> animationType:PPCounterAnimationTypeEaseOut formatBlock:^<span class=\"hljs-built_in\">NSString</span> *(<span class=\"hljs-built_in\">CGFloat</span> number) {\n    <span class=\"hljs-comment\">// 此处自由拼接内容</span>\n    <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-built_in\">NSString</span> stringWithFormat:<span class=\"hljs-string\">@\"%.2f\"</span>,number];\n} completeBlock:^{\n    <span class=\"hljs-comment\">// 完成的回调</span>\n}];<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 id=\"1-2-uilabel\" data-id=\"heading-5\">1.2 设置富文本字体属性UILabel</h4>\n<pre><code class=\"hljs objc copyable\">....\n[label pp_fromNumber:<span class=\"hljs-number\">0</span> toNumber:<span class=\"hljs-number\">100</span> duration:<span class=\"hljs-number\">1.5</span> animationType:PPCounterAnimationTypeEaseOut attributedFormatBlock:^<span class=\"hljs-built_in\">NSAttributedString</span> *(<span class=\"hljs-built_in\">CGFloat</span> number) {\n\n    <span class=\"hljs-comment\">// 此处自由设置富文本属性的内容</span>\n    <span class=\"hljs-built_in\">NSMutableAttributedString</span> *attributedString = [[<span class=\"hljs-built_in\">NSMutableAttributedString</span> alloc] initWithString:<span class=\"hljs-string\">@\"\"</span>];\n    <span class=\"hljs-keyword\">return</span> attributedString;\n} completeBlock:^{\n    <span class=\"hljs-comment\">// 完成的回调</span>\n}];<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 id=\"2-uibutton\" data-id=\"heading-6\">2. UIButton</h3>\n<h4 id=\"2-1-uibutton\" data-id=\"heading-7\">2.1 设置一般字体属性UIButton</h4>\n<pre><code class=\"hljs objc copyable\">....\n[button pp_fromNumber:<span class=\"hljs-number\">0</span> toNumber:<span class=\"hljs-number\">100</span> duration:<span class=\"hljs-number\">1.5</span> animationType:PPCounterAnimationTypeEaseOut formatBlock:^<span class=\"hljs-built_in\">NSString</span> *(<span class=\"hljs-built_in\">CGFloat</span> number) {\n    <span class=\"hljs-comment\">// 此处自由拼接内容</span>\n    <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-built_in\">NSString</span> stringWithFormat:<span class=\"hljs-string\">@\"%.2f\"</span>,number];\n} completeBlock:^{\n    <span class=\"hljs-comment\">// 完成的回调</span>\n}];<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 id=\"2-2-uibutton\" data-id=\"heading-8\">2.2 设置富文本字体属性UIButton</h4>\n<pre><code class=\"hljs objc copyable\">....\n[button pp_fromNumber:<span class=\"hljs-number\">0</span> toNumber:<span class=\"hljs-number\">100</span> duration:<span class=\"hljs-number\">1.5</span> animationType:PPCounterAnimationTypeEaseOut attributedFormatBlock:^<span class=\"hljs-built_in\">NSAttributedString</span> *(<span class=\"hljs-built_in\">CGFloat</span> number) {\n\n    <span class=\"hljs-comment\">// 此处自由设置富文本属性的内容</span>\n    <span class=\"hljs-built_in\">NSMutableAttributedString</span> *attributedString = [[<span class=\"hljs-built_in\">NSMutableAttributedString</span> alloc] initWithString:<span class=\"hljs-string\">@\"\"</span>];\n    <span class=\"hljs-keyword\">return</span> attributedString;\n} completeBlock:^{\n\n    <span class=\"hljs-comment\">// 完成的回调</span>\n}];<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 id=\"3-macos-platform-\" data-id=\"heading-9\">3, macOS Platform 使用</h3>\n<pre><code class=\"hljs objc copyable\">[[PPCounterEngine counterEngine] fromNumber:<span class=\"hljs-number\">0</span>\n                                   toNumber:<span class=\"hljs-number\">999</span>\n                                   duration:<span class=\"hljs-number\">2.</span>f\n                          animationOptions:PPCounterAnimationOptionCurveEaseOut\n                              currentNumber:^(<span class=\"hljs-built_in\">CGFloat</span> number) {\n        <span class=\"hljs-comment\">// lable控件</span>\n        <span class=\"hljs-keyword\">self</span>.numberLabel.stringValue = [<span class=\"hljs-built_in\">NSString</span> stringWithFormat:<span class=\"hljs-string\">@\"%ld\"</span>,(<span class=\"hljs-built_in\">NSInteger</span>)number];\n    } completion:^{\n            <span class=\"hljs-comment\">// 计数完成的回调</span>\n        <span class=\"hljs-keyword\">self</span>.numberLabel.textColor = [<span class=\"hljs-built_in\">NSColor</span> redColor];\n    }];<span class=\"copy-code-btn\">复制代码</span></code></pre><p>以上就是PPCounter的简单使用方法,更详细的用法请看Demo : <a href=\"https://github.com/jkpang/PPCounter\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/jkpang/PPCo…</a>, 欢迎Star,欢迎Fork!</p>\n",
      "id": "1kc9x25z6g4g",
      "author": "jkpang",
      "title": "iOS与macOS中一款优雅的数字/金额增减动效控件(支付宝内金额增加效果)",
      "baseClassName": "article-content"
    },
    {
      "content": "<div data-note-content class=\"show-content\">\n                    <p><strong>editText默认的属性里面是没有金额类型的，所以要实现这个功能我们就必须自己动手丰衣足食。</strong></p>\n                    <h3 data-id=\"heading-0\">一.EditText只允许输入数字、小数点。</h3>\n                    <p>首先要知道金额有两部分构成，整数部分和小数部分，要实现只输入数字和小数点很简单。自己查能很容易查到。</p>\n                    <p><strong>把type设置成InputType.TYPE_NUMBER_FLAG_DECIMAL|InputType.TYPE_CLASS_NUMBER<br>\n就行</strong></p>\n                    <p>那这样做有个缺点，小数部分可以有很多位。而我们知道金额类型的小数部分只能有两位，所以这个方法不合适。</p>\n                    <h3 data-id=\"heading-1\">二.设置字符过滤</h3>\n                    <p>网上有很多文章都是这样写。</p>\n                    <pre class=\"hljs undefined\"><code>mEdit.setFilters(new InputFilter[]{new InputFilter() {\n    @Override\n    public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n        if(source.equals(\".\") && dest.toString().length() == 0){\n            return \"0.\";\n        }\n        if(dest.toString().contains(\".\")){\n            int index = dest.toString().indexOf(\".\");\n            int mlength = dest.toString().substring(index).length();\n            if(mlength == 3){\n                return \"\";\n            }\n        }\n        return null;\n    }\n}});\n</code></pre>\n                    <p>这样的做法能实现是能实现，但是这样的写法没有考虑到很多种会出现的情况，也就是说只是这样写的话，在某些情况下的用户体验很不好。</p>\n                    <h3 data-id=\"heading-2\">三.设置监听addTextChangedListener</h3>\n                    <p>上面的第二种方法你可以在里边加自己的算法来处理特殊情况，但是我不太喜欢这个方法，直到我看到一个哥们用addTextChangedListener来实现。我才发现，用addTextChangedListener来做金额类型的输入挺合适的。<strong>虽然也是要自己写算法去解决特殊情况下的问题，但是用起来比第二种方法舒服。</strong></p>\n                    <p>我先贴代码再做解释。</p>\n                    <pre class=\"hljs undefined\"><code>public class EditTextUtils {\n    /**\n     *  设置edittext只能输入小数点后两位\n     */\n    public static void afterDotTwo(final EditText editText) {\n        editText.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n                // 限制最多能输入9位整数\n                if (s.toString().contains(\".\")) {\n                    if (s.toString().indexOf(\".\") > 9) {\n                        s = s.toString().subSequence(0,9) + s.toString().substring(s.toString().indexOf(\".\"));\n                        editText.setText(s);\n                        editText.setSelection(9);\n                    }\n                }else {\n                    if (s.toString().length() > 9){\n                        s = s.toString().subSequence(0,9);\n                        editText.setText(s);\n                        editText.setSelection(9);\n                    }\n                }\n                // 判断小数点后只能输入两位\n                if (s.toString().contains(\".\")) {\n                    if (s.length() - 1 - s.toString().indexOf(\".\") > 2) {\n                        s = s.toString().subSequence(0,\n                                s.toString().indexOf(\".\") + 3);\n                        editText.setText(s);\n                        editText.setSelection(s.length());\n                    }\n                }\n                //如果第一个数字为0，第二个不为点，就不允许输入\n                if (s.toString().startsWith(\"0\") && s.toString().trim().length() > 1) {\n                    if (!s.toString().substring(1, 2).equals(\".\")) {\n                        editText.setText(s.subSequence(0, 1));\n                        editText.setSelection(1);\n                        return;\n                    }\n                }\n            }\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\n            }\n            @Override\n            public void afterTextChanged(Editable s) {\n                if (editText.getText().toString().trim() != null && !editText.getText().toString().trim().equals(\"\")) {\n                    if (editText.getText().toString().trim().substring(0, 1).equals(\".\")) {\n                        editText.setText(\"0\" + editText.getText().toString().trim());\n                        editText.setSelection(1);\n                    }\n                }\n            }\n        });\n    }\n\n}\n</code></pre>\n                    <p>我先把我工具类中的其它方法屏蔽调，只留这个方法。你会看到算法的代码量不算稍微有点杂。这是我参考那哥们写的再加上自己碰到的特殊需求改进的。当然每个人都应该根据自己的需求去写不同的算法。<br> <strong>但是至少先要掌握两点：addTextChangedListener的了解和Java String字符串的一些基本操作。</strong></p>\n                    <hr>\n                    <h4 data-id=\"heading-3\">我这里做了4中情况的判断：</h4>\n                    <h5 data-id=\"heading-4\">1. 限制整数只能输入多位</h5>\n                    <p>我这边的需求是整数最多为9位数，所以我先判断是否有小数点，有的话就获取前面9位加上小数点以及其后所有。</p>\n                    <pre class=\"hljs undefined\"><code>              if (s.toString().contains(\".\")) {\n                    if (s.toString().indexOf(\".\") > 9) {\n                        s = s.toString().subSequence(0,9) + s.toString().substring(s.toString().indexOf(\".\"));\n                        editText.setText(s);\n                        editText.setSelection(9);\n                    }\n                }else {\n                    if (s.toString().length() > 9){\n                        s = s.toString().subSequence(0,9);\n                        editText.setText(s);\n                        editText.setSelection(9);\n                    }\n                }\n</code></pre>\n                    <h5 data-id=\"heading-5\">2. 限制小数点后只能输两位</h5>\n                    <p>这个判断是判断金额的重点，本来金额小数点后就只能有两位，当然有些人的需求可能是只能有一位，这不要紧，把数字改下就行。首先判断是否有小数点，如果有，判断是否小数点后大于两位，如果大于就只取前两位。</p>\n                    <pre class=\"hljs undefined\"><code>\n                if (s.toString().contains(\".\")) {\n                    if (s.length() - 1 - s.toString().indexOf(\".\") > 2) {\n                        s = s.toString().subSequence(0,\n                                s.toString().indexOf(\".\") + 3);\n                        editText.setText(s);\n                        editText.setSelection(s.length());\n                    }\n                }\n</code></pre>\n                    <h5 data-id=\"heading-6\">3.第一个数为0的情况</h5>\n                    <p>我这里写的判断不是很好，之后可以改进。这个特殊情况是这样的，假如你输入的第一位是0，你想想，你能输入0233，05这种数字吗，就是您能，这样展示给用户的效果也很不友好，所以要判断如果第一位数是0，第二位不是小数点的话，就输出0。</p>\n                    <pre class=\"hljs undefined\"><code>                if (s.toString().startsWith(\"0\") && s.toString().trim().length() > 1) {\n                    if (!s.toString().substring(1, 2).equals(\".\")) {\n                        editText.setText(s.subSequence(0, 1));\n                        editText.setSelection(1);\n                        return;\n                    }\n                }\n</code></pre>\n                    <p>上面也说了这步的算法有两个问题，第一，如果在0.26的情况下，我把光标点在0后面，输入一个不为0的数字假设5，得到的结果是0而不是5.26。第二，假如还是0.26的情况下，我把光标点在小数点后面，删除小数点，得到的不是26而是0。所以这步的算法有些问题。那为什么不现在改呢，不好意思，最近太忙，写文章都很赶。</p>\n                    <h5 data-id=\"heading-7\">4.第一个是小数点的情况</h5>\n                    <p>假如你的数是5.26，这时候你把光标放到5后面，删除5，如果你不做处理，那展示出来的就是.26，这样的展示就很不友好，所以我们要想办法要在第一位为小数点的情况下补0。</p>\n                    <pre class=\"hljs undefined\"><code>            public void afterTextChanged(Editable s) {\n                if (editText.getText().toString().trim() != null && !editText.getText().toString().trim().equals(\"\")) {\n                    if (editText.getText().toString().trim().substring(0, 1).equals(\".\")) {\n                        editText.setText(\"0\" + editText.getText().toString().trim());\n                        editText.setSelection(1);\n                    }\n                }\n            }\n</code></pre>\n                    <p>这里写在afterTextChanged里面，所以让大家先要了解addTextChangedListener再来看算法，写在afterTextChanged里面是因为我要在“之后”做操作。算法也很简单，判断有字符串并且第一位为小数点的情况下，添加个0在前面。</p>\n                    <h5 data-id=\"heading-8\">因为这个算法是很赶的情况下写的，很多地方也许可以合并，可能也有一些特殊的情况没有考虑到，最好不要直接拿来用，我只是举个栗子说明addTextChangedListener能很好的实现这个功能，具体要怎么实现还需要根据个人自己的需求和特殊情况去写算法。</h5>\n                    <h3 data-id=\"heading-9\">四.最方便的方法</h3>\n                    <p>没错，要实现这个功能的最方便方法就是......跪求谷歌在下一个版本添加一个MONEY类型的TYPE，这样就是一行代码的事情了，呵呵。</p>\n                </div>",
      "id": "2rfrtkuuc8y0",
      "author": "994866755",
      "title": "Android EditText 输入金额类型",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)(qqqqqqqqqqqqqqqqqqqqqq1q!ssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxfj一种明敏敏名模1呢1额1额1额1哦哦1哦11111111你和弟弟弟弟的1额1额1额1额1的1额1的11的11的1额1)哦破婆婆婆婆您公民你<br></p>",
      "id": "1z9w03w4yfz4",
      "author": "大王叫我来巡山_e04b",
      "title": "呃呃呃额额的",
      "baseClassName": "_2rhmJa"
    },
    {
      "content": "<p>呃呃呃额额</p>",
      "id": "3fbgmt4wy100",
      "author": "宇宙肉丸",
      "title": "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyywbn阿鲁科目他爸爸巴巴爸爸Babe呃呃呃额额的呃呃呃额额的得得得得得得的呃呃呃额额的呃呃呃额额的呃呃呃额额的呃呃呃额额的呃呃呃额额的",
      "baseClassName": "_2rhmJa"
    }
  ],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dafb263f265da5b9b80244d",
      "k": "juejin",
      "id": "42ou4p218z40",
      "author": "第一名的小蝌蚪",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容..."
    },
    {
      "url": "https://juejin.im/post/5db5cf2e6fb9a02074738b25",
      "k": "juejin",
      "id": "5dagssi80f80",
      "author": "云中桥",
      "title": "小蝌蚪传记：200行代码实现前端无痕埋点",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>灰色的天</p>\n<p>妳的脸</p>\n<p>说分手的语气斩钉截铁</p>\n<p>小蝌蚪：“能不走吗”</p>\n<p>女神：“不能”</p>\n<p>小蝌蚪：“那个男人有什么好”</p>\n<p>女神：“他说话好听，长得帅，还有钱”</p>\n<p>小蝌蚪：“我没房没车没存款，但我有一颗爱妳的心”</p>\n<p>高富帅出现：“我有房有车有存款，我也有一颗爱她的心”</p>\n<p>小蝌蚪：“我能跑十公里去为她买宵夜”</p>\n<p>高富帅：“我开兰博基尼去为她买宵夜”</p>\n<p>小蝌蚪：“我一..."
    },
    {
      "url": "https://juejin.im/post/5db684ddf265da4d495c40e5",
      "k": "juejin",
      "id": "2zxb1dwpeok0",
      "author": "Void_0",
      "title": "「前端进阶」高性能渲染十万条数据(虚拟列表)",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做<code>长列表</code>。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>\n<p>在<a target=\"_blank\" href=\"https://juejin.im/post/5d76f469f265da03..."
    },
    {
      "url": "https://juejin.im/post/5db52dedf265da4d495c3fb8",
      "k": "juejin",
      "id": "3l7uk66lz100",
      "author": "voanit",
      "title": "基于vue+vant搭建H5通用架子",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h3 class=\"heading\" data-id=\"heading-0\">项目初衷</h3>\n<p>开发一个H5的通用架子，让前端同学开箱即用，迅速投入战斗。</p>\n<blockquote>\n<p>截止到2019-10-29 10:25，已经被fork了34次，如果您在使用过程中还希望能给我提<a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/issues\" rel=\"nofollow noopener noreferre..."
    },
    {
      "url": "https://juejin.im/post/5db66672f265da4d0e009aad",
      "k": "juejin",
      "id": "4bymoe296qi0",
      "author": "前端小智",
      "title": "VSCode前端必备插件，有可能你装了却不知道如何使用？",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>Visual Studio Code 是由微软开发的一款免费、跨平台的文本编辑器。由于其卓越的性能和丰富的功能，它很快就受到了大家的喜爱。</p>\n<p>就像大多数 IDE 一样，VSCode 也有一个扩展和主题市场，包含了数以千计质量不同的插件。下面我列出一些VSCode前端必备插件，并配有图文介绍，快来看看你是否都会使用呢？</p>\n<h2 class=\"heading\" data-id=\"heading-0\">VS Code 安装和汉化</h2>\n<p>下载地址：VS Code官网链..."
    },
    {
      "url": "https://juejin.im/post/5db62f1bf265da4d560906ab",
      "k": "juejin",
      "id": "4jxr194oaqk0",
      "author": "极客James",
      "title": "13 个 JS 数组精简技巧，一起来看看",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>作者：Duomly</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong>阿里云服务器很便宜火爆，今年比去年便宜，10.24~11.11购买是1年86元，3年229元，可以点击 下面链接进行参与：</strong>\n<a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBE..."
    },
    {
      "url": "https://juejin.im/post/5dafc91a6fb9a04e4047a713",
      "k": "juejin",
      "id": "58mvpog3e0g0",
      "author": "非著名程序猿",
      "title": "Vue登录注册-掘金可爱萌猫",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"..."
    },
    {
      "url": "https://juejin.im/post/5db919816fb9a020333c362f",
      "k": "juejin",
      "id": "7cemnhisr380",
      "author": "前端劝退师",
      "title": "大前端团队代码规范",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h3 class=\"heading\" data-id=\"heading-0\">1 前言</h3>\n<p>随着团队人数的增加，每个人的代码编写喜好不同，代码风格也迥然不同。如果有一个大家的统一的愿意遵守的代码规范，肯定事半功倍，提高效率，避免代码<code>Review</code>和<code>重构</code>。</p>\n<p>其中一部分规则参考了 腾讯<code>alloyteam</code>团队的代码规范，如有错误，请指出，将会非常感谢。</p>\n<p>坚持好的代码风格规范，从你我做起..."
    },
    {
      "url": "https://juejin.im/post/5db10695e51d452a091fde90",
      "k": "juejin",
      "id": "j3zela7ct0g",
      "author": "voanit",
      "title": "现代浏览器观察者 Observer API  指南（新）",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>前段时间在研究前端异常监控/埋点平台的实现。</p>\n<p>在思考方案时，想到了浏览器自带的观察者以及页面生命周期API 。</p>\n<p>于是在翻查资料时意外发现，原来现代浏览器支持多达四种不同类型的观察者：</p>\n<ul>\n<li><code>Intersection Observer</code>，交叉观察者。</li>\n<li><code>Mutation Observer</code..."
    },
    {
      "url": "https://juejin.im/post/5db105a1f265da4d082b7d27",
      "k": "juejin",
      "id": "wmziflvzylc",
      "author": "于是乎_",
      "title": "“1024”竟然火于“羞羞”论坛？程序员节敢不敢一起来吐槽",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h1 data-id=\"heading-0\">程序员节起源</h1><p>程序员的工作我们都知道，编程嘛。但为什么程序员节要在1024呢？1024最早火起来是因为一个“不可描述”的论坛，那里的回帖机制是：新用户发过贴之后，过1024秒才能发一贴，如果没到1024秒就又发了一条，则帖子里只会显示1024。</p><p><br></p><p>久而久之，1024成为了在这个论坛中灌水的最常用词，再加上在计算机数学中，1024M=1GB，谐音为“一级棒”，引申为对帖子的肯定。<br></p><p>再后..."
    },
    {
      "url": "https://juejin.im/post/5da9c6b0e51d4524d67486e2",
      "k": "juejin",
      "id": "6cwrhcl51yc0",
      "author": "ikoala",
      "title": "前端工程师应该知道的yarn知识",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>yarn 是在工作中离不开的工具，但在工作中，很多人基本只会使用 <code>yarn install</code>，而且会手动删除 <code>node-modules</code>，或删除 <code>yarn.lock</code> 文件等不规范操作。本文将从一些基础的知识点开始介绍，循序渐进的让你对 <code>Yarn</code> 有一个更深入的了解，来保证规范的使用yarn，避免一些隐藏bug的产生。<br>\n本文主要介绍以下知识：</p>\n<blockquote>\n<ol>..."
    }
  ]
}