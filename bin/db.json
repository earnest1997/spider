{
  "searchResList": [],
  "hotArticleDetailList": [
    {
      "content": "<p>笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！</p>\n<h2 class=\"heading\" data-id=\"heading-0\">第一篇: JS数据类型之问——概念篇</h2>\n<h3 class=\"heading\" data-id=\"heading-1\">1.JS原始数据类型有哪些？引用数据类型有哪些？</h3>\n<p>在 JS 中，存在着 7 种原始值，分别是：</p>\n<ul>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>number</li>\n<li>string</li>\n<li>symbol</li>\n<li>bigint</li>\n</ul>\n<p>引用数据类型:\n对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</p>\n<h3 class=\"heading\" data-id=\"heading-2\">2.说出下面运行的结果，解释原因。</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\">person</span>) </span>{\n  person.age = <span class=\"hljs-number\">26</span>\n  person = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'hzj'</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span>\n  }\n  <span class=\"hljs-keyword\">return</span> person\n}\n<span class=\"hljs-keyword\">const</span> p1 = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'fyq'</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">19</span>\n}\n<span class=\"hljs-keyword\">const</span> p2 = test(p1)\n<span class=\"hljs-built_in\">console</span>.log(p1) <span class=\"hljs-comment\">// -> ?</span>\n<span class=\"hljs-built_in\">console</span>.log(p2) <span class=\"hljs-comment\">// -> ?</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>结果:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">p1：{name: “fyq”, age: 26}\np2：{name: “hzj”, age: 18}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><blockquote>\n<p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-3\">3.null是对象吗？为什么？</h3>\n<p>结论: null不是对象。</p>\n<p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p>\n<h3 class=\"heading\" data-id=\"heading-4\">4.'1'.toString()为什么可以调用？</h3>\n<p>其实在这个语句运行的过程中做了这样几件事情：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-string\">'1'</span>);\ns.toString();\ns = <span class=\"hljs-literal\">null</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</p>\n<p>第二步: 调用实例方法。</p>\n<p>第三步: 执行完方法立即销毁这个实例。</p>\n<p>整个过程体现了<code>基本包装类型</code>的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</p>\n<blockquote>\n<p>参考:《JavaScript高级程序设计(第三版)》P118</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-5\">5.0.1+0.2为什么不等于0.3？</h3>\n<p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">6.如何理解BigInt?</h3>\n<h4 class=\"heading\" data-id=\"heading-7\">什么是BigInt?</h4>\n<blockquote>\n<p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对<code>大整数</code>执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-8\">为什么需要BigInt?</h4>\n<p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p>\n<p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">999999999999999</span>);  <span class=\"hljs-comment\">//=>10000000000000000</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>同时也会有一定的安全性问题:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-number\">9007199254740992</span> === <span class=\"hljs-number\">9007199254740993</span>;    <span class=\"hljs-comment\">// → true 居然是true!</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-9\">如何创建并使用BigInt？</h4>\n<p>要创建BigInt，只需要在数字末尾追加n即可。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-number\">9007199254740995</span>n );    <span class=\"hljs-comment\">// → 9007199254740995n\t</span>\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-number\">9007199254740995</span> );     <span class=\"hljs-comment\">// → 9007199254740996</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>另一种创建BigInt的方法是用BigInt()构造函数、</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">BigInt(<span class=\"hljs-string\">\"9007199254740995\"</span>);    <span class=\"hljs-comment\">// → 9007199254740995n</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>简单使用如下:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-number\">10</span>n + <span class=\"hljs-number\">20</span>n;    <span class=\"hljs-comment\">// → 30n\t</span>\n<span class=\"hljs-number\">10</span>n - <span class=\"hljs-number\">20</span>n;    <span class=\"hljs-comment\">// → -10n\t</span>\n+<span class=\"hljs-number\">10</span>n;         <span class=\"hljs-comment\">// → TypeError: Cannot convert a BigInt value to a number\t</span>\n<span class=\"hljs-number\">-10</span>n;         <span class=\"hljs-comment\">// → -10n\t</span>\n<span class=\"hljs-number\">10</span>n * <span class=\"hljs-number\">20</span>n;    <span class=\"hljs-comment\">// → 200n\t</span>\n<span class=\"hljs-number\">20</span>n / <span class=\"hljs-number\">10</span>n;    <span class=\"hljs-comment\">// → 2n\t</span>\n<span class=\"hljs-number\">23</span>n % <span class=\"hljs-number\">10</span>n;    <span class=\"hljs-comment\">// → 3n\t</span>\n<span class=\"hljs-number\">10</span>n ** <span class=\"hljs-number\">3</span>n;    <span class=\"hljs-comment\">// → 1000n\t</span>\n\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">10</span>n;\t\n++x;          <span class=\"hljs-comment\">// → 11n\t</span>\n--x;          <span class=\"hljs-comment\">// → 9n</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> x);   <span class=\"hljs-comment\">//\"bigint\"</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">值得警惕的点</h4>\n<ol>\n<li>\n<p>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</p>\n</li>\n<li>\n<p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p>\n</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-number\">10</span> + <span class=\"hljs-number\">10</span>n;    <span class=\"hljs-comment\">// → TypeError</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-built_in\">Math</span>.max(<span class=\"hljs-number\">2</span>n, <span class=\"hljs-number\">4</span>n, <span class=\"hljs-number\">6</span>n);    <span class=\"hljs-comment\">// → TypeError</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">0</span>n){<span class=\"hljs-comment\">//条件判断为false</span>\n\n}\n<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">3</span>n){<span class=\"hljs-comment\">//条件为true</span>\n\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li>\n<p>元素都为BigInt的数组可以进行sort。</p>\n</li>\n<li>\n<p>BigInt可以正常地进行位运算，如|、&、<<、>>和^</p>\n</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-11\">浏览器兼容性</h4>\n<p>caniuse的结果:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df110a69c0ae17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1268\" data-height=\"553\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1268\" height=\"553\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。</p>\n<p>我们期待BigInt的光明前途！</p>\n<h2 class=\"heading\" data-id=\"heading-12\">第二篇:  JS数据类型之问——检测篇</h2>\n<h3 class=\"heading\" data-id=\"heading-13\">1. typeof 是否能正确判断类型？</h3>\n<p>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 'number'</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">'1'</span> <span class=\"hljs-comment\">// 'string'</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> <span class=\"hljs-comment\">// 'undefined'</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 'boolean'</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>() <span class=\"hljs-comment\">// 'symbol'</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>但对于引用数据类型，除了函数之外，都会显示\"object\"。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">typeof</span> [] <span class=\"hljs-comment\">// 'object'</span>\n<span class=\"hljs-keyword\">typeof</span> {} <span class=\"hljs-comment\">// 'object'</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">console</span>.log <span class=\"hljs-comment\">// 'function'</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> Person = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> Person()\np1 <span class=\"hljs-keyword\">instanceof</span> Person <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-keyword\">var</span> str1 = <span class=\"hljs-string\">'hello world'</span>\nstr1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">String</span> <span class=\"hljs-comment\">// false</span>\n\n<span class=\"hljs-keyword\">var</span> str2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">'hello world'</span>)\nstr2 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">String</span> <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-14\">2. instanceof能否判断基本数据类型？</h3>\n<p>能。比如下面这种方式:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrimitiveNumber</span> </span>{\n  <span class=\"hljs-keyword\">static</span> [<span class=\"hljs-built_in\">Symbol</span>.hasInstance](x) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'number'</span>\n  }\n}\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">111</span> <span class=\"hljs-keyword\">instanceof</span> PrimitiveNumber) <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果你不知道Symbol，可以看看<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance\" rel=\"nofollow noopener noreferrer\">MDN上关于hasInstance的解释</a>。</p>\n<p>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">3. 能不能手动实现一下instanceof的功能？</h3>\n<p>核心: 原型链的向上查找。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myInstanceof</span>(<span class=\"hljs-params\">left, right</span>) </span>{\n    <span class=\"hljs-comment\">//基本数据类型直接返回false</span>\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> left !== <span class=\"hljs-string\">'object'</span> || left === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-comment\">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span>\n    <span class=\"hljs-keyword\">let</span> proto = <span class=\"hljs-built_in\">Object</span>.getPrototypeOf(left);\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-comment\">//查找到尽头，还没找到</span>\n        <span class=\"hljs-keyword\">if</span>(proto == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-comment\">//找到相同的原型对象</span>\n        <span class=\"hljs-keyword\">if</span>(proto == right.prototype) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        proto = <span class=\"hljs-built_in\">Object</span>.getPrototypeof(proto);\n    }\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>测试:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-built_in\">console</span>.log(myInstanceof(<span class=\"hljs-string\">\"111\"</span>, <span class=\"hljs-built_in\">String</span>)); <span class=\"hljs-comment\">//false</span>\n<span class=\"hljs-built_in\">console</span>.log(myInstanceof(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">\"111\"</span>), <span class=\"hljs-built_in\">String</span>));<span class=\"hljs-comment\">//true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-16\">4. Object.is和===的区别？</h3>\n<p>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。\n源码如下：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">is</span>(<span class=\"hljs-params\">x, y</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (x === y) {\n    <span class=\"hljs-comment\">//运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的</span>\n    <span class=\"hljs-keyword\">return</span> x !== <span class=\"hljs-number\">0</span> || y !== <span class=\"hljs-number\">0</span> || <span class=\"hljs-number\">1</span> / x === <span class=\"hljs-number\">1</span> / y;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理</span>\n    <span class=\"hljs-comment\">//两个都是NaN的时候返回true</span>\n    <span class=\"hljs-keyword\">return</span> x !== x && y !== y;\n  }\n \n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-17\">第三篇: JS数据类型之问——转换篇</h2>\n<h3 class=\"heading\" data-id=\"heading-18\">1. [] == ![]结果是什么？为什么？</h3>\n<p>解析:</p>\n<p>== 中，左右两边都需要转换为数字然后进行比较。</p>\n<p>[]转换为数字为0。</p>\n<p>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,</p>\n<p>因此![]为false，进而在转换成数字，变为0。</p>\n<p>0 == 0 ， 结果为true</p>\n<h3 class=\"heading\" data-id=\"heading-19\">2. JS中类型转换有哪几种？</h3>\n<p>JS中，类型转换只有三种：</p>\n<ul>\n<li>转换成数字</li>\n<li>转换成布尔值</li>\n<li>转换成字符串</li>\n</ul>\n<p>转换具体规则如下:</p>\n<blockquote>\n<p>注意\"Boolean 转字符串\"这行结果指的是 true 转字符串的例子</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de9512eaf1158a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"910\" data-height=\"648\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"910\" height=\"648\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-20\">3. == 和 ===有什么区别？</h3>\n<blockquote class=\"warning\"><p>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。\n</p></blockquote><p>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</p>\n<ul>\n<li>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false</li>\n<li>判断的是否是null和undefined，是的话就返回true</li>\n<li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li>\n<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>\n<li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li>\n</ul>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-built_in\">console</span>.log({<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>} == <span class=\"hljs-literal\">true</span>);<span class=\"hljs-comment\">//false</span>\n<span class=\"hljs-built_in\">console</span>.log({<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>} == <span class=\"hljs-string\">\"[object Object]\"</span>);<span class=\"hljs-comment\">//true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-21\">4. 对象转原始类型是根据什么流程运行的？</h3>\n<p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>\n<ol>\n<li>如果Symbol.toPrimitive()方法，优先调用再返回</li>\n<li>调用valueOf()，如果转换为原始类型，则返回</li>\n<li>调用toString()，如果转换为原始类型，则返回</li>\n<li>如果都没有返回原始类型，会报错</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>,\n  valueOf() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;\n  },\n  toString() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'5'</span>\n  },\n  [<span class=\"hljs-built_in\">Symbol</span>.toPrimitive]() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">6</span>\n  }\n}\n<span class=\"hljs-built_in\">console</span>.log(obj + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 输出7</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-22\">5. 如何让if(a == 1 && a == 2)条件成立？</h3>\n<p>其实就是上一个问题的应用。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">valueOf</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.value++;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.value;\n  }\n};\n<span class=\"hljs-built_in\">console</span>.log(a == <span class=\"hljs-number\">1</span> && a == <span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-23\">第四篇: 谈谈你对闭包的理解</h2>\n<h3 class=\"heading\" data-id=\"heading-24\">什么是闭包？</h3>\n<blockquote class=\"warning\"><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，\n</p></blockquote><blockquote class=\"warning\"><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。\n\n（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n</p></blockquote><h3 class=\"heading\" data-id=\"heading-25\">闭包产生的原因?</h3>\n<p>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，<code>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链</code>，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f1</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f2</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-built_in\">console</span>.log(a);<span class=\"hljs-comment\">//3</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！</p>\n<p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f1</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f2</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(a);<span class=\"hljs-comment\">//2</span>\n  }\n  <span class=\"hljs-keyword\">return</span> f2;\n}\n<span class=\"hljs-keyword\">var</span> x = f1();\nx();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。</p>\n<p>那是不是只有返回函数才算是产生了闭包呢？、</p>\n<p>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> f3;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f1</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>\n  f3 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(a);\n  }\n}\nf1();\nf3();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>让f1执行，给f3赋值后，等于说现在<code>f3拥有了window、f1和f3本身这几个作用域的访问权限</code>，还是自底向上查找，<code>最近是在f1</code>中找到了a,因此输出2。</p>\n<p>在这里是外面的变量<code>f3存在着父级作用域的引用</code>，因此产生了闭包，形式变了，本质没有改变。</p>\n<h3 class=\"heading\" data-id=\"heading-26\">闭包有哪些表现形式?</h3>\n<p>明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？</p>\n<ol>\n<li>返回一个函数。刚刚已经举例。</li>\n<li>作为函数参数传递</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(a);\n  }\n  bar(baz);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">fn</span>)</span>{\n  <span class=\"hljs-comment\">// 这就是闭包</span>\n  fn();\n}\n<span class=\"hljs-comment\">// 输出2，而不是1</span>\nfoo();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</li>\n</ol>\n<p>以下的闭包保存的仅仅是window和当前作用域。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 定时器</span>\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeHandler</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'111'</span>);\n}，<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-comment\">// 事件监听</span>\n$(<span class=\"hljs-string\">'#app'</span>).click(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'DOM Listener'</span>);\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li>IIFE(立即执行函数表达式)创建闭包, 保存了<code>全局作用域window</code>和<code>当前函数的作用域</code>，因此可以全局的变量。</li>\n</ol>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-comment\">// 输出2</span>\n  <span class=\"hljs-built_in\">console</span>.log(a);\n})();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-27\">如何解决下面的循环输出问题？</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i <= <span class=\"hljs-number\">5</span>; i ++){\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timer</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  }, <span class=\"hljs-number\">0</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p>\n<p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p>\n<p>解决方法：</p>\n<p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>;i <= <span class=\"hljs-number\">5</span>;i++){\n  (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>)</span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timer</span>(<span class=\"hljs-params\"></span>)</span>{\n      <span class=\"hljs-built_in\">console</span>.log(j)\n    }, <span class=\"hljs-number\">0</span>)\n  })(i)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">1</span>;i<=<span class=\"hljs-number\">5</span>;i++){\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timer</span>(<span class=\"hljs-params\">j</span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(j)\n  }, <span class=\"hljs-number\">0</span>, i)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>3、使用ES6中的let</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i <= <span class=\"hljs-number\">5</span>; i++){\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timer</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  },<span class=\"hljs-number\">0</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// i = 1\n{\n  <span class=\"hljs-built_in\">set</span>Timeout(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">timer</span></span>(){\n    console.log(1)\n  },0)\n}\n// i = 2\n{\n  <span class=\"hljs-built_in\">set</span>Timeout(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">timer</span></span>(){\n    console.log(2)\n  },0)\n}\n// i = 3\n...\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>因此能输出正确的结果。</p>\n<h2 class=\"heading\" data-id=\"heading-28\">第五篇: 谈谈你对原型链的理解</h2>\n<h3 class=\"heading\" data-id=\"heading-29\">1.原型对象和构造函数有何关系？</h3>\n<p>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。</p>\n<p>当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de955a81892535?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"704\" data-height=\"408\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"704\" height=\"408\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-30\">2.能不能描述一下原型链？</h3>\n<p>JavaScript对象通过prototype指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de955ca89f6091?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1137\" data-height=\"408\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1137\" height=\"408\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>\n<li>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-31\">第六篇: JS如何实现继承？</h2>\n<h3 class=\"heading\" data-id=\"heading-32\">第一种: 借助call</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent1</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'parent1'</span>;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child1</span>(<span class=\"hljs-params\"></span>)</span>{\n    Parent1.call(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'child1'</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> Child1);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>\n<h3 class=\"heading\" data-id=\"heading-33\">第二种: 借助原型链</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent2</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'parent2'</span>;\n    <span class=\"hljs-keyword\">this</span>.play = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child2</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'child2'</span>;\n  }\n  Child2.prototype = <span class=\"hljs-keyword\">new</span> Parent2();\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> Child2());\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">new</span> Child2();\n  <span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-keyword\">new</span> Child2();\n  s1.play.push(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">console</span>.log(s1.play, s2.play);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以看到控制台：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de955fbdbd9d9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"385\" data-height=\"37\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"385\" height=\"37\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。</p>\n<p>那么还有更好的方式么？</p>\n<h3 class=\"heading\" data-id=\"heading-34\">第三种：将前两种组合</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent3</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'parent3'</span>;\n    <span class=\"hljs-keyword\">this</span>.play = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child3</span>(<span class=\"hljs-params\"></span>) </span>{\n    Parent3.call(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'child3'</span>;\n  }\n  Child3.prototype = <span class=\"hljs-keyword\">new</span> Parent3();\n  <span class=\"hljs-keyword\">var</span> s3 = <span class=\"hljs-keyword\">new</span> Child3();\n  <span class=\"hljs-keyword\">var</span> s4 = <span class=\"hljs-keyword\">new</span> Child3();\n  s3.play.push(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">console</span>.log(s3.play, s4.play);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以看到控制台：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de95621c0cdde1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"353\" data-height=\"28\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"353\" height=\"28\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？</p>\n<h3 class=\"heading\" data-id=\"heading-35\">第四种: 组合继承的优化1</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent4</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'parent4'</span>;\n    <span class=\"hljs-keyword\">this</span>.play = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child4</span>(<span class=\"hljs-params\"></span>) </span>{\n    Parent4.call(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'child4'</span>;\n  }\n  Child4.prototype = Parent4.prototype;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> s3 = <span class=\"hljs-keyword\">new</span> Child4();\n  <span class=\"hljs-keyword\">var</span> s4 = <span class=\"hljs-keyword\">new</span> Child4();\n  <span class=\"hljs-built_in\">console</span>.log(s3)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de956480812408?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"539\" data-height=\"159\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"539\" height=\"159\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p>\n<h3 class=\"heading\" data-id=\"heading-36\">第五种(最推荐使用): 组合继承的优化1</h3>\n<pre><code class=\"hljs js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent5</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">'parent5'</span>;\n    <span class=\"hljs-keyword\">this</span>.play = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child5</span>(<span class=\"hljs-params\"></span>) </span>{\n    Parent5.call(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'child5'</span>;\n  }\n  Child5.prototype = <span class=\"hljs-built_in\">Object</span>.create(Parent5.prototype);\n  Child5.prototype.constructor = Child5;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。</p>\n<h3 class=\"heading\" data-id=\"heading-37\">ES6的extends被编译后的JavaScript代码</h3>\n<p>ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。</p>\n<p>那最后编译成了什么样子呢？</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_possibleConstructorReturn</span> (<span class=\"hljs-params\">self, call</span>) </span>{ \n\t\t<span class=\"hljs-comment\">// ...</span>\n\t\t<span class=\"hljs-keyword\">return</span> call && (<span class=\"hljs-keyword\">typeof</span> call === <span class=\"hljs-string\">'object'</span> || <span class=\"hljs-keyword\">typeof</span> call === <span class=\"hljs-string\">'function'</span>) ? call : self; \n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_inherits</span> (<span class=\"hljs-params\">subClass, superClass</span>) </span>{ \n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-comment\">//看到没有</span>\n\t\tsubClass.prototype = <span class=\"hljs-built_in\">Object</span>.create(superClass && superClass.prototype, { \n\t\t\t\t<span class=\"hljs-attr\">constructor</span>: { \n\t\t\t\t\t\t<span class=\"hljs-attr\">value</span>: subClass, \n\t\t\t\t\t\t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>, \n\t\t\t\t\t\t<span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>, \n\t\t\t\t\t\t<span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span> \n\t\t\t\t} \n\t\t}); \n\t\t<span class=\"hljs-keyword\">if</span> (superClass) <span class=\"hljs-built_in\">Object</span>.setPrototypeOf ? <span class=\"hljs-built_in\">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; \n}\n\n\n<span class=\"hljs-keyword\">var</span> Parent = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent</span> (<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-comment\">// 验证是否是 Parent 构造出来的 this</span>\n\t\t_classCallCheck(<span class=\"hljs-keyword\">this</span>, Parent);\n};\n\n<span class=\"hljs-keyword\">var</span> Child = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_Parent</span>) </span>{\n\t\t_inherits(Child, _Parent);\n\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child</span> (<span class=\"hljs-params\"></span>) </span>{\n\t\t\t\t_classCallCheck(<span class=\"hljs-keyword\">this</span>, Child);\n\t\t\n\t\t\t\t<span class=\"hljs-keyword\">return</span> _possibleConstructorReturn(<span class=\"hljs-keyword\">this</span>, (Child.__proto__ || <span class=\"hljs-built_in\">Object</span>.getPrototypeOf(Child)).apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>));\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">return</span> Child;\n}(Parent));\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？</p>\n<p>答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。</p>\n<blockquote class=\"warning\"><p>追问: 面向对象的设计一定是好的设计吗？\n</p></blockquote><p>不一定。从继承的角度说，这一设计是存在巨大隐患的。</p>\n<h3 class=\"heading\" data-id=\"heading-38\">从设计思想上谈谈继承本身的问题</h3>\n<p>假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span></span>{\n  <span class=\"hljs-keyword\">constructor</span>(id) {\n    <span class=\"hljs-keyword\">this</span>.id = id;\n  }\n  drive(){\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"wuwuwu!\"</span>);\n  }\n  music(){\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"lalala!\"</span>)\n  }\n  addOil(){\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"哦哟！\"</span>)\n  }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">otherCar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Car</span></span>{}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>现在可以实现车的功能，并且以此去扩展不同的车。</p>\n<p>但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。</p>\n<p>如果让新能源汽车的类继承Car的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。</p>\n<blockquote>\n<p>继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。</p>\n</blockquote>\n<p>当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，<code>代码势必会大量重复</code>，另一方面一旦子类有所变动，父类也要进行相应的更新，<code>代码的耦合性太高</code>，维护性不好。</p>\n<p>那如何来解决继承的诸多问题呢？</p>\n<p>用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。</p>\n<p>顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">drive</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"wuwuwu!\"</span>);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">music</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"lalala!\"</span>)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addOil</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"哦哟！\"</span>)\n}\n\n<span class=\"hljs-keyword\">let</span> car = compose(drive, music, addOil);\n<span class=\"hljs-keyword\">let</span> newEnergyCar = compose(drive, music);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>代码干净，复用性也很好。这就是面向组合的设计方式。</p>\n<p>参考出处:</p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d0da727518825326d492b2f\" rel>ES5实现继承那些事</a></p>\n<p><a target=\"_blank\" href=\"https://yuchengkai.cn/blog/2019-03-18.html#%E5%8E%9F%E5%9E%8B\" rel=\"nofollow noopener noreferrer\">重学JS系列:聊聊继承</a></p>\n<p><a target=\"_blank\" href=\"https://segmentfault.com/a/1190000019912017\" rel=\"nofollow noopener noreferrer\">JS最新基本数据类型:BigInt(译)</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/book/5bdc715fe51d454e755f75ef\" rel>yck前端面试之道</a></p>\n<p>更多有趣内容见微信公众号:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16debab49ce156b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"900\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "3zpphpxg36e0",
      "author": "火狼1",
      "title": "(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<blockquote>\n<p>是时候撸一波 JS 基础啦,撸熟了,银十速拿 offer;<br>\n本文不从传统的问答方式梳理,而是从知识维度梳理,以便形成知识网络;<br>\n包括函数,数组,对象,数据结构,算法,设计模式和 http.</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-1\">1. 函数</h1>\n<h2 class=\"heading\" data-id=\"heading-2\">1.1函数的3种定义方法</h2>\n<h3 class=\"heading\" data-id=\"heading-3\">1.1.1 函数声明</h3>\n<pre><code class=\"copyable\">//ES5\nfunction getSum(){}\nfunction (){}//匿名函数\n//ES6\n()=>{}//如果{}内容只有一行{}和return关键字可省,\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-4\">1.1.2 函数表达式(函数字面量)</h3>\n<pre><code class=\"copyable\">//ES5\nvar sum=function(){}\n//ES6\nlet sum=()=>{}//如果{}内容只有一行{}和return关键字可省,\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-5\">1.1.3 构造函数</h3>\n<pre><code class=\"copyable\">const sum = new Function('a', 'b' , 'return a + b')\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-6\">1.1.4 三种方法的对比</h3>\n<p>1.函数声明有预解析,而且函数声明的优先级高于变量;\n2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串</p>\n<h2 class=\"heading\" data-id=\"heading-7\">1.2.ES5中函数的4种调用</h2>\n<p>在ES5中函数内容的this指向和调用方法有关</p>\n<h3 class=\"heading\" data-id=\"heading-8\">1.2.1 函数调用模式</h3>\n<p>包括函数名()和匿名函数调用,this指向window</p>\n<pre><code class=\"copyable\"> function getSum() {\n    console.log(this) //这个属于函数名调用，this指向window\n }\n getSum()\n \n (function() {\n    console.log(this) //匿名函数调用，this指向window\n })()\n \n var getSum=function() {\n    console.log(this) //实际上也是函数名调用，window\n }\n getSum()\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-9\">1.2.2 方法调用</h3>\n<p>对象.方法名(),this指向对象</p>\n<pre><code class=\"copyable\">var objList = {\n   name: 'methods',\n   getSum: function() {\n     console.log(this) //objList对象\n   }\n}\nobjList.getSum()\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-10\">1.2.3 构造器调用</h3>\n<p>new 构造函数名(),this指向实例化的对象</p>\n<pre><code class=\"copyable\">function Person() {\n  console.log(this); //是构造函数调用，指向实例化的对象personOne\n}\nvar personOne = new Person();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-11\">1.2.4 间接调用</h3>\n<p>利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window</p>\n<pre><code class=\"copyable\">function foo() {\n   console.log(this);\n}\nfoo.apply('我是apply改变的this值');//我是apply改变的this值\nfoo.call('我是call改变的this值');//我是call改变的this值\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-12\">1.3 ES6中函数的调用</h2>\n<p>箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误\n箭头函数的this是和定义时有关和调用无关\n调用就是函数调用模式</p>\n<pre><code class=\"copyable\">(() => {\n   console.log(this)//window\n})()\n\nlet arrowFun = () => {\n  console.log(this)//window\n}\narrowFun()\n\nlet arrowObj = {\n  arrFun: function() {\n   (() => {\n     console.log(this)//this指向的是arrowObj对象\n   })()\n   }\n }\n arrowObj.arrFun();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-13\">1.4.call,apply和bind</h2>\n<p>1.IE5之前不支持call和apply,bind是ES5出来的;\n2.call和apply可以调用函数,改变this,实现继承和借用别的对象的方法;</p>\n<h3 class=\"heading\" data-id=\"heading-14\">1.4.1 call和apply定义</h3>\n<p>调用方法,用一个对象替换掉另一个对象(this)\n对象.call(新this对象,实参1,实参2,实参3.....)\n对象.apply(新this对象,[实参1,实参2,实参3.....])</p>\n<h3 class=\"heading\" data-id=\"heading-15\">1.4.2 call和apply用法</h3>\n<p>1.间接调用函数,改变作用域的this值\n2.劫持其他对象的方法</p>\n<pre><code class=\"copyable\">var foo = {\n  name:\"张三\",\n  logName:function(){\n    console.log(this.name);\n  }\n}\nvar bar={\n  name:\"李四\"\n};\nfoo.logName.call(bar);//李四\n实质是call改变了foo的this指向为bar,并调用该函数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>3.两个函数实现继承</p>\n<pre><code class=\"copyable\">function Animal(name){   \n  this.name = name;   \n  this.showName = function(){   \n    console.log(this.name);   \n  }   \n}   \nfunction Cat(name){  \n  Animal.call(this, name);  \n}    \nvar cat = new Cat(\"Black Cat\");   \ncat.showName(); //Black Cat\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>4.为类数组(arguments和nodeList)添加数组方法push,pop</p>\n<pre><code class=\"copyable\">(function(){\n  Array.prototype.push.call(arguments,'王五');\n  console.log(arguments);//['张三','李四','王五']\n})('张三','李四')\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>5.合并数组</p>\n<pre><code class=\"copyable\">let arr1=[1,2,3]; \nlet arr2=[4,5,6]; \nArray.prototype.push.apply(arr1,arr2); //将arr2合并到了arr1中\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>6.求数组最大值</p>\n<pre><code class=\"copyable\">Math.max.apply(null,arr)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>7.判断字符类型</p>\n<pre><code class=\"copyable\">Object.prototype.toString.call({})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-16\">1.4.3 bind</h3>\n<p>bind是function的一个函数扩展方法，bind以后代码重新绑定了func内部的this指向,不会调用方法,不兼容IE8</p>\n<pre><code class=\"copyable\">var name = '李四'\n var foo = {\n   name: \"张三\",\n   logName: function(age) {\n   console.log(this.name, age);\n   }\n }\n var fooNew = foo.logName;\n var fooNewBind = foo.logName.bind(foo);\n fooNew(10)//李四,10\n fooNewBind(11)//张三,11  因为bind改变了fooNewBind里面的this指向\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-17\">1.4.4 call,apply和bind原生实现</h3>\n<p>call实现:</p>\n<pre><code class=\"copyable\">Function.prototype.newCall = function(context, ...parameter) {\nif(context.instanceof Object) context={}\n  context.fn = this;  \n  context.fn(...parameter);\n  delete context.fn;\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nsayHi.newCall (person, 25, '男'); // Abiel 25 男\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>apply实现:</p>\n<pre><code class=\"copyable\">Function.prototype.newApply = function(context, parameter) {\n  if (typeof context === 'object') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  context[fn](parameter);\n  delete context[fn]\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>bind实现:</p>\n<pre><code class=\"copyable\">Function.prototype.bind = function (context,...innerArgs) {\n  var me = this\n  return function (...finnalyArgs) {\n    return me.call(context,...innerArgs,...finnalyArgs)\n  }\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nlet personSayHi = sayHi.bind(person, 25)\npersonSayHi('男')\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-18\">1.4.5 三者异同</h3>\n<p>同:都是改变this指向,都可接收参数\n异:bind和call是接收单个参数,apply是接收数组</p>\n<h2 class=\"heading\" data-id=\"heading-19\">1.5.函数的节流和防抖</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>概念</th>\n<th>应用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节流</td>\n<td>事件触发后每隔一段时间触发一次,可触发多次</td>\n<td>scroll,resize事件一段时间触发多次</td>\n</tr>\n<tr>\n<td>防抖</td>\n<td>事件触发动作完成后一段时间触发一次</td>\n<td>scroll,resize事件触发完后一段时间触发</td>\n</tr>\n</tbody>\n</table>\n<p>节流:</p>\n<h3 class=\"heading\" data-id=\"heading-20\">1.5.1 节流</h3>\n<pre><code class=\"copyable\">let throttle = function(func, delay) {\n    let timer = null;\n    return ()=> {\n      if (!timer) {\n        timer = setTimeout(function() {\n          func.apply(this, arguments);\n          timer = null;\n        }, delay);\n      }\n    };\n  };\n  function handle() {\n    console.log(Math.random());\n  }\n  window.addEventListener(\"scroll\", throttle(handle, 1000)); //事件处理函数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-21\">1.5.2 防抖</h3>\n<pre><code class=\"copyable\">function debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n      if (timeout !== null) clearTimeout(timeout);//如果多次触发将上次记录延迟清除掉\n      timeout = setTimeout(()=> {\n          fn.apply(this, arguments);\n          timeout = null;\n        }, wait);\n    };\n  }\n  // 处理函数\n  function handle() {\n    console.log(Math.random());\n  }\n  // 滚动事件\n  window.addEventListener(\"scroll\", debounce(handle, 1000));\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-22\">1.6.原型链</h2>\n<h3 class=\"heading\" data-id=\"heading-23\">1.6.1 定义</h3>\n<p>对象继承属性的一个链条</p>\n<h3 class=\"heading\" data-id=\"heading-24\">1.6.2构造函数,实例与原型对象的关系</h3>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df35ccb827f1e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"638\" data-height=\"241\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"638\" height=\"241\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"copyable\">var Person = function (name) { this.name = name; }//person是构造函数\nvar o3personTwo = new Person('personTwo')//personTwo是实例\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df35d0ab151801?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"534\" data-height=\"333\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"534\" height=\"333\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>原型对象都有一个默认的constructor属性指向构造函数</p>\n<h3 class=\"heading\" data-id=\"heading-25\">1.6.3 创建实例的方法</h3>\n<p>1.字面量</p>\n<pre><code class=\"copyable\">let obj={'name':'张三'}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.Object构造函数创建</p>\n<pre><code class=\"copyable\">let Obj=new Object()\nObj.name='张三'\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>3.使用工厂模式创建对象</p>\n<pre><code class=\"copyable\">function createPerson(name){\n var o = new Object();\n o.name = name;\n return o; \n}\nvar person1 = createPerson('张三');\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>4.使用构造函数创建对象</p>\n<pre><code class=\"copyable\">function Person(name){\n this.name = name;\n}\nvar person1 = new Person('张三');\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-26\">1.6.4 new运算符</h3>\n<p>1.创了一个新对象;<br>\n2.this指向构造函数;<br>\n3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象<br>\n4.手动封装一个new运算符</p>\n<pre><code class=\"copyable\">var new2 = function (func) {\n    var o = Object.create(func.prototype);//创建对象\n    var k = func.call(o);//改变this指向，把结果付给k\n    if (typeof k === 'object') {//判断k的类型是不是对象\n        return k;&emsp;//是，返回k\n    } else {\n        return o;//不是返回返回构造函数的执行结果\n    }\n}  \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-27\">1.6.5 对象的原型链</h3>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df35e34dc568b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"570\" data-height=\"709\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"570\" height=\"709\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-28\">1.7 继承的方式</h2>\n<p>JS是一门弱类型动态语言,封装和继承是他的两大特性</p>\n<h3 class=\"heading\" data-id=\"heading-29\">1.7.1 原型链继承</h3>\n<p>将父类的实例作为子类的原型\n1.代码实现\n定义父类:</p>\n<pre><code class=\"copyable\">// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>子类:</p>\n<pre><code class=\"copyable\">function Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//&emsp;Test Code\nvar cat = new Cat();\nconsole.log(cat.name);//cat\nconsole.log(cat.eat('fish'));//cat正在吃：fish  undefined\nconsole.log(cat.sleep());//cat正在睡觉！ undefined\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.优缺点\n简单易于实现,但是要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行,无法实现多继承</p>\n<h3 class=\"heading\" data-id=\"heading-30\">1.7.2 构造继承</h3>\n<p>实质是利用call来改变Cat中的this指向\n1.代码实现\n子类:</p>\n<pre><code class=\"copyable\">function Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.优缺点\n可以实现多继承,不能继承原型属性/方法</p>\n<h3 class=\"heading\" data-id=\"heading-31\">1.7.3 实例继承</h3>\n<p>为父类实例添加新特性，作为子类实例返回\n1.代码实现\n子类</p>\n<pre><code class=\"copyable\">function Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.优缺点\n不限制调用方式,但不能实现多继承</p>\n<h3 class=\"heading\" data-id=\"heading-32\">1.7.4 拷贝继承</h3>\n<p>将父类的属性和方法拷贝一份到子类中\n1.子类:</p>\n<pre><code class=\"copyable\">function Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.优缺点\n支持多继承,但是效率低占用内存</p>\n<h3 class=\"heading\" data-id=\"heading-33\">1.7.5 组合继承</h3>\n<p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n1.子类:</p>\n<pre><code class=\"copyable\">function Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-34\">1.7.6 寄生组合继承</h3>\n<pre><code class=\"copyable\">function Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-35\">1.7.7 ES6的extends继承</h3>\n<p>ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this</p>\n<pre><code class=\"copyable\">//父类\nclass Person {\n    //constructor是构造方法\n    constructor(skin, language) {\n        this.skin = skin;\n        this.language = language;\n    }\n    say() {\n        console.log('我是父类')\n    }\n}\n\n//子类\nclass Chinese extends Person {\n    constructor(skin, language, positon) {\n        //console.log(this);//报错\n        super(skin, language);\n        //super();相当于父类的构造函数\n        //console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this)\n        this.positon = positon;\n    }\n    aboutMe() {\n        console.log(`${this.skin} ${this.language}  ${this.positon}`);\n    }\n}\n\n\n//调用只能通过new的方法得到实例,再调用里面的方法\nlet obj = new Chinese('红色', '中文', '香港');\nobj.aboutMe();\nobj.say();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-36\">1.8.高阶函数</h2>\n<h3 class=\"heading\" data-id=\"heading-37\">1.8.1定义</h3>\n<p>函数的参数是函数或返回函数</p>\n<h3 class=\"heading\" data-id=\"heading-38\">1.8.2 常见的高阶函数</h3>\n<p>map,reduce,filter,sort</p>\n<h3 class=\"heading\" data-id=\"heading-39\">1.8.3 柯里化</h3>\n<p>1.定义:只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>\n<pre><code class=\"copyable\">fn(a,b,c,d)=>fn(a)(b)(c)(d)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.代码实现:</p>\n<pre><code class=\"copyable\">const currying = fn => {\nconst len = fn.length\nreturn function curr (...args1) {\n    if (args1.length >= len) {\n         return fn(...args1)\n    }\n    return (...args2) => curr(...args1, ...args2)\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-40\">1.8.4 反柯里化</h3>\n<p>1.定义:</p>\n<pre><code class=\"copyable\">obj.func(arg1, arg2)=>func(obj, arg1, arg2)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.代码实现:</p>\n<pre><code class=\"copyable\">Function.prototype.uncurrying = function() {\n  var that = this;\n  return function() {\n    return Function.prototype.call.apply(that, arguments);\n  }\n};\n \nfunction sayHi () {\n  return \"Hello \" + this.value +\" \"+[].slice.call(arguments);\n}\nlet sayHiuncurrying=sayHi.uncurrying();\nconsole.log(sayHiuncurrying({value:'world'},\"hahaha\"));\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-41\">1.8.5偏函数</h3>\n<p>1.定义:指定部分参数来返回一个新的定制函数的形式\n2.例子:</p>\n<pre><code class=\"copyable\">function foo(a, b, c) {\n  return a + b + c;\n}\nfunction func(a, b) {\n  return foo(a,b,8);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-42\">2.对象</h1>\n<h2 class=\"heading\" data-id=\"heading-43\">2.1.对象的声明方法</h2>\n<h3 class=\"heading\" data-id=\"heading-44\">2.1.1 字面量</h3>\n<pre><code class=\"copyable\">var test2 = {x:123,y:345};\nconsole.log(test2);//{x:123,y:345};\nconsole.log(test2.x);//123\nconsole.log(test2.__proto__.x);//undefined\nconsole.log(test2.__proto__.x === test2.x);//false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-45\">2.1.2 构造函数</h3>\n<pre><code class=\"copyable\">var test1 = new Object({x:123,y:345});\nconsole.log(test1);//{x:123,y:345}\nconsole.log(test1.x);//123\nconsole.log(test1.__proto__.x);//undefined\nconsole.log(test1.__proto__.x === test1.x);//false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>new的作用:\n1.创了一个新对象;\n2.this指向构造函数;\n3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象</p>\n<h3 class=\"heading\" data-id=\"heading-46\">2.1.3 内置方法</h3>\n<p>Obejct.create(obj,descriptor),obj是对象,describe描述符属性(可选)</p>\n<pre><code class=\"copyable\">let test = Object.create({x:123,y:345});\nconsole.log(test);//{}\nconsole.log(test.x);//123\nconsole.log(test.__proto__.x);//3\nconsole.log(test.__proto__.x === test.x);//true\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-47\">2.1.4 三种方法的优缺点</h3>\n<p>1.功能:都能实现对象的声明,并能够赋值和取值<br>\n2.继承性:内置方法创建的对象继承到__proto__属性上<br>\n3.隐藏属性:三种声明方法会默认为内部的每个成员（属性或方法）生成一些隐藏属性，这些隐藏属性是可以读取和可配置的,属性分类见下面<br>\n4.属性读取:Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptor()<br>\n5.属性设置:Object.definePropertype或Object.defineProperties</p>\n<h2 class=\"heading\" data-id=\"heading-48\">2.2.对象的属性</h2>\n<h3 class=\"heading\" data-id=\"heading-49\">2.2.1 属性分类</h3>\n<p>1.数据属性4个特性:\nconfigurable(可配置),enumerable(可枚举),writable(可修改),value(属性值)</p>\n<p>2.访问器属性2个特性:\nget(获取),set(设置)</p>\n<p>3.内部属性\n由JavaScript引擎内部使用的属性;\n不能直接访问,但是可以通过对象内置方法间接访问,如:[[Prototype]]可以通过                Object.getPrototypeOf()访问;\n内部属性用[[]]包围表示,是一个抽象操作,没有对应字符串类型的属性名,如[[Prototype]].</p>\n<h3 class=\"heading\" data-id=\"heading-50\">2.2.2 属性描述符</h3>\n<p>1.定义:将一个属性的所有特性编码成一个对象返回\n2.描述符的属性有:数据属性和访问器属性\n3.使用范围:\n作为方法Object.defineProperty, Object.getOwnPropertyDescriptor, Object.create的第二个参数,</p>\n<h3 class=\"heading\" data-id=\"heading-51\">2.2.3 属性描述符的默认值</h3>\n<p>1.访问对象存在的属性</p>\n<table>\n<thead>\n<tr>\n<th>特性名</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>对应属性值</td>\n</tr>\n<tr>\n<td>get</td>\n<td>对应属性值</td>\n</tr>\n<tr>\n<td>set</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>true</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>true</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>所以通过上面三种声明方法已存在的属性都是有这些默认描述符\n2.访问对象不存在的属性</p>\n<table>\n<thead>\n<tr>\n<th>特性名</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>set</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-52\">2.2.3 描述符属性的使用规则</h3>\n<p>get,set与wriable,value是互斥的,如果有交集设置会报错</p>\n<h3 class=\"heading\" data-id=\"heading-53\">2.2.4 属性定义</h3>\n<p>1.定义属性的函数有两个:Object.defineProperty和Object.defineProperties.例如:\nObject.defineProperty(obj, propName, desc)</p>\n<p>2.在引擎内部,会转换成这样的方法调用:\nobj.[[DefineOwnProperty]](propName, desc, true)</p>\n<h3 class=\"heading\" data-id=\"heading-54\">2.2.5 属性赋值</h3>\n<p>1.赋值运算符(=)就是在调用[[Put]].比如:\nobj.prop = v;</p>\n<p>2.在引擎内部,会转换成这样的方法调用:\nobj.[[Put]](\"prop\", v, isStrictModeOn)</p>\n<h3 class=\"heading\" data-id=\"heading-55\">2.2.6 判断对象的属性</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>如果指定的属性在指定的对象或其原型链中，则in 运算符返回true</td>\n<td>'name' in test        //true</td>\n</tr>\n<tr>\n<td>hasOwnProperty()</td>\n<td>只判断自身属性</td>\n<td>test.hasOwnProperty('name')        //true</td>\n</tr>\n<tr>\n<td>.或[]</td>\n<td>对象或原型链上不存在该属性，则会返回undefined</td>\n<td>test.name            //\"lei\"   test[\"name\"]  //\"lei\"</td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-56\">2.3.Symbol</h2>\n<h3 class=\"heading\" data-id=\"heading-57\">2.3.1概念</h3>\n<p>是一种数据类型;\n不能new,因为Symbol是一个原始类型的值，不是对象。</p>\n<h3 class=\"heading\" data-id=\"heading-58\">2.3.2 定义方法</h3>\n<p>Symbol(),可以传参\nvar s1 = Symbol();\nvar s2 = Symbol();\ns1 === s2 // false</p>\n<pre><code class=\"copyable\">// 有参数的情况\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\ns1 === s2 // false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-59\">2.3.3 用法</h3>\n<p>1.不能与其他类型的值进行运算;\n2.作为属性名</p>\n<pre><code class=\"copyable\">let mySymbol = Symbol();\n\n// 第一种写法\nvar a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nvar a = {\n  [mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>3.作为对象属性名时，不能用点运算符,可以用[]</p>\n<pre><code class=\"copyable\">let a = {};\nlet name = Symbol();\na.name = 'lili';\na[name] = 'lucy';\nconsole.log(a.name,a[name]); \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>4.遍历不会被for...in、for...of和Object.keys()、Object.getOwnPropertyNames()取到该属性</p>\n<h3 class=\"heading\" data-id=\"heading-60\">2.3.4 Symbol.for</h3>\n<p>1.定义:在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值\n2.举例:</p>\n<pre><code class=\"copyable\">var s1 = Symbol.for('foo');\nvar s2 = Symbol.for('foo');\ns1 === s2 // true\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-61\">2.3.5 Symbol.keyFor</h3>\n<p>1.定义:返回一个已登记的Symbol类型值的key\n2.举例:</p>\n<pre><code class=\"copyable\">var s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n\nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-62\">2.4.遍历</h2>\n<h3 class=\"heading\" data-id=\"heading-63\">2.4.1 一级对象遍历方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>for ... in</td>\n<td>遍历对象自身的和继承的可枚举属性(不含Symbol属性)</td>\n</tr>\n<tr>\n<td>Object.keys(obj)</td>\n<td>返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertyNames(obj)</td>\n<td>返回一个数组,包括对象自身的所有可枚举属性(不含Symbol属性)</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertySymbols(obj)</td>\n<td>返回一个数组,包含对象自身的所有Symbol属性</td>\n</tr>\n<tr>\n<td>Reflect.ownKeys(obj)</td>\n<td>返回一个数组,包含对象自身的所有(不枚举、可枚举和Symbol)属性</td>\n</tr>\n<tr>\n<td>Reflect.enumerate(obj)</td>\n<td>返回一个Iterator对象,遍历对象自身的和继承的所有可枚举属性(不含Symbol属性)</td>\n</tr>\n</tbody>\n</table>\n<p>总结:1.只有Object.getOwnPropertySymbols(obj)和Reflect.ownKeys(obj)可以拿到Symbol属性\n2.只有Reflect.ownKeys(obj)可以拿到不可枚举属性</p>\n<h3 class=\"heading\" data-id=\"heading-64\">2.4.2 多级对象遍历</h3>\n<p>数据模型:</p>\n<pre><code class=\"copyable\">var treeNodes = [\n    {\n     id: 1,\n     name: '1',\n     children: [\n       {\n        id: 11,\n        name: '11',\n        children: [\n         {\n          id: 111,\n          name: '111',\n          children:[]\n          },\n          {\n            id: 112,\n            name: '112'\n           }\n          ]\n         },\n         {\n          id: 12,\n          name: '12',\n          children: []\n         }\n         ],\n         users: []\n        },\n      ];\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>递归:</p>\n<pre><code class=\"copyable\">var parseTreeJson = function(treeNodes){\n      if (!treeNodes || !treeNodes.length) return;\n\n       for (var i = 0, len = treeNodes.length; i < len; i++) {\n\n            var childs = treeNodes[i].children;\n\n            console.log(treeNodes[i].id);\n\n            if(childs && childs.length > 0){\n                 parseTreeJson(childs);\n            }\n       }\n    };\n\n    console.log('------------- 递归实现 ------------------');\n    parseTreeJson(treeNodes);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-65\">2.5.深度拷贝</h2>\n<h3 class=\"heading\" data-id=\"heading-66\">2.5.1 Object.assign</h3>\n<p>1.定义:将源对象（source）的所有可枚举属性，复制到目标对象（target）\n2.用法:</p>\n<pre><code class=\"copyable\">合并多个对象\nvar target = { a: 1, b: 1 };\nvar source1 = { b: 2, c: 2 };\nvar source2 = { c: 3 };\nObject.assign(target, source1, source2);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>3.注意:\n这个是伪深度拷贝,只能拷贝第一层</p>\n<h3 class=\"heading\" data-id=\"heading-67\">2.5.2 JSON.stringify</h3>\n<p>1.原理:是将对象转化为字符串,而字符串是简单数据类型</p>\n<h3 class=\"heading\" data-id=\"heading-68\">2.5.3 递归拷贝</h3>\n<pre><code class=\"copyable\">function deepClone(source){\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\n  for(let keys in source){ // 遍历目标\n    if(source.hasOwnProperty(keys)){\n      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下\n        targetObj[keys] = source[keys].constructor === Array ? [] : {};\n        targetObj[keys] = deepClone(source[keys]);\n      }else{ // 如果不是，就直接赋值\n        targetObj[keys] = source[keys];\n      }\n    }\n  }\n  return targetObj;\n}  \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-69\">2.6.数据拦截</h2>\n<p>定义:利用对象内置方法,设置属性,进而改变对象的属性值</p>\n<h3 class=\"heading\" data-id=\"heading-70\">2.6.1 Object.defineProterty</h3>\n<p>1.ES5出来的方法;\n2.三个参数:对象(必填),属性值(必填),描述符(可选);\n3.defineProterty的描述符属性</p>\n<pre><code class=\"copyable\">数据属性:value,writable,configurable,enumerable\n访问器属性:get,set\n注:不能同时设置value和writable,这两对属性是互斥的\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>4.拦截对象的两种情况:</p>\n<pre><code class=\"copyable\">let obj = {name:'',age:'',sex:''  },\n    defaultName = [\"这是姓名默认值1\",\"这是年龄默认值1\",\"这是性别默认值1\"];\n  Object.keys(obj).forEach(key => {\n    Object.defineProperty(obj, key, {\n      get() {\n        return defaultName;\n      },\n      set(value) {\n        defaultName = value;\n      }\n    });\n  });\n\n  console.log(obj.name);\n  console.log(obj.age);\n  console.log(obj.sex);\n  obj.name = \"这是改变值1\";\n  console.log(obj.name);\n  console.log(obj.age);\n  console.log(obj.sex);\n\n  let objOne={},defaultNameOne=\"这是默认值2\";\n  Object.defineProperty(obj, 'name', {\n      get() {\n        return defaultNameOne;\n      },\n      set(value) {\n        defaultNameOne = value;\n      }\n  });\n  console.log(objOne.name);\n  objOne.name = \"这是改变值2\";\n  console.log(objOne.name);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>5.拦截数组变化的情况</p>\n<pre><code class=\"copyable\">let a={};\nbValue=1;\nObject.defineProperty(a,\"b\",{\n    set:function(value){\n        bValue=value;\n        console.log(\"setted\");\n    },\n    get:function(){\n        return bValue;\n    }\n});\na.b;//1\na.b=[];//setted\na.b=[1,2,3];//setted\na.b[1]=10;//无输出\na.b.push(4);//无输出\na.b.length=5;//无输出\na.b;//[1,10,3,4,undefined];\n\n结论:defineProperty无法检测数组索引赋值,改变数组长度的变化;\n    但是通过数组方法来操作可以检测到\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>6.存在的问题</p>\n<pre><code class=\"copyable\">不能监听数组索引赋值和改变长度的变化\n必须深层遍历嵌套的对象,因为defineProterty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 class=\"heading\" data-id=\"heading-71\">2.6.2 proxy</h3>\n<p>1.ES6出来的方法,实质是对对象做了一个拦截,并提供了13个处理方法</p>\n<p>2.两个参数:对象和行为函数</p>\n<pre><code class=\"copyable\">let handler = {\n    get(target, key, receiver) {\n      console.log(\"get\", key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      console.log(\"set\", key, value);\n      return Reflect.set(target, key, value, receiver);\n    }\n  };\n  let proxy = new Proxy(obj, handler);\n  proxy.name = \"李四\";\n  proxy.age = 24;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>3.问题和优点\nreflect对象没有构造函数\n可以监听数组索引赋值,改变数组长度的变化,\n是直接监听对象的变化,不用深层遍历</p>\n<h3 class=\"heading\" data-id=\"heading-72\">2.6.3 defineProterty和proxy的对比</h3>\n<p>1.defineProterty是es5的标准,proxy是es6的标准;</p>\n<p>2.proxy可以监听到数组索引赋值,改变数组长度的变化;</p>\n<p>3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;</p>\n<p>3.利用defineProterty实现双向数据绑定(vue2.x采用的核心)\n4.利用proxy实现双向数据绑定(vue3.x会采用)</p>\n<h1 class=\"heading\" data-id=\"heading-73\">3.数组</h1>\n<p>数组基本上考察数组方法多一点,所以这里就单纯介绍常见的场景数组的方法,还有很多场景后续补充;<br>\n本文主要从应用来讲数组api的一些骚操作;<br>\n如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等；<br>\n上面这些应用场景你可以用一行代码实现？</p>\n<h2 class=\"heading\" data-id=\"heading-74\">3.1 扁平化n维数组</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,[2,3]].flat(2) //[1,2,3]\n[1,[2,3,[4,5]].flat(3) //[1,2,3,4,5]\n[1,[2,3,[4,5]]].toString()  //'1,2,3,4,5'\n[1[2,3,[4,5[...]].flat(Infinity) //[1,2,3,4...n]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大</p>\n<p>2.开始篇</p>\n<pre><code class=\"copyable\">function flatten(arr) {\n    while(arr.some(item=>Array.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n    return arr;\n}\nflatten([1,[2,3]]) //[1,2,3]\nflatten([1,[2,3,[4,5]]) //[1,2,3,4,5]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>实质是利用递归和数组合并方法concat实现扁平</p>\n<h2 class=\"heading\" data-id=\"heading-75\">3.2 去重</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]\n[...new Set([1,2,3,3,4,4])] //[1,2,3,4]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>set是ES6新出来的一种一种定义不重复数组的数据类型\nArray.from是将类数组转化为数组\n...是扩展运算符,将set里面的值转化为字符串\n2.开始篇</p>\n<pre><code class=\"copyable\">Array.prototype.distinct = nums => {\nconst map = {}\nconst result = []\nfor (const n of nums) {\n    if (!(n in map)) {\n        map[n] = 1\n        result.push(n)\n    }\n}\nreturn result\n}\n[1,2,3,3,4,4].distinct(); //[1,2,3,4]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>取新数组存值,循环两个数组值相比较</p>\n<h2 class=\"heading\" data-id=\"heading-76\">3.3排序</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,2,3,4].sort((a, b) => a - b); // [1, 2,3,4],默认是升序\n[1,2,3,4].sort((a, b) => b - a); // [4,3,2,1] 降序\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>sort是js内置的排序方法,参数为一个函数\n2.开始篇\n冒泡排序:</p>\n<pre><code class=\"copyable\">Array.prototype.bubleSort=function () {\n    let arr=this,\n        len = arr.length;\n    for (let outer = len; outer >= 2; outer--) {\n      for (let inner = 0; inner <= outer - 1; inner++) {\n        if (arr[inner] > arr[inner + 1]) {\n          //升序\n          [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]];\n          console.log([arr[inner], arr[inner + 1]]);\n        }\n      }\n    }\n    return arr;\n  }\n[1,2,3,4].bubleSort() //[1,2,3,4]    \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>选择排序</p>\n<pre><code class=\"copyable\">    Array.prototype.selectSort=function () {\n        let arr=this,\n            len = arr.length;\n        for (let i = 0, len = arr.length; i < len; i++) {\n    for (let j = i, len = arr.length; j < len; j++) {\n      if (arr[i] > arr[j]) {\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n      }\n    }\n  }\n    return arr;\n  }\n  [1,2,3,4].selectSort() //[1,2,3,4] \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-77\">3.4最大值</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">Math.max(...[1,2,3,4]) //4\nMath.max.apply(this,[1,2,3,4]) //4\n[1,2,3,4].reduce( (prev, cur,curIndex,arr)=> {\n return Math.max(prev,cur);\n},0) //4\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>Math.max()是Math对象内置的方法,参数是字符串;\nreduce是ES5的数组api,参数有函数和默认初始值;\n函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)</p>\n<p>2.开始篇\n先排序再取值</p>\n<h2 class=\"heading\" data-id=\"heading-78\">3.5求和</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,2,3,4].arr.reduce(function (prev, cur) {\n   return prev + cur;\n },0) //10 \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.开始篇</p>\n<pre><code class=\"copyable\">function sum(arr) {\n  var len = arr.length;\n  if(len == 0){\n    return 0;\n  } else if (len == 1){\n    return arr[0];\n  } else {\n    return arr[0] + sum(arr.slice(1));\n  }\n}\nsum([1,2,3,4]) //10\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>利用slice截取改变数组,再利用递归求和</p>\n<h2 class=\"heading\" data-id=\"heading-79\">3.6合并</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6]\n[...[1,2,3,4],...[4,5]] //[1,2,3,4,5,6]\nlet arrA = [1, 2], arrB = [3, 4]\nArray.prototype.push.apply(arrA, arrB))//arrA值为[1,2,3,4]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>2.开始篇</p>\n<pre><code class=\"copyable\">let arr=[1,2,3,4];\n  [5,6].map(item=>{\n   arr.push(item)\n })\n //arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-80\">3.7判断是否包含值</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,2,3].includes(4) //false\n[1,2,3].indexOf(4) //-1 如果存在换回索引\n[1, 2, 3].find((item)=>item===3)) //3 如果数组中无值返回undefined\n[1, 2, 3].findIndex((item)=>item===3)) //2 如果数组中无值返回-1\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>includes(),find(),findIndex()是ES6的api</p>\n<p>2.开始篇</p>\n<pre><code class=\"copyable\">[1,2,3].some(item=>{\n  return item===3\n}) //true 如果不包含返回false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-81\">3.8类数组转化</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)\nArray.prototype.slice.apply(arguments)\nArray.from(arguments)\n[...arguments]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>类数组:表示有length属性,但是不具备数组的方法<br>\ncall,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法<br>\nArray.from是将类似数组或可迭代对象创建为数组<br>\n...是将类数组扩展为字符串,再定义为数组</p>\n<p>2.开始篇</p>\n<pre><code class=\"copyable\">Array.prototype.slice = function(start,end){  \n      var result = new Array();  \n      start = start || 0;  \n      end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  \n      for(var i = start; i < end; i++){  \n           result.push(this[i]);  \n      }  \n      return result;  \n } \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-82\">3.9每一项设置值</h2>\n<p>1.终极篇</p>\n<pre><code class=\"copyable\">[1,2,3].fill(false) //[false,false,false] \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>fill是ES6的方法\n2.开始篇</p>\n<pre><code class=\"copyable\">[1,2,3].map(() => 0)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-83\">3.10每一项是否满足</h2>\n<pre><code class=\"copyable\">[1,2,3].every(item=>{return item>2}) //false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>every是ES5的api,每一项满足返回 true</p>\n<h2 class=\"heading\" data-id=\"heading-84\">3.11有一项满足</h2>\n<pre><code class=\"copyable\">[1,2,3].some(item=>{return item>2}) //true\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>some是ES5的api,有一项满足返回 true</p>\n<h2 class=\"heading\" data-id=\"heading-85\">3.12.过滤数组</h2>\n<pre><code class=\"copyable\">[1,2,3].filter(item=>{return item>2}) //[3]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>filter是ES5的api,返回满足添加的项的数组</p>\n<h2 class=\"heading\" data-id=\"heading-86\">3.13对象和数组转化</h2>\n<pre><code class=\"copyable\">Object.keys({name:'张三',age:14}) //['name','age']\nObject.values({name:'张三',age:14}) //['张三',14]\nObject.entries({name:'张三',age:14}) //[[name,'张三'],[age,14]]\nObject.fromEntries([name,'张三'],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:'张三',age:14}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-87\">3.14 对象数组</h2>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[{count:1},{count:2},{count:3}].reduce((p, e)=>p+(e.count), 0)\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-88\">4.数据结构篇</h1>\n<blockquote>\n<p>数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。<br>\n也是程序猿进阶的一个重要技能。<br>\n手撸代码实现栈,队列,链表,字典,二叉树,动态规划和贪心算法</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-89\">4.1 栈</h2>\n<p>栈的特点：先进后出</p>\n<pre><code class=\"copyable\">class Stack {\n    constructor() {\n      this.items = [];\n    }\n\n    // 入栈\n    push(element) {\n      this.items.push(element);\n    }\n\n    // 出栈\n    pop() {\n      return this.items.pop();\n    }\n\n    // 末位\n    get peek() {\n      return this.items[this.items.length - 1];\n    }\n\n    // 是否为空栈\n    get isEmpty() {\n      return !this.items.length;\n    }\n\n    // 长度\n    get size() {\n      return this.items.length;\n    }\n\n    // 清空栈\n    clear() {\n      this.items = [];\n    }\n  }\n\n  // 实例化一个栈\n  const stack = new Stack();\n  console.log(stack.isEmpty); // true\n\n  // 添加元素\n  stack.push(5);\n  stack.push(8);\n\n  // 读取属性再添加\n  console.log(stack.peek); // 8\n  stack.push(11);\n  console.log(stack.size); // 3\n  console.log(stack.isEmpty); // false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-90\">4.2 队列</h2>\n<p>队列：先进先出\nclass Queue {\nconstructor(items) {\nthis.items = items || [];\n}</p>\n<pre><code class=\"copyable\">    enqueue(element) {\n      this.items.push(element);\n    }\n\n    dequeue() {\n      return this.items.shift();\n    }\n\n    front() {\n      return this.items[0];\n    }\n\n    clear() {\n      this.items = [];\n    }\n\n    get size() {\n      return this.items.length;\n    }\n\n    get isEmpty() {\n      return !this.items.length;\n    }\n\n    print() {\n      console.log(this.items.toString());\n    }\n  }\n\n  const queue = new Queue();\n  console.log(queue.isEmpty); // true\n\n  queue.enqueue(\"John\");\n  queue.enqueue(\"Jack\");\n  queue.enqueue(\"Camila\");\n  console.log(queue.size); // 3\n  console.log(queue.isEmpty); // false\n  queue.dequeue();\n  queue.dequeue();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-91\">4.3 链表</h2>\n<p>链表:<br>\n存贮有序元素的集合;<br>\n但是不同于数组,每个元素是一个存贮元素本身的节点和指向下一个元素引用组成<br>\n要想访问链表中间的元素,需要从起点开始遍历找到所需元素</p>\n<pre><code class=\"copyable\">class Node {\n    constructor(element) {\n      this.element = element;\n      this.next = null;\n    }\n  }\n\n  // 链表\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.length = 0;\n    }\n\n    // 追加元素\n    append(element) {\n      const node = new Node(element);\n      let current = null;\n      if (this.head === null) {\n        this.head = node;\n      } else {\n        current = this.head;\n        while (current.next) {\n          current = current.next;\n        }\n        current.next = node;\n      }\n      this.length++;\n    }\n\n    // 任意位置插入元素\n    insert(position, element) {\n      if (position >= 0 && position <= this.length) {\n        const node = new Node(element);\n        let current = this.head;\n        let previous = null;\n        let index = 0;\n        if (position === 0) {\n          this.head = node;\n        } else {\n          while (index++ < position) {\n            previous = current;\n            current = current.next;\n          }\n          node.next = current;\n          previous.next = node;\n        }\n        this.length++;\n        return true;\n      }\n      return false;\n    }\n\n    // 移除指定位置元素\n    removeAt(position) {\n      // 检查越界值\n      if (position > -1 && position < length) {\n        let current = this.head;\n        let previous = null;\n        let index = 0;\n        if (position === 0) {\n          this.head = current.next;\n        } else {\n          while (index++ < position) {\n            previous = current;\n            current = current.next;\n          }\n          previous.next = current.next;\n        }\n        this.length--;\n        return current.element;\n      }\n      return null;\n    }\n\n    // 寻找元素下标\n    findIndex(element) {\n      let current = this.head;\n      let index = -1;\n      while (current) {\n        if (element === current.element) {\n          return index + 1;\n        }\n        index++;\n        current = current.next;\n      }\n      return -1;\n    }\n\n    // 删除指定文档\n    remove(element) {\n      const index = this.findIndex(element);\n      return this.removeAt(index);\n    }\n\n    isEmpty() {\n      return !this.length;\n    }\n\n    size() {\n      return this.length;\n    }\n\n    // 转为字符串\n    toString() {\n      let current = this.head;\n      let string = \"\";\n      while (current) {\n        string += ` ${current.element}`;\n        current = current.next;\n      }\n      return string;\n    }\n  }\n  const linkedList = new LinkedList();\n\n  console.log(linkedList);\n  linkedList.append(2);\n  linkedList.append(6);\n  linkedList.append(24);\n  linkedList.append(152);\n\n  linkedList.insert(3, 18);\n  console.log(linkedList);\n  console.log(linkedList.findIndex(24));  \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-92\">4.4 字典</h2>\n<p>字典：类似对象，以key，value存贮值\nclass Dictionary {\nconstructor() {\nthis.items = {};\n}</p>\n<pre><code class=\"copyable\">    set(key, value) {\n      this.items[key] = value;\n    }\n\n    get(key) {\n      return this.items[key];\n    }\n\n    remove(key) {\n      delete this.items[key];\n    }\n\n    get keys() {\n      return Object.keys(this.items);\n    }\n\n    get values() {\n      /*\n    也可以使用ES7中的values方法\n    return Object.values(this.items)\n    */\n\n      // 在这里我们通过循环生成一个数组并输出\n      return Object.keys(this.items).reduce((r, c, i) => {\n        r.push(this.items[c]);\n        return r;\n      }, []);\n    }\n  }\n  const dictionary = new Dictionary();\n  dictionary.set(\"Gandalf\", \"gandalf@email.com\");\n  dictionary.set(\"John\", \"johnsnow@email.com\");\n  dictionary.set(\"Tyrion\", \"tyrion@email.com\");\n\n  console.log(dictionary);\n  console.log(dictionary.keys);\n  console.log(dictionary.values);\n  console.log(dictionary.items);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-93\">4.5 二叉树</h2>\n<p>特点：每个节点最多有两个子树的树结构\nclass NodeTree {\nconstructor(key) {\nthis.key = key;\nthis.left = null;\nthis.right = null;\n}\n}</p>\n<pre><code class=\"copyable\">  class BinarySearchTree {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(key) {\n      const newNode = new NodeTree(key);\n      const insertNode = (node, newNode) => {\n        if (newNode.key < node.key) {\n          if (node.left === null) {\n            node.left = newNode;\n          } else {\n            insertNode(node.left, newNode);\n          }\n        } else {\n          if (node.right === null) {\n            node.right = newNode;\n          } else {\n            insertNode(node.right, newNode);\n          }\n        }\n      };\n      if (!this.root) {\n        this.root = newNode;\n      } else {\n        insertNode(this.root, newNode);\n      }\n    }\n\n    //访问树节点的三种方式:中序,先序,后序\n    inOrderTraverse(callback) {\n      const inOrderTraverseNode = (node, callback) => {\n        if (node !== null) {\n          inOrderTraverseNode(node.left, callback);\n          callback(node.key);\n          inOrderTraverseNode(node.right, callback);\n        }\n      };\n      inOrderTraverseNode(this.root, callback);\n    }\n\n    min(node) {\n      const minNode = node => {\n        return node ? (node.left ? minNode(node.left) : node) : null;\n      };\n      return minNode(node || this.root);\n    }\n\n    max(node) {\n      const maxNode = node => {\n        return node ? (node.right ? maxNode(node.right) : node) : null;\n      };\n      return maxNode(node || this.root);\n    }\n  }\n  const tree = new BinarySearchTree();\n  tree.insert(11);\n  tree.insert(7);\n  tree.insert(5);\n  tree.insert(3);\n  tree.insert(9);\n  tree.insert(8);\n  tree.insert(10);\n  tree.insert(13);\n  tree.insert(12);\n  tree.insert(14);\n  tree.inOrderTraverse(value => {\n    console.log(value);\n  });\n\n  console.log(tree.min());\n  console.log(tree.max());\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-94\">5.算法篇</h1>\n<h2 class=\"heading\" data-id=\"heading-95\">5.1 冒泡算法</h2>\n<p>冒泡排序，选择排序，插入排序，此处不做赘述.</p>\n<h2 class=\"heading\" data-id=\"heading-96\">5.2 斐波那契</h2>\n<p>特点：第三项等于前面两项之和</p>\n<pre><code class=\"copyable\">function fibonacci(num) { \n    if (num === 1 || num === 2) { \n        return 1\n    }\n    return fibonacci(num - 1) + fibonacci(num - 2)\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-97\">5.3 动态规划</h2>\n<p>特点：通过全局规划,将大问题分割成小问题来取最优解<br>\n案例：最少硬币找零<br>\n美国有以下面额(硬币）：d1=1, d2=5, d3=10, d4=25<br>\n如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（ 1美分)</p>\n<pre><code class=\"copyable\">class MinCoinChange {\n\nconstructor(coins) {\n    this.coins = coins\n    this.cache = {}\n}\n\nmakeChange(amount) {\n    if (!amount) return []\n    if (this.cache[amount]) return this.cache[amount]\n    let min = [], newMin, newAmount\n    this.coins.forEach(coin => {\n        newAmount = amount - coin\n        if (newAmount >= 0) {\n            newMin = this.makeChange(newAmount)\n        }\n        if (newAmount >= 0 && \n             (newMin.length < min.length - 1 || !min.length) && \n             (newMin.length || !newAmount)) {\n            min = [coin].concat(newMin)\n        }\n    })\n    return (this.cache[amount] = min)\n}\n}\n\nconst rninCoinChange = new MinCoinChange([1, 5, 10, 25])\nconsole.log(rninCoinChange.makeChange(36))\n// [1, 10, 25]\nconst minCoinChange2 = new MinCoinChange([1, 3, 4])\nconsole.log(minCoinChange2.makeChange(6))\n// [3, 3]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-98\">5.4 贪心算法</h2>\n<p>特点：通过最优解来解决问题\n用贪心算法来解决2.3中的案例</p>\n<pre><code class=\"copyable\">class MinCoinChange2 {\n\nconstructor(coins) {\n    this.coins = coins\n}\n\nmakeChange(amount) {\n    const change = []\n    let total = 0\n    this.coins.sort((a, b) => a < b).forEach(coin => {\n        if ((total + coin) <= amount) {\n            change.push(coin)\n            total += coin\n        }\n    })\n    return change\n}\n}\nconst rninCoinChange2 = new MinCoinChange2 ( [ 1, 5, 10, 25])\nconsole.log (rninCoinChange2. makeChange (36))\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-99\">6 设计模式</h1>\n<blockquote>\n<p>设计模式如果应用到项目中，可以实现代码的复用和解耦，提高代码质量。 本文主要介绍14种设计模式\n写UI组件,封装框架必备</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-100\">6.1 简单工厂模式</h2>\n<p>1.定义：又叫静态工厂方法，就是创建对象，并赋予属性和方法<br>\n2.应用：抽取类相同的属性和方法封装到对象上<br>\n3.代码：</p>\n<pre><code class=\"copyable\">    let UserFactory = function (role) {\n  function User(opt) {\n    this.name = opt.name;\n    this.viewPage = opt.viewPage;\n  }\n  switch (role) {\n    case 'superAdmin':\n      return new User(superAdmin);\n      break;\n    case 'admin':\n      return new User(admin);\n      break;\n    case 'user':\n      return new User(user);\n      break;\n    default:\n      throw new Error('参数错误, 可选参数:superAdmin、admin、user')\n  }\n}\n\n//调用\nlet superAdmin = UserFactory('superAdmin');\nlet admin = UserFactory('admin') \nlet normalUser = UserFactory('user')\n//最后得到角色,可以调用\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-101\">6.2工厂方法模式</h2>\n<p>1.定义：对产品类的抽象使其创建业务主要负责用于创建多类产品的实例<br>\n2.应用:创建实例<br>\n3.代码:</p>\n<pre><code class=\"copyable\">var Factory=function(type,content){\n  if(this instanceof Factory){\n    var s=new this[type](content);\n    return s;\n  }else{\n    return new Factory(type,content);\n  }\n}\n\n//工厂原型中设置创建类型数据对象的属性\nFactory.prototype={\n  Java:function(content){\n    console.log('Java值为',content);\n  },\n  PHP:function(content){\n    console.log('PHP值为',content);\n  },\n  Python:function(content){\n    console.log('Python值为',content);\n  },\n}\n\n//测试用例\nFactory('Python','我是Python');\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-102\">6.3原型模式</h2>\n<p>1.定义:设置函数的原型属性\n2.应用:实现继承\n3.代码:</p>\n<pre><code class=\"copyable\">function Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//&emsp;Test Code\nvar cat = new Cat();\nconsole.log(cat.name);//cat\nconsole.log(cat.eat('fish'));//cat正在吃：fish  undefined\nconsole.log(cat.sleep());//cat正在睡觉！ undefined\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true  \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-103\">6.4单例模式</h2>\n<p>1.定义:只允许被实例化依次的类\n2.应用:提供一个命名空间\n3.代码:</p>\n<pre><code class=\"copyable\">let singleCase = function(name){\n    this.name = name;\n};\nsingleCase.prototype.getName = function(){\n    return this.name;\n}\n// 获取实例对象\nlet getInstance = (function() {\n    var instance = null;\n    return function(name) {\n        if(!instance) {//相当于一个一次性阀门,只能实例化一次\n            instance = new singleCase(name);\n        }\n        return instance;\n    }\n})();\n// 测试单体模式的实例,所以one===two\nlet one = getInstance(\"one\");\nlet two = getInstance(\"two\");   \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-104\">6.5外观模式</h2>\n<p>1.定义:为子系统中的一组接口提供一个一致的界面\n2.应用:简化复杂接口\n3.代码:\n<a target=\"_blank\" href=\"https://www.cnblogs.com/linda586586/p/4237093.html\" rel=\"nofollow noopener noreferrer\">外观模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-105\">6.6适配器模式</h2>\n<p>1.定义:将一个接口转换成客户端需要的接口而不需要去修改客户端代码，使得不兼容的代码可以一起工作\n2.应用:适配函数参数\n3.代码:\n<a target=\"_blank\" href=\"https://www.cnblogs.com/TomXu/archive/2012/04/11/2435452.html\" rel=\"nofollow noopener noreferrer\">适配器模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-106\">6.7装饰者模式</h2>\n<p>1.定义:不改变原对象的基础上,给对象添加属性或方法\n2.代码</p>\n<pre><code class=\"copyable\">let decorator=function(input,fn){\n  //获取事件源\n  let input=document.getElementById(input);\n  //若事件源已经绑定事件\n  if(typeof input.onclick=='function'){\n    //缓存事件源原有的回调函数\n    let oldClickFn=input.onclick;\n    //为事件源定义新事件\n    input.onclick=function(){\n      //事件源原有回调函数\n      oldClickFn();\n      //执行事件源新增回调函数\n      fn();\n    }\n  }else{\n    //未绑定绑定\n    input.onclick=fn;\n  }\n}\n\n//测试用例\ndecorator('textInp',function(){\n  console.log('文本框执行啦');\n})\ndecorator('btn',function(){\n  console.log('按钮执行啦');\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-107\">6.8桥接模式</h2>\n<p>1.定义:将抽象部分与它的实现部分分离，使它们都可以独立地变化\n2.代码\n<a target=\"_blank\" href=\"https://www.cnblogs.com/TomXu/archive/2012/04/19/2437321.html\" rel=\"nofollow noopener noreferrer\">桥接模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-108\">6.9模块方法模式</h2>\n<p>1.定义:定义一个模板,供以后传不同参数调用\n2.代码:\n<a target=\"_blank\" href=\"https://blog.csdn.net/namechenfl/article/details/80685741\" rel=\"nofollow noopener noreferrer\">模块方法模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-109\">6.10.观察者模式</h2>\n<p>1.作用:解决类与对象,对象与对象之间的耦合\n2.代码:</p>\n<pre><code class=\"copyable\">let Observer=\n  (function(){\n    let _message={};\n    return {\n      //注册接口,\n        //1.作用:将订阅者注册的消息推入到消息队列\n        //2.参数:所以要传两个参数,消息类型和处理动作,\n        //3.消息不存在重新创建,存在将消息推入到执行方法\n        \n      regist:function(type,fn){\n        //如果消息不存在,创建\n        if(typeof _message[type]==='undefined'){\n          _message[type]=[fn];\n        }else{\n          //将消息推入到消息的执行动作\n          _message[type].push(fn);\n        }\n      },\n\n      //发布信息接口\n        //1.作用:观察这发布消息将所有订阅的消息一次执行\n        //2.参数:消息类型和动作执行传递参数\n        //3.消息类型参数必须校验\n      fire:function(type,args){\n        //如果消息没有注册,则返回\n        if(!_message[type]) return;\n          //定义消息信息\n          var events={\n            type:type, //消息类型\n            args:args||{} //消息携带数据\n          },\n          i=0,\n          len=_message[type].length;\n          //遍历消息\n          for(;i<len;i++){\n            //依次执行注册消息\n            _message[type][i].call(this,events);\n          }\n      },\n\n      //移除信息接口\n        //1.作用:将订阅者注销消息从消息队列清除\n        //2.参数:消息类型和执行的动作\n        //3.消息参数校验\n      remove:function(type,fn){\n        //如果消息动作队列存在\n        if(_message[type] instanceof Array){\n          //从最后一个消息动作序遍历\n          var i=_message[type].length-1;\n          for(;i>=0;i--){\n            //如果存在该动作在消息队列中移除\n            _message[type][i]===fn&&_message[type].splice(i,1);\n          }\n        }\n      }\n    }\n  })()\n\n//测试用例\n  //1.订阅消息\n  Observer.regist('test',function(e){\n    console.log(e.type,e.args.msg);\n  })\n\n  //2.发布消息\n  Observer.fire('test',{msg:'传递参数1'});\n  Observer.fire('test',{msg:'传递参数2'});\n  Observer.fire('test',{msg:'传递参数3'});\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 class=\"heading\" data-id=\"heading-110\">6.11状态模式</h2>\n<p>1.定义:一个对象状态改变会导致行为变化\n2.作用:解决复杂的if判断\n3.代码\n<a target=\"_blank\" href=\"https://www.jianshu.com/p/ec9b9a1cd148\" rel=\"nofollow noopener noreferrer\">状态模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-111\">6.12策略模式</h2>\n<p>1.定义:定义了一系列家族算法，并对每一种算法单独封装起来，让算法之间可以相互替换，独立于使用算法的客户\n2.代码\n<a target=\"_blank\" href=\"https://www.cnblogs.com/Medeor/p/5001841.html\" rel=\"nofollow noopener noreferrer\">策略模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-112\">6.13.访问模式</h2>\n<p>1.定义:通过继承封装一些该数据类型不具备的属性,\n2.作用:让对象具备数组的操作方法\n3.代码:\n<a target=\"_blank\" href=\"https://blog.csdn.net/itpinpai/article/details/51644922\" rel=\"nofollow noopener noreferrer\">访问者模式</a></p>\n<h2 class=\"heading\" data-id=\"heading-113\">6.14中介者模式</h2>\n<p>1.定义:设置一个中间层,处理对象之间的交互\n2.代码:\n<a target=\"_blank\" href=\"https://www.cnblogs.com/xiaohuochai/p/8042198.html\" rel=\"nofollow noopener noreferrer\">中介者模式</a></p>\n<h1 class=\"heading\" data-id=\"heading-114\">7. HTTP</h1>\n<h2 class=\"heading\" data-id=\"heading-115\">1.1 什么是 HTTP</h2>\n<p>HTTP 是一个连接客户端，网关和服务器的一个协议。</p>\n<h2 class=\"heading\" data-id=\"heading-116\">7.2 特点</h2>\n<p>支持客户/服务器模式：可以连接客户端和服务端；<br>\n简单快速：请求只需传送请求方法，路径和请求主体；<br>\n灵活：传输数据类型灵活；<br>\n无连接：请求结束立即断开；<br>\n无状态：无法记住上一次请求。</p>\n<h2 class=\"heading\" data-id=\"heading-117\">7.3 怎么解决无状态和无连接</h2>\n<p>无状态：HTTP 协议本身无法解决这个状态，只有通过 cookie 和 session 将状态做贮存，常见的场景是登录状态保持；</p>\n<p>无连接：可以通过自身属性 Keep-Alive。</p>\n<h2 class=\"heading\" data-id=\"heading-118\">7.4 请求过程</h2>\n<p>HTTP(S) 请求地址 → DNS 解析 → 三次握手 → 发送请求 → 四次挥手</p>\n<p>三次握手过程图片来源 CSDN）\n</p><figure><img alt=\"3 次握手.jpg\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df367f3bcb72d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"656\" data-height=\"450\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"656\" height=\"450\"></svg>\"><figcaption></figcaption></figure>\n在这里插入图片描述<p></p>\n<ol start=\"3\">\n<li>四次挥手过（图片来源 CSDN）\n<figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df358c44fb0adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"691\" data-height=\"467\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"691\" height=\"467\"></svg>\"><figcaption></figcaption></figure>\n在这里插入图片描述</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-119\">7.5 HTTP 0.9~3.0 对比</h2>\n<h3 class=\"heading\" data-id=\"heading-120\">7.5.1 HTTP 0.9</h3>\n<p>只允许客户端发送 GET 这一种请求；<br>\n且不支持请求头，协议只支持纯文本；<br>\n无状态性，每个访问独立处理，完成断开；<br>\n无状态码。</p>\n<h3 class=\"heading\" data-id=\"heading-121\">7.5.2 HTTP 1.0</h3>\n<p>有身份认证，三次握手；\n请求与响应支持头域；\n请求头内容；</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>可接受的 MIME 类型</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>数据可解码的格式</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>可接受语言</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>值 keep-alive 是长连接</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>主机和端口</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>是否缓存,指定 no-cache 返回刷新</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>页面路由</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>值为时间</td>\n</tr>\n</tbody>\n</table>\n<p>响应头内容；</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>值 keep-alive 是长连接</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>返回文档类型,常见的值有 text/plain,text/html,text/json</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>消息发送的时间</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>值为时间,s 返回的最后修改时间</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>缓存过期时间,b 和 s 时间做对比</td>\n</tr>\n</tbody>\n</table>\n<p>注意</p>\n<p>expires 是响应头内容，返回一个固定的时间,缺陷是时间到了服务器要重新设置;<br>\n请求头中如果有 If-Modified-Since，服务器会将时间与 last-modified 对比，相同返回 304;<br>\n响应对象以一个响应状态行开始;<br>\n响应对象不只限于超文本;<br>\n支持 GET、HEAD、POST 方法;<br>\n有状态码;<br>\n支持长连接（但默认还是使用短连接）、缓存机制以及身份认证。</p>\n<h3 class=\"heading\" data-id=\"heading-122\">7.5.3 HTTP 1.1</h3>\n<p>请求头增加 Cache-Control</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>在1.1 引入的方法,指定请求和响应遵循的缓存机制,值有:public(b 和 s 都缓存),private(b 缓存),no-cache(不缓存),no-store(不缓存),max-age(缓存时间,s 为单位),min-fresh(最小更新时间),max-age=3600</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>上次请求响应头返回的 etag 值响应头增加 Cache-Control，表示所有的缓存机制是否可以缓存及哪种类型 etag 返回的哈希值,第二次请求头携带去和服务器值对比</td>\n</tr>\n</tbody>\n</table>\n<p>注意</p>\n<p>Cache-Control 的 max-age 返回是缓存的相对时间\nCache-Control 优先级比 expires 高\n缺点：不能第一时间拿到最新修改文件</p>\n<h3 class=\"heading\" data-id=\"heading-123\">7.5.4 HTTP 2.0</h3>\n<p>采用二进制格式传输;<br>\n多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;<br>\n报头压缩;<br>\n服务器推送主动向 B 端发送静态资源，避免往返延迟。</p>\n<h3 class=\"heading\" data-id=\"heading-124\">7.5.5 HTTP 3.0</h3>\n<p>1.是基于 QUIC 协议，基于 UDP<br>\n2.特点:<br>\n自定义连接机制：TCP 以 IP/端口标识,变化重新连接握手，UDP 是一 64 位 ID 标识，是无连接；<br>\n自定义重传机制：TCP 使用序号和应答传输，QUIC 是使用递增序号传输； 无阻塞的多路复用：同一条 QUIC 可以创建多个 steam。</p>\n<h3 class=\"heading\" data-id=\"heading-125\">7.5.6 HTTPS</h3>\n<p>1.https 是在 http 协议的基础上加了个 SSL；<br>\n2.主要包括\u0010：握手(凭证交换和验证)和记录协议(数据进行加密)。</p>\n<h3 class=\"heading\" data-id=\"heading-126\">7.5.7 缓存</h3>\n<p>1.按协议分：协议层缓存和非 http 协议缓存：<br>\n1.1协议层缓存：利用 http 协议头属性值设置；<br>\n1.2非协议层缓存：利用 meta 标签的 http-equiv 属性值 Expires,set-cookie。</p>\n<p>2.按缓存分：强缓存和协商缓存：<br>\n2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；<br>\n2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</p>\n<p>3.协商缓存对比： etag 优先级高于 last-modified；<br>\n4.etag 精度高，last-modified 精度是 s，1s 内 etag 修改多少次都会被记录； last-modified 性能好，etag 要得到 hash 值。</p>\n<p>5.浏览器读取缓存流程：\n会先判断强缓存；再判断协商缓存 etag(last-modified)是否存在；<br>\n存在利用属性 If-None-match(If-Modified-since)携带值；<br>\n请求服务器,服务器对比 etag(last-modified)，生效返回 304。</p>\n<p>F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</p>\n<h3 class=\"heading\" data-id=\"heading-127\">7.5.8 状态码</h3>\n<table>\n<thead>\n<tr>\n<th>序列</th>\n<th>详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX(通知)</td>\n<td></td>\n</tr>\n<tr>\n<td>2XX(成功)</td>\n<td>200(成功)、201(服务器创建)、202(服务器接收未处理)、203(非授权信息)、204(未返回内容)、205(重置内容)、206(部分内容)</td>\n</tr>\n<tr>\n<td>3XX(重定向)</td>\n<td>301(永久移动)、302(临时移动)、303(查看其他位置)、304(未修改)、305(使用代理)、307(临时重定向)</td>\n</tr>\n<tr>\n<td>4XX(客户端错误)</td>\n<td>400(错误请求)、401(未授权)、403(禁止)、404(未找到)、405(方法禁用)、406(不接受)、407（需要代理授权）</td>\n</tr>\n<tr>\n<td>5XX(服务器错误)</td>\n<td>500(服务器异常)、501（尚未实施）、502（错误网关）、503（服务不可用）、504（网关超时）、505（HTTP 版本不受支持）</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-128\">7.5.9 浏览器请求分析</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df36b1b7da0876?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"514\" data-height=\"524\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"514\" height=\"524\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-129\">7.5.10 总结</h3>\n<p>协议</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>http0.9</td>\n<td>只允许客户端发送 GET 这一种请求;且不支持请求头,协议只支持纯文本;无状态性,每个访问独立处理,完成断开;无状态码</td>\n</tr>\n<tr>\n<td>http1.0\t解决 0.9 的缺点,增加 If-modify-since(last-modify)和 expires 缓存属性</td>\n<td></td>\n</tr>\n<tr>\n<td>http1.x</td>\n<td>增加 cache-control 和 If-none-match(etag)缓存属性</td>\n</tr>\n<tr>\n<td>http2.0</td>\n<td>采用二进制格式传输;多路复用;报头压缩;服务器推送</td>\n</tr>\n<tr>\n<td>http3.0</td>\n<td>采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用</td>\n</tr>\n</tbody>\n</table>\n<p>缓存</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强缓存</td>\n<td>通过 If-modify-since(last-modify)、expires 和 cache-control 设置，属性值是时间，所以在时间内不用请求</td>\n</tr>\n<tr>\n<td>协商缓存</td>\n<td>通过 If-none-match(etag)设置，etag 属性是哈希值，所以要请求和服务器值对比</td>\n</tr>\n</tbody>\n</table>\n<h1 class=\"heading\" data-id=\"heading-130\">8.总结</h1>\n<p>这只是 JS 原生从初级到高级的梳理;<br>\n原创码字不易,欢迎 star!</p>\n",
      "id": "hftl9wkfzsg",
      "author": "荒山",
      "title": "JS 原生面经从初级到高级【近1.5W字】"
    },
    {
      "content": "<p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc21324c38b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"592\" data-height=\"268\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"592\" height=\"268\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>一年一度的 React 春晚: <a target=\"_blank\" href=\"https://conf.reactjs.org/schedule.html\" rel=\"nofollow noopener noreferrer\">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber...\n我得赶在 React Conf 之前发布这篇文章:</p>\n<ul>\n<li>\n<p>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧...</em></p>\n</li>\n<li>\n<p>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。</p>\n</li>\n<li>\n<p>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em></p>\n</li>\n<li>\n<p>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? <em>真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗</em>？</p>\n</li>\n<li>\n<p>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong></p>\n</li>\n</ul>\n<br>\n<p><strong>以下文章大纲</strong></p>\n<ul>\n<li><a href=\"#%E5%8D%95%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-fiber-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF\">单处理进程调度: Fiber 不是一个新的东西</a></li>\n<li><a href=\"#%E7%B1%BB%E6%AF%94%E6%B5%8F%E8%A7%88%E5%99%A8javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\">类比浏览器JavaScript执行环境</a></li>\n<li><a href=\"#%E4%BD%95%E4%B8%BA-fiber\">何为 Fiber</a>\n<ul>\n<li><a href=\"#1-%E4%B8%80%E7%A7%8D%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD\">1. 一种流程控制原语</a></li>\n<li><a href=\"#2-%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83\">2. 一个执行单元</a></li>\n</ul>\n</li>\n<li><a href=\"#react-%E7%9A%84fiber%E6%94%B9%E9%80%A0\">React 的Fiber改造</a>\n<ul>\n<li><a href=\"#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4\">1. 数据结构的调整</a></li>\n<li><a href=\"#2-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8B%86%E5%88%86\">2. 两个阶段的拆分</a></li>\n<li><a href=\"#3-reconcilation\">3. Reconcilation</a></li>\n<li><a href=\"#4-%E5%8F%8C%E7%BC%93%E5%86%B2\">4. 双缓冲</a></li>\n<li><a href=\"#5-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E6%8F%90%E4%BA%A4\">5. 副作用的收集和提交</a></li>\n</ul>\n</li>\n<li><a href=\"#%E2%9A%A0%EF%B8%8F-%E6%9C%AA%E5%B1%95%E5%BC%80%E9%83%A8%E5%88%86-%F0%9F%9A%A7----%E4%B8%AD%E6%96%AD%E5%92%8C%E6%81%A2%E5%A4%8D\">⚠️ 未展开部分 🚧 -- 中断和恢复</a></li>\n<li><a href=\"#%E5%87%8C%E6%B3%A2%E5%BE%AE%E6%AD%A5\">凌波微步</a></li>\n<li><a href=\"#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A\">站在巨人的肩膀上</a></li>\n</ul>\n<br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-0\">单处理进程调度: Fiber 不是一个新的东西</h2>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc2160c5d19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"960\" data-height=\"772\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"960\" height=\"772\"></svg>\"><figcaption></figcaption></figure>\n<i>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</i><p></p>\n<br>\n<p>微软 <a target=\"_blank\" href=\"https://zh.wikipedia.org/zh-cn/DOS\" rel=\"nofollow noopener noreferrer\"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a target=\"_blank\" href=\"https://www.zhihu.com/people/s.invalid\" rel=\"nofollow noopener noreferrer\">invalid s</a>在<a target=\"_blank\" href=\"https://www.zhihu.com/question/319595914/answer/683541635\" rel=\"nofollow noopener noreferrer\">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: '<strong>一种压根没有任务调度的“残疾”操作系统</strong>'.</p>\n<p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p>\n<p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p>\n<blockquote>\n<p>注意并发和并行不是同一个概念。</p>\n</blockquote>\n<br>\n<p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p>\n<p><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p>\n\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc244cdd934?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"580\" data-height=\"794\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"580\" height=\"794\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc230c34e9b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"357\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"357\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p>\n<p>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a target=\"_blank\" href=\"https://blog.golang.org/concurrency-is-not-parallelism\" rel=\"nofollow noopener noreferrer\">Concurrency is not parallelism</a></p>\n<br>\n<p>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：</p>\n<br>\n<p><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong></p>\n<p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).</p>\n<p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p>\n<ul>\n<li>\n<p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久...</em></p>\n</li>\n<li>\n<p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平...</em></p>\n</li>\n</ul>\n<p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p>\n<br>\n<p><strong>1️⃣ 轮转</strong></p>\n<p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p>\n<blockquote>\n<p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p>\n</blockquote>\n<p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p>\n<p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.</p>\n<p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p>\n<br>\n<p><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong></p>\n<p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让'最短'的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p>\n<p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p>\n<p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p>\n<p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p>\n<br>\n<p><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong></p>\n<p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p>\n<p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p>\n<br>\n<p><strong>4️⃣ 最高响应比优先(HRRN)</strong></p>\n<p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p>\n<ul>\n<li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li>\n<li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li>\n</ul>\n<br>\n<p><strong>5️⃣ 反馈法</strong></p>\n<p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p>\n<p>举个例子:</p>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">队列1\n队列2\n...\n队列N\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p>\n<p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p>\n<p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p>\n<br>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc24dfd080c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"942\" data-height=\"498\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"942\" height=\"498\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>没有一种调度策略是万能的, 它需要考虑很多因素:</p>\n<ul>\n<li>响应速率。进程等待被执行的时间</li>\n<li>公平性。兼顾短进程、长进程、I/O进程</li>\n</ul>\n<p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p>\n<p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a target=\"_blank\" href=\"https://blog.csdn.net/gatieme/article/details/51456569\" rel=\"nofollow noopener noreferrer\">《Linux进程调度策略的发展和演变》</a>。</p>\n<br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-1\">类比浏览器JavaScript执行环境</h2>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc207590429?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"500\" data-height=\"375\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"500\" height=\"375\"></svg>\"><figcaption></figcaption></figure>\n<i>JavaScript 就像单行道</i><p></p>\n<br>\n<p>JavaScript 是<a target=\"_blank\" href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\" rel>单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p>\n<blockquote>\n<p>这里特指Javascript 引擎是单线程运行的。 严格来说，页面绘制由单独的<code>GUI渲染进程</code>负责，只不过<code>GUI渲染线程</code>和<code>Javascript线程</code>是互斥的. 另外底层的异步操作实际上也是多线程的。</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc35b99001e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1093\" data-height=\"167\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1093\" height=\"167\"></svg>\"><figcaption></figcaption></figure>\n<i>图片来源: <a href=\"https://developers.google.com/web/fundamentals/performance/rendering\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rendering Performance</a></i><p></p>\n<p><strong>它只是一个'JavaScript'，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p>\n<br>\n<p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p>\n<ul>\n<li>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量</li>\n<li>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互</li>\n<li>3️⃣ 尝试 Worker 多线程</li>\n</ul>\n<p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a target=\"_blank\" href=\"https://www.yuque.com/vueconf/2019/gwn1z0\" rel=\"nofollow noopener noreferrer\">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p>\n<br>\n<p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc366f124be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"670\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"670\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p>\n<p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a target=\"_blank\" href=\"https://twitter.com/dan_abramov\" rel=\"nofollow noopener noreferrer\">Dan Abramov</a> 的 <a target=\"_blank\" href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\" rel=\"nofollow noopener noreferrer\">Beyond React 16</a> 演讲, 推荐看一下👍. 另外非常感谢<a target=\"_blank\" href=\"https://www.zhihu.com/people/BlackGanglion/activities\" rel=\"nofollow noopener noreferrer\">淡苍</a> 将一个<a target=\"_blank\" href=\"https://codesandbox.io/s/koyz664q35\" rel=\"nofollow noopener noreferrer\">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p>\n<br>\n<p>同步模式下的 React:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc3acaf5689?imageslim\" data-width=\"1280\" data-height=\"823\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"823\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>优化后的 <code>Concurrent</code> 模式下的 React:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc385cc0286?imageslim\" data-width=\"1280\" data-height=\"803\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"803\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p>\n<p>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p>\n<br>\n<p><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 '适时'地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p>\n<ul>\n<li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a target=\"_blank\" href=\"https://juejin.im/post/5d76f469f265da039a28aff7#heading-1\" rel>《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/37095662\" rel=\"nofollow noopener noreferrer\">《React Fiber架构》</a> 都做了相关实验</li>\n<li>司徒正美在<a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/37095662\" rel=\"nofollow noopener noreferrer\">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li>\n</ul>\n<br>\n<p>这就是为什么React 需要 Fiber 😏。</p>\n<br>\n<h2 class=\"heading\" data-id=\"heading-2\">何为 Fiber</h2>\n<p>对于 React 来说，Fiber 可以从两个角度理解:</p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-3\">1. 一种流程控制原语</h3>\n<p>Fiber 也称<a target=\"_blank\" href=\"https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272\" rel=\"nofollow noopener noreferrer\">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\" rel=\"nofollow noopener noreferrer\"><code>Generator</code></a>。</p>\n<blockquote>\n<p>本文不纠结 <a target=\"_blank\" href=\"https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591\" rel=\"nofollow noopener noreferrer\">Processes, threads, green threads, protothreads, fibers, coroutines: what's the difference?</a></p>\n</blockquote>\n<p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p>\n<p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> tasks = []\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> task\n  <span class=\"hljs-keyword\">while</span> (task = tasks.shift()) {\n    execute(task)\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>而 <code>Generator</code> 可以:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> tasks = []\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> task\n\n  <span class=\"hljs-keyword\">while</span> (task = tasks.shift()) {\n    <span class=\"hljs-comment\">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span>\n    <span class=\"hljs-keyword\">if</span> (hasHighPriorityEvent()) {\n      <span class=\"hljs-keyword\">yield</span>\n    }\n\n    <span class=\"hljs-comment\">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span>\n    execute(task)\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p>\n<br>\n<p>那么现在你应该有以下疑问:</p>\n<ul>\n<li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li>\n<li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li>\n<li>3️⃣ React 那为什么不使用 Generator？</li>\n</ul>\n<br>\n<br>\n<p><strong>答1️⃣: 没错, 主动让出机制</strong></p>\n<p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p>\n<p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a target=\"_blank\" href=\"https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7\" rel><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p>\n<p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc37fdd60d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1268\" data-height=\"700\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1268\" height=\"700\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p>\n<p>当然你超时不还浏览器也拿你没办法 🤷‍... 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p>\n<br>\n<hr>\n<br>\n<p><strong>答2️⃣: requestIdleCallback API</strong></p>\n<p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p>\n<p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p>\n<p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p>\n<p>其实浏览器提供了相关的接口 —— <a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" rel=\"nofollow noopener noreferrer\"><code>requestIdleCallback</code></a> API：</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-built_in\">window</span>.requestIdleCallback(\n  callback: <span class=\"hljs-function\">(<span class=\"hljs-params\">dealine: IdleDeadline</span>) =></span> <span class=\"hljs-built_in\">void</span>,\n  option?: {timeout: <span class=\"hljs-built_in\">number</span>}\n  )\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p><code>IdleDeadline</code>的接口如下：</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-keyword\">interface</span> IdleDealine {\n  didTimeout: <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-comment\">// 表示任务执行是否超过约定时间</span>\n  timeRemaining(): DOMHighResTimeStamp <span class=\"hljs-comment\">// 任务可供执行的剩余时间</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p>\n<br>\n<p><strong>那浏览器什么时候有空？</strong></p>\n<p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd81f16c6f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"850\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"850\"></svg>\"><figcaption></figcaption></figure>\n<i>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</i><p></p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc428fb4c0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"260\"></svg>\"><figcaption></figcaption></figure>\n<i>图片来源: <a href=\"https://juejin.im/post/5ad71f39f265da239f07e862\" target=\"_blank\" rel>你应该知道的requestIdleCallback</a></i><p></p>\n<p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p>\n<ul>\n<li>处理用户输入事件</li>\n<li>Javascript执行</li>\n<li>requestAnimation 调用</li>\n<li>布局 Layout</li>\n<li>绘制 Paint</li>\n</ul>\n<br>\n<p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc43c710e16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"737\" data-height=\"139\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"737\" height=\"139\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p>\n<blockquote>\n<p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p>\n</blockquote>\n<br>\n<p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a target=\"_blank\" href=\"https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js\" rel=\"nofollow noopener noreferrer\">自己实现了一个</a>。它利用<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel\" rel=\"nofollow noopener noreferrer\"><code>MessageChannel</code></a> 模拟将回调延迟到'绘制操作'之后执行:</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc5839a3974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1185\" data-height=\"243\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1185\" height=\"243\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<details>\n<summary>简单看一下代码</summary>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n<span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'btn'</span>)\n<span class=\"hljs-keyword\">const</span> ch = <span class=\"hljs-keyword\">new</span> MessageChannel()\n<span class=\"hljs-keyword\">let</span> pendingCallback\n<span class=\"hljs-keyword\">let</span> startTime\n<span class=\"hljs-keyword\">let</span> timeout\n\nch.port2.onmessage = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">work</span>(<span class=\"hljs-params\"></span>)  </span>{\n  <span class=\"hljs-comment\">// 在绘制之后被执行</span>\n  <span class=\"hljs-keyword\">if</span> (pendingCallback) {\n    <span class=\"hljs-keyword\">const</span> now = performance.now()\n    <span class=\"hljs-comment\">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span>\n    <span class=\"hljs-comment\">// 通过这些数据来计算剩余时间</span>\n    <span class=\"hljs-comment\">// 另外还要处理超时(timeout)，避免任务被饿死</span>\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">if</span> (hasRemain && noTimeout) {\n      pendingCallback(deadline)\n    }\n  }\n}\n\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">simpleRequestIdleCallback</span>(<span class=\"hljs-params\">callback, timeout</span>) </span>{\n  requestAnimationFrame(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">animation</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 在绘制之前被执行</span>\n    <span class=\"hljs-comment\">// 记录开始时间</span>\n    startTime = performance.now()\n    timeout = timeout\n    dosomething()\n    <span class=\"hljs-comment\">// 调度回调到绘制结束后执行</span>\n    pendingCallback = callback\n    ch.port1.postMessage(<span class=\"hljs-string\">'hello'</span>)\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre></details>\n<br>\n<p><strong>任务优先级</strong></p>\n<p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p>\n<ul>\n<li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li>\n<li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li>\n<li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li>\n<li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li>\n<li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li>\n</ul>\n<br>\n<hr>\n<br>\n<p><strong>答3️⃣: 太麻烦</strong></p>\n<p>官方在<a target=\"_blank\" href=\"https://github.com/facebook/react/issues/7942\" rel=\"nofollow noopener noreferrer\">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p>\n<ol>\n<li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li>\n<li>Generator 是有状态的, 很难在中间恢复这些状态。</li>\n</ol>\n<blockquote>\n<p>上面理解可能有出入，建议看一下原文</p>\n</blockquote>\n<p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p>\n<br>\n<br>\n<h3 class=\"heading\" data-id=\"heading-4\">2. 一个执行单元</h3>\n<p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个'执行单元',  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p>\n<br>\n<p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p>\n<p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">updateQueue.push(updateTask);\nrequestIdleCallback(performWork, {timeout});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performWork</span>(<span class=\"hljs-params\">deadline</span>) </span>{\n\n  <span class=\"hljs-comment\">// 2️⃣ 循环取出updateQueue中的任务</span>\n  <span class=\"hljs-keyword\">while</span> (updateQueue.length > <span class=\"hljs-number\">0</span> && deadline.timeRemaining() > ENOUGH_TIME) {\n    workLoop(deadline);\n  }\n\n  <span class=\"hljs-comment\">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span>\n  <span class=\"hljs-keyword\">if</span> (updateQueue.length > <span class=\"hljs-number\">0</span>) {\n    requestIdleCallback(performWork);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p>\n<br>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 保存当前的处理现场</span>\n<span class=\"hljs-keyword\">let</span> nextUnitOfWork: Fiber | <span class=\"hljs-literal\">undefined</span> <span class=\"hljs-comment\">// 保存下一个需要处理的工作单元</span>\n<span class=\"hljs-keyword\">let</span> topWork: Fiber | <span class=\"hljs-literal\">undefined</span>        <span class=\"hljs-comment\">// 保存第一个工作单元</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">workLoop</span>(<span class=\"hljs-params\">deadline: IdleDeadline</span>) </span>{\n  <span class=\"hljs-comment\">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span>\n  <span class=\"hljs-keyword\">if</span> (nextUnitOfWork == <span class=\"hljs-literal\">null</span>) {\n    nextUnitOfWork = topWork = getNextUnitOfWork();\n  }\n\n  <span class=\"hljs-comment\">// 🔴 每执行完一个执行单元，检查一次剩余时间</span>\n  <span class=\"hljs-comment\">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span>\n  <span class=\"hljs-keyword\">while</span> (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {\n    <span class=\"hljs-comment\">// 下文我们再看performUnitOfWork</span>\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);\n  }\n\n  <span class=\"hljs-comment\">// 提交工作，下文会介绍</span>\n  <span class=\"hljs-keyword\">if</span> (pendingCommit) {\n    commitAllWork(pendingCommit);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>画个流程图吧！</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deed1711f281b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1056\" data-height=\"1089\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1056\" height=\"1089\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-5\">React 的Fiber改造</h2>\n<p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-6\">1. 数据结构的调整</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc72bc9a14c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1019\" data-height=\"330\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1019\" height=\"330\"></svg>\"><figcaption></figcaption></figure>\n<i>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</i><p></p>\n<br>\n<p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a target=\"_blank\" href=\"https://juejin.im/post/5cfa29e151882539c33e4f5e\" rel>《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p>\n<br>\n<p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。</p>\n<p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p>\n<p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/36425839\" rel=\"nofollow noopener noreferrer\"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p>\n<br>\n<p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-keyword\">export</span> type Fiber = {\n  <span class=\"hljs-comment\">// Fiber 类型信息</span>\n  type: any,\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// ⚛️ 链表结构</span>\n  <span class=\"hljs-comment\">// 指向父节点，或者render该节点的组件</span>\n  <span class=\"hljs-keyword\">return</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-comment\">// 指向第一个子节点</span>\n  child: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-comment\">// 指向下一个兄弟节点</span>\n  sibling: Fiber | <span class=\"hljs-literal\">null</span>,\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>用图片来展示这种关系会更直观一些：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc6db5530be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"982\" data-height=\"439\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"982\" height=\"439\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Call_stack\" rel=\"nofollow noopener noreferrer\">Wiki</a>：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecc9a904099b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"566\" data-height=\"461\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"566\" height=\"461\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p>\n</blockquote>\n<br>\n<p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>函数调用栈</th>\n<th>Fiber</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本单位</td>\n<td>函数</td>\n<td>Virtual DOM 节点</td>\n</tr>\n<tr>\n<td>输入</td>\n<td>函数参数</td>\n<td>Props</td>\n</tr>\n<tr>\n<td>本地状态</td>\n<td>本地变量</td>\n<td>State</td>\n</tr>\n<tr>\n<td>输出</td>\n<td>函数返回值</td>\n<td>React Element</td>\n</tr>\n<tr>\n<td>下级</td>\n<td>嵌套函数调用</td>\n<td>子节点(child)</td>\n</tr>\n<tr>\n<td>上级引用</td>\n<td>返回地址</td>\n<td>父节点(return)</td>\n</tr>\n</tbody>\n</table>\n<br>\n<p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p>\n<br>\n<p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p>\n<br>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">/**\n * @params fiber 当前需要处理的节点\n * @params topWork 本次更新的根节点\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber: Fiber, topWork: Fiber</span>) </span>{\n  <span class=\"hljs-comment\">// 对该节点进行处理</span>\n  beginWork(fiber);\n\n  <span class=\"hljs-comment\">// 如果存在子节点，那么下一个待处理的就是子节点</span>\n  <span class=\"hljs-keyword\">if</span> (fiber.child) {\n    <span class=\"hljs-keyword\">return</span> fiber.child;\n  }\n\n  <span class=\"hljs-comment\">// 没有子节点了，上溯查找兄弟节点</span>\n  <span class=\"hljs-keyword\">let</span> temp = fiber;\n  <span class=\"hljs-keyword\">while</span> (temp) {\n    completeWork(temp);\n\n    <span class=\"hljs-comment\">// 到顶层节点了, 退出</span>\n    <span class=\"hljs-keyword\">if</span> (temp === topWork) {\n      <span class=\"hljs-keyword\">break</span>\n    }\n\n    <span class=\"hljs-comment\">// 找到，下一个要处理的就是兄弟节点</span>\n    <span class=\"hljs-keyword\">if</span> (temp.sibling) {\n      <span class=\"hljs-keyword\">return</span> temp.sibling;\n    }\n\n    <span class=\"hljs-comment\">// 没有, 继续上溯</span>\n    temp = temp.return;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p>\n<p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p>\n<p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecca7850a24d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"708\" data-height=\"439\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"708\" height=\"439\"></svg>\"><figcaption></figcaption></figure>\n<i>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</i><p></p>\n<br>\n<p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p>\n<br>\n<br>\n<h3 class=\"heading\" data-id=\"heading-7\">2. 两个阶段的拆分</h3>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd830671a70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1232\" data-height=\"464\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1232\" height=\"464\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p>\n<blockquote>\n<p>我在之前的多篇文章中都有提及: <a target=\"_blank\" href=\"https://juejin.im/post/5d8395646fb9a06ad16faa57\" rel>《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p>\n</blockquote>\n<p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p>\n<ul>\n<li>\n<p><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为'<code>副作用</code>(Effect)' . 以下生命周期钩子会在协调阶段被调用：</p>\n<ul>\n<li>constructor</li>\n<li>componentWillMount 废弃</li>\n<li>componentWillReceiveProps 废弃</li>\n<li>static getDerivedStateFromProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate 废弃</li>\n<li>render</li>\n<li>getSnapshotBeforeUpdate()</li>\n</ul>\n</li>\n<li>\n<p><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p>\n<ul>\n<li>componentDidMount</li>\n<li>componentDidUpdate</li>\n<li>componentWillUnmount</li>\n</ul>\n</li>\n</ul>\n<br>\n<p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p>\n<p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。</p>\n<p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p>\n<br>\n<p>现在你应该知道为什么'提交阶段'必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用... 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p>\n<p>关于为什么要拆分两个阶段，<a target=\"_blank\" href=\"https://github.com/facebook/react/issues/13186#issuecomment-403959161\" rel=\"nofollow noopener noreferrer\">这里</a>有更详细的解释。</p>\n<br>\n<br>\n<h3 class=\"heading\" data-id=\"heading-8\">3. Reconcilation</h3>\n<p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p>\n<p>首先再进一步看一下<code>Fiber</code>的结构:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-keyword\">interface</span> Fiber {\n  <span class=\"hljs-comment\">/**\n   * ⚛️ 节点的类型信息\n   */</span>\n  <span class=\"hljs-comment\">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span>\n  tag: WorkTag,\n  <span class=\"hljs-comment\">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span>\n  <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>,\n\n  <span class=\"hljs-comment\">/**\n   * ⚛️ 结构信息\n   */</span> \n  <span class=\"hljs-keyword\">return</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n  child: Fiber | <span class=\"hljs-literal\">null</span>,\n  sibling: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-comment\">// 子节点的唯一键, 即我们渲染列表传入的key属性</span>\n  key: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">string</span>,\n\n  <span class=\"hljs-comment\">/**\n   * ⚛️ 节点的状态\n   */</span>\n  <span class=\"hljs-comment\">// 节点实例(状态)：</span>\n  <span class=\"hljs-comment\">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span>\n  <span class=\"hljs-comment\">//        对于类组件来说，这里保存类组件的实例</span>\n  <span class=\"hljs-comment\">//        对于函数组件说，这里为空，因为函数组件没有实例</span>\n  stateNode: <span class=\"hljs-built_in\">any</span>,\n  <span class=\"hljs-comment\">// 新的、待处理的props</span>\n  pendingProps: <span class=\"hljs-built_in\">any</span>,\n  <span class=\"hljs-comment\">// 上一次渲染的props</span>\n  memoizedProps: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// The props used to create the output.</span>\n  <span class=\"hljs-comment\">// 上一次渲染的组件状态</span>\n  memoizedState: <span class=\"hljs-built_in\">any</span>,\n\n\n  <span class=\"hljs-comment\">/**\n   * ⚛️ 副作用\n   */</span>\n  <span class=\"hljs-comment\">// 当前节点的副作用类型，例如节点更新、删除、移动</span>\n  effectTag: SideEffectTag,\n  <span class=\"hljs-comment\">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span>\n  nextEffect: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">/**\n   * ⚛️ 替身\n   * 指向旧树中的节点\n   */</span>\n  alternate: Fiber | <span class=\"hljs-literal\">null</span>,\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>Fiber 包含的属性可以划分为 5 个部分:</p>\n<ul>\n<li>\n<p><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</p>\n</li>\n<li>\n<p><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</p>\n</li>\n<li>\n<p><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</p>\n</li>\n<li>\n<p><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的'副作用'(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).\n那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</p>\n</li>\n<li>\n<p><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</p>\n</li>\n</ul>\n<br>\n<p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">beginWork</span>(<span class=\"hljs-params\">fiber: Fiber</span>): <span class=\"hljs-title\">Fiber</span> | <span class=\"hljs-title\">undefined</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (fiber.tag === WorkTag.HostComponent) {\n    <span class=\"hljs-comment\">// 宿主节点diff</span>\n    diffHostComponent(fiber)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.tag === WorkTag.ClassComponent) {\n    <span class=\"hljs-comment\">// 类组件节点diff</span>\n    diffClassComponent(fiber)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.tag === WorkTag.FunctionComponent) {\n    <span class=\"hljs-comment\">// 函数组件节点diff</span>\n    diffFunctionalComponent(fiber)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// ... 其他类型节点，省略</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>宿主节点比对:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">diffHostComponent</span>(<span class=\"hljs-params\">fiber: Fiber</span>) </span>{\n  <span class=\"hljs-comment\">// 新增节点</span>\n  <span class=\"hljs-keyword\">if</span> (fiber.stateNode == <span class=\"hljs-literal\">null</span>) {\n    fiber.stateNode = createHostComponent(fiber)\n  } <span class=\"hljs-keyword\">else</span> {\n    updateHostComponent(fiber)\n  }\n\n  <span class=\"hljs-keyword\">const</span> newChildren = fiber.pendingProps.children;\n\n  <span class=\"hljs-comment\">// 比对子节点</span>\n  diffChildren(fiber, newChildren);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>类组件节点比对也差不多:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">diffClassComponent</span>(<span class=\"hljs-params\">fiber: Fiber</span>) </span>{\n  <span class=\"hljs-comment\">// 创建组件实例</span>\n  <span class=\"hljs-keyword\">if</span> (fiber.stateNode == <span class=\"hljs-literal\">null</span>) {\n    fiber.stateNode = createInstance(fiber);\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.hasMounted) {\n    <span class=\"hljs-comment\">// 调用更新前生命周期钩子</span>\n    applybeforeUpdateHooks(fiber)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 调用挂载前生命周期钩子</span>\n    applybeforeMountHooks(fiber)\n  }\n\n  <span class=\"hljs-comment\">// 渲染新节点</span>\n  <span class=\"hljs-keyword\">const</span> newChildren = fiber.stateNode.render();\n  <span class=\"hljs-comment\">// 比对子节点</span>\n  diffChildren(fiber, newChildren);\n\n  fiber.memoizedState = fiber.stateNode.state\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>子节点比对:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">diffChildren</span>(<span class=\"hljs-params\">fiber: Fiber, newChildren: React.ReactNode</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-comment\">// 全新节点，直接挂载</span>\n  <span class=\"hljs-keyword\">if</span> (oldFiber == <span class=\"hljs-literal\">null</span>) {\n    mountChildFibers(fiber, newChildren)\n    <span class=\"hljs-keyword\">return</span>\n  }\n\n  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> newFiber = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-comment\">// 新子节点</span>\n  <span class=\"hljs-keyword\">const</span> elements = extraElements(newChildren)\n\n  <span class=\"hljs-comment\">// 比对子元素</span>\n  <span class=\"hljs-keyword\">while</span> (index < elements.length || oldFiber != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">const</span> prevFiber = newFiber;\n    <span class=\"hljs-keyword\">const</span> element = elements[index]\n    <span class=\"hljs-keyword\">const</span> sameType = isSameType(element, oldFiber)\n    <span class=\"hljs-keyword\">if</span> (sameType) {\n      newFiber = cloneFiber(oldFiber, element)\n      <span class=\"hljs-comment\">// 更新关系</span>\n      newFiber.alternate = oldFiber\n      <span class=\"hljs-comment\">// 打上Tag</span>\n      newFiber.effectTag = UPDATE\n      newFiber.return = fiber\n    }\n\n    <span class=\"hljs-comment\">// 新节点</span>\n    <span class=\"hljs-keyword\">if</span> (element && !sameType) {\n      newFiber = createFiber(element)\n      newFiber.effectTag = PLACEMENT\n      newFiber.return = fiber\n    }\n\n    <span class=\"hljs-comment\">// 删除旧节点</span>\n    <span class=\"hljs-keyword\">if</span> (oldFiber && !sameType) {\n      oldFiber.effectTag = DELETION;\n      oldFiber.nextEffect = fiber.nextEffect\n      fiber.nextEffect = oldFiber\n    }\n\n    <span class=\"hljs-keyword\">if</span> (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (index == <span class=\"hljs-number\">0</span>) {\n      fiber.child = newFiber;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (prevFiber && element) {\n      prevFiber.sibling = newFiber;\n    }\n\n    index++\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p>\n<br>\n<p>这里引用一下<a target=\"_blank\" href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" rel=\"nofollow noopener noreferrer\">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p>\n<blockquote>\n<p>这篇文章<a target=\"_blank\" href=\"https://juejin.im/post/5ab7b3a2f265da2378403e57\" rel>《React Fiber》</a> 用文字版解释了Link Clark Slide.</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecce3162b355?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"915\" data-height=\"690\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"915\" height=\"690\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了'标签'。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p>\n<br>\n<br>\n<h3 class=\"heading\" data-id=\"heading-9\">4. 双缓冲</h3>\n<p><code>WIP 树</code>构建这种技术类似于图形化领域的'<strong>双缓存(Double Buffering)</strong>'技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p>\n<p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p>\n<p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p>\n<p>Dan 在 <a target=\"_blank\" href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\" rel=\"nofollow noopener noreferrer\">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deeccf3468b00b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"560\" data-height=\"342\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"560\" height=\"342\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<br>\n<h3 class=\"heading\" data-id=\"heading-10\">5. 副作用的收集和提交</h3>\n<p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">completeWork</span>(<span class=\"hljs-params\">fiber</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> parent = fiber.return\n\n  <span class=\"hljs-comment\">// 到达顶端</span>\n  <span class=\"hljs-keyword\">if</span> (parent == <span class=\"hljs-literal\">null</span> || fiber === topWork) {\n    pendingCommit = fiber\n    <span class=\"hljs-keyword\">return</span>\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.effectTag != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">if</span> (parent.nextEffect) {\n      parent.nextEffect.nextEffect = fiber\n    } <span class=\"hljs-keyword\">else</span> {\n      parent.nextEffect = fiber\n    }\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.nextEffect) {\n    parent.nextEffect = fiber.nextEffect\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<p>最后了，将所有副作用提交了:</p>\n<pre><code class=\"hljs ts copyable\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitAllWork</span>(<span class=\"hljs-params\">fiber</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> next = fiber\n  <span class=\"hljs-keyword\">while</span>(next) {\n    <span class=\"hljs-keyword\">if</span> (fiber.effectTag) {\n      <span class=\"hljs-comment\">// 提交，偷一下懒，这里就不展开了</span>\n      commitWork(fiber)\n    }\n    next = fiber.nextEffect\n  }\n\n  <span class=\"hljs-comment\">// 清理现场</span>\n  pendingCommit = nextUnitOfWork = topWork = <span class=\"hljs-literal\">null</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-11\">⚠️ 未展开部分 🚧 -- 中断和恢复</h2>\n<p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p>\n<p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p>\n<p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p>\n<br>\n<p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deeccf96dac168?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"709\" data-height=\"155\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"709\" height=\"155\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd05f86b375?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"681\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"681\" height=\"200\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd121a8657a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"716\" data-height=\"258\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"716\" height=\"258\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>\n<p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd19b1362c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"587\" data-height=\"239\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"587\" height=\"239\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p>\n<p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p>\n<p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p>\n<br>\n<p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p>\n<br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-12\">凌波微步</h2>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd21336ca41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1067\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1067\" height=\"1280\"></svg>\"><figcaption></figcaption></figure>\n<i>同样来自Link Clark 的 Slider</i><p></p>\n<p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒... 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p>\n<p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd2d4124b05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"569\" data-height=\"292\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"569\" height=\"292\"></svg>\"><figcaption></figcaption></figure>\n<i>来源：<a href=\"https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Flarnie Marchan - Ready for Concurrent Mode?</a></i><p></p>\n<br>\n<p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a target=\"_blank\" href=\"https://www.youtube.com/watch?v=ByBPyMBTzM0\" rel=\"nofollow noopener noreferrer\">Concurrent Rendering in React</a>):</p>\n<ul>\n<li>快速响应用户操作和输入，提升用户交互体验</li>\n<li>让动画更加流畅，通过调度，可以让应用保持高帧率</li>\n<li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li>\n<li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li>\n</ul>\n<br>\n<p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p>\n<p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存...</p>\n<p>尤雨溪在今年的<a target=\"_blank\" href=\"https://www.yuque.com/vueconf/2019\" rel=\"nofollow noopener noreferrer\">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p>\n<p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p>\n<br>\n<br>\n<h2 class=\"heading\" data-id=\"heading-13\">站在巨人的肩膀上</h2>\n<br>\n<p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p>\n<p><strong>迷你 Fiber 实现</strong>:</p>\n<p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a target=\"_blank\" href=\"https://www.zhihu.com/people/he-shi-jun\" rel=\"nofollow noopener noreferrer\">Hax</a> 在 <a target=\"_blank\" href=\"https://www.zhihu.com/question/270428598/answer/354017709\" rel=\"nofollow noopener noreferrer\">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低... 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p>\n<p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/RubyLouvre/anu\" rel=\"nofollow noopener noreferrer\">anu</a> <a target=\"_blank\" href=\"https://github.com/RubyLouvre\" rel=\"nofollow noopener noreferrer\">司徒正美</a> 开发的类React框架</li>\n<li><a target=\"_blank\" href=\"https://github.com/132yse/fre\" rel=\"nofollow noopener noreferrer\">Fre</a> <a target=\"_blank\" href=\"https://www.zhihu.com/people/132yse\" rel=\"nofollow noopener noreferrer\">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li>\n<li><a target=\"_blank\" href=\"https://github.com/Foveluy/Luy\" rel=\"nofollow noopener noreferrer\">Luy</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/pomber/didact\" rel=\"nofollow noopener noreferrer\">didact</a></li>\n</ul>\n<br>\n<p><strong>优秀的文章 & 演讲</strong></p>\n<p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" rel=\"nofollow noopener noreferrer\">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li>\n<li><a target=\"_blank\" href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\" rel=\"nofollow noopener noreferrer\">Beyond React 16 - Dan Abramov 👍🎦</a></li>\n<li><a target=\"_blank\" href=\"https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s\" rel=\"nofollow noopener noreferrer\">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/37095662\" rel=\"nofollow noopener noreferrer\">司徒正美: React Fiber架构 👍</a> 看不如写</li>\n<li><a target=\"_blank\" href=\"https://www.zhihu.com/people/NE_SmallTown/posts\" rel=\"nofollow noopener noreferrer\">展望 React 17，回顾 React 往事 👍</a> 看完 <a target=\"_blank\" href=\"https://www.zhihu.com/people/NE_SmallTown\" rel=\"nofollow noopener noreferrer\">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/jheaven\" rel=\"nofollow noopener noreferrer\">冰山一角</a>，我们都没资格说我们懂 React。</li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/36425839\" rel=\"nofollow noopener noreferrer\">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li>\n<li><a target=\"_blank\" href=\"https://www.zhihu.com/search?type=content&q=requestIdleCallback\" rel=\"nofollow noopener noreferrer\">淡苍：深入剖析 React Concurrent 👍</a></li>\n<li><a target=\"_blank\" href=\"https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec\" rel=\"nofollow noopener noreferrer\">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/26027085\" rel=\"nofollow noopener noreferrer\">程墨: React Fiber是什么</a></li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/57346388\" rel=\"nofollow noopener noreferrer\">译 深入React fiber架构及源码</a></li>\n<li><a target=\"_blank\" href=\"http://www.ayqy.net/blog/dive-into-react-fiber/\" rel=\"nofollow noopener noreferrer\">黯羽轻扬: 完全理解React Fiber</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/facebook/react/issues/7942\" rel=\"nofollow noopener noreferrer\">Fiber Principles: Contributing To Fiber</a></li>\n<li><a target=\"_blank\" href=\"https://philippspiess.com/scheduling-in-react/\" rel=\"nofollow noopener noreferrer\">Scheduling in React</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d12c907f265da1b6d4033c5\" rel>桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12\" rel>为 Luy 实现 React Fiber 架构</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5ab7b3a2f265da2378403e57\" rel>妖僧风月: React Fiber</a></li>\n<li><a target=\"_blank\" href=\"https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s\" rel=\"nofollow noopener noreferrer\">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li>\n<li><a target=\"_blank\" href=\"https://developers.google.com/web/fundamentals/performance/rendering\" rel=\"nofollow noopener noreferrer\">Web Fundamentals > Performance</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5ad71f39f265da239f07e862\" rel>你应该知道的requestIdleCallback</a></li>\n<li><a target=\"_blank\" href=\"https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/\" rel=\"nofollow noopener noreferrer\">深入探究 eventloop 与浏览器渲染的时序问题</a></li>\n<li><a target=\"_blank\" href=\"https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/\" rel=\"nofollow noopener noreferrer\">Accurately measuring layout on the web</a></li>\n</ul>\n<br>\n<p><strong>自荐React 相关文章</strong></p>\n<p>回顾一下今年写的关于 React 的相关文章</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cd7f2c4e51d453a7d63b715\" rel>React组件设计实践总结 系列 共5篇</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d8395646fb9a06ad16faa57\" rel>自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d44e3745188255d5861d654\" rel>谈谈React事件机制和未来(react-events)</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d594ea5518825041301bbcb\" rel>2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d045350f265da1b695d5bf2\" rel>浅谈React性能优化的方向</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cfa29e151882539c33e4f5e\" rel>从Preact中了解React组件和hooks基本原理</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d06bf0a51882528194a9736\" rel>React性能测量和分析</a></li>\n</ul>\n<br>\n<p>本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend...  还有很多没讲完，后面的文章见！</p>\n<br>\n<p>问卷调查，你觉得这种文章风格怎样？</p>\n<ul>\n<li>A. 事无巨细，太啰嗦了</li>\n<li>B. 娓娓道来，深入浅出我喜欢</li>\n<li>C. 内容不够深入</li>\n<li>D. 文章篇幅太长，可以拆分</li>\n</ul>\n<p>多选，下方评论，👍点赞走起</p>\n<br>\n<blockquote>\n<p><strong>改了一个正经一点的网名：<em>sx</em>(傻叉) -> 荒山 ⛰</strong></p>\n</blockquote>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deecd38f465448?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"450\" data-height=\"450\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"450\" height=\"450\"></svg>\"><figcaption></figcaption></figure><p></p>\n<br>",
      "id": "3bk2ny1ywu80",
      "author": "张张-💫",
      "title": "这可能是最通俗的 React Fiber(时间分片) 打开方式"
    },
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-2\">2.css3的新特性</h4>\n<blockquote>\n<p>transtion\ntransition-property 规定设置过渡效果的 CSS 属性的名称。</p>\n</blockquote>\n<blockquote>\n<p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p>\n</blockquote>\n<blockquote>\n<p>transition-timing-function 规定速度效果的速度曲线。</p>\n</blockquote>\n<blockquote>\n<p>transition-delay 定义过渡效果何时开始。</p>\n</blockquote>\n<blockquote>\n<p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p>\n</blockquote>\n<blockquote>\n<p>ainimation实现动画效果主要由两部分组成：</p>\n</blockquote>\n<blockquote>\n<p>通过类似Flash动画中的帧来声明一个动画；</p>\n</blockquote>\n<blockquote>\n<p>在animation属性中调用关键帧声明的动画。</p>\n</blockquote>\n<blockquote>\n<p>translate 3D建模效果</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-3\">3.img中alt和title的区别</h4>\n<blockquote>\n<p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。</p>\n</blockquote>\n<blockquote>\n<p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-4\">4.用纯CSS创建一个三角形</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n    div {\n        width: 0;\n        height: 0;\n        border-top: 40px solid transparent;\n        border-left: 40px solid transparent;\n        border-right: 40px solid transparent;\n        border-bottom: 40px solid <span class=\"hljs-comment\">#ff0000;</span>\n    }\n    </style>\n</head>\n<body>\n  <div></div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-5\">5.如何理解CSS的盒子模型？</h4>\n<blockquote>\n<p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p>\n</blockquote>\n<blockquote>\n<p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-6\">6.如何让一个div水平居中</h4>\n<blockquote>\n<p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p>\n</blockquote>\n<blockquote>\n<p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-7\">7.如何让一个div水平垂直居中</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">div {\nposition: relative / fixed; /* 相对定位或绝对定位均可 */\nwidth:500px;\nheight:300px;\ntop: 50%;\nleft: 50%;\nmargin-top:-150px;\nmargin-left:-250px;\n 外边距为自身宽高的一半 */\nbackground-color: pink; /* 方便看效果 */\n }\n\n.container {\ndisplay: flex;\nalign-items: center; /* 垂直居中 */\njustify-content: center; /* 水平居中 */\n \n}\n.container div {\nwidth: 100px; /* 可省 */\nheight: 100px; /* 可省 */\nbackground-color: pink; /* 方便看效果 */\n}  \n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-8\">8.如何清除浮动？</h4>\n<blockquote>\n<p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式\n{clear:both;height:0;overflow:hidden;}</p>\n</blockquote>\n<blockquote>\n<p>给浮动元素父级设置高度</p>\n</blockquote>\n<blockquote>\n<p>父级同时浮动（需要给父级同级元素添加浮动）</p>\n</blockquote>\n<blockquote>\n<p>父级设置成inline-block，其margin: 0 auto居中方式失效</p>\n</blockquote>\n<blockquote>\n<p>给父级添加overflow:hidden 清除浮动方法</p>\n</blockquote>\n<blockquote>\n<p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">float_div:after{\ncontent:<span class=\"hljs-string\">\".\"</span>;\nclear:both;\ndisplay:block;\nheight:0;\noverflow:hidden;\nvisibility:hidden;\n}\n.float_div{\nzoom:1\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-9\">9.css3实现三栏布局，左右固定，中间自适应</h4>\n<blockquote>\n<p>圣杯布局/双飞翼布局</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .middle,\n        .left,\n        .right {\n            position: relative;\n            <span class=\"hljs-built_in\">float</span>: left;\n            min-height: 130px;\n        }\n        .container {\n            padding: 0 220px 0 200px;\n            overflow: hidden;\n        }\n        .left {\n            margin-left: -100%;\n            left: -200px;\n            width: 200px;\n            background: red;\n        }\n        .right {\n            margin-left: -220px;\n            right: -220px;\n            width: 220px;\n            background: green;\n        }\n        .middle {\n            width: 100%;\n            background: blue;\n            word-break: <span class=\"hljs-built_in\">break</span>-all;\n        }\n    </style>\n</head>\n<body>\n    <div class=<span class=\"hljs-string\">'container'</span>>\n        <div class=<span class=\"hljs-string\">'middle'</span>></div>\n        <div class=<span class=\"hljs-string\">'left'</span>></div>\n        <div class=<span class=\"hljs-string\">'right'</span>></div>\n    </div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">10.display:none 和 visibility: hidden的区别</h4>\n<blockquote>\n<p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>\n</blockquote>\n<blockquote>\n<p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-11\">11.CSS中 link 和@import 的区别是？</h4>\n<blockquote>\n<p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p>\n</blockquote>\n<blockquote>\n<p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p>\n</blockquote>\n<blockquote>\n<p>link方式的样式的权重 高于@import的权重.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-12\">12.position的absolute与fixed共同点与不同点</h4>\n<blockquote>\n<p>共同点：\n改变行内元素的呈现方式，display被置为block\n让元素脱离普通流，不占据空间\n默认会覆盖到非定位元素上</p>\n</blockquote>\n<blockquote>\n<p>不同点：\nabsolute的”根元素“是可以设置的\nfixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-13\">13..transition和animation的区别</h4>\n<blockquote>\n<p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</p>\n</blockquote>\n<blockquote>\n<p>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始\nanimation  指定要绑定到选择器的关键帧的名称</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-14\">14.CSS优先级</h4>\n<pre><code class=\"copyable\">不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性\n\t1.属性后面加!import 会覆盖页面内任何位置定义的元素样式\n\t2.作为style属性写在元素内的样式\n\t3.id选择器\n\t4.类选择器\n\t5.标签选择器\n\t6.通配符选择器（*）\n\t7.浏览器自定义或继承\n**同一级别：后写的会覆盖先写的**\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-15\">15.雪碧图：</h4>\n<pre><code class=\"copyable\">        多个图片集成在一个图片中的图\n\t使用雪碧图可以减少网络请求的次数，加快允许的速度\n\t通过background-position，去定位图片在屏幕的哪个位置\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-16\">二、JS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-17\">1.typeof和instance of 检测数据类型有什么区别？</h4>\n<blockquote>\n<p>相同点：\n都常用来判断一个变量是否为空，或者是什么类型的。</p>\n</blockquote>\n<blockquote>\n<p>不同点：\ntypeof\t\t返回值是一个字符串，用来说明变量的数据类型\ninstanceof        用于判断一个变量是否属于某个对象的实例.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-18\">16.使元素消失的方法</h4>\n<pre><code class=\"copyable\">visibility:hidden、display:none、z-index=-1、opacity：0\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发\n2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-19\">.谈一谈深克隆和浅克隆？</h4>\n<blockquote>\n<p>浅克隆:\n只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p>\n</blockquote>\n<blockquote>\n<p>深克隆：\n创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\nJSON.parse、JSON.stringify()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-20\">3.es6的新特性都有哪些？</h4>\n<blockquote>\n<p>let定义块级作用域变量\n没有变量的提升，必须先声明后使用\nlet声明的变量，不能与前面的let，var，conset声明的变量重名</p>\n</blockquote>\n<blockquote>\n<p>const 定义只读变量\nconst声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改\nconst声明变量也是一个块级作用域变量\nconst声明的变量没有“变量的提升”，必须先声明后使用\nconst声明的变量不能与前面的let， var ， const声明的变量重\nconst定义的对象\\数组中的属性值可以修改,基础数据类型不可以</p>\n</blockquote>\n<blockquote>\n<p>ES6可以给形参函数设置默认值</p>\n</blockquote>\n<blockquote>\n<p>在数组之前加上三个点（...）展开运算符</p>\n</blockquote>\n<blockquote>\n<p>数组的解构赋值、对象的解构赋值</p>\n</blockquote>\n<blockquote>\n<p>箭头函数的特点\n箭头函数相当于匿名函数，是不能作为构造函数的，不能被new\n箭头函数没有arguments实参集合,取而代之用...剩余运算符解决\n箭头函数没有自己的this。他的this是继承当前上下文中的this\n箭头函数没有函数原型\n箭头函数不能当做Generator函数，不能使用yield关键字\n不能使用call、apply、bind改变箭头函数中this指向\nSet数据结构，数组去重</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-21\">4.==和===区别是什么？</h4>\n<blockquote>\n<p>=赋值</p>\n</blockquote>\n<blockquote>\n<p>==返回一个布尔值；相等返回true，不相等返回false；\n允许不同数据类型之间的比较；\n如果是不同类型的数据进行，会默认进行数据类型之间的转换；\n如果是对象数据类型的比较，比较的是空间地址</p>\n</blockquote>\n<blockquote>\n<p>=== 只要数据类型不一样，就返回false；</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-22\">5.常见的设计模式有哪些？</h4>\n<pre><code class=\"copyable\">1、js工厂模式\n2、js构造函数模式\n3、js原型模式\n4、构造函数+原型的js混合模式\n5、构造函数+原型的动态原型模式\n6、观察者模式\n7、发布订阅模式\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-23\">6.call bind apply 的区别？</h4>\n<blockquote>\n<p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p>\n</blockquote>\n<blockquote>\n<p>call()和apply()的区别就在于，两者之间的参数。</p>\n</blockquote>\n<blockquote>\n<p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p>\n</blockquote>\n<blockquote>\n<p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。\nbind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是\t直接执行该函数。他的参数和call()相同。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-24\">7.js继承方式有哪些？</h4>\n<blockquote>\n<p>原型链继承\n核心： 将父类的实例作为子类的原型</p>\n</blockquote>\n<blockquote>\n<p>构造继承\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>\n</blockquote>\n<blockquote>\n<p>实例继承\n核心：为父类实例添加新特性，作为子类实例返回</p>\n</blockquote>\n<blockquote>\n<p>拷贝继承</p>\n</blockquote>\n<blockquote>\n<p>组合继承\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现\t函数复用</p>\n</blockquote>\n<blockquote>\n<p>寄生组合继承\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实\t例方法/属性，避免的组合继承的缺点</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-25\">8.你怎样看待闭包？</h4>\n<blockquote>\n<p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-26\">9.你是如何理解原型和原型链的？</h4>\n<blockquote>\n<p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-27\">10.浏览器渲染的主要流程是什么?</h4>\n<blockquote>\n<p>将html代码按照深度优先遍历来生成DOM树。\ncss文件下载完后也会进行渲染，生成相应的CSSOM。\n当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。\n接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。\n最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-28\">11.从输入url地址到页面相应都发生了什么？</h4>\n<pre><code class=\"copyable\">1、浏览器的地址栏输入URL并按下回车。\n2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。\n4、根据IP建立TCP连接（三次握手）。\n5、HTTP发起请求。\n6、服务器处理请求，浏览器接收HTTP响应。\n7、渲染页面，构建DOM树。\n8、关闭TCP连接（四次挥手）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-29\">12.session、cookie、localStorage的区别</h4>\n<blockquote>\n<p>相同点\n都是保存在浏览器端，且同源的。</p>\n</blockquote>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li>\n<li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>\n<li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。\n存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>\n<li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>\n<li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li>\n<li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-30\">13.js中跨域方法</h4>\n<blockquote>\n<p>同源策略（协议+端口号+域名要相同）</p>\n</blockquote>\n<blockquote>\n<p>1、jsonp跨域(只能解决get）\n原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p>\n<blockquote>\n<p>步骤：\n1).去创建一个script标签\n2).script的src属性设置接口地址\n3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据\n4).通过定义函数名去接受返回的数据</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>2、document.domain 基础域名相同 子域名不同</p>\n</blockquote>\n<blockquote>\n<p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p>\n</blockquote>\n<blockquote>\n<p>4、服务器设置对CORS的支持\n原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>\n</blockquote>\n<blockquote>\n<p>5、利用h5新特性window.postMessage()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-31\">14.前端有哪些页面优化方法?</h4>\n<ul>\n<li>减少 HTTP请求数</li>\n<li>从设计实现层面简化页面</li>\n<li>合理设置 HTTP缓存</li>\n<li>资源合并与压缩</li>\n<li>合并 CSS图片，减少请求数的又一个好办法。</li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li>\n<li>多图片网页使用图片懒加载。</li>\n<li>在js中尽量减少闭包的使用</li>\n<li>尽量合并css和js文件</li>\n<li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li>\n<li>减少对DOM的操作</li>\n<li>在JS中避免“嵌套循环”和 “死循环”</li>\n<li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-32\">15.Ajax的四个步骤</h4>\n<blockquote>\n<p>1.创建ajax实例</p>\n</blockquote>\n<blockquote>\n<p>2.执行open 确定要访问的链接 以及同步异步</p>\n</blockquote>\n<blockquote>\n<p>3.监听请求状态</p>\n</blockquote>\n<blockquote>\n<p>4.发送请求</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-33\">16.数组去重的方法</h4>\n<blockquote>\n<p>ES6的set对象\n先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> unique(arr){\n    var arr2 = arr.sort();\n    var res = [arr2[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr2.length;i++){\n        <span class=\"hljs-keyword\">if</span>(arr2[i] !== res[res.length-1]){\n        res.push(arr2[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> res;\n}\n利用下标查询\n <span class=\"hljs-keyword\">function</span> unique(arr){\n    var newArr = [arr[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr.length;i++){\n        <span class=\"hljs-keyword\">if</span>(newArr.indexOf(arr[i]) == -1){\n        newArr.push(arr[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> newArr;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-34\">17.ajax中get和post请求的区别</h4>\n<ul>\n<li>get 一般用于获取数据</li>\n<li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li>\n<li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li>\n<li>get安全性较低</li>\n<li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li>\n<li>post 一般用于发送数据</li>\n<li>post传递参数，需要把参数放进请求体中，发送给服务器；</li>\n<li>post请求参数放进了请求体中，对大小没有要求；</li>\n<li>post安全性比较高；</li>\n<li>post请求不会走缓存；</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-35\">18.ajax的状态码</h4>\n<blockquote>\n<p>2开头</p>\n</blockquote>\n<ul>\n<li>200 : 代表请求成功；</li>\n</ul>\n<blockquote>\n<p>3开头</p>\n</blockquote>\n<ul>\n<li>301 : 永久重定向；</li>\n<li>302: 临时转移</li>\n<li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li>\n<li>307:临时重定向</li>\n</ul>\n<blockquote>\n<p>以4开头的都是客户端的问题；</p>\n</blockquote>\n<ul>\n<li>400 :数据/格式错误</li>\n<li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li>\n<li>404 : 路径错误，找不到文件</li>\n</ul>\n<blockquote>\n<p>以5开头都是服务端的问题</p>\n</blockquote>\n<ul>\n<li>500 : 服务器的问题</li>\n<li>503: 超负荷；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-36\">19.移动端的兼容问题</h4>\n<ul>\n<li>给移动端添加点击事件会有300S的延迟\n如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟\n一般在移动端用ontouchstart、ontouchmove、ontouchend</li>\n<li>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上\n尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。\n用fastclick，<a target=\"_blank\" href=\"https://github.com/ftlabs/fastclick\" rel=\"nofollow noopener noreferrer\">github.com/ftlabs/fast…</a>\n用preventDefault阻止a标签的click\n消除 IE10 里面的那个叉号\ninput:-ms-clear{display:none;}</li>\n<li>设置缓存\n手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</li>\n</ul>\n\n<ul>\n<li>圆角BUG\n某些Android手机圆角失效\nbackground-clip: padding-box;\n防止手机中网页放大和缩小\n这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</li>\n</ul>\n\n<ul>\n<li>设置用户截止缩放，一般写视口的时候就已经写好了。</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-37\">20.JS中同步和异步,以及js的事件流</h4>\n<blockquote>\n<p>同步：在同一时间内做一件事情</p>\n</blockquote>\n<blockquote>\n<p>异步：在同一时间内做多个事情\nJS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-38\">21.JS中常见的异步任务</h4>\n<blockquote>\n<p>定时器、ajax、事件绑定、回调函数、async await、promise</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-39\">22.TCP的三次握手和四次挥手</h4>\n<blockquote>\n<p>三次握手</p>\n</blockquote>\n<ul>\n<li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li>\n<li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li>\n<li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li>\n</ul>\n<blockquote>\n<p>四次挥手</p>\n</blockquote>\n<ul>\n<li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li>\n<li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li>\n<li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li>\n<li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-40\">23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4>\n<blockquote>\n<blockquote>\n<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-41\">24.DOM diff原理</h4>\n<blockquote>\n<ul>\n<li>如果元素类型发生变化，直接替换</li>\n<li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-42\">25.作用域</h4>\n<blockquote>\n<p>全局作用域</p>\n</blockquote>\n<ul>\n<li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域\n一个页面只有一个全局作用域，全局作用域下有一个window对象\nwindow是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下）\n如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值\n如果变量只被var过，那么存储值是undefined\n在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li>\n</ul>\n<blockquote>\n<p>私有作用域</p>\n</blockquote>\n<ul>\n<li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域）\n私有作用域在全局作用域中形成，具有包含的关系；\n在一个全局作用域中，可以有很多个私有作用域\n在私有作用域下定义的变量都是私有变量\n形参也是私有变量\n函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li>\n</ul>\n<blockquote>\n<p>块级作用域</p>\n</blockquote>\n<ul>\n<li>es6中新引入的一种作用域\n在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域\nvar obj = {} //对象的大括号不是块级作用域\n块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错）\n作用域链</li>\n</ul>\n<blockquote>\n<p>上级作用域</p>\n</blockquote>\n<ul>\n<li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系\n作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链\n当前作用域没有的，则会继续向上一级作用域查找\n当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-43\">26.Promise处理异步</h4>\n<blockquote>\n<p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式”\nnew Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)==\nPromise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行\nPromise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法)\nthen()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject\najax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-44\">27.map和forEach的区别</h4>\n<blockquote>\n<p>相同点</p>\n</blockquote>\n<ul>\n<li>都是循环遍历数组中的每一项\nforEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个\n匿名函数中的this都是指向window\n只能遍历数组</li>\n</ul>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。)\nmap()方法不会改变原始数组\nmap()方法不会对空数组进行检测\nforEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-45\">28.async await函数</h4>\n<blockquote>\n<p>async/await函数是异步代码的新方式</p>\n</blockquote>\n<blockquote>\n<p>async/await是基于promise实现的</p>\n</blockquote>\n<blockquote>\n<p>async/await使异步代码更像同步代码</p>\n</blockquote>\n<blockquote>\n<p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p>\n</blockquote>\n<blockquote>\n<p>默认返回一个promise实例，不能被改变</p>\n</blockquote>\n<blockquote>\n<p>await下面的代码是异步，后面的代码是同步的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-46\">29.this指向</h4>\n<blockquote>\n<ul>\n<li>全局作用域下的this指向window</li>\n<li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li>\n<li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li>\n<li>自执行函数中的this永远指向window</li>\n<li>定时器中函数的this指向window</li>\n<li>构造函数中的this指向当前的实例</li>\n<li>call、apply、bind可以改变函数的this指向</li>\n<li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-47\">30.原型</h4>\n<blockquote>\n<blockquote>\n<p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象\nprototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类\n所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-48\">31.异步回调（如何解决回调地狱）</h4>\n<pre><code class=\"copyable\">promise、generator、async/await\n\npromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理\n\t  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱\n\t  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）\n\t  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败\n\t\tpromise.all() 里面状态都改变，那就会输出，得到一个数组\n\t\tpromise.race() 里面只有一个状态变为rejected或者fulfilled即输出\n\t\tpromis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-49\">32.前端事件流</h4>\n<pre><code class=\"copyable\">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。\n      3、冒泡阶段：事件又传播回文档\n   阻止冒泡事件event.stopPropagation()\n\t  function stopBubble(e) {\n    \t\tif (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器\n      \t\te.stopPropagation()\n    \t\t} else {\n      \t\twindow.event.cancelBubble = true //IE方式阻止冒泡\n    \t      }\n  \t\t   }\n   阻止默认行为event.preventDefault()\n function stopDefault(e) {\n    if (e && e.preventDefault) {\n      e.preventDefault()\n    } else {\n      // IE浏览器阻止函数器默认动作的行为\n      window.event.returnValue = false\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-50\">33.事件如何先捕获后冒泡？</h4>\n<blockquote>\n<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，\n对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>\n</blockquote>\n<ul>\n<li>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter\n焦点事件：blur focus\nUI事件：scroll resize</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-51\">34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4>\n<pre><code class=\"copyable\">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。\n对于引用类型：除function，都返回object   null返回object。</p>\n</blockquote>\n<blockquote>\n<p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p>\n</blockquote>\n<blockquote>\n<p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>\n</blockquote>\n<blockquote>\n<p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p>\n</blockquote>\n<blockquote>\n<p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-52\">35.setTimeout 和 setInterval的机制</h4>\n<pre><code class=\"copyable\">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的\n待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-53\">36.splice和slice、map和forEach、 filter()、reduce()的区别</h4>\n<pre><code class=\"copyable\"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，\n 包含从start到end（不包含该元素）的数组方法\n\t注意：该方法不会更新原数组，而是返回一个子数组\n 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）\n\tsplice(index, howmany,item1,...itemx)\n\t\t·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置\n\t\t·howmany参数：必须，要删除的数量，\n\t\t·item1..itemx:可选，向数组添加新项目\n3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据\n4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素\n5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值\n6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-54\">VUE问题</h1>\n<h4 class=\"heading\" data-id=\"heading-55\">1.聊聊对vue的理解</h4>\n<blockquote>\n<p>vue是一个渐进式的JS框架。他易用，灵活，高效；\n可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用；\n他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-56\">2.V-model的原理是什么？</h4>\n<blockquote>\n<p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。\n数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。\n在数据变动时作你想做的事</p>\n<ul>\n<li>原理\n通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新\n在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-57\">3.谈谈对生命周期的理解</h4>\n<ul>\n<li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li>\n<li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li>\n<li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li>\n<li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li>\n<li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li>\n<li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li>\n<li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li>\n<li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-58\">4.VUE和REACT有什么区别？</h4>\n<blockquote>\n<p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p>\n</blockquote>\n<blockquote>\n<p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-59\">5.vuex的流程</h4>\n<pre><code class=\"copyable\">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。\nmutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中\n通过mapGetter来动态获取state中的值\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-60\">6.vuex有哪几种状态和属性</h4>\n<blockquote>\n<ul>\n<li>state中保存着共有数据，数据是响应式的</li>\n<li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li>\n<li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li>\n<li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li>\n<li>modules：模块化vuex</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-61\">7.vue路由的两种模式</h4>\n<blockquote>\n<ul>\n<li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算）\nhash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li>\n<li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li>\n</ul>\n<p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-62\">8.vue中 key 值的作用</h4>\n<blockquote>\n<p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。\n如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>\n</blockquote>\n<blockquote>\n<p>key的作用主要是为了高效的更新虚拟DOM。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-63\">9<code>$route</code>和<code>$router</code>的区别</h4>\n<blockquote>\n<ul>\n<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>\n<li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-64\">10.vue-router守卫</h4>\n<blockquote>\n<ul>\n<li>导航守卫 router.beforeEach 全局前置守卫</li>\n</ul>\n</blockquote>\n<ul>\n<li>to: Route: 即将要进入的目标（路由对象）</li>\n<li>from: Route: 当前导航正要离开的路由</li>\n<li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）\n执行效果依赖 next 方法的调用参数。</li>\n<li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li>\n<li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// main.js 入口文件\n    import router from <span class=\"hljs-string\">'./router'</span>; // 引入路由\n    router.beforeEach((to, from, next) => { \n      next();\n    });\n    router.beforeResolve((to, from, next) => {\n      next();\n    });\n    router.afterEach((to, from) => {\n      console.log(<span class=\"hljs-string\">'afterEach 全局后置钩子'</span>);\n    });\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const router = new VueRouter({\n  routes: [\n    {\n      path: <span class=\"hljs-string\">'/foo'</span>,\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开\n    // 可以访问组件实例 `this`\n    // 比如还未保存草稿，或者在用户离开前，\n    将<span class=\"hljs-built_in\">set</span>Interval销毁，防止离开之后，定时器还在调用。\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-65\">11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4>\n<blockquote>\n<p>请求后台资源的模块。</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">$ npm install axios -S装好\n<span class=\"copy-code-btn\">复制代码</span></code></pre><blockquote>\n<p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。\njs中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-66\">12.vue修饰符</h4>\n<ul>\n<li>stop：阻止事件的冒泡</li>\n<li>prevent：阻止事件的默认行为</li>\n<li>once：只触发一次</li>\n<li>self：只触发自己的事件行为时，才会执行</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-67\">13.vue项目中的性能优化</h4>\n<blockquote>\n<p>1.不要在模板里面写过多表达式</p>\n</blockquote>\n<blockquote>\n<p>2.循环调用子组件时添加key</p>\n</blockquote>\n<blockquote>\n<p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p>\n</blockquote>\n<blockquote>\n<p>4.尽量少用float，可以用flex</p>\n</blockquote>\n<blockquote>\n<p>5.按需加载，可以用require或者import()按需加载需要的组件</p>\n</blockquote>\n<blockquote>\n<p>6.路由懒加载</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-68\">14.vue.extend和vue.component</h4>\n<blockquote>\n<ul>\n<li>extend\n是构造一个组件的语法器。\n然后这个组件你可以作用到Vue.component这个全局注册方法里\n还可以在任意vue模板里使用组件。\n也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li>\n<li>Vue.component\n你可以创建 ，也可以取组件。</li>\n</ul>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-69\">常见的兼容问题</h3>\n<blockquote>\n<p>png24位的图片在iE6浏览器上出现背景\n解决方案是做成PNG8.也可以引用一段脚本处理.</p>\n</blockquote>\n<blockquote>\n<p>浏览器默认的margin和padding不同。\n解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>\n</blockquote>\n<blockquote>\n<p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>\n</blockquote>\n<blockquote>\n<p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-70\">React问题</h1>\n<h4 class=\"heading\" data-id=\"heading-71\">1.react和vue的区别</h4>\n<pre><code class=\"copyable\">   =>  相同点：\n\t1.数据驱动页面，提供响应式的试图组件\n\t2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n\t3.数据流动单向，都支持服务器的渲染SSR\n\t4.都有支持native的方法，react有React native， vue有wexx\n=>  不同点：\n\t1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n\t2.数据渲染：大规模的数据渲染，react更快\n\t3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n\t4.开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\t\t    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-72\">2.redux中的reducer（纯函数）</h4>\n<pre><code class=\"copyable\">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）\n更新state(这个state可以理解为上下累加器的结果）\n每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),\n进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-73\">3.react的refs</h4>\n<pre><code class=\"copyable\">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，\n它将接受地城dom元素或组件的已挂在实例，作为第一个参数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-74\">4.react中的keys</h4>\n<pre><code class=\"copyable\">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-75\">5.React的生命周期</h4>\n<pre><code class=\"copyable\">三个状态：Mounting(已插入真实的DOM）\n\t  Updating(正在被重新渲染)\n\t  Unmounting(已移除真实的DOM)\ncomponentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，\ncomponentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-76\">6.React子组件向父组件传值</h4>\n<pre><code class=\"copyable\">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-77\">7.为什么虚拟DOM会提高性能 <a target=\"_blank\" href=\"https://www.zhihu.com/question/29504639?sort=created\" rel=\"nofollow noopener noreferrer\">www.zhihu.com/question/29…</a></h4>\n<pre><code class=\"copyable\">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能\n具体实现步骤：\n\t·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中\n        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异\n\t·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-78\">8.diff算法</h4>\n<pre><code class=\"copyable\">1.把树形结构按照层级分解，只比较同级元素\n2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记\n3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面\nVritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用\nreact只会匹配相同的class的component（这里的class指的是组件的名字）\n合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制\n4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-79\">9.简述下flux的思想</h4>\n<pre><code class=\"copyable\">flux的最大特点，就是数据的‘单向流动’\n1.用户访问View\n2.View发出用户的Action\n3.Dispatcher收到Action,要求state进行相应的更新\n4.store更新后，发出一个‘change’事件后，更新页面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-80\">10.reac性能优化是哪个周期函</h4>\n<pre><code class=\"copyable\">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，\n如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-81\">11.react怎么划分业务组件和技术组件</h4>\n<pre><code class=\"copyable\">根据组件的职责通常把组件分为UI组件和容器组件\nUI组件负责UI的呈现，容器组件负责管理数据和逻辑\n两者通过React-redux提供connect方法联系起来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-82\">12.setState</h4>\n<pre><code class=\"copyable\">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列\n而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值\t\n那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误\n\n同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state\n\n同步更新state:\n\tsetState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。\n\t第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行\n\t也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步\n\n例子：componentDidMount() {\n\n\tfetch('https://test.com')\n    \n\t.then((res) => res.json())\n    \n\t.then(\n    (data) => {\nthis.setState({ data:data });\n\t\t\tStatusBar.setNetworkActivityIndicatorVisible(false);\n        }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-83\">性能优化</h1>\n<h4 class=\"heading\" data-id=\"heading-84\">一、webpack打包文件体积过大？（最终打包为一个js文件）</h4>\n<pre><code class=\"copyable\">1.异步加载模块\n2.提取第三库\n3.代码压缩\n4.去除不必要的插件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-85\">二、如何优化webpack构建的性能</h4>\n<pre><code class=\"copyable\">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积\n\t\t 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理\n\t\t 3.对一些组件库采用按需加载，避免无用的代码\n二、减少目录检索范围\n\t\t ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度\n\t\n三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-86\">三、移动端的性能优化</h4>\n<pre><code class=\"copyable\">  1、首屏加载和按需加载，懒加载\n  2、资源预加载\n  3、图片压缩处理，使用base64内嵌图片\n  4、合理缓存dom对象\n  5、使用touchstart代替click（click 300毫秒的延迟）\n  6、利用transform:translateZ(0)，开启硬件GUP加速\n  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明\n  8、使用viewport固定屏幕渲染，加速页面渲染内容\n  9、尽量使用事件代理，避免直接事件绑定\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-87\">四、Vue的SPA 如何优化加载速度</h4>\n<pre><code class=\"copyable\">1.减少入口文件体积\n2.静态资源本地缓存\n3.开启Gzip压缩\n4.使用SSR,nuxt.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-88\">五、移动端300ms延迟</h4>\n<pre><code class=\"copyable\">由来：\n300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，\n当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作\n因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕\n       \n解决方案：1.禁用缩放，设置meta标签 user-scalable=no\n\t  2.fastclick.js\n\t\t原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即\n\t\t      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉\nfastclick.js还可以解决穿透问题\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-89\">六、页面的重构；</h4>\n<blockquote>\n<p>在不改变外部行为的前提下，简化结构、添加可读性</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-90\">服务器端</h1>\n<h4 class=\"heading\" data-id=\"heading-91\">一、状态码：</h4>\n<pre><code class=\"copyable\">  2XX（成功处理了请求状态）\n      200 服务器已经成功处理请求，并提供了请求的网页\n      201 用户新建或修改数据成功\n      202 一个请求已经进入后台\n      204 用户删除成功\n  3XX（每次请求使用的重定向不要超过5次）\n      304 网页上次请求没有更新，节省带宽和开销\n  4XX（表示请求可能出错，妨碍了服务器的处理）\n      400 服务器不理解请求的语法\n      401 用户没有权限（用户名，密码输入错误）\n      403 用户得到授权（401相反），但是访问被禁止\n      404 服务器找不到请求的网页，\n  5XX（表示服务器在处理请求的时候发生内部错误）\n      500 服务器遇到错误，无法完成请求\n      503 服务器目前无法使用（超载或停机维护）     \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-92\">二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4>\n<pre><code class=\"copyable\">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）\n2.304是\tHTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件\n3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A\n\t并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304\n\nlast-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间\n\t\t客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，\n\t\t询问该事件之后文件是否被修改，没修改返回304\n\n 有了Last-Modified，为什么还要用ETag？\n  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）\n  2、某些服务器不能精确的得到文件的最后修改时间\n  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get\n\nETag，为什么还要用Last-Modified？\n  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改\n  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。\n\n\nETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）\n  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-93\">三、get/post的区别</h4>\n<pre><code class=\"copyable\">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提交的数据放在http包的Body中\n2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制\n3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值\n4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-94\">四、http协议的理解</h4>\n<pre><code class=\"copyable\">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议\n2.基于TCP/IP通信协议来传递数据（HTML，图片资源）\n3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统\n4.http请求信息request：\n\t请求行（request line）、请求头部（header）,空行和请求数据四部分构成\n\n\t请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\t请求头部，用来说明服务器要使用的附加信息\n\t空行，请求头部后面的空行是必须的\n\t请求数据也叫主体，可以添加任意的其他数据。\n5.http相应信息Response\n\t状态行、消息报头、空行和响应正文\n\n\t状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成\n\t消息报头，用来说明客户端要使用的一些附加信息\n\t空行，消息报头后面的空行是必须的\n\t响应正文，服务器返回给客户端的文本信息。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-95\">五、http和https</h4>\n<pre><code class=\"copyable\">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密\nhttp：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-96\">六、http1.0 1.1 2.0的区别</h4>\n<pre><code class=\"copyable\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-97\">七、web缓存</h4>\n<pre><code class=\"copyable\">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本\n2.缓存的好处\n        （1）减少不必要的请求\n    （2）降低服务器的压力，减少服务器的消耗\n    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-98\">八、常见的web安全及防护原理</h4>\n<pre><code class=\"copyable\">1.sql注入原理：通郭sql命令插入到web表单递交或者输入活命，达到欺骗服务器执行的恶意sql命令\n\t\t防范：1.对用户输入进行校验\n\t\t       2.不适用动态拼接sql\n2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。\n\t\t        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息\n\t\t\t防范：1.尽量采用post而不使用get提交表单\n\t\t\t      2.避免cookie中泄漏用户的隐式\n3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求\n\t\t\t举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据\n\t\t\t防范：在客服端页面增加伪随机数，通过验证码\nXSS和CSRF的区别：\n   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包\n   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-99\">九、CDN（内容分发网络）</h4>\n<pre><code class=\"copyable\">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。\n2.关键技术：内容存储和分发技术中\n3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术\n\t    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-100\">十、TCP三次握手\t(客服端和服务器端都需要确认各自可收发）</h4>\n<pre><code class=\"copyable\">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。\n第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段\n第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段\n第三次握手： 服务器端确认客服端收到了自己发送的报文段\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-101\">十一、从输入url到获取页面的完整过程  <a target=\"_blank\" href=\"https://blog.csdn.net/samjustin1/article/details/52650520\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/samjustin1/…</a></h4>\n<pre><code class=\"copyable\">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存\n2.浏览器与服务器建立tcp链接（三次握手）\n3.浏览器向服务器发送http请求(请求和传输数据）\n4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器\n5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤\n6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-102\">十二、浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print</h4>\n<pre><code class=\"copyable\">流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树\n概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树\n      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）\n      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置\n      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点\n\n重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上\n\t触发重绘的条件：改变元素外观属性。如：color，background-color等\n\t重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观\n注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局\n\n重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。\n\t每个页面都需要一次回流，就是页面第一次渲染的时候\n\n重排一定会影响重绘，但是重绘不一定会影响重排\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-103\">十三、为什么css放在顶部而js写在后面</h4>\n<pre><code class=\"copyable\">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了\n2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。\n3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验\n\n但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-104\">十四、存储方式与传输方式</h4>\n<pre><code class=\"copyable\">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m\n2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响\n3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）\n4.localStroage: h5的本地存储，数据永久保存在客服端\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-105\">cookie，sessionStorage，localStorage</h4>\n<p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上\n实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象\nsession存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据\n2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id\nsessionStorage，localStorage仅在本地保存\n3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB\n4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭\nsessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储）\nlocalStorage始终有效</p>\n<p>SessionStorage和localStorage区别：\n1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中）\n并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存\n2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p>\n<h4 class=\"heading\" data-id=\"heading-106\">token、cookie、session三者的理解？？？！！！</h4>\n<pre><code class=\"copyable\">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）\n    用户身份的验证方式    \n\n2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名\n    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）\n\n3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）\n    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-107\">基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4>\n<pre><code class=\"copyable\">  1、用户通过用户名和密码发送请求\n  2、服务器端验证\n  3、服务器端返回一个带签名的token，给客户端\n  4、客户端储存token，并且每次用于发送请求\n  5、服务器验证token并且返回数据\n  每一次请求都需要token\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-108\">cookie与session区别</h4>\n<pre><code class=\"copyable\">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。\n  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-109\">session与token区别</h4>\n<pre><code class=\"copyable\">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App\n  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，\n     token不能转移到其他的App，也不能转到其他用户上。（适用于App）\n  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-110\">Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4>\n<pre><code class=\"copyable\">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）\n  2、安全性问题。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-111\">设计模式</h1>\n<blockquote>\n<p>一、观察者模式：<a target=\"_blank\" href=\"https://juejin.im/post/5a14e9edf265da4312808d86\" rel>juejin.im/post/5a14e9…</a>   <a target=\"_blank\" href=\"https://juejin.im/post/5af05d406fb9a07a9e4d2799\" rel>juejin.im/post/5af05d…</a>\n在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系\n简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p>\n</blockquote>\n<blockquote>\n<p>二、发布-订阅者  有一个信息中介，过滤 耦合性低\n它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p>\n</blockquote>\n<ul>\n<li>-两者的区别：\n1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信\n2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。\n3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（）\n4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-112\">数据结构和算法</h1>\n<h4 class=\"heading\" data-id=\"heading-113\">一、两个栈实现一个队列，两个队列实现一个栈 <a target=\"_blank\" href=\"https://www.cnblogs.com/MrListening/p/5697459.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/MrListening…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-114\">二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a target=\"_blank\" href=\"https://juejin.im/post/5a27c6946fb9a04509096248\" rel>juejin.im/post/5a27c6…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-115\">三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a target=\"_blank\" href=\"https://juejin.im/post/5a2ff8c651882533d0230a85\" rel>juejin.im/post/5a2ff8…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-116\">四、十大排序</h4>\n<pre><code class=\"copyable\">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。\n  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个\n\t    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n\t    3.针对所有的元素重复以上的步骤，除了最后一个\n\t    4.重复步骤1-3，直到排序完成。\n2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾\n  实现过程：\n\n3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入\n  实现过程：1.从第一个元素开始，该元素可以认为已经被排序\n\t    2.取出下一个元素，在已排序的元素序列中冲后向前扫描\n\t    3.如果该元素（以排序）大于新元素，将元素向后移一位\n\t    4.在取出一个元素，比较之前的，直到找到自己合适的位置\n\n4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序\n\n1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现\n  实现过程：1.从数组中挑出一个元素，成为一个基准\n\t    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）\n\t\t这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。\n\t    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序\n算法实现： function quickSort (arr) {\n\t\tif （arr.length <= 1） {return arr}\n\t\tvar destIndex = Math.floor(arr.length/2)\n\t\tvar left = [], right = [];\n\t\tvar dest = arr.splice(destIndex,1)[0];\n\t\tfor (var i =0;i<arr.length;i++){\n\t\t\tif (arr[i]<dest) {\n\t\t\tleft.push(arr[i])\n\t\t\t} else {\n\t\t\tright.push(arr[i]) }\n\t\treturn quickSort(left).concat([dest],quickSort(right)\n\t\t\t\n\n2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。\n  实现过程：1.\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-117\">五、数组去重 <a target=\"_blank\" href=\"https://juejin.im/post/5aed6110518825671b026bed#heading-6\" rel>juejin.im/post/5aed61…</a></h4>\n<pre><code class=\"copyable\">1.双重循环\n2.indexOf\n3.数组排序去重 最快你Olong\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-118\">六、字符串</h4>\n<pre><code class=\"copyable\">判断回文字符串：（递归的思想）\n\t1.字符串分隔，倒转，聚合[...obj].reverse().join('')\n\t2.字符串头部和尾部，逐次向中间检测 \n\t\t实现：function isPalindrome(line) {\n\t\t\tline += '';\n\t\t\tfor (var i=0,j=line.length-1;i<j;i++,j--) {\n\t\t\t\tif (line.chartAt(i) !== line.chartAt(j) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t3.递归\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-119\">七、二分查找（有序数组的查找）</h4>\n<pre><code class=\"copyable\"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数\n (1) 一开始,数据范围覆盖整个数组。\n (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。\n (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T\n代码实现：function binarySearch (data, dest, start, end){\n\t\tvar end = end || data.length-1;\n\t\tvar start = start || 0;\n\t\tvar m = Math.floor((start+end)/2);\n\t\tif (dest<data[m]){\n\t\t\treturn binarySearch(data, dest, 0, m-1)\n\t\t} else {\n\t\t\treturn binarySearch(data, dest, m+1, end)\n\t\t}}\n\t\treturn false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-120\">手写代码</h1>\n<h4 class=\"heading\" data-id=\"heading-121\">一、动手实现一个bind（原理通过apply，call）</h4>\n<pre><code class=\"copyable\">一句话概括：1.bind()返回一个新函数，并不会立即执行。\n\t    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数\n\t    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Function.prototype.bind = <span class=\"hljs-keyword\">function</span> (obj, arg) {\n   var arg = Array.prototype.slice.call(arguments, 1);\n   var context = this;\n   var bound = <span class=\"hljs-keyword\">function</span> (newArg) {\n   arg = arg.concat(Array.prototype.slice.call(newArg);\n   <span class=\"hljs-built_in\">return</span> context.apply(obj, arg)\n}\n  var F =  <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {}  // 在new一个<span class=\"hljs-built_in\">bind</span>会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程\n  F.prototype = context.prototype;\n  bound.prototype =  new F();\n  <span class=\"hljs-built_in\">return</span> bound;\n}\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-122\">二、 AJAX （异步的javascript和xml）</h4>\n<pre><code class=\"copyable\">ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。\n优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载\n      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带\n劣势：不支持back。对搜索引擎的支持比较弱；不容易调试\t\n怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，\n解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> getData(url) {\n    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象\n    xhr.open(<span class=\"hljs-string\">'get'</span>, url, <span class=\"hljs-literal\">true</span>)  // 设置一个http请求，设置请求的方式，url以及验证身份\n    xhr.send() //发送一个http请求\n    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  //设置一个http请求状态的函数\n      <span class=\"hljs-keyword\">if</span> (xhr.readyState == 4 && xhr.status ==200) {\n        console.log(xhr.responseText)  // 获取异步调用返回的数据\n      }\n    }\n  }\n  Promise(getData(url)).resolve(data => data)\n\n\t AJAX状态码：0 - （未初始化）还没有调用send()方法\n\t\t     1 - （载入）已调用send方法，正在发送请求\n\t\t     2 - （载入完成呢）send()方法执行完成\n\t\t     3 - （交互）正在解析相应内容\n\t\t     4 - （完成）响应内容解析完成，可以在客户端调用了\n```\n\n<span class=\"hljs-comment\">#### 三、函数节流（throttle）</span>\n```\n <span class=\"hljs-keyword\">function</span> throttle (func, <span class=\"hljs-built_in\">wait</span>) {\n        var timeout;\n        var previous = 0;\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n            context = this;\n            args = arguments;\n            <span class=\"hljs-keyword\">if</span> (!timeout) {\n                timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                    timeout = null;\n                    func.apply(context,args)\n                }, <span class=\"hljs-built_in\">wait</span>);\n            }\n        }\n    }\n     \n}\n```\n\n<span class=\"hljs-comment\">#### 四、函数防抖（dobounce）</span>\n```\n <span class=\"hljs-keyword\">function</span> debounce (func, <span class=\"hljs-built_in\">wait</span>) {\n         var timeout;\n         <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n             var context = this;\n             var args = arguments;\n             clearTimeout(timeout);\n             timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                 func.apply(context,args)\n             }, <span class=\"hljs-built_in\">wait</span>);\n         }\n     }\n```\n\n<span class=\"hljs-comment\">#### 五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span>\n```    \n    Object.prototype.clone = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> e <span class=\"hljs-keyword\">in</span> this) { //遍历对象的属性 <span class=\"hljs-keyword\">in</span>  this[e]\n        newObject[e] = typeof this[e] === <span class=\"hljs-string\">'object'</span> ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型\n      }\n      <span class=\"hljs-built_in\">return</span> newObject\n    }\n```\n \n<span class=\"hljs-comment\">#### 六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab</span>\n```\nclass Promise {\n  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。\n    this.status = <span class=\"hljs-string\">'pending'</span>,\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功存放的数组\n    this.onResolvedCallbacks = [];\n     // 失败存放法数组\n     this.onRejectedCallbacks = [];\n    <span class=\"hljs-built_in\">let</span> resolve = (value) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'resolve'</span>;\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n\n    <span class=\"hljs-built_in\">let</span> reject = (reason) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'reject'</span>;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  } \n  <span class=\"hljs-keyword\">then</span> (onFullFilled,onRejected) {\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'resolved'</span>) {\n      onFullFilled(this.value)\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'rejectd'</span>) {\n      onRejected(this.reason);\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n      this.onResolvedCallbacks.push(()=>{\n        onFullFilled(this.value);\n      })\n      this.onRejectedCallbacks.push(()=> {\n          onRejected(this.reason);\n      })\n  }\n   \n  }\n}\n\nconst p = new Promise((resolve, reject) => {\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n      resolve(<span class=\"hljs-string\">'hello world'</span>)\n  }, 1000);\n})\np.then((data) =>{\n  console.log(data)\n},(err) =>{\n  console.log(err);\n})\n```\n\n<span class=\"hljs-comment\">#### 七、发布订阅者模式（观察者模式）</span>\n```\nvar event = {}; // 发布者\nevent.clientList = [] //发布者的缓存列表\n\nevent.listen = <span class=\"hljs-keyword\">function</span> (fn) {  // 增加订阅者函数\n  this.clientList.push(fn)\n}\n\nevent.trigger = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  // 发布信息\n  <span class=\"hljs-keyword\">for</span> (var i =0;i<this.clientList.length;i++) {\n    var fn = this.clientList[i];\n    fn.apply(this, arguments);\n  }\n}\n\nevent.listen (<span class=\"hljs-keyword\">function</span>(time) {\n  console.log(<span class=\"hljs-string\">'正式上班时间为：'</span> +time)\n})\nevent.trigger (<span class=\"hljs-string\">'2018/7'</span>)\n```\n\n<span class=\"hljs-comment\">#### 八、手动写一个node服务器</span>\n```\nconst http = require(<span class=\"hljs-string\">'http'</span>);\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\nconst server = http.createServer((req,res) => {\n\t<span class=\"hljs-keyword\">if</span> (reu.url == <span class=\"hljs-string\">'/'</span>) {\n\tconst indexFile = fs.createReadStream(<span class=\"hljs-string\">'./index.html'</span>)\n\treq.writeHead(200,{<span class=\"hljs-string\">'context-Type'</span>:<span class=\"hljs-string\">'text/html;charset = utf8})\n\tindexFile.pipe(res)\n}\nserver.listen(8080)\n```</span><span class=\"copy-code-btn\">复制代码</span></code></pre>",
      "id": "1u7tueve3hts",
      "author": "voanit",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）"
    },
    {
      "content": "<blockquote>\n<p>vue or react？That's a question.</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>近两年前端技术层出不穷，目前市面上已经有了很多供前端人员使用的开发框架，转眼19年已过大半，前端框架领域日趋成熟，实现了三足鼎立的局面，截止到10月22日，Angular，react和vue数据统计如下图所示:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df1137a15df8d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"992\" data-height=\"178\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"992\" height=\"178\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>最近在学习使用框架的时候，分别使用vue和react开发了两个移动端产品，对这两个框架的学习曲线有了一些感悟，这两个都是现在比较热门的js框架，它俩在使用方式上和学习复杂度上还是有很大区别的，这里简单总结下两者的差异。</p>\n<p>主要从以下几个方面入手方面展开：</p>\n<ul>\n<li>框架的诞生</li>\n<li>设计思想</li>\n<li>编写语法</li>\n<li>脚手架构建工具</li>\n<li>数据绑定</li>\n<li>虚拟DOM</li>\n<li>指令</li>\n<li>性能优化</li>\n<li>原生渲染native</li>\n<li>ssr服务端渲染</li>\n<li>生命周期函数</li>\n<li>销毁组件</li>\n<li>状态集管理工具</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-1\">诞生</h2>\n<h4 class=\"heading\" data-id=\"heading-2\">vue</h4>\n<p>vue由尤雨溪开发，由独立团队维护，现在大部分的子项目都交给团队成员打理，Vue核心库依然主要由尤雨溪亲自维护。vue近几年来特别的受关注，三年前的时候angularJS霸占前端JS框架市场很长时间，接着react框架横空出世，因为它有一个特性是虚拟DOM，从性能上碾轧angularJS，这个时候，vue1.0悄悄的问世了，它的优雅，轻便也吸引了一部分用户，开始受到关注，16年中旬，VUE2.0问世，不管从性能上，还是从成本上都隐隐超过了react，火的一塌糊涂，这个时候，angular开发团队也开发了angular2.0版本，并且更名为angular，吸收了react、vue的优点，加上angular本身的特点，也吸引到很多用户，目前已经迭代到8.0了。友情提示注意下vue的诞生时间，如果正好有小伙伴在面试，被问到你是从什么时候开始接触并且使用vue的，你要是回答用了5、6年了那场面就十分尴尬了。</p>\n<h4 class=\"heading\" data-id=\"heading-3\">react</h4>\n<p>起初facebook在建设instagram（图片分享）的时候，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</p>\n<p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">设计思想</h2>\n<h4 class=\"heading\" data-id=\"heading-5\">vue</h4>\n<p>vue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计。这里我们需要明确一个概念，什么是渐进式框架。在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。</p>\n<h4 class=\"heading\" data-id=\"heading-6\">react</h4>\n<p>react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以手动实现，比如借助 onChange 和 setState 来实现一个双向的数据流。而vue是基于可变数据的，支持双向绑定，它提供了v-model这样的指令来实现文本框的数据流双向绑定。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">编写语法</h2>\n<h4 class=\"heading\" data-id=\"heading-8\">vue</h4>\n<p>vue推荐的做法是webpack+vue-loader的单文件组件格式，vue保留了html、css、js分离的写法，使得现有的前端开发者在开发的时候能保持原有的习惯，更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css。其中<style>标签还提供了一个可选的scoped属性，它会为组件内 CSS 指定作用域，用它来控制仅对当前组件有效还是全局生效。</p>\n<p>模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。</p>\n<p>同时vue也支持JSX语法，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">react</h4>\n<p>用过react的开发者可能知道，react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。在react中，所有的组件的渲染功能都依靠JSX。你可以在render()中编写类似XML的语法，它最终会被编译成原生JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。JSX是基于 JS 之上的一套额外语法，学习使用起来有一定的成本。</p>\n<h2 class=\"heading\" data-id=\"heading-10\">构建工具</h2>\n<h4 class=\"heading\" data-id=\"heading-11\">vue</h4>\n<p>vue提供了CLI 脚手架，可以帮助你非常容易地构建项目。全局安装之后，我们就可以用 vue create命令创建一个新的项目，vue 的 CLI 跟其他 CLI不同之处在于，有多个可选模板，有简单的也有复杂的，可以让用户自定义选择需要安装的模块，还可以将你的选择保存成模板，便于后续使用。</p>\n<p>极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。</p>\n<h4 class=\"heading\" data-id=\"heading-12\">react</h4>\n<p>React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：</p>\n<ul>\n<li>它不允许在项目生成时进行任何配置，而 Vue CLI 运行于可升级的运行时依赖之上，该运行时可以通过插件进行扩展。</li>\n<li>它只提供一个构建单页面应用的默认选项，而 Vue 提供了各种用途的模板。</li>\n<li>它不能用用户自建的预设配置构建项目，这对企业环境下预先建立约定是特别有用的。</li>\n</ul>\n<p>而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。</p>\n<h2 class=\"heading\" data-id=\"heading-13\">数据绑定</h2>\n<h4 class=\"heading\" data-id=\"heading-14\">vue</h4>\n<p>vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p>\n<p>Vue采用数据劫持&发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作。</p>\n<h4 class=\"heading\" data-id=\"heading-15\">react</h4>\n<p>react是单向数据流，react中属性是不允许更改的，状态是允许更改的。react中组件不允许通过this.state这种方式直接更改组件的状态。自身设置的状态，可以通过setState来进行更改。在setState中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受prevState和props。通过调用this.setState去更新this.state,不能直接操作this.state，请把它当成不可变的。<br>\n调用setState更新this.state，它不是马上就会生效的，它是异步的。所以不要认为调用完setState后可以立马获取到最新的值。多个顺序执行的setState不是同步的一个接着一个的执行，会加入一个异步队列，然后最后一起执行，即批处理。</p>\n<p>setState是异步的，导致获取dom可能拿的还是之前的内容，所以我们需要在setState第二个参数（回调函数）中获取更新后的新的内容。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">diff算法</h2>\n<h4 class=\"heading\" data-id=\"heading-17\">vue</h4>\n<p>vue中diff算法实现流程</p>\n<ol>\n<li>在内存中构建虚拟dom树</li>\n<li>将内存中虚拟dom树渲染成真实dom结构</li>\n<li>数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树</li>\n<li>将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。</li>\n<li>会将对比出来的差异进行重新渲染</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-18\">react</h4>\n<p>react中diff算法实现流程</p>\n<ol>\n<li>DOM结构发生改变-----直接卸载并重新create</li>\n<li>DOM结构一样-----不会卸载,但是会update变化的内容</li>\n<li>所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点<br>\n（其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）</li>\n</ol>\n<p>React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。</p>\n<p>vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。</p>\n<h2 class=\"heading\" data-id=\"heading-19\">指令</h2>\n<p>指令 (Directives) 是带有</p>\n<p>v- 前缀的特殊特性，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>\n<h4 class=\"heading\" data-id=\"heading-20\">vue</h4>\n<p>vue中提供很多内部指令供我们使用，它可以让我们进行一些模板的操作，例如有时候，我们的data中的存放的数据不是个简单的数字或者字符串，而是数组Array类型，这个时候，我们要把数组的元素展示在视图上，就需要用到vue提供的 v-for 指令，来实现列表的渲染。</p>\n<h4 class=\"heading\" data-id=\"heading-21\">react</h4>\n<p>因为react中没有v-for指令，所以循环渲染的时候需要用到map()方法来渲染视图，并且将符合条件的元素放入一个新数组返回。</p>\n<h2 class=\"heading\" data-id=\"heading-22\">性能优化</h2>\n<h4 class=\"heading\" data-id=\"heading-23\">vue</h4>\n<p>vue中的每个组件内部自动实现了</p>\n<p>shouldComponentUpdate的优化，在vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。而在react中我们需要手动去优化其性能，但是当数据特别多的时候vue中的watcher也会特别多，从而造成页面卡顿，所以一般数据比较多的大型项目会倾向于使用react。在react官网中，官方也建议我们使用React来构建快速响应的大型 Web 应用程序。</p>\n<h4 class=\"heading\" data-id=\"heading-24\">react</h4>\n<p>当props或state发生改变的时候会触发</p>\n<p>shouldComponentUpdate生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；如果它返回false，则不会触发重新渲染的过程。</p>\n<p>有的时候我们希望它在更新之前，和之前的状态进行一个对比，这个时候我们就需要重写</p>\n<p>shouldComponentUpdate来避免不必要的dom操作，对比当前的props或state和更新之后的nextProps或nextState，返回true时 ，组件更新；返回false，则不会更新，节省性能。</p>\n<pre><code class=\"copyable\">shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.a !== nextProps.a) {\n        return true;\n    }\n    if (this.state.b !== nextState.b) {\n        return true;\n    }\n    return false;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>我们也可以创建一个继承React.PureComponent的React组件，它自带</p>\n<p>shouldComponentUpdate，可以对props进行浅比较，发现更新之后的props与当前的props一样，就不会进行render了。</p>\n<p>classTestextendsReact.PureComponent{constructor(props){super(props);}render(){return<div>hello...{this.props.a}</div>}}</p>\n<p>由于React.PureComponent进行的是浅比较，也就是说它只会对比原对象的值是否相同，当我们的props或state为数组或者对象这种引用类型的时候，我们修改它的数值，由于数据引用指针没有发生改变，所以组件也是不会重新渲染的。这个时候我们就需要进行深拷贝，创建一个新的对象或数组，将原对象的各项属性的\"值\"（数组的所有元素）拷贝过来，是\"值\"而不仅仅是\"引用地址\"。我们可以使用slice()方法：</p>\n<p>ew_state.todos = new_state.todos.slice();</p>\n<p>或者引入immutable库来实现数据不可变。</p>\n<h2 class=\"heading\" data-id=\"heading-25\">原生渲染native</h2>\n<p>native指的是使用原生API来开发App，比如ios使用OC语言，android使用java。</p>\n<h4 class=\"heading\" data-id=\"heading-26\">vue</h4>\n<p>vue和Weex进行官方合作，weex是阿里巴巴发起的跨平台用户界面开发框架，它的思想是多个平台，只写一套代码，weex允许你使用 vue 语法开发不仅仅可以运行在浏览器端，还能被用于开发 iOS 和 Android 上的原生应用的组件。即只需要编写一份代码，即可运行在Web、iOS、Android上。</p>\n<p>weex相对来说上手比较简单，安装vue-cli之后就可以使用，学习门槛低，但是它的社区目前还处于成长期，react native的社区非常成熟活跃，有非常丰富的组件可供扩展。</p>\n<h4 class=\"heading\" data-id=\"heading-27\">react</h4>\n<p>react native是Facebook在2015年3月在F8开发者大会上开源的跨平台UI框架，需针对iOS、Android不同编写2份代码，使用react native需要按照文档安装配置很多依赖的工具，相对比较麻烦。weex的思想是多个平台，只写一套代码，而react-native的思想是多个平台可以写多套代码，但其使用的是同一套语言框架。<br>\nweex的目标在于抹平各个平台的差异性，从而简化应用开发。而react-native承认了各个平台之间的差异，退而求其次，在语言和框架层面对平台进行抽象，从方法论的角度去解决多平台开发的问题。</p>\n<h2 class=\"heading\" data-id=\"heading-28\">ssr服务端渲染</h2>\n<p>服务端渲染核心在于方便seo优化，后端先调用数据库，获得数据之后，将数据和页面元素进行拼装，组合成完整的html页面，再直接返回给浏览器，以便用户浏览。</p>\n<h4 class=\"heading\" data-id=\"heading-29\">vue</h4>\n<p>2016 年 10 月 25 日，zeit.co背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。</p>\n<p>服务端渲染支持流式渲染，因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。</p>\n<ul>\n<li>基于 Vue.js</li>\n<li>自动代码分层</li>\n<li>服务端渲染</li>\n<li>强大的路由功能，支持异步数据</li>\n<li>静态文件服务</li>\n<li>ES2015+ 语法支持</li>\n<li>打包和压缩 JS 和 CSS</li>\n<li>HTML 头部标签管理</li>\n<li>本地开发支持热加载</li>\n<li>集成 ESLint</li>\n<li>支持各种样式预处理器： SASS、LESS、 Stylus 等等</li>\n<li>支持 HTTP/2 推送</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-30\">react</h4>\n<p>Next是一个React框架，允许使用React构建SSR和静态web应用</p>\n<ul>\n<li>服务器渲染，获取数据非常简单</li>\n<li>无需学习新框架，支持静态导出。</li>\n<li>支持CSS-in-JS库</li>\n<li>自动代码拆分，加快页面加载速度，不加载不必要的代码</li>\n<li>基于Webpack的开发环境，支持模块热更新（HMR）</li>\n<li>支持Babel和Webpack自定义配置服务器、路由和next插件。</li>\n<li>能够部署在任何能运行node的平台</li>\n<li>内置页面搜索引擎优化（SEO）处理</li>\n<li>在生产环境下，打包文件体积更小，运行速度更快</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-31\">生命周期</h2>\n<h4 class=\"heading\" data-id=\"heading-32\">vue</h4>\n<p>【初始化阶段（4个）】</p>\n<p>（1）beforeCreate</p>\n<p>此钩子函数不能获取到数据，dom元素也没有渲染出来，此钩子函数不会用来做什么事情。</p>\n<p>（2）created</p>\n<p>此钩子函数，数据已经挂载了，但是dom节点还是没有渲染出来，在这个钩子函数里面，如果同步更改数据的话，不会影响运行中钩子函数的执行。可以用来发送ajax请求，也可以做一些初始化事件的相关操作。</p>\n<p>（3）beforeMount</p>\n<p>代表dom节点马上要被渲染出来了，但是还没有真正的渲染出来，此钩子函数跟created钩子函数基本一样，也可以做一些初始化数据的配置。</p>\n<p>（4）mounted</p>\n<p>是生命周期初始化阶段的最后一个钩子函数，数据已经挂载完毕了，真实dom也可以获取到了。</p>\n<p>【运行中阶段（2个）】</p>\n<p>（5）beforeUpdate</p>\n<p>运行中钩子函数beforeUpdate默认是不会执行的，当数据更改的时候，才会执行。数据更新的时候，先调用beforeUpdate，然后数据更新引发视图渲染完成之后，再会执行updated。运行时beforeUpdate这个钩子函数获取的数据还是更新之前的数据（获取的是更新前的dom内容），在这个钩子函数里面，千万不能对数据进行更改，会造成死循环。</p>\n<p>（6）updated</p>\n<p>这个钩子函数获取的数据是更新后的数据，生成新的虚拟dom，跟上一次的虚拟dom结构进行比较，比较出来差异（diff算法）后再渲染真实dom，当数据引发dom重新渲染的时候，在updated钩子函数里面就可以获取最新的真实dom了。</p>\n<p>【销毁阶段（2个）】</p>\n<p>（7）beforeDestroy</p>\n<p>切换路由的时候，组件就会被销毁了，销毁之前执行beforeDestroy。在这个钩子函数里面，我们可以做一些善后的操作，例如可以清空一下全局的定时器（created钩子函数绑定的初始化阶段的事件）、清除事件绑定。</p>\n<p>（8）destoryed</p>\n<p>组件销毁后执行destroyed，销毁后组件的双向数据绑定、事件监听watcher相关的都被移除掉了，但是组件的真实dom结构还是存在在页面中的。</p>\n<p>添加keep-alive标签后会增加active和deactive这两个生命周期函数，初始化操作放在actived里面，一旦切换组件，因为组件没有被销毁，所以它不会执行销毁阶段的钩子函数，所以移除操作需要放在deactived里面，在里面进行一些善后操作，这个时候created钩子函数只会执行一次，销毁的钩子函数一直没有执行。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16debf6f691f598a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-33\">react</h4>\n<p>【初始化阶段（5个）】：</p>\n<p>（1）getDefaultProps：实例化组件之后，组件的getDefaultProps钩子函数会执行</p>\n<p>这个钩子函数的目的是为组件的实例挂载默认的属性</p>\n<p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p>\n<p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p>\n<p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p>\n<p>（2）getInitialState：为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态。</p>\n<p>（3）componentWillMount：执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行。</p>\n<p>（4）render：渲染dom</p>\n<p>render()方法必须是一个纯函数，他不应该改变</p>\n<p>state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果</p>\n<p>shouldComponentUpdate()返回</p>\n<p>false，</p>\n<p>render()不会被调用。</p>\n<p>（5）componentDidMount：相当于Vue里的mounted,多用于操作真实dom</p>\n<p>【运行中阶段（5个）】</p>\n<p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p>\n<p>（1）componentWillReceiveProps(nextProps,nextState)</p>\n<p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行。初始化props时候不会主动执行</p>\n<p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态。</p>\n<p>（2）接下来就会执行shouldComponentUpdate(nextProps,nextState),这个函数的作用：当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true。</p>\n<p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p>\n<p>如果</p>\n<p>shouldComponentUpdate()返回</p>\n<p>false，</p>\n<p>componentWillUpdate,</p>\n<p>render和</p>\n<p>componentDidUpdate不会被调用。</p>\n<p>（3）componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环 相当于Vue中的beforeUpdate</p>\n<p>（4）render，重新渲染dom</p>\n<p>（5）componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p>\n<p>【销毁阶段】</p>\n<p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p>\n<p>相当于Vue里的beforeDestroy，所以说一般会做一些善后的事情，例如使定时器无效，取消网络请求或清理在</p>\n<p>componentDidMount中创建的任何监听。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16debf7c76553b3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"730\" data-height=\"768\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"730\" height=\"768\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-34\">销毁组件</h2>\n<h4 class=\"heading\" data-id=\"heading-35\">vue</h4>\n<p>vue在调用$destroy方法的时候就会执行beforeDestroy生命周期函数，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed生命周期函数中处理。</p>\n<h4 class=\"heading\" data-id=\"heading-36\">react</h4>\n<p>react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，也就是说当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁，所以根本不需要其他的钩子函数了。react销毁组件的时候，会将组件的dom结构也移除，vue则不然，在调用destory方法销毁组件的时候，组件的dom结构还是存在于页面中的，this.$destory组件结构还是存在的，只是移除了事件监听，所以这就是为什么vue中有destroyed，而react却没有componentDidUnmount。</p>\n<h2 class=\"heading\" data-id=\"heading-37\">状态集管理工具</h2>\n<h4 class=\"heading\" data-id=\"heading-38\">vue</h4>\n<p>vuex是一个专门为vue构建的状态集管理工具，vue和react都是基于组件化开发的，项目中包含很多的组件，组件都会有组件嵌套，想让组件中的数据被其他组件也可以访问到就需要使用到Vuex。</p>\n<p>vuex的流程</p>\n<ol>\n<li>将需要共享的状态挂载到state上：this.$store.state来调用</li>\n</ol>\n<p>创建store，将状态挂载到state上，在根实例里面配置store，之后我们在组件中就可以通过this.$store.state来使用state中管理的数据，但是这样使用时，当state的数据更改的时候，vue组件并不会重新渲染，所以我们要通过计算属性computed来使用，但是当我们使用多个数据的时候这种写法比较麻烦，vuex提供了mapState辅助函数，帮助我们在组件中获取并使用vuex的store中保存的状态。</p>\n<ol>\n<li>我们通过getters来创建状态：通过this.$store.getters来调用</li>\n</ol>\n<p>可以根据某一个状态派生出一个新状态，vuex也提供了mapGetters辅助函数来帮助我们在组件中使用getters里的状态。</p>\n<ol>\n<li>使用mutations来更改state：通过this.$store.commit来调用</li>\n</ol>\n<p>我们不能直接在组件中更改state，而是需要使用mutations来更改，mutations也是一个纯对象，里面包含很多更改state的方法，这些方法的形参接收到state，在函数体里更改，这时，组件用到的数据也会更改，实现响应式。vuex提供了mapMutations方法来帮助我们在组件中调用mutations 的方法。</p>\n<ol>\n<li>使用actions来处理异步操作：this.$store.dispatch来调用</li>\n</ol>\n<p>Actions类似于mutations，不同在于：Actions提交的是mutations，而不是直接变更状态。Actions可以包含任意异步操作。也就是说，如果有这样的需求：在一个异步操作处理之后，更改状态，我们在组件中应该先调用actions，来进行异步动作，然后由actions调用mutations来更改数据。在组件中通过this.$store.dispatch方法调用actions的方法，当然也可以使用mapMutations来辅助使用。</p>\n<h4 class=\"heading\" data-id=\"heading-39\">react</h4>\n<p>2015年Redux出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。它的出现主要是为解决react中组件之间的通信问题。建议把数据放入到redux中管理，目的就是方便数据统一，好管理。项目一旦出现问题，可以直接定位问题点。组件扩展的时候，后续涉及到传递的问题。本来的话，组件使用自己的数据，但是后来公用组件，还需要考虑如何值传递，在redux中可以存储至少5G以上的数据。</p>\n<p>redux的流程</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16debf86d5319f37?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"657\" data-height=\"448\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"657\" height=\"448\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol>\n<li>创建store： 从redux工具中取出createStore去生成一个store。</li>\n<li>创建一个reducer，然后将其传入到createStore中辅助store的创建。 reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态。 想要给store创建默认状态其实就是给reducer一个参数创建默认值。</li>\n<li>组件通过调用store.getState方法来使用store中的state，挂载在了自己的状态上。</li>\n<li>组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducer</li>\n<li>reducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态，这个时候store的数据就会发生改变， reducer返回什么状态，store.getState就可以获取什么状态。</li>\n<li>我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-40\">小结</h2>\n<p>vue和react的核心都是专注于轻量级的视图层，虽然只是解决一个很小的问题，但是它们庞大的生态圈提供了丰富的配套工具，一开始它并不会给你提供全套的配置方案，将所有的功能都一次性给你打包好，它只会给你提供一些简单的核心功能，当你需要做一个更复杂的应用时，再增添相应的工具。例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。</p>\n<p>框架的存在就是为了帮助我们应对不同的项目复杂度，当我们面对一个大型、复杂的开发项目时，使用太简陋的工具会极大的降低开发人员的生产力，影响工作效率，框架的诞生就是在这些工程中提取一些重复的并且已经受过验证的模式，抽象到一个已经帮你设计好的API封装当中，帮助我们去应对不同复杂度的问题。所以在开发的过程中，选择一个合适的框架就会事半功倍。但是，框架本身也有复杂度，有些框架会让人一时不知如何上手。当你接到一个并不复杂的需求，却使用了很复杂的框架，那么就相当于杀鸡用牛刀，会遇到工具复杂度所带来的副作用，不仅会失去工具本身所带来优势，还会增加各种问题，例如学习成本、上手成本，以及实际开发效率等。</p>\n<p>所以并不是说做得少的框架就不如做的做的框架，每个框架都有各自的优势和劣势，并不能找到完全符合需求的框架，最重要的适合当前项目，目前两大框架的生态圈一片繁荣，react社区是当前最活跃的，最快的时候三天更新一个版本，一个问题可能存在几十种不同的解决方案，这就需要我们前端人员去在不同的功能之间做取舍，以后前端框架的发展方向应该是小而精、灵活以及开放的，核心功能+生态附加库可以帮我们更加灵活的构建项目，为了跟上前进的脚步，就需要不停的吸收最新的内容，这也是从事前端开发领域的一大乐趣，希望大家都能在学习中获得长足的进步。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16debf90bf4c9fc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"702\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"702\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-41\">彩蛋</h2>\n<p>以上为本期介绍，您可以关注我的公众号前端之阶，关注更多前端知识，获取前端大群，里面很多知名互联网前端朋友，前端技术更新太快，不能被落伍淘汰，共同学习，共同进步！</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/19/16de1b4fe1ef8b4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "6gsoi8c7ag40",
      "author": "取舍🍂",
      "title": "前端框架用vue还是react？清晰对比两者差异"
    },
    {
      "content": "<p>最近手有点痒琢磨着做个啥,朝思暮想还是写个KTV点歌系统,模拟了一下KTV开户的思路,7天累死我了,不过技术点还挺多的,希望你可以看完（〜^㉨^)〜</p>\n<p><strong>用Node(Express)教你写KTV点歌系统，包括前台内容和后台管理系统，整合Express框架和Mongodb数据库服务器开发；教你用Vue.JS，ElementUI和iViewUI写出超漂亮的页面,随心点歌随心听</strong></p>\n<blockquote class=\"warning\"><p>作者原创文章, 转载前请留言或联系作者!!!\n</p></blockquote><h1 class=\"heading\" data-id=\"heading-0\">思维导图</h1>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8c870a352432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1061\" data-height=\"595\" src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8c870a352432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-1\"><strong>技术栈</strong></h1>\n<ul>\n<li>\n<p>后端： Express + Mongodb + jsonwebtoken等等</p>\n</li>\n<li>\n<p>前端： Vue.JS + ElementUI + iViewUI + Axios等等</p>\n</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-2\"><strong>功能介绍</strong></h1>\n<p><strong>本项目分前台开发,后台开发和服务器开发</strong></p>\n<ul>\n<li>用户听歌需要登录(路由守卫)</li>\n<li>用户需要到管理员申请账号和密码</li>\n<li>用户登录听歌(风格点歌,语种点歌,明星点歌,热门歌曲等等...)</li>\n<li>剩余时长30分钟提醒,到时间自动下机</li>\n<li>管理员对歌曲的增删改查</li>\n<li>管理员给用户开户,可以选择上机的时间</li>\n<li>管理员查看订单,删除订单,搜索订单</li>\n<li>管理员收藏歌曲,推荐到ktv推荐歌曲</li>\n<li>等等...</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-3\"><strong>项目设计结构</strong></h1>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">-- 服务器基本架构\nktv-select_music-system\n├── README.md\n├── index.js  -- 后台文件入口\n├── test.http  -- 测试文件\n├── api  -- 路由文件\n│    ├── admin.js  -- 配置管理员的操作\n|    ├── music.js  -- 配置歌曲信息\n|    ├── user.js  -- 配置用户的相关操作\n|    └── safecode.js  -- 配置安全码\n├── config -- 配置\n|    ├── Date.js  -- 配置日期格式化插件\n|    ├── delNoUse.js  -- 封装闲置删除闲置资源方法\n|    ├── http.js  -- 配置跨域\n|    ├── isBadAccount.js  -- 封装账户是否合法\n|    ├── newaccount.js  -- 封装随机开户方法\n|    ├── passport.js  -- 验证token是否合法\n|    ├── uploadImg.js  -- 封装上传图片方法\n|    └── uploadMusic.js  -- 封装上传歌曲方法\n├── ktv-admin  --后台管理系统界面\n├── ktv-client  --前台用户点歌项目界面\n├── dbModel\n|    └── **  -- Mongodb数据库的一些模型\n├── mongodb\n|    └── mongodb.js  -- 配置Mongodb,链接数据库 \n├── secret\n|    ├── mongodbURI.js  -- Mongodb地址\n|    └── jwtkey.js  -- token的私钥\n├── static -- 资源存放处\n|    ├── music  -- 歌曲上传目标文件夹 \n|    ├── poster  -- 歌曲海报上传目标文件夹\n└──  └── view  -- 配置404文件\n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs bash copyable\" lang=\"bash\">-- 后台管理系统架构\nktv-admin\n├── README.md\n├── public \n|    ├── index.html  -- vue挂载页面\n|    └── **  -- 你可以在这里链接少量静态资源\n├── src  -- 开发文件夹\n|    ├── App.vue  -- Vue挂载根页面\n|    ├── main.js  -- Vue程序入口文件,挂载各种组件\n|    ├── router.js  -- Vue路由配置文件\n|    ├── store.js  -- Vuex的状态管理文件\n|    ├── assets  -- 静态资源文件夹\n|    ├── components  --公共组件\n|    |      └── nav.vue  -- 后台导航栏\n|    ├── plugins  --插件\n|    |      ├── axios.js   -- 配置跨域,拦截器等等 \n|    |      ├── Date.js   -- 格式化日期 \n|    |      └── Date.js   -- 加载动画Loading\n|    ├── stores  -- 状态管理文件夹\n|    |      └── adminStore.js  -- 管理员状态 \n|    ├── views  -- 页面文件夹\n|    |      ├── 404.vue   -- 404页面\n|    |      ├── adminlikes.vue   -- 管理员处理ktv收藏歌曲\n|    |      ├── allorders.vue   -- 订单管理\n|    |      ├── Home.vue   -- 后台根页面\n|    |      ├── Index.vue   -- 后台首页\n|    |      ├── managemusic.vue   -- 音乐管理\n|    |      ├── user_service.vue   -- 给用户开户\n|    |      └── login.vue   -- 后台登录\n└── babel.config.js  -- babel配置\n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs bash copyable\" lang=\"bash\">\n-- 前台用户听歌架构\nktv-client\n├── README.md\n├── public \n|    ├── index.html  -- vue挂载页面\n|    └── **  -- 你可以在这里链接少量静态资源\n├── src  -- 开发文件夹\n|    ├── App.vue  -- Vue挂载根页面\n|    ├── main.js  -- Vue程序入口文件,挂载各种组件\n|    ├── router.js  -- Vue路由配置文件\n|    ├── store.js  -- Vuex的状态管理文件\n|    ├── assets  -- 静态资源文件夹\n|    ├── components  --公共组件\n|    |      ├── bottomNav.vue  -- 底部音乐控制区域\n|    |      └── topNav.vue  -- 顶部信息区域\n|    ├── config  --配置\n|    |      ├── addSong.js    --封装选取歌曲方法\n|    |      ├── isBadAccount.js    --验证账户合法性\n|    |      ├── isLogin.js    --是否登录\n|    |      ├── nextSong.js    --封装下一首歌曲方法\n|    |      └── prevSong.js    --封装上一首歌曲方法\n|    ├── plugins  --插件\n|    |      ├── axios.js   -- 配置跨域,拦截器等等 \n|    |      └── wsmLoading.js   -- 加载动画Loading\n|    ├── stores  -- 状态管理文件夹\n|    |      └── song.js  -- 存储歌曲信息 \n|    ├── views  -- 页面文件夹\n|    |      ├── 404.vue   -- 404页面\n|    |      ├── abc.vue   -- 拼音点歌\n|    |      ├── artist.vue   -- 明星点歌\n|    |      ├── Home.vue   -- 后台根页面\n|    |      ├── Index.vue   -- 后台首页\n|    |      ├── hot.vue   -- 热播歌曲\n|    |      ├── ktvlikes.vue   -- ktv推荐歌曲\n|    |      ├── selected.vue   -- 已选歌曲\n|    |      ├── style.vue   -- 风格点歌\n|    |      └── language.vue   -- 语种点歌\n├── babel.config.js  -- babel配置\n└── vue.config.js  -- vue配置\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-4\"><strong>项目启动介绍</strong></h1>\n<h2 class=\"heading\" data-id=\"heading-5\">首先</h2>\n<ol>\n<li>\n<p>首先不要改变服务器端口,否则报错.</p>\n</li>\n<li>\n<p>你需要在装有Node和Vue的环境中测试，如果其中一个没有请先下载(<a target=\"_blank\" href=\"https://nodejs.org/en/\" rel=\"nofollow noopener noreferrer\">Node下载</a>,<a target=\"_blank\" href=\"https://cn.vuejs.org/v2/guide/installation.html\" rel=\"nofollow noopener noreferrer\">Vue下载</a>).</p>\n</li>\n<li>\n<p>首先在最外层文件夹下载依赖:npm install 下载后端依赖,</p>\n</li>\n<li>\n<p>接着进入ktv-client, npm install 下载用户前端依赖.</p>\n</li>\n<li>\n<p>接着进入ktv-admin, npm install 下载管理员前端依赖.</p>\n</li>\n<li>\n<p>以上工作完成后,使用命令<code>npm run server 或者 node index</code>命令启动Node服务器，启动成功会显示:</p>\n<p><strong>Server is running on port [8633].</strong></p>\n<p><strong>Mongodb is Connected.Please have a great coding.</strong></p>\n</li>\n<li>\n<p>进入ktv-client,打开命令板,使用命令<code>npm run client</code>启动前台用户项目,启动成功后用浏览器访问<code>http://localhost:xxxx</code></p>\n</li>\n<li>\n<p>进入ktv-admin,打开命令板,使用命令<code>npm run admin</code>启动后台管理系统项目,启动成功后用浏览器访问<code>http://localhost:xxxx</code></p>\n</li>\n<li>\n<p>本例中将Mongodb部署在本地电脑上，如果你仔细阅读了这篇文档，启动项目应该是很容易的。如果你把Mongodb部署在其他地方，请自行修改<code>secret/mongodbURI.js</code>配置文件信息。</p>\n</li>\n<li>\n<p>项目启动成功,最好用 chrome 浏览器打开, 美化了滚动条</p>\n</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-6\">接着注册管理员账号</h2>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">admin.js最下面有个注册接口\n\n// 管理员注册\nrouter.post(<span class=\"hljs-string\">\"/account/register\"</span>, (req, res) => {\n    const email = req.body.email;\n    Admin.findOne({email})\n        .then(hasOne => {\n            <span class=\"hljs-keyword\">if</span>(hasOne){\n                <span class=\"hljs-built_in\">return</span> req.status(422).json({status:<span class=\"hljs-string\">\"422\"</span>, result:<span class=\"hljs-string\">\"邮箱被占用\"</span>});\n            }<span class=\"hljs-keyword\">else</span>{\n                const username = req.body.username;\n                const password = req.body.password;\n                const identity = req.body.identity ? req.body.identity : null;\n                const date = new Date().format(<span class=\"hljs-string\">\"yyyy/MM/dd HH:mm:ss\"</span>);\n                const newAdmin = new Admin({\n                    email,\n                    username,\n                    password,\n                    identity,\n                    date\n                });\n                newAdmin.save()\n                    .then(() => {\n                        res.json({status:<span class=\"hljs-string\">\"200\"</span>, result:<span class=\"hljs-string\">\"注册成功\"</span>})\n                    }).catch(err => {\n                        console.log(err);\n                        res.status(500).json({status:<span class=\"hljs-string\">\"500\"</span>, result:<span class=\"hljs-string\">\"未知错误,注册失败\"</span>})\n                    })\n            }\n        })\n})\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><strong>然后用postman注册或者其他工具</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dedaeaef585ff1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"744\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"744\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-7\">技术攻关</h1>\n<h2 class=\"heading\" data-id=\"heading-8\">Date方法</h2>\n<p>由于脑袋不好使的原因加上js没有元素格式化日期的方法,就瞎掰一个(值得学习)</p>\n<p><strong>Date.js</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">\n/** \n*\n*  @author: Mr_Wei \n*  @version: 1.0.0 \n*  @description: 格式化日期\n*  @Date: 2019/10/16 09:32\n*\n*/ \n\nDate.prototype.format = <span class=\"hljs-keyword\">function</span>(format) {\n    var o = {\n\t\t<span class=\"hljs-string\">\"M+\"</span>: this.getMonth() + 1, //月份\n\t\t<span class=\"hljs-string\">\"d+\"</span>: this.getDate(), //日\n\t\t<span class=\"hljs-string\">\"H+\"</span>: this.getHours(), //小时\n\t\t<span class=\"hljs-string\">\"m+\"</span>: this.getMinutes(), //分\n\t\t<span class=\"hljs-string\">\"s+\"</span>: this.getSeconds(), //秒\n\t\t<span class=\"hljs-string\">\"q+\"</span>: Math.floor((this.getMonth() + 3) / 3), //季度\n\t\t<span class=\"hljs-string\">\"f+\"</span>: this.getMilliseconds() //毫秒\n\t};\n\t<span class=\"hljs-keyword\">if</span> (/(y+)/.test(format))\n\t\tformat = format.replace(RegExp.<span class=\"hljs-variable\">$1</span>, (this.getFullYear() + <span class=\"hljs-string\">\"\"</span>).substr(4 - RegExp.<span class=\"hljs-variable\">$1</span>.length));\n\t<span class=\"hljs-keyword\">for</span> (var k <span class=\"hljs-keyword\">in</span> o)\n\t\t<span class=\"hljs-keyword\">if</span> (new RegExp(<span class=\"hljs-string\">\"(\"</span> + k + <span class=\"hljs-string\">\")\"</span>).test(format))\n\t\t\tformat = format.replace(RegExp.<span class=\"hljs-variable\">$1</span>, (RegExp.<span class=\"hljs-variable\">$1</span>.length == 1) ? (o[k]) : ((<span class=\"hljs-string\">\"00\"</span> + o[k]).substr((<span class=\"hljs-string\">\"\"</span> + o[k]).length)));\n\t<span class=\"hljs-built_in\">return</span> format;\n}\n\n<span class=\"hljs-built_in\">export</span> default Date.prototype.format\n\n\n然后我们使用其格式日期\nrequire(Date);\n// const now = new Date().format(<span class=\"hljs-string\">\"yyyy/MM/dd HH:mm:ss.S\"</span>);\nconst now = new Date().format(<span class=\"hljs-string\">\"yyyy/MM/dd HH:mm:ss\"</span>);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-9\">验证码(svg-captcha)</h2>\n<p>svg-captcha验证码的运用,防止暴力破解密码,加强安全性.\n详细的文档地址：<a target=\"_blank\" href=\"https://www.npmjs.com/package/svg-captcha\" rel=\"nofollow noopener noreferrer\">svg-captcha</a></p>\n<p><strong>使用验证码</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 后台生成验证码\nrouter.get(<span class=\"hljs-string\">\"/getCaptcha\"</span>, (req, res) => {\n    var captcha = svgCaptcha.create({  \n        // 翻转颜色  \n        inverse: <span class=\"hljs-literal\">false</span>,  \n        // 字体大小  \n        fontSize: 38,  \n        // 噪声线条数  \n        noise: 3,  \n        // 宽度  \n        width: 80,  \n        // 高度  \n        height: 32,  \n      });  \n      // 保存到session,忽略大小写  \n      req.session = captcha.text.toLowerCase(); \n      console.log(req.session); //0xtg 生成的验证码\n      //保存到cookie 方便前端调用验证\n      res.cookie(<span class=\"hljs-string\">'captcha'</span>, req.session); \n      res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'image/svg+xml'</span>);\n      res.send(String(captcha.data));\n      res.end();\n})\n\n\n// 前台获取验证码\n--HTML\n<img width=<span class=\"hljs-string\">\"80\"</span> style=<span class=\"hljs-string\">\"background:#EEE9E9;margin-left:30px;\"</span> ref=<span class=\"hljs-string\">\"captcha\"</span> height=<span class=\"hljs-string\">\"32\"</span> src=<span class=\"hljs-string\">\"http://localhost:3001/api/user/getCaptcha\"</span> @click=<span class=\"hljs-string\">\"refreshCaptcha\"</span>>\n\n--js\n// 获取验证码cookie\ngetCookie(cname){\n    var name = cname + <span class=\"hljs-string\">\"=\"</span>;\n    var ca = document.cookie.split(<span class=\"hljs-string\">';'</span>);\n    <span class=\"hljs-keyword\">for</span>(var i=0; i<ca.length; i++){\n        var c = ca[i].trim();\n        <span class=\"hljs-keyword\">if</span> (c.indexOf(name)==0) <span class=\"hljs-built_in\">return</span> c.substring(name.length,c.length);\n    }\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">\"\"</span>;\n},\n// 刷新验证码\n<span class=\"hljs-function\"><span class=\"hljs-title\">refreshCaptcha</span></span>(){\n    this.<span class=\"hljs-variable\">$refs</span>.captcha.src = <span class=\"hljs-string\">\"http://localhost:3001/api/user/getCaptcha?d=\"</span> + Math.random();\n},\n\n最后用 填写的验证码进行对比\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8e22c5ac4cf4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"686\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"686\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8e2a4b88adbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1204\" data-height=\"729\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1204\" height=\"729\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">上传歌曲或图片</h2>\n<p>formidable来处理文件上传信息,用起来方便,很友好,如果你没有接触过文件操作,赶紧收藏起来</p>\n<p><strong>封装歌曲方法uploadMusic.js</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/** \n*\n*  @author: Mr_Wei \n*  @version: 1.0.0 \n*  @description: 封装上传音乐方法\n*  @Date: 2019/10/16 08:35\n*\n*/ \n\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\nconst path = require(<span class=\"hljs-string\">'path'</span>);\nconst formidable = require(<span class=\"hljs-string\">'formidable'</span>);  // 文件处理库\nconst formatTime = require(<span class=\"hljs-string\">'silly-datetime'</span>);  // 格式化数据\n\nmodule.exports = (req, res) => {\n    \n    <span class=\"hljs-built_in\">let</span> form = new formidable.IncomingForm();  //创建上传表单\n    form.encoding = <span class=\"hljs-string\">'utf-8'</span>;  // 设置编码格式\n    form.uploadDir = path.join(__dirname, <span class=\"hljs-string\">'../static/music'</span>); // 设置上传目录(这个目录必须先创建好)\n    form.keepExtensions = <span class=\"hljs-literal\">true</span>;  // 保留文件后缀名\n    form.maxFieldsSize = 20 * 1024 *1024; // 设置文件大小\n\n    /* 格式化form数据 */\n    form.parse(req, (err, fields, files) => {\n        <span class=\"hljs-built_in\">let</span> file = files.file;\n        /* 获取异常 */\n        <span class=\"hljs-keyword\">if</span>(err) {\n            <span class=\"hljs-built_in\">return</span> res.status(500).json({<span class=\"hljs-string\">'status'</span>: 500, result: <span class=\"hljs-string\">'服务器内部错误'</span>});\n        }\n        <span class=\"hljs-keyword\">if</span>(file.size > form.maxFieldsSize) {\n            fs.unlink(file.path);\n            <span class=\"hljs-built_in\">return</span> res.status(412).json({<span class=\"hljs-string\">'status'</span>: 412, result: <span class=\"hljs-string\">'音频不能超过20M'</span>});\n        }\n\n        /* 存储后缀名 */\n        <span class=\"hljs-built_in\">let</span> extName = <span class=\"hljs-string\">''</span>;\n        switch (file.type) {\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'audio/mp3'</span>:\n                extName = <span class=\"hljs-string\">'mp3'</span>;\n                <span class=\"hljs-built_in\">break</span>;\n        }\n        <span class=\"hljs-keyword\">if</span>(extName.length == 0) {\n            fs.unlink(file.path);\n            <span class=\"hljs-built_in\">return</span> res.status(412).json({<span class=\"hljs-string\">'status'</span>: 412, result: <span class=\"hljs-string\">'只支持mp3格式音频'</span>});\n        }\n        /* 拼接新的文件名 */\n        <span class=\"hljs-built_in\">let</span> time = formatTime.format(new Date(), <span class=\"hljs-string\">'YYYYMMDDHHmmss'</span>);\n        <span class=\"hljs-built_in\">let</span> num = Math.floor(Math.random() * 8999 + 10000);\n        <span class=\"hljs-built_in\">let</span> songName = `<span class=\"hljs-variable\">${time}</span>_<span class=\"hljs-variable\">${num}</span>.<span class=\"hljs-variable\">${extName}</span>`;\n        <span class=\"hljs-built_in\">let</span> newPath = form.uploadDir + <span class=\"hljs-string\">'/'</span> + songName;\n\n        /* 更改名字和路径 */\n        fs.rename(file.path, newPath, (err) => {\n            <span class=\"hljs-keyword\">if</span>(err) {\n                <span class=\"hljs-built_in\">return</span> res.status(500).json({<span class=\"hljs-string\">'status'</span>: 500, result: <span class=\"hljs-string\">'音频上传失败'</span>});\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-built_in\">return</span> res.send({<span class=\"hljs-string\">'status'</span>: 200, <span class=\"hljs-string\">'msg'</span>: <span class=\"hljs-string\">'音频上传成功'</span>, result: {src: songName}});\n            }\n        })\n        \n    })\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8ea6335135f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"626\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"626\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8fad5128bfac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1186\" data-height=\"617\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1186\" height=\"617\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">Vue、ElementUI分页使用</h2>\n<p>关于ElementUI分页详细请见：<a target=\"_blank\" href=\"https://element.eleme.cn/#/zh-CN/component/pagination\" rel=\"nofollow noopener noreferrer\">ElementUI的Pagination分页学习</a></p>\n<p><strong>上图</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">-- html\n<el-pagination\n    v-if=<span class=\"hljs-string\">'paginations.total > 0'</span>\n    :page-sizes=<span class=\"hljs-string\">\"paginations.page_sizes\"</span>\n    :page-size=<span class=\"hljs-string\">\"paginations.page_size\"</span>\n    :layout=<span class=\"hljs-string\">\"paginations.layout\"</span>\n    :total=<span class=\"hljs-string\">\"paginations.total\"</span>\n    :current-page.sync=<span class=\"hljs-string\">'paginations.page_index'</span>\n    @current-change=<span class=\"hljs-string\">'handleCurrentChange'</span>\n    @size-change=<span class=\"hljs-string\">'handleSizeChange'</span>>\n</el-pagination>\n\n-- js\n<span class=\"hljs-function\"><span class=\"hljs-title\">data</span></span>(){\n    <span class=\"hljs-built_in\">return</span>{\n        allUsers:[],  // 用来存储最终信息, 被显示的dom点调用\n        allTableData:[],  // 用户承接分页设置的数据\n        paginations: {   // 分页组件信息\n            page_index: 1, // 当前位于哪页\n            total: 0, // 总数\n            page_size: 5, // 1页显示多少条\n            page_sizes: [5, 10, 15, 20], //每页显示多少条\n            layout: <span class=\"hljs-string\">\"total, sizes, prev, pager, next, jumper\"</span> // 翻页属性\n        },\n    }\n},\nmethods:{\n    // 获取当前页\n    handleCurrentChange(page) {\n        <span class=\"hljs-built_in\">let</span> sortnum = this.paginations.page_size * (page - 1);\n        <span class=\"hljs-built_in\">let</span> table = this.allTableData.filter((item, index) => {\n            <span class=\"hljs-built_in\">return</span> index >= sortnum;\n        });\n        // 设置默认分页数据\n        this.getAllUsers = table.filter((item, index) => {\n            <span class=\"hljs-built_in\">return</span> index < this.paginations.page_size;\n        });\n        this.getAllUsers = table.filter((item, index) => {\n            <span class=\"hljs-built_in\">return</span> index < this.paginations.page_size;\n        });\n    },\n    // 切换size\n    handleSizeChange(page_size) {\n        this.paginations.page_index = 1;\n        this.paginations.page_size = page_size;\n        this.getAllUsers = this.allTableData.filter((item, index) => {\n            <span class=\"hljs-built_in\">return</span> index < page_size;\n        });\n    },\n     // 总页数\n    <span class=\"hljs-function\"><span class=\"hljs-title\">setPaginations</span></span>() {\n        this.paginations.total = this.allTableData.length;\n        this.paginations.page_index = 1;\n        this.paginations.page_size = 5;\n        // 设置默认分页数据\n        this.getAllUsers = this.allTableData.filter((item, index) => {\n            <span class=\"hljs-built_in\">return</span> index < this.paginations.page_size;\n        });\n    },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8ebd6a9c80af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1139\" data-height=\"403\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1139\" height=\"403\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>没了吗?对,分页就是这么简单!你学会了吗?有些前端开发的同学总是对分页比较陌生,学会这个,让你不再产生烦恼!</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-12\">token和自定义验证合法性</h2>\n<p>jsonwebtoken是对用户信息加密成不可逆向破解的token.关于passport-jwt，是用来对用户请求时所带的token信息进行过期验证,如果超过签证的合法时间,则会请前台发出token失效的信息,提示用户重新获取合法的token信息,否则无法继续请求加密的信息；</p>\n<p><strong>用法</strong></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">- passport-jwt\nconst key = require(<span class=\"hljs-string\">\"../config/keys\"</span>).KEYORSECRET;\nconst JwtStrategy = require(<span class=\"hljs-string\">'passport-jwt'</span>).Strategy,\n      ExtractJwt = require(<span class=\"hljs-string\">'passport-jwt'</span>).ExtractJwt;\nvar opts = {}\nopts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();\nopts.secretOrKey = key;\n\nmodule.exports = passport => {\n    passport.use(new JwtStrategy(opts, (jwt_payload, <span class=\"hljs-keyword\">done</span>) => {\n        UserInfo.findById(jwt_payload.id)\n                .then(user => {\n                    <span class=\"hljs-keyword\">if</span> (user) {\n                        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-keyword\">done</span>(null, user);\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-keyword\">done</span>(null, <span class=\"hljs-literal\">false</span>);\n                        // or you could create a new account\n                    }\n                })\n    }));\n}\n\n\n\n// 设置token\n// 规则\n const rule = {\n    id:String(userinfo._id),\n    username:userinfo.username,\n    email:userinfo.email,\n    date:user.date,\n    signdate:userinfo.signdate,\n    signcount:userinfo.signcount,\n    avatar:userinfo.avatar,\n    phone:userinfo.phone\n};\n\n// 签证加密\n// jwt.sign(规则, key(私钥), {配置:比如过期时长}, (err, token){ 响应程序 })\njwt.sign(rule,key,{expiresIn:7200},(err, token) => {\n    <span class=\"hljs-keyword\">if</span>(err) throw err;\n    res.json({<span class=\"hljs-string\">\"token\"</span> : <span class=\"hljs-string\">\"Bearer \"</span> + token})\n})\n\n\n\n自定义验证方法\n/** \n*\n*  @author: Mr_Wei \n*  @version: 1.0.0 \n*  @description: 判断是否过期用户\n*  @Date: 2019/10/19 12:19\n*\n*/ \nconst UserOrOrders = require(<span class=\"hljs-string\">\"../dbModel/user\"</span>);\nmodule.exports = async params => {\n    \n    \n    const flag = await new Promise((resolve) => {\n        <span class=\"hljs-keyword\">if</span>(params){\n            const account = params.account;\n            UserOrOrders.findOne({account})\n                .then(user => {\n                    <span class=\"hljs-keyword\">if</span>(user){\n                        <span class=\"hljs-keyword\">if</span>(new Date().getTime() > new Date(user.endTime).getTime()){\n                            console.log(<span class=\"hljs-string\">\"过期用户\"</span>);\n                            // 处理\n                            <span class=\"hljs-built_in\">return</span> resolve(<span class=\"hljs-literal\">false</span>);\n                        }<span class=\"hljs-keyword\">else</span>{\n                            console.log(<span class=\"hljs-string\">\"合法用户\"</span>);\n                            <span class=\"hljs-built_in\">return</span> resolve(<span class=\"hljs-literal\">true</span>);\n                        }\n                    }<span class=\"hljs-keyword\">else</span>{\n                        <span class=\"hljs-built_in\">return</span> resolve(<span class=\"hljs-literal\">false</span>);\n                    }\n                })\n        }<span class=\"hljs-keyword\">else</span>{\n            console.log(<span class=\"hljs-string\">\"不合法用户\"</span>);\n            <span class=\"hljs-built_in\">return</span> resolve(<span class=\"hljs-literal\">false</span>);\n        }\n        \n    }) \n    <span class=\"hljs-built_in\">return</span> flag;\n}\n\n\n\n\n使用:\n// 测试  isBadAccount(params)方法\nrouter.post(<span class=\"hljs-string\">\"/test\"</span>, passport.authenticate(<span class=\"hljs-string\">\"jwt\"</span>, {session:<span class=\"hljs-literal\">false</span>}), async (req, res) => {\n    // console.log(req.user)\n    <span class=\"hljs-keyword\">if</span>(await isBadAccount(req.user)){\n        // <span class=\"hljs-keyword\">do</span> something\n        res.send(<span class=\"hljs-string\">\"OK\"</span>);\n    }<span class=\"hljs-keyword\">else</span>{\n        res.status(401).json({status:<span class=\"hljs-string\">\"401\"</span>, result:<span class=\"hljs-string\">\"帐号过期,请联系管理员\"</span>})\n    }\n})\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de91e74dabb7b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1203\" data-height=\"354\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1203\" height=\"354\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>详细的文档地址：<a target=\"_blank\" href=\"https://www.npmjs.com/package/passport-jwt\" rel=\"nofollow noopener noreferrer\">Passport-Jwt合法验证</a>,<a target=\"_blank\" href=\"https://www.npmjs.com/package/jsonwebtoken\" rel=\"nofollow noopener noreferrer\">token加密</a></p>\n<h1 class=\"heading\" data-id=\"heading-13\">截图</h1>\n<h2 class=\"heading\" data-id=\"heading-14\">后台管理系统</h2>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f20c45d16c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"687\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"687\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f3aff440179?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"687\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"687\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f4c16660196?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"688\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"688\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f56c6b8f49b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"691\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"691\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f61023ef8f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"690\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"690\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f6dff0f10f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"686\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"686\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f7e2021c16e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"690\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"690\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8f87ee4336ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"691\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"691\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-15\">前台点歌界面</h2>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de90855c3a31b7?imageslim\" data-width=\"1280\" data-height=\"692\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"692\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de8fe56259b0df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"685\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"685\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de900f3122d838?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"692\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"692\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de9021416bd557?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"689\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"689\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de903452757d7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"692\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"692\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/20/16de90855c3a31b7?imageslim\" data-width=\"1280\" data-height=\"692\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"692\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-16\">源码在这里</h1>\n<p>以上代码均已上传 github</p>\n<p><a target=\"_blank\" href=\"https://github.com/1046224544/ktv-select_music-system\" rel=\"nofollow noopener noreferrer\">github.com/1046224544/…</a></p>\n<h1 class=\"heading\" data-id=\"heading-17\">联系</h1>\n<p>如果大家有兴趣，<a target=\"_blank\" href=\"https://github.com/1046224544/ktv-select_music-system\" rel=\"nofollow noopener noreferrer\">欢迎star</a>. 欢迎大家加入我的前端交流群：866068198 ，一起交流学习前端技术。博主目前一直在自学Node中，技术有限，如果可以，会尽力给大家提供一些帮助，或是一些学习方法.</p>\n<ul>\n<li>群二维码</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/16/16dd3758643e9c2b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"540\" data-height=\"740\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"540\" height=\"740\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-18\">其他</h1>\n<ul>\n<li><strong>Node-vue-iView开发类似博客的综合性网站</strong> <a target=\"_blank\" href=\"https://juejin.im/post/5da2a8ed6fb9a04de818eeff\" rel>juejin.im/post/5da2a8…</a></li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-19\">最后</h1>\n<p>If you have some questions after you see this article, you can contact me or you can find some info by clicking these links.</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/user/5d1079ab6fb9a07ed4410cc0\" rel>juejin@wsm's juejin</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/1046224544\" rel=\"nofollow noopener noreferrer\">GitHub@1046224544</a></li>\n<li><a target=\"_blank\" href=\"https://segmentfault.com/u/xiaolajiao_5d81dbf1f09b2\" rel=\"nofollow noopener noreferrer\">Segmentfault@wsm</a></li>\n</ul>\n<blockquote>\n<p><strong>如果对你有帮助,请赏个star~</strong> <a target=\"_blank\" href=\"https://github.com/1046224544/ktv-select_music-system\" rel=\"nofollow noopener noreferrer\">github地址</a></p>\n</blockquote>\n",
      "id": "77z0oq7442s0",
      "author": "云音乐前端技术团队",
      "title": "7天撸完KTV点歌系统,含后台管理系统(完整版)"
    },
    {
      "content": "<blockquote>\n<p>本文将介绍一款全新的前端开发工具，希望它能给你的前端开发带来看起来和现在一样但其实又不那么一样的体验。</p>\n</blockquote>\n<p>你可能会说，大家都是 <s>秃头的</s> 成熟的前端程序员了，每一台电脑上都有几套自己辛辛苦苦装好的全家桶，为什么还要新换一个开发工具？</p>\n<p>对，盲生，你可能发现了华点。</p>\n<p>数一数你电脑上目前为前端本地开发安装了多少小工具、小插件？\n这其中仅仅是为代码开发阶段，就可能有本地服务器、远程调试工具、代理工具、浏览器插件等等。\n它们也许是你一个个尝试无数同款后最终确定安装的，\n也可能是被各类『震惊！超好用前端开发工具大全』安利的，\n并且其中不乏全局安装、全局配置的「重器」。</p>\n<p></p><figure><img alt=\"震惊！超好用前端开发工具大全\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec471252590c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"749\" data-height=\"508\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"749\" height=\"508\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>试想现在你要换一台新电脑或者重装新系统了，你还得一个个把它们重新安装回来。\n况且大部分这样的工具是无法根据工程进行独立配置的，\n也就是说你在不同项目之间切换时还需要手动修改你的开发工具配置。\n这些都是一些强迫症患者如作者本人无法忍受的。</p>\n<p>总结一下平时搞开发的时候一些习以为常但仔细一想又挺麻烦的场景：</p>\n<ul>\n<li>你必须手动安装各类工具软件以丰富你的本地开发环境</li>\n<li>这样的本地开发环境无法拷贝或者很难拷贝，无法分享</li>\n<li>每种工具都要单独配置，且配置基本不是按照项目隔离的，切换项目时经常需要修改配置</li>\n<li>有时候你的需求并没有合适的工具来满足，自己写一个又太麻烦</li>\n<li>写一个项目要同时打开 N 种 工具：本地服务器、mock 服务器等</li>\n<li>经常还需要不断重启这些工具以刷新配置</li>\n<li>……</li>\n</ul>\n<p>基于以上以及一些其它痛点，便有了下文将介绍的 server-x。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">什么是 server-x</h2>\n<p>如同它名字的前半部分，<code>server</code>，你可以简单地说，server-x（缩写为 svrx）就是一个本地服务器，\n并且它还是一个功能丰富、使用便捷的轻量级服务器。</p>\n<p>先来看下最简单的使用场景：</p>\n<p>首先你需要安装 svrx 的 CLI 工具，</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm install -g @svrx/cli\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>然后新建一个简单的页面，在项目根目录启动 svrx，</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">mkdir example && <span class=\"hljs-built_in\">cd</span> example\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'<html><body>Hello svrx!</body></html>'</span> > index.html\nsvrx\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>访问 <a target=\"_blank\" href=\"http://localhost:8000\" rel=\"nofollow noopener noreferrer\">http://localhost:8000</a> 即可看到你的前端页面。</p>\n<p></p><figure><img alt=\"启动demo\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec471246868bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"633\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"633\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>安装便捷，启动迅速，独立使用，除了 node ，<strong>不依赖任何别的环境</strong>。\n当然，这是任何一个独立的、基础的 dev server 都能做到的最必不可少的功能。</p>\n<p>除此之外还有什么？svrx 还自带了诸如自动打开浏览器、监听代码变动自动刷新（livereload）、proxy 等实用性非常强的功能。\n是的，你也可以说，部分 dev server 也是能做到的。</p>\n<p>svrx 和其它本地服务器最大的区别，其实是它名字 <code>server-x</code> 的后半部分：<code>x</code>。\n我们都知道，<code>x</code> 可以代表「未知和无限」，即 svrx 是一个有着无限可能的服务器。\n为什么说它有无限的可能？因为 svrx 最大的特点：它是一个插件平台。</p>\n<p>通过插件，理论上你的 svrx 确实可以拥有任意的功能。\n每一个小功能在这里就是一个独立的插件，你只需要声明就能使用它，就像这样：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">svrx --webpack --qrcode --markdown\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>很清晰直观，没有冗余的配置，在你声明插件以后，svrx 会自动帮你下载安装插件，然后直接启动。</p>\n<p>所以你可以说，svrx 是一个聚合了众多功能插件的平台，它本身就是一个全家桶。\n不过不同的是，你丝毫<strong>不需要关心插件的安装过程</strong>。除了 svrx 的 CLI，你<strong>无需安装其它任何工具</strong>。</p>\n<p>另外，所有插件都不是全局安装，而是直接安装到你工程的<code>node_modules</code>目录中。\n所以<strong>工程开发是真正独立隔离的</strong>，\n你可以自由给每一个项目定制一套开发环境，不用考虑安装卸载，完全不担心环境污染问题，同时系统也可以保持干净清爽。</p>\n<p>事实上，业内目前可用的本地 dev server 有很多，\n但像 svrx 这样，轻量易用的、具有完备插件机制的、完全不依赖工程环境的，几乎是没有的。\n接下来，我们通过创建一个简单的前端工程，继续探索一下使用 svrx 进行开发的全新体验，\n带你深入了解一些进阶用法和黑科技，这些才是 svrx 真正有趣的地方。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">创建工程及启动</h2>\n<p>方便起见，我们选用前端常用的 <a target=\"_blank\" href=\"https://github.com/facebook/create-react-app\" rel=\"nofollow noopener noreferrer\">Create React App</a> 进行示例工程创建\n（前面提到，svrx 不依赖任何工程环境，选取 CRA 仅仅为了示例方便）。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm init react-app svrx-example\n<span class=\"hljs-built_in\">cd</span> svrx-example\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于新工程默认使用 <code>webpack</code> 打包，想要启动这样的工程，\n我们需要使用插件 <a target=\"_blank\" href=\"https://github.com/svrxjs/svrx-plugin-webpack\" rel=\"nofollow noopener noreferrer\">svrx-plugin-webpack</a>。\n这个插件的作用就是读取项目配置，\n调用 <a target=\"_blank\" href=\"https://github.com/webpack/webpack-dev-middleware\" rel=\"nofollow noopener noreferrer\">webpack-dev-middleware</a>，\n使你的 <code>webpack</code> 项目可以无缝接入到 svrx 服务中。</p>\n<p>不过由于新工程并没有暴露出 <code>webpack</code> 配置项，所以我们需要先在根目录创建一个 <code>webpack.config.js</code>：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react-scripts/config/webpack.config'</span>)(<span class=\"hljs-string\">'development'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>然后我们就可以顺利启动项目了：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">svrx --webpack\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>浏览器会自动弹出 <a target=\"_blank\" href=\"http://localhost:8000/\" rel=\"nofollow noopener noreferrer\">http://localhost:8000/</a> 页面：</p>\n<p></p><figure><img alt=\"start svrx\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec471268d3f6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1274\" data-height=\"670\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1274\" height=\"670\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>这时可以尝试编辑下 <code>src/App.css</code>，看看页面是不是实时变化了？</p>\n<p></p><figure><img alt=\"livereload\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec47126322bbc?imageslim\" data-width=\"640\" data-height=\"360\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"360\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-2\">进阶 1：添加配置项</h2>\n<p>默认地，svrx 会在启动时自动开启一些内置的基础插件，\n如静态伺服（serve）、转发服务（proxy）、页面自动刷新（livereload）等。\n它们都有一些默认行为以保证用户可以快速启动 svrx，\n当然，如果你需要对这些内置配置项做一些自定义修改，svrx 也提供了两种方式。</p>\n<p>你可以在命令行启动 svrx 时传入参数进行配置：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">svrx --port 3000 --https --no-livereload\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>也可以在你的工程目录下建立<code>.svrxrc.js</code>或<code>svrx.config.js</code>文件，将上面的命令行参数持久化下来：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// .svrxrc.js</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3000</span>,\n  <span class=\"hljs-attr\">https</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">livereload</span>: <span class=\"hljs-literal\">false</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>svrx 的全部配置项及描述可以在<a target=\"_blank\" href=\"https://docs.svrx.io/zh/guide/option.html\" rel=\"nofollow noopener noreferrer\">官方文档-内置项</a>中查看。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">进阶 2：开始尝试使用其它插件</h2>\n<p>除了内置插件以外，svrx 还有很多独立插件，比如前面提到的 <code>svrx-plugin-webpack</code>。\n在你需要别的开发功能（如远程调试、mock 等）时，只需要简单地在 svrx 配置中声明这些独立功能插件的名字即可正常使用。\n正是这些独立插件，为 svrx 项目提供了丰富多彩的功能体验。下面先介绍几个好用的好玩的插件：</p>\n<h3 class=\"heading\" data-id=\"heading-4\"><a target=\"_blank\" href=\"https://github.com/svrxjs/svrx-plugin-localtunnel\" rel=\"nofollow noopener noreferrer\">localtunnel</a> - 把本地服务暴露出去</h3>\n<p>试想你正紧张有序地在进行页面开发，这个时候你领导的消息弹了出来：</p>\n<blockquote>\n<p>让我看看你的页面写得怎么样了</p>\n</blockquote>\n<p>这个时候你怎么办？你是不是得先检查进度，把能用的代码先提交，然后你灵机一动，部署了一个本地服务，准备甩给你领导一串本机 IP。\n但是你突然想起来，领导不是在出差吗？（太敬业了，还在时刻检查你的开发进度）领导访问不了内网啊。\n这时你只能慌忙找服务器再部署一个测试环境给领导，部署得还贼慢，领导飞机都要起飞了！</p>\n<p>这个时候，你就需要 svrx 的 <a target=\"_blank\" href=\"https://github.com/localtunnel/localtunnel\" rel=\"nofollow noopener noreferrer\">localtunnel</a> 插件了！\n它可以将你的本地服务暴露到<code>localtunnel.me</code>，从而方便地进行本地代码的测试和分享。\n你再也无需为了测试你的一点代码变动就专门部署一次测试服务了。</p>\n<p>启动 <code>localtunnel</code> 只需在之前的启动命令后添加声明即可：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">svrx --webpack --localtunnel\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>上面的命令将会自动安装 localtunnel 插件并启动 svrx，\n其他人（是的，你们甚至不需要在同一个内网）此时访问终端打印的 https://*.localtunnel.me 也将看到你的本地服务：</p>\n<p></p><figure><img alt=\"localtunnel\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec471d9a11a29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"638\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"638\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>并且，你的每次本地页面变动都可以被别人实时看到，再也不用担心领导突然检查作业了！</p>\n<p></p><figure><img alt=\"localtunnel-livereload\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec47165c302b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-5\"><a target=\"_blank\" href=\"https://github.com/svrxjs/svrx-plugin-weinre\" rel=\"nofollow noopener noreferrer\">weinre</a> - 远程调试移动端代码</h3>\n<p>现在一般都是如何进行移动端代码调试的？你可能会说，“这题我会！”很简单，先在手机上打开设置里的<code>开发者模式</code>（可能要找一下），允许<code>USB 连接</code>，再找一根 USB 连接线，把手机和电脑连接起来，然后你打开你电脑上的浏览器开发者工具，开启一些东西，找到远程设备，然后<code>Inspect</code>……</p>\n<p>万一有更简便的方法呢？你可以试试 svrx 的 <a target=\"_blank\" href=\"http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html\" rel=\"nofollow noopener noreferrer\">weinre</a> 插件，它用于方便地远程调试移动端的页面，而且是“无线”的。</p>\n<p>我们再次回到刚才的 example 工程，这次我们在启动命令后面添加两个新的插件：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">svrx --open=external --webpack --weinre --qrcode \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>首先通过上面的命令快速安装 weinre 和二维码插件并启动 svrx，\n此时试着拿手机访问启动好的项目页面，这里推荐配合 <code>qrcode</code> 二维码插件让手机轻松扫码访问页面地址:</p>\n<p></p><figure><img alt=\"qrcode\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec4716be4307c?imageslim\" data-width=\"640\" data-height=\"360\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"360\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>紧接着电脑打开 weinre 的调试器页面 <a target=\"_blank\" href=\"http://$\" rel=\"nofollow noopener noreferrer\">http://$</a>{your_ip}:8001（默认），\n找到手机的访问记录，就可以在调试器上对手机页面进行远程调试了。</p>\n<p></p><figure><img alt=\"weinre 调试器截图\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec471731ddae6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"978\" data-height=\"746\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"978\" height=\"746\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-6\">定制你的插件</h3>\n<p>除了上述的，svrx 还有很多有趣好用的插件，你可以在<a target=\"_blank\" href=\"https://svrx.io/plugin?query=svrx-plugin-\" rel=\"nofollow noopener noreferrer\">svrx 的官网</a> 查询目前所有的插件，并从中挑选使用。\n通过不同插件的组合，你就可以自由定制你的开发环境啦！</p>\n<p></p><figure><img alt=\"部分插件列表\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec47173536dc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"664\" data-height=\"666\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"664\" height=\"666\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>当然，如果没找到你想要的功能插件，你还可以尝试自己写一个。</p>\n<p>你可以用插件实现哪些功能呢？\n拿前面的 <code>qrcode</code> 二维码插件来说，为了把二维码显示到页面上，你可以往前端页面注入一些 js 脚本，css 样式；\n也可以像 <code>webpack</code> 插件那样，往后端逻辑中注入一些 koa 风格的中间件，拦截请求做数据处理，比如这里的 <code>webpack-dev-middleware</code>。</p>\n<p>有了强大的前后端注入能力，几乎所有的本地开发需求，都可以通过创建一个 svrx 插件来解决。\n而且<strong>插件的开发异常简单</strong>！刚刚介绍的一些插件的核心代码几乎都只有 50 行左右！\n此外，svrx 还提供了快速创建插件的脚手架工具，可以去<a target=\"_blank\" href=\"https://docs.svrx.io/zh/plugin/contribution.html\" rel=\"nofollow noopener noreferrer\">官方文档-如何写一个插件</a>查看更多插件开发的细节，在这里就不赘述了。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">进阶 3：可以热更新的快捷路由</h2>\n<p>在前后端分离的开发场景中，前端经常会碰到需要进行数据 mock 的情况。于是你可能会经历：</p>\n<ul>\n<li>修改 mock 数据，重启 mock 服务器</li>\n<li>打开、关闭接口转发，重启</li>\n<li>修改工程代码，重启</li>\n<li>……</li>\n</ul>\n<p>就算你说现在的 mock 服务都很智能，不需要重启了，但是你还是需要在本地服务外手动再开启一个 mock 服务，要么就是狠一点，把 mock 数据写到工程代码里。太不优雅了！</p>\n<p>于是 svrx 的动态路由就派上用场了。是的，除了丰富的插件体系，svrx 其实还有一个功能强大、使用便捷的动态路由功能。\n还是回到我们的 example 工程，你可以通过以下命令开启快速尝试：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">touch route.js <span class=\"hljs-comment\"># create empty routing file</span>\nsvrx --webpack --route route.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>在<code>route.js</code>中：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">get(<span class=\"hljs-string\">'/blog'</span>).to.json({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'svrx'</span> });\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>此时打开<code>/blog</code>，你将看到<code>{ title: 'svrx' }</code>的 json 输出。</p>\n<p>有了这个路由功能，你将可以在不侵入项目代码的前提下<strong>快速直观地创建你的 mock 数据</strong>。\n并且它是支持 <strong>hot reload</strong> 的，即每次编辑 <code>route.js</code> 后，无需重启 svrx 服务，路由数据会自动更新。</p>\n<p></p><figure><img alt=\"动态路由示例\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec4719f1b438f?imageslim\" data-width=\"640\" data-height=\"360\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"360\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>当然，除了用于本地开发数据 mock 外，svrx 路由还可以做很多。下面是一些路由示例：</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">get(<span class=\"hljs-string\">'/index.html'</span>).to.sendFile(<span class=\"hljs-string\">'./index.html'</span>);\nget(<span class=\"hljs-string\">'/blog'</span>).to.redirect(<span class=\"hljs-string\">'/user'</span>);\nget(<span class=\"hljs-string\">'/old/rewrite:path(.*)'</span>).to.rewrite(<span class=\"hljs-string\">'/svrx/{path}'</span>);\nget(<span class=\"hljs-string\">'/api(.*)'</span>).to.proxy(<span class=\"hljs-string\">'http://mock.server.com/'</span>);\nget(<span class=\"hljs-string\">'/blog'</span>)\n  .to.header({ <span class=\"hljs-string\">'X-Engine'</span>: <span class=\"hljs-string\">'svrx'</span> })\n  .json({ <span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">200</span> });\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如你所见，svrx 的路由语法非常简单，你可以清晰直观地阅读出每一条规则，比如发送文件、重定向、路由重写、proxy 等等。并且除了官方提供的一些路由操作外，你也可以通过插件来对路由操作进行扩展。关于 svrx 路由的语法规则、扩展等详情可以参阅<a target=\"_blank\" href=\"https://docs.svrx.io/zh/guide/route.html\" rel=\"nofollow noopener noreferrer\">官方文档-路由的使用</a>。</p>\n<h2 class=\"heading\" data-id=\"heading-8\">写在最后</h2>\n<blockquote>\n<p>一个渐进且易于使用的、插件化的前端开发平台。</p>\n</blockquote>\n<p>这是 svrx 的 slogan，同时也非常准确地描述了 svrx 的定位：</p>\n<ul>\n<li>svrx 是面向前端开发者的一个强大的本地 dev server，它由本地服务、proxy、livereload 等功能插件组成</li>\n<li>svrx 有着丰富强大的插件系统，你可以自由使用或者定制想要的功能</li>\n</ul>\n<p>在致力于为前端开发者提供更为优雅便捷的本地开发体验的同时，svrx 也为大家提供了一个可以快速进行自定义功能开发的平台。\n作为用户，你可以挑选合适的插件组合来满足你的本地服务需求，一键启动，省时省力，易拔插的功能设计，也不用担心环境污染。\n如果没有找到合适的插件，你可以变身开发者，自给自足，快速实现想要的功能。作为开发者，你还可以大开脑洞，通过你写的插件提升更多人的本地开发体验。</p>\n<p>之后，svrx 也将继续推出更多优质功能或插件，持续为前端开发服务。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">Links</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://svrx.io/\" rel=\"nofollow noopener noreferrer\">svrx 官网</a> 官方使用文档、API、插件查询</li>\n<li><a target=\"_blank\" href=\"https://github.com/svrxjs/svrx\" rel=\"nofollow noopener noreferrer\">Github - svrx</a> 核心源码、讨论交流、bug report</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dec4aa8cfd394b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"755\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"755\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>微信群超过一百人无法进群的话加微信：cyxu0825 ，加你入群</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dee73110e2470f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "49g1jsa3pm20",
      "author": "_Dreams",
      "title": "Server-X：一款可能提升你十倍工作效率的工具"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在平时的H5移动端开发时，我们难免会遇到各种各样的坑点，这篇文章就带着大家来看看怎么解决，文章较长，建议收藏方便以后查阅！</p>\n<h2 class=\"heading\" data-id=\"heading-1\">前方高能！</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">canvas在retina屏模糊</h3>\n<p>只需要将画笔根据像素比缩放即可</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">run(canvasEl) {\n    <span class=\"hljs-keyword\">const</span> canvas = canvasEl;\n    <span class=\"hljs-keyword\">const</span> ctx = canvas.getContext(<span class=\"hljs-string\">'2d'</span>);\n    <span class=\"hljs-keyword\">const</span> devicePixelRatio = <span class=\"hljs-built_in\">window</span>.devicePixelRatio || <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">const</span> backingStorePixelRatio = ctx.webkitBackingStorePixelRatio ||\n    ctx.mozBackingStorePixelRatio ||\n    ctx.msBackingStorePixelRatio ||\n    ctx.oBackingStorePixelRatio ||\n    ctx.backingStorePixelRatio || <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">const</span> ratio = devicePixelRatio / backingStorePixelRatio;\n    <span class=\"hljs-keyword\">if</span> (devicePixelRatio !== backingStorePixelRatio) {\n      <span class=\"hljs-keyword\">const</span> oldWidth = canvas.width;\n      <span class=\"hljs-keyword\">const</span> oldHeight = canvas.height;\n\n      canvas.width = oldWidth * ratio;\n      canvas.height = oldHeight * ratio;\n\n      canvas.style.width = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${oldWidth}</span>px`</span>;\n      canvas.style.height = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${oldHeight}</span>px`</span>;\n      ctx.scale(ratio, ratio);\n    }\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-3\">用同等比例的图片在PC机上很清楚,但是手机上很模糊,原因是什么呢?</h3>\n<p>经研究发现是devicePixelRatio作怪,因为手机分辨率太小,如果按照分辨率来显示网页字会非常小,所以苹果就把iPhone 4的960640分辨率在网页里只显示了480320,这样devicePixelRatio＝2;现在android比较乱,有1.5/2/3等,想让图片在手机里显示更为清晰必须使用2x的背景图来代替img标签(一般情况都是用2倍),例如一个div的宽高是100100,背景图必须得200200,然后background-size:contain;,这样显示出来的图片就比较清晰了;代码如下:</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\">   background:url(../images/icon/all.png) no-repeat center center;\n   -webkit-background-size:50px 50px;\n   background-size: 50px 50px;\n   display:inline-block; \n   width:100%; \n   height:50px;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-4\">启动或禁用自动识别页面中的电话号码;</h3>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"format-detection\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"telephone=no\"</span>></span> \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>默认情况下设备会自动识别任何可能是电话号码的字符串,设置telephone=no可以禁用这项功能,设置不识别邮箱和地址也同理</p>\n<h3 class=\"heading\" data-id=\"heading-5\">h5网站input设置为type=number的问题</h3>\n<p>h5网页input的type设置为number一般会产生三个问题:</p>\n<p>问题1:maxlength属性不好用</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><input type=<span class=\"hljs-string\">\"number\"</span> oninput=<span class=\"hljs-string\">\"checkTextLength(this ,10)\"</span>>\n<span class=\"xml\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span>></span><span class=\"actionscript\">\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkTextLength</span><span class=\"hljs-params\">(obj, length)</span> </span>{\n        <span class=\"hljs-keyword\">if</span>(obj.value.length > length)  {\n            obj.value = obj.value.substr(<span class=\"hljs-number\">0</span>, length);\n        }\n    }\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>问题2:form提交的时候默认取整</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span> <span class=\"hljs-attr\">step</span>=<span class=\"hljs-string\">\"0.01\"</span> /></span> //input中type=number一般会自动生成一个上下箭头,点击上箭头默认增加一个step,点击下箭头默认会减少一个step;number中默认step是1,也就是step=0.01可以允许输入2位小数,并且点击上下箭头分别增加0.01和减少0.01;step和min一起使用时数值必须在min和max之间\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>问题3:部分安卓手机出现样式问题</p>\n<p>去除input默认样式的方法:</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\">input,textarea {\n    border: 0;\n    -webkit-appearance: none; //可同时屏蔽输入框怪异的内阴影,解决iOS下无法修改按钮样式,测试还发现,加了此属性后,iOS下默认还是有圆角的,不过可以用border-radius属性修改\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">select下拉选择设置问题</h3>\n<p>问题1:右对齐实现</p>\n<p>设置如下属性</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-tag\">select</span> <span class=\"hljs-selector-tag\">option</span> {\n    <span class=\"hljs-attribute\">direction</span>: rtl;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>问题2:禁用select默认箭头</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-pseudo\">::-ms-expand</span>修改表单控件下拉箭头,设置隐藏并使用背景图片来修饰\n\n<span class=\"hljs-selector-tag\">select</span><span class=\"hljs-selector-pseudo\">::-ms-expand</span> { <span class=\"hljs-attribute\">display</span>:none; }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">移动端HTML5 audio autoplay失效问题</h3>\n<p>由于自动播放网页中的音频或视频会给用户带来困扰或不必要的流量消耗,所以苹果系统和安卓系统通常都会禁止自动播放和使用JS的触发播放,必须由用户来触发才播放;解决方法思路:先通过用户touchstart触碰触发播放并暂停(让音频开始加载),后面用JS再操作就没问题了;解决代码:</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">'touchstart'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">'audio'</span>)[<span class=\"hljs-number\">0</span>].play();\n    <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">'audio'</span>)[<span class=\"hljs-number\">0</span>].pause();\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">CSS动画页面闪白,动画卡顿,图片错乱的问题</h3>\n<p>1.尽可能地使用合成属性transform和opacity来设计CSS3动画,不使用position的left和top来定位</p>\n<p>2.开启硬件加速</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-tag\">-webkit-transform</span>: <span class=\"hljs-selector-tag\">translate3d</span>(0, 0, 0);\n<span class=\"hljs-selector-tag\">-moz-transform</span>: <span class=\"hljs-selector-tag\">translate3d</span>(0, 0, 0);\n<span class=\"hljs-selector-tag\">-ms-transform</span>: <span class=\"hljs-selector-tag\">translate3d</span>(0, 0, 0);\n<span class=\"hljs-selector-tag\">transform</span>: <span class=\"hljs-selector-tag\">translate3d</span>(0, 0, 0);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-9\">浮动子元素撑开父元素盒子高度(BFC)</h3>\n<p>解决方法如下：</p>\n<p>1.父元素设置为 overflow: hidden;</p>\n<p>2.父元素设置为 display: inline-block;等</p>\n<p>这里两种方法都是通过设置css属性将浮动元素的父元素变成BFC(块级格式化上下文)元素,使子元素高度可以撑开父元素;不过最好使用方法1,因为inline-block元素本身会自带一些宽高度撑开其本身</p>\n<h3 class=\"heading\" data-id=\"heading-10\">往返缓存问题</h3>\n<p>点击浏览器的回退有时候不会自动执行js,特别是在mobilesafari中;这与往返缓存(bfcache)有关系,解决方法:</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-built_in\">window</span>.onunload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-11\">定位的坑</h3>\n<p>在IOS下fixed定位在软键盘顶起时会失效，所以我们在开发时统一使用absolute代替</p>\n<h3 class=\"heading\" data-id=\"heading-12\">audio元素和video元素在ios和andriod中播放问题</h3>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">audio</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"music/bg.mp3\"</span> <span class=\"hljs-attr\">autoplay</span> <span class=\"hljs-attr\">loop</span> <span class=\"hljs-attr\">controls</span>></span>你的浏览器还不支持哦<span class=\"hljs-tag\"></<span class=\"hljs-name\">audio</span>></span> //音频,写法一\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">audio</span> <span class=\"hljs-attr\">controls</span>=<span class=\"hljs-string\">\"controls\"</span>></span> //音频,写法二   \n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">source</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"music/bg.ogg\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"audio/ogg\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">source</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">source</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"music/bg.mp3\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"audio/mpeg\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">source</span>></span> //优先播放音乐bg.ogg,不支持在播放bg.mp3    \n<span class=\"hljs-tag\"></<span class=\"hljs-name\">audio</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>到这里一般都可以播放音乐了,如果还不行很有可能是微信的限制</p>\n<p>问题3:微信的限制</p>\n<p>如果是微信的限制,这时需要调用微信接口,页面先引入:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><script src=<span class=\"hljs-string\">\"http://res.wx.qq.com/open/js/jweixin-1.0.0.js\"</span>></script>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>然后JS写入微信事件:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">document.addEventListener(<span class=\"hljs-string\">\"WeixinJSBridgeReady\"</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n    document.getElementById(<span class=\"hljs-string\">'music'</span>).play();\n}, <span class=\"hljs-literal\">false</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>小结:</p>\n<p>1.audio元素的autoplay属性在IOS及Android上无法使用,在PC端正常</p>\n<p>2.audio元素没有设置controls时,在IOS及Android会占据空间大小,而在PC端Chrome是不会占据任何空间</p>\n<p>问题4:Safari浏览器自动播放</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">'touchstart'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{   \n    audio.play();\n}, <span class=\"hljs-literal\">false</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-13\">ios系统不支持动画暂停样式(animation-play-state)</h3>\n<p>H5页面一般都会有BGM,也会提供一个旋转的音乐图标供用户开启关闭音乐;我们希望当用户点击音乐按钮时图标停止旋转,再点图标顺着之前停止的位置继续跑动画;animation-play-state是最简便的方式,然而ios不支持</p>\n<p>目前的解决方案是:音乐图标负责跑动画,图标父级元素负责记录停止时的转动值</p>\n<h3 class=\"heading\" data-id=\"heading-14\">ios防止长按页面元素被选中</h3>\n<p>解决:加入样式可禁止用户进行复制,ios和一般的安卓都可以解决</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\">-webkit-touch-callout:none;  //系统默认菜单被禁用;可以实现页面因为长按弹出各种操作窗口\n-webkit-user-select:none; //webkit浏览器  \n-khtml-user-select:none; //早期浏览器 \n-moz-user-select:none; //火狐 \n-ms-user-select:none; //IE10 \nuser-select:none; \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>添加完这段代码后在IOS上会有问题,这时发现input框无法正在输入内容了;造成这个原因是-webkit-user-select:none;这个属性,解决方法就是在css文件中同时设置一下input的属性,如下:</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\">input {      \n     -webkit-user-select:auto; //webkit浏览器    \n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-15\">html5碰到上下拉动滚动条时卡顿/慢怎么解决</h3>\n<p>首先你可能会给页面的html和body增加了height: 100%, 然后就可能造成IOS上页面滑动的卡顿问题。</p>\n<p>解决方案是：\n1.让html和body固定100%（或者100vh），\n2.然后再在内部放一个height:100%的div，设置overflow-y: auto;和-webkit-overflow-scrolling: touch;</p>\n<p>overflow-x:auto在iOS有兼容问题，解决方法:</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-class\">.scroll-box</span> {\n  <span class=\"hljs-comment\">/* 模态框之类的div不能放在这个容器中,否则关闭模态框有时候关闭不了 */</span>\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n  <span class=\"hljs-attribute\">overflow-y</span>: auto;\n  <span class=\"hljs-attribute\">-webkit-overflow-scrolling</span>: touch;\n  <span class=\"hljs-attribute\">overflow-scrolling</span>: touch;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-16\">点击元素产生背景或边框怎么去掉</h3>\n<p>a,button,input,textarea{\n-webkit-tap-highlight-color: rgba(0,0,0,0);\n-webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用,就是输入法不再能够输入多个字符\n}\n或\na,button,input,textarea{\n-webkit-tap-highlight-color: rgba(0,0,0,0);\n}</p>\n<h3 class=\"heading\" data-id=\"heading-17\">浏览器后退不刷新</h3>\n<p>这种情况是以前遇到的,这里也说下;主要会发生在webview里多一点,当点击后退时页面以缓存形式出现,而不是刷新后的,很多情况下这不是你预期的效果,解决方法是用js:</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">方法<span class=\"hljs-number\">1</span>：\n<span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'pageshow'</span>, () => {\n  <span class=\"hljs-keyword\">if</span> (e.persisted || (<span class=\"hljs-built_in\">window</span>.performance && \n    <span class=\"hljs-built_in\">window</span>.performance.navigation.type == <span class=\"hljs-number\">2</span>)) {\n    location.reload()\n  }\n}, <span class=\"hljs-literal\">false</span>);\n\n方法<span class=\"hljs-number\">2</span>:\n<span class=\"hljs-built_in\">window</span>.history.replaceState(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">''</span>, <span class=\"hljs-built_in\">window</span>.location.href + <span class=\"hljs-string\">'?timestamp='</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime());\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>onpageshow每次页面加载都会触发,无论是从缓存中加载还是正常加载,这是他和onload的区别;persisted判断页面是否从缓存中读出</p>\n<p>页面通过历史记录和前进后退访问时。type值为2</p>\n<h3 class=\"heading\" data-id=\"heading-18\">transition清除闪屏</h3>\n<pre><code class=\"hljs css copyable\" lang=\"css\">-webkit-transform-style: preserve-3d; //设置内嵌的元素在 3D 空间如何呈现：保留3D\n-webkit-backface-visibility:hidden; //设置进行转换的元素的背面在面对用户时是否可见：隐藏\n-webkit-perspective: 1000;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-19\">解决active伪类失效</h3>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">ontouchstart</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">body</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">顶部状态栏背景色</h3>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行;语法:\n<meta name=<span class=\"hljs-string\">\"apple-mobile-web-app-capable\"</span> content=<span class=\"hljs-string\">\"yes\"</span>> //content设置为yesWeb应用会以全屏模式\n<meta name=<span class=\"hljs-string\">\"apple-mobile-web-app-status-bar-style\"</span> content=<span class=\"hljs-string\">\"black\"</span> />\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>说明:除非你先使用apple-mobile-web-app-capable指定全屏模式,否则这个meta标签不会起任何作用;如果content设置为default,则状态栏正常显示;如果设置为blank,则状态栏会有一个黑色的背景;如果设置为blank-translucent,则状态栏显示为黑色半透明;如果设置为default或blank,则页面显示在状态栏的下方,即状态栏占据上方部分;页面占据下方部分，二者没有遮挡对方或被遮挡;如果设置为blank-translucent,则页面会充满屏幕,其中页面顶部会被状态栏遮盖住(会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px);默认值是default。</p>\n<h2 class=\"heading\" data-id=\"heading-21\">ios专区</h2>\n<h3 class=\"heading\" data-id=\"heading-22\">IOS中对input键盘事件keyup/keydown/keypress等支持不好的问题</h3>\n<p>经查发现,IOS的输入法(不管是第三方还是自带)能检测到英文或数字的keyup,但检测不到中文的keyup,在输入中文后需要点回退键才开始搜索;解决办法是用html5的oninput事件去代替keyup,通过如下代码达到类似keyup的效果;</p>\n<p>1.修改了input:checkbox或input:radio元素的选择中状态,checked属性发生变化</p>\n<p>2.修改了input:text或textarea元素的值,value属性发生变化</p>\n<p>3.修改了select元素的选中项,selectedIndex属性发生变化\n统一使用input监听</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> id=<span class=\"hljs-string\">\"testInput\"</span>>\n<script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span>>\n    document.getElementById(<span class=\"hljs-string\">'testInput'</span>).addEventListener(<span class=\"hljs-string\">'input'</span>, <span class=\"hljs-keyword\">function</span>(e){\n        var value = e.target.value; //e.target指向事件执行时鼠标所点击区域的那个元素;初学者会认为当前事件所绑定的元素就是鼠标所点击的那个元素,这时就要看看时间绑定的元素内部有没有子元素,如果有e.target指向这个子元素,如果没有e.target和this都指向事件所绑定的元素\n    });\n</script>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-23\">IOS键盘字母输入,默认首字母大写的解决方案</h3>\n<p>设置如下属性</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><input autocapitalize=<span class=\"hljs-string\">\"off\"</span> autocorrect=<span class=\"hljs-string\">\"off\"</span> />\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>//input的三个属性autocomplete:默认为on,代表是否让浏览器自动记录输入的值,可以在input中加入autocomplete=\"off\"来关闭记录,保密输入内容;autocapitalize:自动大小写;autocorrect:纠错</p>\n<h3 class=\"heading\" data-id=\"heading-24\">关于iOS与OS X端字体的优化(横竖屏会出现字体加粗不一致等)问题</h3>\n<p>iOS浏览器横屏时会重置字体大小,设置text-size-adjust为none可以解决iOS上的问题,但桌面版Safari的字体缩放功能会失效,因此最佳方案是将text-size-adjust为100%</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-tag\">-webkit-text-size-adjust</span>: 100%;\n<span class=\"hljs-selector-tag\">-ms-text-size-adjust</span>: 100%;\n<span class=\"hljs-selector-tag\">text-size-adjust</span>: 100%;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-25\">某些情况下非可点击元素如(label,span)监听click事件,ios下不会触发</h3>\n<p>针对此种情况只需对不触发click事件的元素添加一行css代码即可</p>\n<pre><code class=\"hljs css copyable\" lang=\"css\"><span class=\"hljs-selector-tag\">cursor</span>: <span class=\"hljs-selector-tag\">pointer</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-26\">ios对时间date()的支持不一样</h3>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var date =new Date(<span class=\"hljs-string\">\"2019/10/21\"</span>); \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>调试发现2019/10/21等同2019-10-21 00:00:00,也就是说ios默认就是从0开始计算的,我们不需要设置后面的时分秒为00:00:00</p>\n<h3 class=\"heading\" data-id=\"heading-27\">iOS(safari)标签绑定点击事件无效</h3>\n<p>iOS(safari)有时候某个标签绑定点击事件无效,加上空的onclick=\"\"就好了,如:<code><a onclick=\"\"></a></code></p>\n<h3 class=\"heading\" data-id=\"heading-28\">ios中location.href跳转页面空白</h3>\n<p>在location.href外套一层setTimeout就解决了！</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n       <span class=\"hljs-built_in\">window</span>.location.href = <span class=\"hljs-string\">'www.juejin.im'</span>\n}, <span class=\"hljs-number\">0</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-29\">键盘弹起下落时的bug解决方法</h3>\n<p>在App.vue的created钩子里统一处理即可</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">created() {\n    <span class=\"hljs-keyword\">this</span>.handleFocusOut();\n    <span class=\"hljs-keyword\">this</span>.handleResize();\n},\n<span class=\"hljs-attr\">methods</span>:{\n    handleFocusOut() {\n      <span class=\"hljs-comment\">// input 焦点失焦后，ios 键盘收起，但没有触发 window resize，导致实际页面dom仍然被键盘顶上去--错位</span>\n      <span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">'focusout'</span>, () => {\n        <span class=\"hljs-built_in\">document</span>.body.scrollTop = <span class=\"hljs-number\">0</span>;\n      });\n    },\n    <span class=\"hljs-comment\">// 监听resize事件（键盘弹起触发），然后将 input textarea 元素滑动到可视区域，并将特定元素隐藏</span>\n    handleResize() {\n      <span class=\"hljs-keyword\">const</span> clientHeight = <span class=\"hljs-built_in\">document</span>.documentElement.clientHeight;\n      <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'resize'</span>, () => {\n        <span class=\"hljs-comment\">// 判断当前 active 的元素是否为 input 或 textarea</span>\n        <span class=\"hljs-keyword\">if</span> (\n          <span class=\"hljs-built_in\">document</span>.activeElement.tagName === <span class=\"hljs-string\">'INPUT'</span> ||\n          <span class=\"hljs-built_in\">document</span>.activeElement.tagName === <span class=\"hljs-string\">'TEXTAREA'</span>\n        ) {\n          setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n            <span class=\"hljs-comment\">// 原生方法，滚动至需要显示的位置</span>\n            <span class=\"hljs-built_in\">document</span>.activeElement.scrollIntoView();\n          }, <span class=\"hljs-number\">0</span>);\n        }\n\n        <span class=\"hljs-comment\">// 解决键盘弹起后 fixed 定位元素被顶起问题</span>\n        <span class=\"hljs-keyword\">const</span> bodyHeight = <span class=\"hljs-built_in\">document</span>.documentElement.clientHeight;\n        <span class=\"hljs-keyword\">const</span> ele = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'fixed-bottom'</span>);\n        <span class=\"hljs-keyword\">if</span> (ele) {\n          <span class=\"hljs-keyword\">if</span> (clientHeight > bodyHeight) {\n            ele.style.display = <span class=\"hljs-string\">'none'</span>;\n          } <span class=\"hljs-keyword\">else</span> {\n            ele.style.display = <span class=\"hljs-string\">'block'</span>;\n          }\n        }\n      });\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-30\">总结</h2>\n<p>路漫漫其修远兮,在兼容的道路上渐行渐远</p>\n",
      "id": "64ymkkr9kzs0",
      "author": "西岚",
      "title": "移动端H5页面开发坑点指南"
    },
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">写在前言</h1>\n<p>要知道在深圳上班是非常痛苦的事情，特别是我上班的科兴科技园这一块，去的人非常多，每天上班跟春运一样，如果我能换到以前的大冲上班那就幸福了，可惜，换不得。</p>\n<p>尤其是我这个站等车的多的一笔，上班公交挤的不行，车满的时候只有少部分人能硬挤上去。通常我只会用两个字来形容这种人：“公交怪”</p>\n<p>想当年我朋友瘦的像只猴还能上去，老子身高182体重72kg挤个公交，不成问题，反手一个阻挡，闷声发大财，前面的阿姨你快点阿姨，别磨磨唧唧的，快上去啊阿姨，嗯？你还想挤掉我？你能挤掉我？你能挤掉我！我当场！把车吃了！</p>\n<p>....</p>\n<p>咳咳，挤公交是不可能挤公交滴，因为今天我发现了一个可以定制路线的网约巴士公众号【深圳xxx】</p>\n<p>但是呢，票经常会被抢光，同时我还我发现，有时候会有人退票，这时候就有空余票了，关键是我不可能时时都在公众号上盯着，于是，我就写了一个抢票+短信通知的小工具</p>\n<h1 class=\"heading\" data-id=\"heading-1\">获取接口信息</h1>\n<h2 class=\"heading\" data-id=\"heading-2\">查看页面结构</h2>\n<p>这个就是订票页面，显示当前月的车票情况，根据图示，红色为已满，绿色为已购，灰色为不可选\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbb8fe1d3f8fc3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"1092\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"1092\"></svg>\"><figcaption></figcaption></figure>\n如果是可选就是白色的小方块，并且在下面显示余票，如下图所示：<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/17/16dd8cd6b2201199?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"324\" data-height=\"162\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"324\" height=\"162\"></svg>\"><figcaption></figcaption></figure>\n我们打算这么做，<p></p>\n<ol>\n<li>定时抓取返回的接口信息</li>\n<li>根据接口返回值判断是否有余票</li>\n</ol>\n<p>好，审查下源代码看下接口信息，等等，微信浏览器没办法审查源代码，于是</p>\n<h2 class=\"heading\" data-id=\"heading-3\">使用chrome 调试微信公众号网页页面</h2>\n<p>首先面临个问题，如果直接copy公众号网页Url在chrome打开的话，就会显示这个画面，他被302重定向到了这个页面，所以是行不通的，只有获取OAuth2.0授权才能进去</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddaee758b42b4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"356\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"356\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>所以我们得先通过抓包工具，知道手机访问微信公众号网页的时候，需要带什么信息过去，这时候我们就得借助抓包工具，因为我电脑是Mac，用不了<code>Fiddler</code>，我用的是<code>Charles</code>花瓶，就是下面这位仁兄</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbba130282d533?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"380\" data-height=\"348\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"380\" height=\"348\"></svg>\"><figcaption></figcaption></figure>\n借助这个工具，我们只需3步就可以轻松搞定手机数据抓包：<p></p>\n<ol>\n<li><strong>获取本机IP地址和端口</strong></li>\n<li><strong>设置代理手机上网</strong></li>\n<li>依次执行上面两步</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-4\">获取本机IP地址和端口</h3>\n<p>第一步，找到端口号，一般默认是8088，但是为了确认可以打开<code>Proxy</code>/<code>Proxy Setting</code>看下，哦原来我之前设置成了8888</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbbb6d83d75fc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"766\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"766\"></svg>\"><figcaption></figcaption></figure>\n然后找到<code>Charles</code>的<code>help</code>/<code>Local IP Address</code>，点击它就会看到自己的本机地址，找到本机地址记下来，然后进行下一步<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dde2ebaec1fcae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"807\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"807\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-5\">设置代理手机上网</h3>\n<p>首先保证手机跟电脑连接的是同一个wifi，然后在wifi设置那里会有设置代理信息，比如我的猴米...不对，小米9手机！设置如下：</p>\n<p>输入上一步获取主机名，端口号就ok了\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbbb54704d737e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"590\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"590\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>输入完成，点击确定后。<code>Charles</code>就会弹出一个对话框，问你是否同意接入代理，点击确定allow就行了。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">用手机访问目标网页</h3>\n<p>我们用手机访问微信公众号【深圳x出行】进入到抢票页面后，发现<code>Charles</code>已经成功抓包到了网页信息，当我们进入这个抢票页面的时候，他会发起两个请求，一个是获取document文档内容，一个post请求获取票务信息。</p>\n<p>仔细分析了下，大概明白了业务逻辑：</p>\n<p>整个项目技术站是java+jsp，传统写法，用户身份验证主要是cookie+session方案，前端这一块主要是使用<code>jQuery</code>。</p>\n<p>当用户进入页面的时候，会携带查询参数，如起始站点，时间，车次等信息和cookie请求document文档，\n也就是圈起来的这一块，\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dde3053bbff4f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"193\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"193\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddaf459b557988?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1119\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1119\"></svg>\"><figcaption></figcaption></figure>\n而我们想要的核心内容：日历表，一开始是不显示的<p></p>\n<p>因为还要在请求一次</p>\n<p>第二次请求，携带cookie和以上的查询参数发起一个post请求，获取当月的车票信息，也就是日历表内容</p>\n<p>下面这个是请求当月票务信息，然而发现他返回的是一堆html节点</p>\n<p>好吧...估计是获取到之后直接<code>append</code>到<code>div</code>里面的，然后渲染生成日历表内容\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbde3d055047f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"545\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"545\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>接着在手机上操作，选择两个日期，然后点击下单，发送购票请求，拉取购票接口，我们看下购票接口的请求和返回内容：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/17/16dd8d12313f69f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"566\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"566\"></svg>\"><figcaption></figcaption></figure>\n看下request 内容，根据字段的意思大概明白是线路，时间，以及车票金额，还有支付方式<p></p>\n<p>在看看返回的内容：返回一个json字符串数据，里面大概涵盖了下单的成功返回码，时间，id号等等信息\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/17/16dd8d1bc2cb32ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"114\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"114\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-7\">记录所需要的信息内容</h3>\n<p>根据上面的分析，总结下内容：\n整个项目用户身份验证是使用<code>cookie</code>和<code>session</code>方案，请求数据用的是<code>form data</code>方式，请求字段啥的我们也都清楚，唯独有一点，就是请求余票的时候，返回的是html节点代码，而不是我们预期的json数据，这样就有个麻烦，我们没办法一目了然的明白他余票的时候是如何显示的</p>\n<p>所以我们只能通过<code>chrome</code>进行调试，才能得出他是如何判断余票的。</p>\n<p>我们找个记事本，记录下信息，记录的内容有：</p>\n<ol>\n<li><strong>请求余票接口和购票接口的<code>url</code>地址</strong></li>\n<li><strong><code>cookie</code>信息</strong></li>\n<li><strong>各自的<code>request</code>参数字段</strong></li>\n<li><strong><code>user-Agent</code>信息</strong></li>\n<li><strong>各自的<code>response</code>返回内容</strong></li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-8\">设置chrome</h3>\n<p>有以上信息后，我们就可以开始用chrome调试了，\n首先打开<code>More tools</code>/<code>Network conditions</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbe019d9130e8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1235\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>\"><figcaption></figcaption></figure>\n把<code>user-Agent</code>填入到<code>Custom</code>里面<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbe02119166380?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"486\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"486\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-9\">Charles抓包本地请求</h3>\n<p>因为我们要把获取到的cookie填入到chrome里面，以我们的用户身份去访问网页，所以我们需要在请求目标地址的时候，改包修改cookie</p>\n<p>首先我们需要开启 <code>macOS Proxy</code>，抓包我们的http请求</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbe201ca6bd22e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"440\" data-height=\"484\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"440\" height=\"484\"></svg>\"><figcaption></figcaption></figure>\n打开chrome访问目标网址，我们可以看到<code>Charles</code>上已经抓包到了我们访问的目标url地址，然后给目标url地址打上断点，方便调试<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbeb7f0e72b6e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"860\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"860\"></svg>\"><figcaption></figcaption></figure>\n然后再次访问，这时候断点就生效了，弹出一个tab名为<code>break points</code>，可以看到之所以我们还是不能访问到目标网址，是因为<code>sessionId</code>不对，所以我们把抓取到的<code>cookie</code>在填入到里面，点击<code>execute</code><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dde356cd8baabc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"668\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"668\"></svg>\"><figcaption></figcaption></figure>\n这时候，能够正确跳到目标页面了。<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/12/16dbed1e1521cab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"804\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"804\"></svg>\"><figcaption></figcaption></figure>\n大概看了下他整体布局，和<code>jQuery</code>代码<code>CSS</code>代码，特别是日历表那一块<p></p>\n<p>审查了下元素发现：</p>\n<ol>\n<li><strong>小方块的结构为：</strong></li>\n</ol>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"b\"</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>这里为日期<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>如果有余票则显示余票数量<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">td</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li><strong>td的样式名为<code>a</code>代表不可选</strong></li>\n<li><strong>样式名为<code>e</code>代表已满</strong></li>\n<li><strong>样式名为<code>d</code>代表已购</strong></li>\n<li><strong>样式名为<code>b</code>则是我们要找的，代表可选，也就是有余票</strong></li>\n</ol>\n<p>到这一步，整个购票流程就清楚了</p>\n<p>到时候我们通过Node.js请求的时候，处理返回数据，用正则去判断是否有余票的class名<code>b</code>\n，有余票的话，在获取div里面的余票数量内容就Ok了</p>\n<h1 class=\"heading\" data-id=\"heading-10\">Node.js 请求目标接口</h1>\n<h2 class=\"heading\" data-id=\"heading-11\">分析需要开发的功能点</h2>\n<p>写代码之前我们需要想好功能点，我们需要什么功能:</p>\n<ol>\n<li><strong>请求余票接口</strong></li>\n<li><strong>定时请求任务</strong></li>\n<li><strong>有余票则自动请求购票接口下订单</strong></li>\n<li><strong>调用腾讯云短信api接口发送短信通知</strong></li>\n<li><strong>多个用户抢票功能</strong></li>\n<li><strong>抢某个日期的票</strong></li>\n</ol>\n<p>首先<code>mkdir ticket</code> 创建名为ticket的文件夹，接着<code>cd ticket</code>进入文件夹<code>npm init</code>一路瞎几把回车也无妨。\n下面开始安装依赖，根据上面的功能需求，我们大概需要：</p>\n<ol>\n<li>请求工具，这里看个人习惯，你也可以使用原生的<code>http.request</code>，我这里选择用的是<code>axios</code>，毕竟<code>axios</code>在node端底层也是调用<code>http.request</code></li>\n</ol>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">cnpm install axios --save\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>定时任务 <code>node-schedule</code></li>\n</ol>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">cnpm install node-schedule --save\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>node端选择dom节点工具 <code>cheerio</code></li>\n</ol>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">cnpm install cheerio --save\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li>腾讯发短信的依赖包 <code>qcloudsms_js</code></li>\n</ol>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">cnpm install qcloudsms_js \n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li>热更新包，诺豆的妈妈，<code>nodemon</code> （其实不用也可以）</li>\n</ol>\n<pre><code class=\"hljs shell copyable\" lang=\"shell\">cnpm install nodemon --save-dev\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-12\">开发请求余票接口</h2>\n<p>接着<code>touch index.js</code>创建核心js文件，开始编码：</p>\n<p>首先引入所有依赖</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">\n<span class=\"hljs-keyword\">const</span> axios = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'axios'</span>)\n<span class=\"hljs-keyword\">const</span> querystring = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"querystring\"</span>); <span class=\"hljs-comment\">//序列化对象，用qs也行，都一样</span>\n<span class=\"hljs-keyword\">let</span> QcloudSms = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"qcloudsms_js\"</span>);\n<span class=\"hljs-keyword\">let</span> cheerio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cheerio'</span>);\n<span class=\"hljs-keyword\">let</span> schedule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'node-schedule'</span>);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>然后我们先定义请求参数,来一个obj</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span> obj = {\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">lineId</span>: <span class=\"hljs-number\">111130</span>, <span class=\"hljs-comment\">//路线id</span>\n    vehTime: <span class=\"hljs-number\">0722</span>, <span class=\"hljs-comment\">//发车时间，</span>\n    startTime: <span class=\"hljs-number\">0751</span>, <span class=\"hljs-comment\">//预计上车时间</span>\n    onStationId: <span class=\"hljs-number\">564492</span>, <span class=\"hljs-comment\">//预定的站点id</span>\n    offStationId: <span class=\"hljs-number\">17990</span>,<span class=\"hljs-comment\">//到站id</span>\n    onStationName: <span class=\"hljs-string\">'宝安交通运输局③'</span>,  <span class=\"hljs-comment\">//预定的站点名称</span>\n    offStationName: <span class=\"hljs-string\">\"深港产学研基地\"</span>,<span class=\"hljs-comment\">//预定到站名称</span>\n    tradePrice: <span class=\"hljs-number\">0</span>,<span class=\"hljs-comment\">//总金额</span>\n    saleDates: <span class=\"hljs-string\">'17'</span>,<span class=\"hljs-comment\">//车票日期</span>\n    beginDate: <span class=\"hljs-string\">''</span>,<span class=\"hljs-comment\">//订票时间，滞空，用于抓取到余票后填入数据</span>\n  },\n  <span class=\"hljs-attr\">phoneNumber</span>: <span class=\"hljs-number\">123123123</span>, <span class=\"hljs-comment\">//用户手机号，接收短信的手机号</span>\n  cookie: <span class=\"hljs-string\">'JSESSIONID=TESTCOOKIE'</span>, <span class=\"hljs-comment\">// 抓取到的cookie</span>\n  day: <span class=\"hljs-string\">\"17\"</span> <span class=\"hljs-comment\">//定17号的票，这个主要是用于抢指定日期的票，滞空则为抢当月所有余票</span>\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>接着声明一个名为<code>queryTicket</code>的类，为啥要用类呢，因为基于第五个需求点，多个用户抢票的时候，我们分别<code>new</code>一下就行了，</p>\n<p>同时我们希望能够记录请求余票的次数，和当抢到票后自动停止查询余票得操作，所以给他加上个计数变量<code>times</code>和是否停止的变量，布尔值<code>stop</code></p>\n<p>编写代码:</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QueryTicket</span></span>{\n  <span class=\"hljs-comment\">/**\n   *Creates an instance of QueryTicket.\n   * @param {Object} { data, phoneNumber, cookie, day }\n   * @param data {Object} 请求余票接口的requery参数\n   * @param phoneNumber {Number} 用户手机号，短信需要用到\n   * @param cookie {String} cookie信息\n   * @params day {String} 某日的票，如'18'\n   * @memberof QueryTicket 请求余票接口\n   */</span>\n  <span class=\"hljs-keyword\">constructor</span>({ data, phoneNumber, cookie, day }) {\n    <span class=\"hljs-keyword\">this</span>.data = data \n    <span class=\"hljs-keyword\">this</span>.cookie = cookie\n    <span class=\"hljs-keyword\">this</span>.day = day\n    <span class=\"hljs-keyword\">this</span>.phoneNumber = phoneNumber\n    <span class=\"hljs-keyword\">this</span>.postData = querystring.stringify(data)\n    <span class=\"hljs-keyword\">this</span>.times = <span class=\"hljs-number\">0</span>;   <span class=\"hljs-comment\">//记录次数</span>\n    <span class=\"hljs-keyword\">let</span> stop = <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">//通过特定接口才能修改stop值，防止外部随意串改</span>\n    <span class=\"hljs-keyword\">this</span>.getStop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">//获取是否停止</span>\n      <span class=\"hljs-keyword\">return</span> stop \n    }\n    <span class=\"hljs-keyword\">this</span>.setStop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ifStop</span>) </span>{ <span class=\"hljs-comment\">//设置是否停止</span>\n      stop = ifStop\n    }\n  }\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>下面开始定义原型方法，为了方便维护，我们把逻辑拆分成各个函数</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QueryTicket</span></span>{\n  <span class=\"hljs-keyword\">constructor</span>({ data, phoneNumber, cookie, day }) {\n  <span class=\"hljs-comment\">//constructor代码... </span>\n  }\n    init(){}<span class=\"hljs-comment\">//初始化</span>\n    handleQueryTicket(){}<span class=\"hljs-comment\">//查询余票的逻辑</span>\n    requestTicket(){} <span class=\"hljs-comment\">//调用查询余票接口</span>\n    handleBuyTicket(){} <span class=\"hljs-comment\">//购票相关逻辑</span>\n    requestOrder(){}<span class=\"hljs-comment\">//调用购票接口</span>\n    handleInfoUser(){}<span class=\"hljs-comment\">//通知用户的逻辑</span>\n    sendMSg(){} <span class=\"hljs-comment\">//发短信接口</span>\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>所有数据都是基于查询余票的操作，因此我们先开发这部分功能</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QueryTicket</span></span>{\n  <span class=\"hljs-keyword\">constructor</span>({ data, phoneNumber, cookie, day }) {\n  <span class=\"hljs-comment\">//constructor代码... </span>\n  }\n  <span class=\"hljs-comment\">//初始化,因为涉及到异步请求，所以我们使用`async await`</span>\n   <span class=\"hljs-keyword\">async</span> init(){\n          <span class=\"hljs-keyword\">let</span> ticketList = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.handleQueryTicket() <span class=\"hljs-comment\">//返回查询到的余票数组</span>\n    }\n    <span class=\"hljs-comment\">//查询余票的逻辑</span>\n    handleQueryTicket(){ \n    <span class=\"hljs-keyword\">let</span> ticketList = [] <span class=\"hljs-comment\">//余票数组</span>\n    <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.requestTicket()\n    <span class=\"hljs-keyword\">this</span>.times++ <span class=\"hljs-comment\">//计数器，记录请求查询多少次</span>\n    <span class=\"hljs-keyword\">let</span> str = res.data.replace(<span class=\"hljs-regexp\">/\\\\/g</span>, <span class=\"hljs-string\">\"\"</span>) <span class=\"hljs-comment\">//格式化返回值</span>\n    <span class=\"hljs-keyword\">let</span> $ = cheerio.load(<span class=\"hljs-string\">`<div class=\"main\"><span class=\"hljs-subst\">${str}</span></div>`</span>) <span class=\"hljs-comment\">// cheerio载入查询接口response的html节点数据</span>\n    <span class=\"hljs-keyword\">let</span> list = $(<span class=\"hljs-string\">\".main\"</span>).find(<span class=\"hljs-string\">\".b\"</span>) <span class=\"hljs-comment\">//查找是否有余票的dom节点</span>\n    <span class=\"hljs-comment\">// 如果没有余票，打印出请求多少次,然后返回，不执行下面的代码</span>\n    <span class=\"hljs-keyword\">if</span> (!list.length) {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`用户<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.phoneNumber}</span>：无票，已进行<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.times}</span>次`</span>)\n      <span class=\"hljs-keyword\">return</span>\n    }\n\n    <span class=\"hljs-comment\">// 如果有余票</span>\n    list.each(<span class=\"hljs-function\">(<span class=\"hljs-params\">idx, item</span>) =></span> {\n      <span class=\"hljs-keyword\">let</span> str = $(item).html() <span class=\"hljs-comment\">//str这时格式是<span>21</span><span>&$x4F59;0</span></span>\n      <span class=\"hljs-comment\">//最后一个span 的内容其实\"余0\"，也就是无票，只不过是被转码了而已</span>\n      <span class=\"hljs-comment\">//因此要在下一步对其进行格式化</span>\n      <span class=\"hljs-keyword\">let</span> arr = str.split(<span class=\"hljs-regexp\">/<span>|<\\/span>|\\&\\#x4F59\\;/</span>).filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> !!item === <span class=\"hljs-literal\">true</span>) \n      <span class=\"hljs-keyword\">let</span> data = {\n        <span class=\"hljs-attr\">day</span>: arr[<span class=\"hljs-number\">0</span>],\n        <span class=\"hljs-attr\">ticketLeft</span>: arr[<span class=\"hljs-number\">1</span>]\n      }\n      \n      <span class=\"hljs-comment\">//如果是要抢指定日期的票</span>\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.day) {\n      <span class=\"hljs-comment\">//如果有指定日期的余票</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">parseInt</span>(data.day) === <span class=\"hljs-built_in\">parseInt</span>(data.day)) {\n          ticketList.push(data)\n        }\n      } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">//如果不是，则返回查询到的所有余票</span>\n        ticketList.push(data)\n      }\n    })\n    <span class=\"hljs-keyword\">return</span> ticketList\n    }\n     <span class=\"hljs-comment\">//调用查询余票接口</span>\n    requestTicket(){\n    <span class=\"hljs-keyword\">return</span> axios.post(<span class=\"hljs-string\">'http://weixin.xxxx.net/ebus/front/wxQueryController.do?BcTicketCalendar'</span>, <span class=\"hljs-keyword\">this</span>.postData, {\n      <span class=\"hljs-attr\">headers</span>: {\n        <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/x-www-form-urlencoded'</span>,\n        <span class=\"hljs-string\">'User-Agent'</span>: <span class=\"hljs-string\">\"Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/5.4.1 NetType/WIFI\"</span>,\n        <span class=\"hljs-string\">\"Cookie\"</span>: <span class=\"hljs-keyword\">this</span>.cookie\n      }\n    })   \n    }\n    handleBuyTicket(){} <span class=\"hljs-comment\">//购票相关逻辑</span>\n    requestOrder(){}<span class=\"hljs-comment\">//调用购票接口</span>\n    handleInfoUser(){}<span class=\"hljs-comment\">//通知用户的逻辑</span>\n    sendMSg(){} <span class=\"hljs-comment\">//发短信接口</span>\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>来解释下那行正则，<code>cheerio</code>抓取到的dom是长这样的，第一个<code>span</code>内容是日期，第二个是余票数量\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddcebe5ff5a6e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"226\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"226\"></svg>\"><figcaption></figcaption></figure>\n所以我们要把它格式化变成这种数组，也就是<code>ticketList</code>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddcec5a3ddac0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"231\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"231\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-13\">开发购票功能</h2>\n<p>首先我们在<code>init</code>方法里做个判断，如果有余票才去购票，没有余票购个毛</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QueryTicket</span></span>{\n  <span class=\"hljs-keyword\">constructor</span>({ data, phoneNumber, cookie, day }) {\n  <span class=\"hljs-comment\">//constructor代码... </span>\n  }\n  <span class=\"hljs-comment\">//初始化</span>\n   <span class=\"hljs-keyword\">async</span> init(){\n    <span class=\"hljs-keyword\">let</span> ticketList = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.handleQueryTicket()\n    <span class=\"hljs-comment\">//如果有余票</span>\n    <span class=\"hljs-keyword\">if</span> (ticketList.length) {\n    <span class=\"hljs-comment\">//把余票传入购票逻辑方法，返回短信通知所需要的数据</span>\n      <span class=\"hljs-keyword\">let</span> resParse = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.handleBuyTicket(ticketList)\n    }\n    }\n    \n    <span class=\"hljs-comment\">//查询余票的逻辑</span>\n   <span class=\"hljs-keyword\">async</span> handleQueryTicket(){\n    <span class=\"hljs-comment\">// 查询余票代码...</span>\n    }\n    <span class=\"hljs-comment\">//调用查询余票接口</span>\n    requestTicket(){\n    <span class=\"hljs-comment\">//调用查询余票接口代码...    </span>\n    } \n    <span class=\"hljs-comment\">//购票相关逻辑</span>\n   <span class=\"hljs-keyword\">async</span> handleBuyTicket(ticketList){\n    <span class=\"hljs-keyword\">let</span> year = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() <span class=\"hljs-comment\">//年份，</span>\n    <span class=\"hljs-keyword\">let</span> month = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getMonth() + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//月份，拼接购票日期用得上，因为余票接口只返回几号</span>\n    <span class=\"hljs-keyword\">let</span> {\n      onStationName,<span class=\"hljs-comment\">//起始站点名</span>\n      offStationName,<span class=\"hljs-comment\">//结束站点名</span>\n      lineId,<span class=\"hljs-comment\">//线路id</span>\n      vehTime,<span class=\"hljs-comment\">//发车时间</span>\n      startTime,<span class=\"hljs-comment\">//预计上车时间</span>\n      onStationId,<span class=\"hljs-comment\">//上车的站台id</span>\n      offStationId <span class=\"hljs-comment\">//到站的站台id</span>\n      } = <span class=\"hljs-keyword\">this</span>.data <span class=\"hljs-comment\">// 初始化的数据</span>\n\n    <span class=\"hljs-keyword\">let</span> station = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${onStationName}</span>-<span class=\"hljs-subst\">${offStationName}</span>`</span> <span class=\"hljs-comment\">//站点，发短信时候用到:\"宝安交通局-深港产学研基地\"</span>\n    <span class=\"hljs-keyword\">let</span> dateStr = <span class=\"hljs-string\">\"\"</span>; <span class=\"hljs-comment\">//车票日期</span>\n    <span class=\"hljs-keyword\">let</span> tickAmount = <span class=\"hljs-string\">\"\"</span> <span class=\"hljs-comment\">//总张数</span>\n    ticketList.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> {\n      dateStr = dateStr + <span class=\"hljs-string\">`<span class=\"hljs-subst\">${year}</span>-<span class=\"hljs-subst\">${month}</span>-<span class=\"hljs-subst\">${item.day}</span>,`</span>\n      tickAmount = tickAmount + <span class=\"hljs-string\">`<span class=\"hljs-subst\">${item.ticketLeft}</span>张,`</span>\n    })\n\n    <span class=\"hljs-keyword\">let</span> buyTicket = {\n      lineId,<span class=\"hljs-comment\">//线路id</span>\n      vehTime,<span class=\"hljs-comment\">//发车时间</span>\n      startTime,<span class=\"hljs-comment\">//预计上车时间</span>\n      onStationId,<span class=\"hljs-comment\">//上车的站点id</span>\n      offStationId,<span class=\"hljs-comment\">//目标站点id</span>\n      tradePrice: <span class=\"hljs-string\">'5'</span>, <span class=\"hljs-comment\">//金额</span>\n      saleDates: dateStr.slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>),\n      <span class=\"hljs-attr\">payType</span>: <span class=\"hljs-string\">'2'</span> <span class=\"hljs-comment\">//支付方式，微信支付</span>\n    }\n\n    <span class=\"hljs-comment\">// 调用购票接口</span>\n     <span class=\"hljs-keyword\">let</span> data = querystring.stringify(buyTicket)\n     <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.requestOrder(data) <span class=\"hljs-comment\">//返回json数据，是否购票成功等等</span>\n     <span class=\"hljs-comment\">//把发短信所需要数据都要传入</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.assign({}, <span class=\"hljs-built_in\">JSON</span>.parse(res.data), { <span class=\"hljs-attr\">queryParam</span>: { dateStr, tickAmount, startTime, station } })\n    }<span class=\"hljs-comment\">//购票相关逻辑</span>\n    <span class=\"hljs-comment\">//调用购票接口</span>\n    requestOrder(obj){\n    <span class=\"hljs-keyword\">return</span> axios.post(<span class=\"hljs-string\">'http://weixin.xxxx.net/ebus/front/wxQueryController.do?BcTicketBuy'</span>, obj, {\n      <span class=\"hljs-attr\">headers</span>: {\n        <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/x-www-form-urlencoded'</span>,\n        <span class=\"hljs-string\">'User-Agent'</span>: <span class=\"hljs-string\">\"Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/5.4.1 NetType/WIFI\"</span>,\n        <span class=\"hljs-string\">\"Cookie\"</span>: <span class=\"hljs-keyword\">this</span>.cookie\n      }\n    })\n    }\n    handleInfoUser(){}<span class=\"hljs-comment\">//通知用户的逻辑</span>\n    sendMSg(){} <span class=\"hljs-comment\">//发短信接口</span>\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>到这里，查询余票，购票这两个核心操作已经完成。</p>\n<p>目前还剩下，如何通知用户是否购票成功。</p>\n<p>之前我尝试过使用qq邮箱的smtp服务，抢票成功后发送邮件通知，但是我觉得吧，并不好用，主要是我没有打开邮箱的习惯，没网也收不到，所以，并没有采纳这个方案。</p>\n<p>加上之前我注册过企业认证的公众号，腾讯云免费送了我1000条短信通知，而且短信也比较直观，所以我这里就安装腾讯云的SDK，部署了一套发短信的功能。</p>\n<h2 class=\"heading\" data-id=\"heading-14\">腾讯云短信的相关内容</h2>\n<p>其实看看文档就行了，我也是copy文档，注意看短信单发那部分</p>\n<p><a target=\"_blank\" href=\"https://cloud.tencent.com/document/product/382/3772\" rel=\"nofollow noopener noreferrer\">cloud.tencent.com/document/pr…</a></p>\n<p>如果跟我一样有企业认证的话，看快速入门这里就行了，一步步跟着操作\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dddd7629b40c48?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"489\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"489\"></svg>\"><figcaption></figcaption></figure>\n看下短信正文，<code>{Number}</code>这些里面的数字是变量。<p></p>\n<p>就是说短信的模板是固定的，但是里面有<code>{Number}</code>的内容可以自定义</p>\n<p>调用的时候，里面的数字对应着传过去的参数数组序号，{1}代表数组[0]参数，以此类推\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dddd6c1dd1a411?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"539\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"539\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>提交审核，审核一般很快就通过，也就是几十万毫秒吧</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dddf02494589bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1210\" data-height=\"108\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1210\" height=\"108\"></svg>\"><figcaption></figcaption></figure>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dddefa8b62db68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"116\" data-height=\"120\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"116\" height=\"120\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-15\">开发通知功能</h2>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QueryTicket</span></span>{\n  <span class=\"hljs-keyword\">constructor</span>({ data, phoneNumber, cookie, day }) {\n  <span class=\"hljs-comment\">//constructor代码... </span>\n  }\n  <span class=\"hljs-comment\">//初始化</span>\n   <span class=\"hljs-keyword\">async</span> init(){\n    <span class=\"hljs-keyword\">let</span> ticketList = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.handleQueryTicket()\n    <span class=\"hljs-comment\">//如果有余票</span>\n    <span class=\"hljs-keyword\">if</span> (ticketList.length) {\n    <span class=\"hljs-comment\">//把余票传入购票逻辑方法，返回短信通知所需要的数据</span>\n      <span class=\"hljs-keyword\">let</span> resParse = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.handleBuyTicket(ticketList)\n    <span class=\"hljs-comment\">//执行通知逻辑</span>\n     <span class=\"hljs-keyword\">this</span>.handleInfoUser(resParse)\n    }\n    }\n    \n    <span class=\"hljs-comment\">//查询余票的逻辑</span>\n   <span class=\"hljs-keyword\">async</span> handleQueryTicket(){\n    <span class=\"hljs-comment\">// 查询余票代码...</span>\n    }\n    <span class=\"hljs-comment\">//调用查询余票接口</span>\n    requestTicket(){\n    <span class=\"hljs-comment\">//调用查询余票接口代码...    </span>\n    } \n    <span class=\"hljs-comment\">//购票相关逻辑</span>\n   <span class=\"hljs-keyword\">async</span> handleBuyTicket(ticketList){\n    <span class=\"hljs-comment\">//购票代码...</span>\n    }\n    <span class=\"hljs-comment\">//调用购票接口</span>\n    requestOrder(obj){\n    <span class=\"hljs-comment\">//购票接口请求代码...</span>\n    }\n    <span class=\"hljs-comment\">//通知用户的逻辑</span>\n    <span class=\"hljs-keyword\">async</span> handleInfoUser(parseData){\n    <span class=\"hljs-comment\">//获取上一步购票的response数据和我们拼接的数据</span>\n    <span class=\"hljs-keyword\">let</span> { returnCode, <span class=\"hljs-attr\">returnData</span>: { <span class=\"hljs-attr\">main</span>: { lineName, tradePrice } }, <span class=\"hljs-attr\">queryParam</span>: { dateStr, tickAmount, startTime, station } } = parseData\n    <span class=\"hljs-comment\">//如果购票成功，则返回500</span>\n    <span class=\"hljs-keyword\">if</span> (returnCode === <span class=\"hljs-string\">\"500\"</span>) {\n      <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.sendMsg({\n        dateStr, <span class=\"hljs-comment\">//日期</span>\n        tickAmount: tickAmount.slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>), <span class=\"hljs-comment\">//总张数</span>\n        station, <span class=\"hljs-comment\">//站点</span>\n        lineName, <span class=\"hljs-comment\">//巴士名称/路线名称</span>\n        tradePrice,<span class=\"hljs-comment\">//总价</span>\n        startTime,<span class=\"hljs-comment\">//出发时间</span>\n        phoneNumber: <span class=\"hljs-keyword\">this</span>.phoneNumber,<span class=\"hljs-comment\">//手机号</span>\n      })\n      <span class=\"hljs-comment\">//如果发信成功，则不再进行抢票操作</span>\n      <span class=\"hljs-keyword\">if</span> (res.result === <span class=\"hljs-number\">0</span> && res.errmsg === <span class=\"hljs-string\">\"OK\"</span>) {\n        <span class=\"hljs-keyword\">this</span>.setStop(<span class=\"hljs-literal\">true</span>)\n      } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">//失败不做任何操作</span>\n        <span class=\"hljs-built_in\">console</span>.log(res.errmsg)\n      }\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">//失败不做任何操作</span>\n      <span class=\"hljs-built_in\">console</span>.log(resParse[<span class=\"hljs-string\">'returnInfo'</span>])\n    }        \n    }\n    <span class=\"hljs-comment\">//发短信接口</span>\n    sendMSg(){\n    <span class=\"hljs-keyword\">let</span> { dateStr, tickAmount, station, lineName, phoneNumber, startTime, tradePrice } = obj\n    <span class=\"hljs-keyword\">let</span> appid = <span class=\"hljs-number\">140034324</span>;  <span class=\"hljs-comment\">// SDK AppID 以1400开头</span>\n    <span class=\"hljs-comment\">// 短信应用 SDK AppKey</span>\n    <span class=\"hljs-keyword\">let</span> appkey = <span class=\"hljs-string\">\"asdfdsvajwienin23493nadsnzxc\"</span>;\n    <span class=\"hljs-comment\">// 短信模板 ID，需要在短信控制台中申请</span>\n    <span class=\"hljs-keyword\">let</span> templateId = <span class=\"hljs-number\">7839</span>;  <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> 这里的模板ID`7839`只是示例，真实的模板 ID 需要在短信控制台中申请</span>\n    <span class=\"hljs-comment\">// 签名</span>\n    <span class=\"hljs-keyword\">let</span> smsSign = <span class=\"hljs-string\">\"测试短信\"</span>;  <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名\"腾讯云\"只是示例，真实的签名需要在短信控制台申请</span>\n    <span class=\"hljs-comment\">// 实例化 QcloudSms</span>\n    <span class=\"hljs-keyword\">let</span> qcloudsms = QcloudSms(appid, appkey);\n    <span class=\"hljs-keyword\">let</span> ssender = qcloudsms.SmsSingleSender();\n    <span class=\"hljs-comment\">// 这里的params就是短信里面可以自定义的内容，也就是填入{1}{2}..的内容</span>\n    <span class=\"hljs-keyword\">let</span> params = [dateStr, station, lineName, startTime, tickAmount, tradePrice];\n    <span class=\"hljs-comment\">//用promise来封装下异步操作</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      ssender.sendWithParam(<span class=\"hljs-number\">86</span>, phoneNumber, templateId, params, smsSign, <span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, res, resData</span>) </span>{\n        <span class=\"hljs-keyword\">if</span> (err) {\n          reject(err)\n        } <span class=\"hljs-keyword\">else</span> {\n          resolve(resData)\n        }\n      });\n    })\n    } \n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果发信成功，返回<code>result:0</code>\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dddf647e452e11?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"142\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"142\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>到这里，大部分需求已经完成了，还剩下一个定时任务</p>\n<h2 class=\"heading\" data-id=\"heading-16\">定时任务</h2>\n<p>也声明一个类，这里我们用到的是<code>schedule</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// 定时任务</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SetInter</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>({ timer, fn }) {\n    <span class=\"hljs-keyword\">this</span>.timer = timer <span class=\"hljs-comment\">// 每几秒执行</span>\n    <span class=\"hljs-keyword\">this</span>.fn = fn <span class=\"hljs-comment\">//执行的回调</span>\n    <span class=\"hljs-keyword\">this</span>.rule = <span class=\"hljs-keyword\">new</span> schedule.RecurrenceRule(); <span class=\"hljs-comment\">//实例化一个对象</span>\n    <span class=\"hljs-keyword\">this</span>.rule.second = <span class=\"hljs-keyword\">this</span>.setRule() <span class=\"hljs-comment\">// 调用原型方法，schedule的语法而已</span>\n    <span class=\"hljs-keyword\">this</span>.init()\n  }\n  setRule() {\n    <span class=\"hljs-keyword\">let</span> rule = [];\n    <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (i < <span class=\"hljs-number\">60</span>) {\n      rule.push(i)\n      i += <span class=\"hljs-keyword\">this</span>.timer\n    }\n    <span class=\"hljs-keyword\">return</span> rule <span class=\"hljs-comment\">//假设传入的timer为5，则表示定时任务每5秒执行一次</span>\n    <span class=\"hljs-comment\">// [1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 51, 56] </span>\n  }\n  init() {\n    schedule.scheduleJob(<span class=\"hljs-keyword\">this</span>.rule, () => {\n      <span class=\"hljs-keyword\">this</span>.fn() <span class=\"hljs-comment\">// 定时调用传入的回调方法</span>\n    });\n  }\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-17\">多个用户抢票</h2>\n<p>假设我们有两个用户要抢票，所以定义两个obj，实例化下<code>QueryTicket</code>类</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">  data: { <span class=\"hljs-comment\">//用户1</span>\n    lineId: <span class=\"hljs-number\">111130</span>,\n    <span class=\"hljs-attr\">vehTime</span>: <span class=\"hljs-number\">0722</span>,\n    <span class=\"hljs-attr\">startTime</span>: <span class=\"hljs-number\">0751</span>,\n    <span class=\"hljs-attr\">onStationId</span>: <span class=\"hljs-number\">564492</span>,\n    <span class=\"hljs-attr\">offStationId</span>: <span class=\"hljs-number\">17990</span>,\n    <span class=\"hljs-attr\">onStationName</span>: <span class=\"hljs-string\">'宝安交通运输局③'</span>,\n    <span class=\"hljs-attr\">offStationName</span>: <span class=\"hljs-string\">\"深港产学研基地\"</span>,\n    <span class=\"hljs-attr\">tradePrice</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">saleDates</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">beginDate</span>: <span class=\"hljs-string\">''</span>,\n  },\n  <span class=\"hljs-attr\">phoneNumber</span>: <span class=\"hljs-number\">123123123</span>,\n  <span class=\"hljs-attr\">cookie</span>: <span class=\"hljs-string\">'JSESSIONID=TESTCOOKIE'</span>,\n  <span class=\"hljs-attr\">day</span>: <span class=\"hljs-string\">\"17\"</span>\n}\n<span class=\"hljs-keyword\">let</span> obj2 = { <span class=\"hljs-comment\">//用户2</span>\n  data: {\n    <span class=\"hljs-attr\">lineId</span>: <span class=\"hljs-number\">134423</span>,\n    <span class=\"hljs-attr\">vehTime</span>: <span class=\"hljs-number\">1820</span>,\n    <span class=\"hljs-attr\">startTime</span>: <span class=\"hljs-number\">1855</span>,\n    <span class=\"hljs-attr\">onStationId</span>: <span class=\"hljs-number\">4322</span>,\n    <span class=\"hljs-attr\">offStationId</span>: <span class=\"hljs-number\">53231</span>,\n    <span class=\"hljs-attr\">onStationName</span>: <span class=\"hljs-string\">'百度国际大厦'</span>,\n    <span class=\"hljs-attr\">offStationName</span>: <span class=\"hljs-string\">\"裕安路口\"</span>,\n    <span class=\"hljs-attr\">tradePrice</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">saleDates</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">beginDate</span>: <span class=\"hljs-string\">''</span>,\n  },\n  <span class=\"hljs-attr\">phoneNumber</span>: <span class=\"hljs-number\">175932123124</span>,\n  <span class=\"hljs-attr\">cookie</span>: <span class=\"hljs-string\">'JSESSIONID=TESTCOOKIE'</span>,\n  <span class=\"hljs-attr\">day</span>: <span class=\"hljs-string\">\"\"</span> \n}\n<span class=\"hljs-keyword\">let</span> ticket = <span class=\"hljs-keyword\">new</span> QueryTicket(obj) <span class=\"hljs-comment\">//用户1</span>\n<span class=\"hljs-keyword\">let</span> ticket2 = <span class=\"hljs-keyword\">new</span> QueryTicket(obj2) <span class=\"hljs-comment\">//用户2</span>\n\n<span class=\"hljs-keyword\">new</span> SetInter({\n  <span class=\"hljs-attr\">timer</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">//每秒执行一次，建议5秒，不然怕被ip拉黑，我这里只是为了方便下面截图</span>\n  fn: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    [ticket,ticket2].map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> { <span class=\"hljs-comment\">//同时进行两个用户的抢票</span>\n      <span class=\"hljs-keyword\">if</span> (!item.getStop()) {  <span class=\"hljs-comment\">//调用实例的原型方法，判断是否停止抢票，如果没有则继续抢</span>\n        item.init()\n      } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// 如果抢到票了，则不继续抢票</span>\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'stop'</span>)\n      }\n    })\n  }\n})\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>node index.js</code> 运行下，跑起来了</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16dedde47ecd677b?imageslim\" data-width=\"800\" data-height=\"364\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"364\"></svg>\"><figcaption></figcaption></figure>\n如果他抢到票的话，我就会收到短信通知：<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16dde1daec3f1eab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"635\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"635\" height=\"1280\"></svg>\"><figcaption></figcaption></figure>\n打开手机，看下订单信息<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddf278e51019c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"516\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"516\"></svg>\"><figcaption></figcaption></figure>\n搞定，收工<p></p>\n<h1 class=\"heading\" data-id=\"heading-18\">写在最后</h1>\n<p>其实可以在此基础上还能添加更多功能，比如直接抓取登录接口获取cookie，指定路线抢票，还有错误处理啊啥的</p>\n<p><strong>值得注意的是，请求接口不能太频繁，最好控制在5秒一次的频率，不然会给别人造成困扰，也容易被ip拉黑</strong></p>\n<p>如果想把它做成一个完整的项目，建议使用ts加持\n，关于ts我推荐阅读这篇JD前端写的文章</p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d8efeace51d45782b0c1bd6\" rel>juejin.im/post/5d8efe…</a></p>\n<p>希望各位能有所收获</p>\n<h1 class=\"heading\" data-id=\"heading-19\">特别声明</h1>\n<blockquote>\n<p><strong>本文只做为技术分享，文中代码仅做学习用途</strong></p>\n</blockquote>\n",
      "id": "503tk9x1xxk",
      "author": "前端小智",
      "title": "Node.js 实现抢票小工具&短信通知提醒"
    },
    {
      "content": "<blockquote>\n<p>作者：Dmitri Pavlutin</p>\n<p>译者：前端小智</p>\n<p>来源：dmitripavlutin</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>这几天自己的公众号无套路送现金 200+，参与方式如下</strong>\n<a target=\"_blank\" href=\"https://mp.weixin.qq.com/s/PTlWMG5KeJJtyS-Yd4FvbQ\" rel=\"nofollow noopener noreferrer\">mp.weixin.qq.com/s/PTlWMG5Ke…</a></p>\n</blockquote>\n<hr>\n<p><strong>为了保证的可读性，本文采用意译而非直译。</strong></p>\n<p>在 JS 面试中，经常会看到一些简单而又沙雕的题目，这些题目包含一些陷阱，但这些在我们规范的编码下或者业务中基本不会出现。 有些面试官就是这样，不专注于制定代码的标准和规范上，却用不规范的代码去检验别人是否细心。</p>\n<p>这魔幻的世界就是一个攀比优越感的，我能考你，我就是比你优越，真实。</p>\n<p>来看看这 7 个沙雕题目是哪些。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">1. 偶然创建的全局变量</h2>\n<p><strong>面试官问</strong></p>\n<p>在下面的代码中 <code>typeof a</code> 和 <code>typeof b</code> 结果各自是什么？（沙雕）</p>\n<pre><code class=\"copyable\">function foo() {\n  let a = b = 0;\n  a++;\n  return a;\n}\n\nfoo();\ntypeof a; // => ???\ntypeof b; // => ???\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>这个代码的重点在<code>第二行</code>:<code>let a = b = 0</code>。这个语句声明了一个局部变量 <code>a</code>，但是它也声明了一个全局变量<code>b</code>。</p>\n<p>在 <code>foo()</code> 作用域或全局作用域中都没有声明变量 <code>b</code>。因此 JS 引荐将<code>b = 0</code> 表达式解释为 <code>window.b = 0</code>。</p>\n<p>如下图所示，函数 <code>foo</code> 中的 <code>i</code> 都是一个偶然创建的全局变量：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deb97bd13e6221?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"600\" data-height=\"682\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"600\" height=\"682\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>同样，在咱们的问题中，<code>b</code> 是一个偶然创建的全局变量。在浏览器中，上面的代码相当于如下：</p>\n<pre><code class=\"copyable\">function foo() {\n  let a;\n  window.b = 0;\n  a = window.b;\n  a++;\n  return a;\n}\n\nfoo();\ntypeof a;        // => 'undefined'\ntypeof window.b; // => 'number'\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><code>typeof a</code> 是 <code>'undefined'</code>。变量 <code>a</code> 仅在 <code>foo()</code> 作用域中声明，在外部作用域内不可用。</p>\n<p><code>typeof b</code> 结果是 <code>'number'</code>。<code>b</code> 是一个值为 <code>0</code> 的全局变量</p>\n<h2 class=\"heading\" data-id=\"heading-1\">2. 数组的 length 属性</h2>\n<p><strong>面试官问</strong></p>\n<p><code>clothes[0]</code> 的值是什么？（沙雕）</p>\n<pre><code class=\"copyable\">const clothes = ['jacket', 't-shirt'];\nclothes.length = 0;\n\nclothes[0]; // => ???\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>数组对象的 <code>length</code> 属性具有一些<a target=\"_blank\" href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-array-instances-length\" rel=\"nofollow noopener noreferrer\">特殊的行为</a>：</p>\n<blockquote>\n<p>减少 <code>length</code> 属性的值的副作用是删除 <code>自己的</code> 数组元素，这些元素的数组索引位于新旧长度值之间。</p>\n</blockquote>\n<p>由于 <code>length</code> 属性行为，当 JS 执行 <code>clothes.length = 0</code> 时，删除所有的 <code>clothes</code> 项。 所以  <code>clothes[0]</code> 的值为 <code>undefined</code>，因为 <code>clothes</code> 数组已被清空。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">3.考验眼力的魔幻题</h2>\n<p><strong>面试官问</strong></p>\n<p>下面代码中 numbers 数组的内容是什么? <strong>注意 <code>for()</code> 后加了一个分号(<code>;</code>)，真是沙雕</strong>。</p>\n<pre><code class=\"copyable\">const length = 4;\nconst numbers = [];\nfor (var i = 0; i < length; i++);{\n  numbers.push(i + 1);\n}\n\nnumbers; // => ???\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>上面代码中 <code>for()</code> 后加了一个分号(<code>;</code>) ，加上分号，JS 会认为该语句结束，所以 for 循环执行了4次空语句，当退出循环的时候，此时的 i 值为 4。</p>\n<p>然后执行  <code>{ numbers.push(i + 1); }</code>，所以最终 <code>numbers</code> 内容只有一个数字 <code>5</code>。</p>\n<p>上面的代码相当于下面的代码</p>\n<pre><code class=\"copyable\">const length = 4;\nconst numbers = [];\nvar i;\nfor (i = 0; i < length; i++) {\n  // does nothing\n}\n{ \n  // a simple block\n  numbers.push(i + 1);\n}\n\nnumbers; // => [5]    \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>用不规范的代码去检验别人是否细心，我觉得很沙雕。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">4.自动分号插入</h2>\n<p><strong>面试官问</strong></p>\n<p><code>arrayFromValue()</code> 返回什么值?（沙雕）</p>\n<pre><code class=\"copyable\">function arrayFromValue(items) {\n  return\n    [items];\n}\n\narrayFromValue(10); // => ???\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>这里需要注意的 <code>return</code> 和 <code>[items]</code> 之间已经换行了，JS 会在换行之间自动插入分号。所以上面等价下面的代码：</p>\n<pre><code class=\"copyable\">function arrayFromValue(items) {\n  return;\n  [items];\n}\n\narrayFromValue(10); // => undefined\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><code>return;</code>在函数内部使该函数返回 <code>undefined</code>，所以 <code>arrayFromValue(10)</code> 的值为 <code>undefined</code>。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">5. 被考烂的一个经典闭包问题</h2>\n<p><strong>面试官问</strong></p>\n<p>下面的代码执行结果是什么？（能不能换个题）</p>\n<pre><code class=\"copyable\">let i;\nfor (i = 0; i < 3; i++) {\n  const log = () => {\n    console.log(i);\n  }\n  setTimeout(log, 100);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>当你对 JS 基础不是很了解的时候，很容易给出 <code>0, 1, 2</code> 的答案，我第一次在学校遇到这个题目也是这个答案。</p>\n<p>执行这段代码的过程有两个阶段。</p>\n<p><strong>阶段1</strong></p>\n<ol>\n<li>\n<p><code>for()</code> 迭代 <code>3</code> 次。在每次迭代时，都会创建一个新函数 <code>log()</code>，该函数将捕获变量 <code>i</code>。然后，<code>setTimout()</code> 调度 <code>log()</code> 的执行。</p>\n</li>\n<li>\n<p>当 <code>for()</code> 循环完成时，变量 <code>i</code> 的值为 <code>3</code>。</p>\n</li>\n</ol>\n<p><code>log()</code> 是一个捕获变量 <code>i</code> 的闭包，该变量在 <code>for()</code> 循环的外部作用域中定义。重要的是要了解闭包在词法上捕获了变量 <code>i</code>。</p>\n<p><strong>阶段 2</strong></p>\n<p>第二阶段发生在 <code>100</code> 毫秒之后</p>\n<p>setTimeout()调用 <code>3</code> 个 <code>log()</code> 回调。<code>log()</code> 读取变量 <code>i</code> 的当前值，即 <code>3</code>。</p>\n<p>这就是为什么控制台输出为 <code>3</code>， <code>3</code> 和 <code>3</code> 的原因</p>\n<h2 class=\"heading\" data-id=\"heading-5\">6. 浮点运算</h2>\n<p><strong>面试官问</strong></p>\n<p>下面的代码输出是什么？ （能不能换个题）</p>\n<pre><code class=\"copyable\">0.1 + 0.2 === 0.3 // => ???\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>首先，来看一下 <code>0.1 + 0.2</code> 的值</p>\n<pre><code class=\"copyable\">0.1 + 0.2; // => 0.30000000000000004\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><code>0.1</code> 和 <code>0.2</code> 的和不等于 <code>0.3</code>，但略高于 <code>0.3</code>。</p>\n<p>由于以二进制方式对浮点数进行编码，因此像浮点数相加之类的操作会产生舍入误差。</p>\n<p>因此， <code>0.1 + 0.2 === 0.3</code> 是 <code>false</code>。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">7. 变量的提升</h2>\n<p><strong>面试官问</strong></p>\n<p>如果在声明之前访问 <code>myVar</code> 和 <code>myConst</code> 会发生什么？（能不能换个题）</p>\n<pre><code class=\"copyable\">myVar;   // => ???\nmyConst; // => ???\n\nvar myVar = 'value';\nconst myConst = 3.14;    \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><strong>答案</strong></p>\n<p>提升和时间死区是影响 JS 变量生命周期的两个重要概念。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deb98068759e48?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"600\" data-height=\"652\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"600\" height=\"652\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>在声明之前访问 <code>myVar</code> 的结果是 <code>undefined</code>，因为使用 var 声明的变量会被提升且值为 <code>undefined</code>。</p>\n<p>但是，在声明行之前访问 <code>myConst</code> 会引发 <code>ReferenceError</code>。在代码行 <code>const myConst = 3.14</code> 之前，<code>const</code> 变量处于临时死区。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">总结</h2>\n<p>你有没有感觉上面的问题，有些是对面试毫无用处，特别是<strong>第3道</strong>题目。但是，还是有一小部分的面试中会被问到。</p>\n<p>当然，虽然都说是沙雕题目，但这些是可以评估你是否精通 JS，还是有我们学习的知识的。</p>\n<p>在面试中，你还遇到哪些像这样的题目，欢迎留言讨论。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a target=\"_blank\" href=\"fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noopener noreferrer\">Fundebug</a>。</strong></p>\n<p>原文：<a target=\"_blank\" href=\"https://dmitripavlutin.com/simple-but-tricky-javascript-interview-questions/\" rel=\"nofollow noopener noreferrer\">dmitripavlutin.com/simple-but-…</a></p>\n<h2 class=\"heading\" data-id=\"heading-8\">交流（欢迎加入群，群工作日都会发红包，互动讨论技术）</h2>\n<p>阿里云最近在做活动，低至2折，有兴趣可以看看：<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<p>干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noopener noreferrer\">github.com/qq449245884…</a></p>\n</blockquote>\n<p>因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。</p>\n<p></p><figure><img alt=\"clipboard.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/15/16dccb6567b08d6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/21/16deb982fc2d0132?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"200\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"200\" height=\"260\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "3wrnug8d8x60",
      "author": "极客James",
      "title": "7 个沙雕又带有陷阱的 JS 面试题"
    },
    {
      "content": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"712\" src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-0\">一、写在前面</h3>\n<p>各位掘友久等了,最近在写Vue全家桶+Vant从零开发搭建电商App实战项目,项目基本完结,后面会不定期分享出来,期待各位掘友的关注。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">二、注册登录</h3>\n<p>注册登录,几乎是所有电商App必备模块,正好今天想把这块知识拆出来,详尽的写下来了,用过掘金的小伙伴都知道,掘金PC端的登录界面非常的萌,当你输入账号的时候萌猫会很开心,输入密码的时候,萌猫会捂眼睛,看到这个可爱的设计,着实让我喜欢,所以我就借鉴了掘金的萌猫图写了个登录注册模块,以下是完整UI.</p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1004\" data-height=\"598\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"998\" data-height=\"600\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-2\">三、整体UI搭建思路</h3>\n<p>UI部分非常的简单,整体就是最外层一个大盒子放一张图片,里面放一张小盒子设备边框圆角,然后把萌猫定位到小盒子的顶部中间位置,然后借助Vant来完成相关输入框,按钮的搭建.</p>\n<h3 class=\"heading\" data-id=\"heading-3\">四、Vant 使用</h3>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/intro\" rel=\"nofollow noopener noreferrer\">Vant</a>是有赞开源的很适合做电商App的UI组件,用起来非常爽,我整个项目都采用Vant UI搭建,风格统一,使用简单方便.\n首先将Vant引入到项目中,建议创建一个单独的文件来管理Vant的组件引入模块,按需加载,原则是用哪个就加载哪个.</p>\n<p>注册登录的切换用到了Vant的标签页组件,快速的实现登录和注册页面的切换。</p>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/tab\" rel=\"nofollow noopener noreferrer\">Vant tab</a>按照文档来,非常的简单和好用。</p>\n<p>输入框用到了Vant的Field组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/field\" rel=\"nofollow noopener noreferrer\">Vant Field</a></p>\n<p>按钮用到了Vant的Button组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/button\" rel=\"nofollow noopener noreferrer\">Vant Button</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">五、萌猫切换</h3>\n<p>萌猫根据你所在的输入框不同切换不同的样式,其实就是三张图片的切换,要么一次把三张图片都加载到页面,然后通过<code>v-show</code>的方式来控制他们的显示,这种方式感觉有点麻烦,我采用数据驱动界面的方式,点击到哪个位置,就让<code>img</code>标签来加载哪张图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 改变萌猫\n    changeImage (index) {\n      <span class=\"hljs-keyword\">if</span> (index == 0) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/greeting.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (index == 1) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/blindfold.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/normal.png'</span>)\n      }\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">六、倒计时</h3>\n<p>倒计时其实就是个定时器,先设置好总时长,然后每秒减一,直到减到0,然后恢复按钮点击的状态.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> // 发送手机验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">sendVerifyCode</span></span> () {\n      Toast({\n        message: <span class=\"hljs-string\">'发送验证码'</span>,\n        duration: 800\n\n      });\n      this.countDown = 60;\n      this.timeIntervalID = <span class=\"hljs-built_in\">set</span>Interval(() => {\n        this.countDown--;\n        // 如果减到0 则清除定时器\n        <span class=\"hljs-keyword\">if</span> (this.countDown == 0) {\n          clearInterval(this.timeIntervalID);\n        }\n      }, 1000)\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">七、手机号码正则验证</h3>\n<p>通过计算属性来验证输入的手机号码是否正确,然后在合适的位置调用这个计算属性就可以</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> computed: {\n    // 手机号码正确验证\n    <span class=\"hljs-function\"><span class=\"hljs-title\">phoneNumVerify</span></span> () {\n      <span class=\"hljs-built_in\">return</span> /[1][3,4,5,6,7,8][0-9]{9}$/.test(this.tel_registered);\n    }\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">八、验证码模块</h3>\n<p>验证码其实就是<code>img</code>标签请求接口获取图片,当点击图片的时候再次请求获取最新的图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 切换验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">getCaptcha</span></span> () {\n      // 获取验证码的标签\n      <span class=\"hljs-built_in\">let</span> captchaEle = this.<span class=\"hljs-variable\">$refs</span>.captcha;\n      this.<span class=\"hljs-variable\">$set</span>(captchaEle, <span class=\"hljs-string\">'src'</span>, <span class=\"hljs-string\">'http://192.168.0.1/web/xlmc/api/captcha?time='</span> + new Date());\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">九、总结</h3>\n<p>注册登录仅仅是整个项目的一部分,先分享出来,后面会将整个完整的电商项目分享出来,希望大家能点赞加关注,你的点赞能让更多的人一起学习,一起进步😄</p>\n<h3 class=\"heading\" data-id=\"heading-9\">十、完整电商项目</h3>\n<h4 class=\"heading\" data-id=\"heading-10\">首页模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb781663eb60a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"596\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"596\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">分类模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7882d5b9fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1022\" data-height=\"582\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1022\" height=\"582\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-12\">吃什么模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7904fd0405a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"574\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"574\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-13\">购物车模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb79b80990194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1026\" data-height=\"592\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1026\" height=\"592\"></svg>\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7a53bb8f4f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"590\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"590\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">个人中心模块</h4>\n<div>\n<img alt=\"图片说明\" height=\"300px\" style=\"padding:5px\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb5f78e4fd55c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"526\" data-height=\"944\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"526\" height=\"944\"></svg>\">\n</div>\n<h3 class=\"heading\" data-id=\"heading-15\">往期分享链接</h3>\n<ul>\n<li>\n<p><strong>Vue甜小白系列专栏</strong>:</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d64f31ae51d4561db5e3a74\" rel>Vue从甜小白到皮大佬系列(一) Vue是个啥?</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d652fb351882505a87a976b\" rel>Vue从甜小白到皮大佬系列(二) v-指令</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6675716fb9a06b10273c1c\" rel>Vue从甜小白到皮大佬系列(三) 生命周期\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d673ad7f265da03934bf266\" rel>Vue从甜小白到皮大佬系列(四) 自定义指令\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d67eac7e51d453c12504e3a\" rel>Vue从甜小白到皮大佬系列(五) 组件\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d699e2b6fb9a06ae3727746\" rel>Vue从甜小白到皮大佬系列(六) 组件通信\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6e6f366fb9a06b32609021\" rel>Vue从甜小白到皮大佬系列(七) Vue Router\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6f5801f265da03da24b365\" rel>Vue从甜小白到皮大佬系列(八) Vuex</a></li>\n</ul>\n</li>\n<li>\n<p>每周一道算法题系列</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6bed3e6fb9a06af372d069\" rel>逆波兰表达式求值</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7505c7f265da03c61e775a\" rel>斐波那契数列</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7e48dbe51d4557dc774f3a\" rel>合并两个有序链表</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>最后感谢您的关注!</strong></p>\n<p><a target=\"_blank\" href=\"https://github.com/Geek-James/Blog\" rel=\"nofollow noopener noreferrer\">我的GitHub</a>,希望能得到你的小星星~</p>\n<blockquote>\n<p>希望我的分享对你能有帮助,有不正确的地方也希望得到您的勘误!本人将不胜感激,另外如果你想获取前端整期学习视频和资料扫一扫下面的二维码,回复<strong>学习</strong>即可,也希望在前端进阶的路上,我们一起成长,一起进步!</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/1/16ceae13d9c4953e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"300\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"300\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "21gnrkvekcn4",
      "author": "黄轶",
      "title": "Vue登录注册-掘金可爱萌猫"
    }
  ],
  "searchArticleDetailList": [],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dac5d82e51d45249850cd20",
      "k": "juejin",
      "id": "3zpphpxg36e0",
      "author": "火狼1",
      "title": "(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)",
      "time": "6天前",
      "detail": "<p>笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。敬请大家关注！</p>\n<h2 class=\"heading\" data-id=\"heading-0\">第一篇: JS数据类型之问——概念篇</h2>\n<h3 class=\"heading\" data-id=\"heading-1\">1.JS原始数据类..."
    },
    {
      "url": "https://juejin.im/post/5daeefc8e51d4524f007fb15",
      "k": "juejin",
      "id": "hftl9wkfzsg",
      "author": "荒山",
      "title": "JS 原生面经从初级到高级【近1.5W字】",
      "time": "4天前",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<blockquote>\n<p>是时候撸一波 JS 基础啦,撸熟了,银十速拿 offer;<br>\n本文不从传统的问答方式梳理,而是从知识维度梳理,以便形成知识网络;<br>\n包括函数,数组,对象,数据结构,算法,设计模式和 http.</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-1\">1. 函数</h1>\n<h2 class=\"hea..."
    },
    {
      "url": "https://juejin.im/post/5dadc6045188255a270a0f85",
      "k": "juejin",
      "id": "3bk2ny1ywu80",
      "author": "张张-💫",
      "title": "这可能是最通俗的 React Fiber(时间分片) 打开方式",
      "time": "5天前",
      "detail": "<p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p>\n<br>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/201..."
    },
    {
      "url": "https://juejin.im/post/5dafb263f265da5b9b80244d",
      "k": "juejin",
      "id": "1u7tueve3hts",
      "author": "voanit",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）",
      "time": "3天前",
      "detail": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容..."
    },
    {
      "url": "https://juejin.im/post/5dad09be518825393e52d1bd",
      "k": "juejin",
      "id": "6gsoi8c7ag40",
      "author": "取舍🍂",
      "title": "前端框架用vue还是react？清晰对比两者差异",
      "time": "6天前",
      "detail": "<blockquote>\n<p>vue or react？That's a question.</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>近两年前端技术层出不穷，目前市面上已经有了很多供前端人员使用的开发框架，转眼19年已过大半，前端框架领域日趋成熟，实现了三足鼎立的局面，截止到10月22日，Angular，react和vue数据统计如下图所示:</p>\n<p></p><figure><img cla..."
    },
    {
      "url": "https://juejin.im/post/5dac3b4351882576534d33d7",
      "k": "juejin",
      "id": "77z0oq7442s0",
      "author": "云音乐前端技术团队",
      "title": "7天撸完KTV点歌系统,含后台管理系统(完整版)",
      "time": "7天前",
      "detail": "<p>最近手有点痒琢磨着做个啥,朝思暮想还是写个KTV点歌系统,模拟了一下KTV开户的思路,7天累死我了,不过技术点还挺多的,希望你可以看完（〜^㉨^)〜</p>\n<p><strong>用Node(Express)教你写KTV点歌系统，包括前台内容和后台管理系统，整合Express框架和Mongodb数据库服务器开发；教你用Vue.JS，ElementUI和iViewUI写出超漂亮的页面,随心点歌随心听</strong></p>\n<blockquote class=\"warning\"><p>作者..."
    },
    {
      "url": "https://juejin.im/post/5dad208ef265da5b7d692340",
      "k": "juejin",
      "id": "49g1jsa3pm20",
      "author": "_Dreams",
      "title": "Server-X：一款可能提升你十倍工作效率的工具",
      "time": "6天前",
      "detail": "<blockquote>\n<p>本文将介绍一款全新的前端开发工具，希望它能给你的前端开发带来看起来和现在一样但其实又不那么一样的体验。</p>\n</blockquote>\n<p>你可能会说，大家都是 <s>秃头的</s> 成熟的前端程序员了，每一台电脑上都有几套自己辛辛苦苦装好的全家桶，为什么还要新换一个开发工具？</p>\n<p>对，盲生，你可能发现了华点。</p>\n<p>数一数你电脑上目前为前端本地开发安装了多少小工具、小插件？\n这其中仅仅是为代码开发阶段，就可能有本地服务器、远程调试工具、代..."
    },
    {
      "url": "https://juejin.im/post/5dafc3df5188257a63539c64",
      "k": "juejin",
      "id": "64ymkkr9kzs0",
      "author": "西岚",
      "title": "移动端H5页面开发坑点指南",
      "time": "4天前",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在平时的H5移动端开发时，我们难免会遇到各种各样的坑点，这篇文章就带着大家来看看怎么解决，文章较长，建议收藏方便以后查阅！</p>\n<h2 class=\"heading\" data-id=\"heading-1\">前方高能！</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">canvas在retina屏模糊</h3>\n<p>只需要将画笔根据像素比缩放即可</..."
    },
    {
      "url": "https://juejin.im/post/5dadd0236fb9a04de04d968e",
      "k": "juejin",
      "id": "503tk9x1xxk",
      "author": "前端小智",
      "title": "Node.js 实现抢票小工具&短信通知提醒",
      "time": "5天前",
      "detail": "<h1 class=\"heading\" data-id=\"heading-0\">写在前言</h1>\n<p>要知道在深圳上班是非常痛苦的事情，特别是我上班的科兴科技园这一块，去的人非常多，每天上班跟春运一样，如果我能换到以前的大冲上班那就幸福了，可惜，换不得。</p>\n<p>尤其是我这个站等车的多的一笔，上班公交挤的不行，车满的时候只有少部分人能硬挤上去。通常我只会用两个字来形容这种人：“公交怪”</p>\n<p>想当年我朋友瘦的像只猴还能上去，老子身高182体重72kg挤个公交，不成问题，反手一个..."
    },
    {
      "url": "https://juejin.im/post/5dacf37ef265da5b926bdc9a",
      "k": "juejin",
      "id": "3wrnug8d8x60",
      "author": "极客James",
      "title": "7 个沙雕又带有陷阱的 JS 面试题",
      "time": "7天前",
      "detail": "<blockquote>\n<p>作者：Dmitri Pavlutin</p>\n<p>译者：前端小智</p>\n<p>来源：dmitripavlutin</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>这几天自己的公众号无套路送现金 200+，参与方式如下</strong>\n<a target=\"_blank\" href=\"https://mp.weixin.qq.com/s/PTlWMG5KeJJtyS-Yd4FvbQ\" rel=\"nofollow n..."
    },
    {
      "url": "https://juejin.im/post/5dafc91a6fb9a04e4047a713",
      "k": "juejin",
      "id": "21gnrkvekcn4",
      "author": "黄轶",
      "title": "Vue登录注册-掘金可爱萌猫",
      "time": "3天前",
      "detail": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"..."
    }
  ]
}