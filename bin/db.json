{
  "searchResList": [
    {
      "source": "掘金",
      "id": "2hqte0lhx000",
      "author": "",
      "time": "3年前",
      "title": "Node入门 » 一本全面的Node.js教程",
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "detail": "Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。Node.js是名副其实的版本帝，版本更新确实很频繁，时间线如下。2013年，发布了0.10版本。2015年1月，发布了1.0.0版本（io..."
    },
    {
      "source": "掘金",
      "id": "5yfvzv7qjng0",
      "author": "sing1ee",
      "time": "1年前",
      "title": "Node 在有赞的实践",
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "detail": "封面千呼万唤始出来，犹抱琵琶生哪吒。真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。Node.js作为近几年新兴的一种编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++开发Node.js原生扩展的口子，让开发者进行项目开发时有了更多的选择。《Node.js：来一打C++扩展》以ChromeV8的知识作为基础，配合GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写..."
    },
    {
      "source": "掘金",
      "id": "42vxcjmjd7q0",
      "author": "",
      "time": "9月前",
      "title": "Node - 从0基础到实战企业官网",
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "detail": ""
    },
    {
      "source": "掘金",
      "id": "u1u7yqlxe8g",
      "author": "有赞技术",
      "time": "2年前",
      "title": "Node 爬虫入门",
      "url": "https://juejin.im/post/592ed10a2f301e00571966b2",
      "detail": ""
    }
  ],
  "articleDetail": [
    {
      "id": "4b6699iyqoo0",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "content": "Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。Node.js是名副其实的版本帝，版本更新确实很频繁，时间线如下。2013年，发布了0.10版本。2015年1月，发布了1.0.0版本（io.js）。2015年5月，发布了2.x版本（io.js）。2015年8月，发布了3.x版本（io.js）。2015年9月，Node.js基金会发布了5.0版本与io.js合并后的第一个版本。2015年10月，Node.js5.2.0版本成为首个LTS（长期支持）版本。2015年年底，发布了5.2.4和5.5.0版本。2016年3月，发布了5.5.0LTS版本和5.9.0Stable稳定版本。2016年年底，6.0版本支持95%以上的ES6特性，7.0版本通过flag支持async函数，全面支持99%的ES6特性。2017年2月，发布了7.6版本，可以不通过flag使用async函数。2017年5月，发布了8.0版本，支持asyncHooks，N-API等特性。2018年4月，发布了10.0版本，新增http2模块，将npm从v5.7更新到了v6，并且增强了对ESMModules的支持。2018年10月，发布了11.0版本，增加了多线程WorkerThreads。整体上来说，Node.js的发展趋于稳定。成立Node.js基金会能够让Node.js在未来获得更好的开源社区支持；发布LTS版本意味着Node.jsSDKAPI趋于稳定；频繁发布版本虽然被很多人诟病，但换个角度来看，这也是社区活跃的一个体现，如果大家真的看了Changelog，便会发现，新版本相比于旧版本只增加了一些小的改进，而且是边边角角的改进，也就是说，Node.js的核心代码已经非常稳定了，可以大规模使用。Node.js在2009年横空出世，可以说靠异步特性获得了很大的性能优势。所有语言几乎没有能和它相比的。但是福祸相依，因为性能太出众，所以促使很多语言、编程模型都纷纷进行改进，比如产生了Go语言，比如PHP里的SWoole框架可以支持异步协程了，再比如鸟哥（惠新宸）对PHP的VM进行了改进，大家似乎都以不支持异步为耻。后来的故事大家都知道了，各种语言的性能都得到了提高。那么在这种情况下，Node.js还有优势吗？在实现难易度上，Node.js除了异步流程控制稍复杂外，其他的都非常简单。比如在写法上，你可以选择编写面向过程、面向对象、函数式的程序。不要因为Node.js变化快，就觉得自己跟不上潮流。一般后端程序员转为Node.js开发人员时，几乎两周就能精通，这一点相比其他语言还是很有优势的。在调优成本上，Node.js即使不进行优化，性能也非常好，另外，对Node.js进行优化也比其他语言更简单。在学习成本上，Node.js是有优势的。学习其他语言，前后端至少要学两种以上，如果学习Node.js，你只需要学会JavaScript即可，可以少学一种语言。我想问，大前端离得开JavaScript吗？今日的前端还不够复杂吗？你真的有那么多精力学习更多语言吗？其实大家可以关注一下基于npm的开源生态，截至2019年3月，npm上已有超过94.7万个模块，“秒杀”无数竞品。npm是所有开源包管理中最强大的，我们说“更了不起的Node.js”，其实npm居功甚伟。下图展示了来自ModuleCounts的各个包管理模块的差异。来自ModuleCounts的各个包管理模块的差异npm生态是Node.js的优势，可是说“Node.js没有性能优势”真的对吗？这其实是对Node.js的误解。Node.js的性能依然很好，不断迭代的版本其实就是在提升性能。而且Node.js具有npm极其完善的生态，可谓性能与生态双剑合璧，这是无与伦比的。正因为异步特性，Node.jsAPI设计只能采用错误优先（Error-First）风格的回调约定，于是大家硬生生地把多层回调写成了回调地狱（callbackhell），这时就有各种“黑粉”冒出来对Node.js进行攻击。但正是因为回调地狱是最差的实践，所以大家才不得不求变，于是Thunk函数、Promise/A+规范等相继出现。虽然Promise/A+规范不是那么完美，但对于解决回调地狱问题来说已经足够。而且Generator特性和Generator的执行环境co模块也被逐渐引入新的异步解决方案，使得异步在写法上越来越接近于同步。当async函数落地的时候，Node.js已经站在了同C#、Python一样的高度上，大家还有什么理由攻击它呢？下面列举了Node.js支持的所有异步解决方案，并给出了推荐建议（5星为最高级别）。从推荐指数可以看出，我们应首选async函数，但要注意版本问题，要使用最新的版本。其次就是Promise，它都能非常好地驾驭callback和async函数，尤其是在异常捕获、扩展上，具有明显的优势。有时，将一件事做到极致，也许能收获另一片天地。异步流程控制是Node.js编程的核心，掌握异步流程控制之后，Node.js中就只剩API需要学习了，后面会详细讲解。自从ES6规范在Node.js中落地之后，整个Node.js开发领域都发生了翻天覆地的变化。从v0.10开始，Node.js中就逐渐加入了ES6特性，比如Node.jsv0.12可以使用Generator，这也促使寻求异步流程控制的TJHolowaychuk写出了co这个著名的模块，进而产生了Koa框架。但是在v5.0之前，必须通过flag才能开启Generator支持，因此Koav1.0迟迟未发布，在Node.jsv5.0发布后，Koav1.0才发布。2015年，传统写法终结；2016年，变革写法开始兴起。其中核心变更是支持使用ES6语法编写Node.js代码。可以使用Node.jsv5.x+里的ES6特性，如果想实现更高级的功能，可以使用Babel编译支持ES7特性，或者使用TypeScript。合理使用Standard或者xo模块代码风格约定。适当引入ES6语法，只要Node.jsSDK内置支持的，都可以使用。大家要重视面向对象写法的使用，虽然ES6的面向对象机制不健全，但以后定会不断完善。面向对象对于大型软件开发更适合，这其实也是我推荐使用TypeScript的原因之一。下面对比了变革前后的技术栈选型，希望读者能够从中感受到其中的变化。本文选自《狼书（卷1）：更了不起的Node.js》一书。对于Node.js来说，在简化并发编程方面，用“了不起”来形容并不过分。Node.js在2009年横空出世时，确实是独一无二的。但在今天，已经10岁的Node.js有了更多、更广泛的应用场景，它的意义已经远远大于设计时的初衷了，用“更了不起”来形容并不过分。点击封面了解详情本书以Node.js为主，讲解了Node.js的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过最新的Node.js和npm编写出更具前端特色、更具工程化优势的代码。本书还讲解了Node.js中最核心、最复杂的异步流程控制，展望了未来异步流程的发展方向，非常适合大前端领域及后端领域的测试、运维及软件开发从业者阅读、学习。愿本书够带你打开Node.js世界的大门，领略大前端领域璀璨的星光。作者简介狼叔（网名i5ting），Node.js技术布道者，“Node全栈”公众号作者，全栈技术实践者。曾就职于多家知名IT企业，从事前端开发、后端开发、数据分析等工作，目前负责公司内的Node.js开发和基础框架开发工作。本书内容本书共分7章，每章的内容简介如下。第1章Node.js初识本章介绍了Node.js的一些基础知识，包括什么是Node.js、Node.js和JavaScript的关系、Node.js的特点和应用场景等。第2章Node.js安装与入门本章介绍了Node.js安装与使用的基本方法，包括3m（即nvm、nrm、npm）安装法、Node.js基础示例，以及编辑器和调试等内容。第3章更了不起的Node.js本章更加详细地介绍了Node.js的各类应用场景，对Node.js的核心作用进行了概括与总结，还对如何成为全栈工程师提供了宝贵建议。第4章更好的Node.js本章介绍了Node.js的各种写法，包括单线程与集群，以及各种优秀实践，包括ES语法、多模块管理器Lerna、npm的替代品Yarn等。第5章Node.js是如何执行的本章介绍了Node.js的源码构建和调试过程，阐述了Node.js是如何执行的，还介绍了API的调用过程，以及事件循环机制。第6章模块与核心本章介绍了Node.js中的CommonJS规范、SDK模块与核心技术，还对未来的ES6模块功能进行了预测与展望。第7章异步写法与流程控制本章介绍了异步流程控制的演进过程、Node.js的核心异步写法，以及更好的异步流程控制机制，如Thunk、Promise、async函数等。本书中的各章在内容上基本是相互独立的，因此各位读者可以挑选自己感兴趣的章节阅读。这本书是“狼书”系列的第1卷，还有第2卷和第3卷稍后会和各位读者见面，内容涉及Web应用和性能优化等，搭配阅读，效果更好。即将出版：《狼书（卷2）：Node.jsWeb应用开发》《狼书（卷3）：Node.js高级技术》了解本书详情：京东、当当",
      "time": "2019.06.2514:39:13"
    },
    {
      "id": "3wii6re7jde0",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "content": "封面千呼万唤始出来，犹抱琵琶生哪吒。真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。Node.js作为近几年新兴的一种编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++开发Node.js原生扩展的口子，让开发者进行项目开发时有了更多的选择。《Node.js：来一打C++扩展》以ChromeV8的知识作为基础，配合GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写其C++的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN以及与异步相关的libuv知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的Node.js以及C++基础。阅读《Node.js：来一打C++扩展》，相当于同时学习ChromeV8开发、libuv开发以及Node.js的原生C++扩展开发知识，非常值得！最后十分感谢包括Node.jsTSC之一的Anna、几位Collaborator以及各位业界的大佬帮忙写推荐语，感谢@yorkie大佬和@justjavac大佬帮忙作序。编辑推荐《Node.js：来一打C++扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍Node.js的包和模块规范开始，深入解析（包括但不限于剖析Node.js自身的源码）Node.js的模块是如何在运行时被引入的，尤其是如何引入C++模块的；接下来详细讲解了在什么时候、为何要编写C++模块；借此契机，深入介绍了Node.js的基石ChromeV8和libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以Node.js的C++扩展为中心，衍生出对Node.js底层风光的层层剖析，最后再回归到如何编写Node.js的C++扩展，一气呵成。读来酣畅淋漓，痛快不已！买这一本书相当于买了“Node.js的底层风光、C++扩展编写”、“ChromeV8”和“libuv”三本书！读完本书后，你甚至能为Node.js自身的添砖加瓦做出非凡贡献。购书链接目前在预售阶段，顺便蹭618活动。京东天猫当当亚马逊豆瓣（不算购书链接）目录1Node.js的C++扩展前驱知识储备11.1Node.js的模块机制21.1.1CommonJS的模块规范21.1.2Node.js的模块41.1.3小结91.1.4参考资料91.2Node.js的包机制91.2.1CommonJS的包规范91.2.2Node.js/NPM下的包131.2.3NPM与CNPM161.2.4小结191.2.5参考资料191.3Node.js依赖简介201.3.1ChromeV8201.3.2libuv251.3.3其他依赖281.3.4小结301.3.5参考资料301.4C++扩展开发的准备工作311.4.1编辑器/IDE311.4.2node-gyp361.4.3其他构建工具541.4.4小结561.4.5参考资料562C++模块原理简析572.1为什么要写C++模块572.1.1C++比JavaScript解释器高效572.1.2已有的C++轮子722.1.3小结772.1.4参考资料772.2什么是C++扩展782.2.1C++模块本质782.2.2Node.js模块加载原理802.2.3小结1022.2.4参考资料1033ChromeV8基础1043.1Node.js与ChromeV81043.2基本概念1053.2.1内存机制1053.2.2隔离实例（Isolate）1083.2.3上下文（Context）1093.2.4脚本（Script）1103.2.5小结1103.2.6参考资料1113.3句柄（Handle）1113.3.1本地句柄（Local）1123.3.2持久句柄（Persistent）1153.3.3永生句柄（Eternal）1193.3.4待实本地句柄（MaybeLocal）1193.3.5小结1213.3.6参考资料1213.4句柄作用域1213.4.1一般句柄作用域（HandleScope）1223.4.2可逃句柄作用域（EscapableHandleScope）1253.4.3小结1293.4.4参考资料1293.5上下文（Context）1293.6模板（Template）1333.6.1函数模板（FunctionTemplate）1333.6.2对象模板（ObjectTemplate）1383.6.3对象模板的访问器（Accessor）与拦截器（Interceptor）1443.6.4对象模板的内置字段（InternalField）1753.6.5函数模板的继承（Inherit）1833.6.6小结1883.6.7参考资料1893.7常用数据类型1893.7.1基值（Value）1893.7.2字符串（String）1943.7.3数值类型1963.7.4布尔类型（Boolean）1963.7.5对象（Object）1963.7.6函数（Function）2003.7.7数组（Array）2023.7.8JSON解析器2033.7.9函数回调信息（FunctionCallbackInfo）2033.7.10函数返回值（ReturnValue）2043.7.11隔离实例（Isolate）2043.7.12小结2053.7.13参考资料2063.8异常机制2063.8.1try-catch2063.8.2抛出异常2093.8.3异常生成类（Exception）2113.8.4小结2113.8.5参考资料2114C++扩展实战初探2124.1binding.gyp2124.1.1惊鸿一瞥2134.1.2binding.gyp基础结构2134.1.3GYP文件2144.1.4常用字段2214.1.5小结2284.1.6参考资料2284.2牛刀小试2294.2.1又是HelloWorld2294.2.2函数参数2324.2.3回调函数2344.2.4函数返回2384.2.5小结2394.2.6参考资料2404.3循序渐进2404.3.1C++与JavaScript类封装2404.3.2实例化C++类封装对象的函数2504.3.3将C++类封装对象传来传去2534.3.4进程退出钩子2554.3.5小结2594.3.6参考资料2595Node.js原生抽象——NAN2605.1Node.js原生模块开发方式的变迁2605.1.1以不变应万变2605.1.2时代在召唤2615.1.3小结2675.1.4参考资料2675.2基础开发2675.2.1什么是NAN2675.2.2安装和配置2695.2.3先睹为快——搭上NAN的快车2705.2.4基础帮助函数和宏2765.2.5忽略node_modules2795.2.6小结2795.2.7参考资料2805.3JavaScript函数2805.3.1函数参数类型2805.3.2函数声明2825.3.3函数设置2885.3.4小结2965.3.5参考资料2965.4常用帮助类与函数2965.4.1句柄相关2965.4.2创建数据对象2985.4.3与数据对象“玩耍”3005.4.4封装一个类3145.4.5异常处理3155.4.6小结3155.4.7参考资料3165.5NAN中的异步机制3165.5.1Nan::AsyncQueueWorker3165.5.2Nan::Callback3175.5.3Nan::AsyncWorker3175.5.4Nan::AsyncProgressWorker3235.5.5小结3275.5.6参考资料3276异步之旅——libuv3286.1基础概念3296.1.1事件循环3306.1.2句柄（Handle）与请求（Request）3336.1.3尝尝甜头3356.1.4小结3406.1.5参考资料3406.2libuv的跨线程编程基础3416.2.1libuv的线程3426.2.2同步原语（SynchronizationPrimitive）3476.2.3工作队列3556.2.4小结3566.2.5参考资料3576.3跨线程通信3576.3.1uv_async_t句柄3576.3.2Watchdog半成品实战解析3586.3.3Watchdog试运行3676.3.4小结3686.3.5参考资料3697实战——文件监视器3707.1准备工作3707.1.1功能规划3707.1.2文件系统监听库——efsw3737.1.3小结3767.1.4参考资料3767.2核心设计3767.2.1API设计3777.2.2EFSWCore的血肉之躯3777.2.3EFSWCore的灵魂3817.2.4小结3857.3编写JavaScript类3867.3.1类的设计3867.3.2核心逻辑3887.3.3简单容错3917.3.4小结3937.4进一步完善3937.4.1C++代码的完善3937.4.2JavaScript代码的完善3987.4.3小结4008实战——现有包剖析4018.1字符串哈希模块——BlingHashes4018.1.1文件设定4028.1.2C++源码剖析4038.1.3JavaScript源码剖析4088.1.4小结4098.1.5参考资料4108.2类Proxy包——AutoObject4108.2.1Proxy4108.2.2AutoObject使用范例4128.2.3代码剖析4158.2.4小结4248.2.5参考资料4249N-API——下一代Node.jsC++扩展开发方式4259.1浅尝辄止4269.1.1实现一个Echo函数4269.1.2尝试运行N-API扩展4309.1.3向下兼容4319.1.4N-APIPackage——C++封装4339.1.5小结4339.1.6参考资料4339.2基本数据类型与错误处理4339.2.1基本数据类型4339.2.2与作用域及生命周期相关的数据类型4359.2.3回调数据类型4389.2.4错误处理4399.2.5模块注册4419.2.6小结4429.2.7参考资料4429.3对象与函数4429.3.1对象4429.3.2函数4489.3.3类的封装4539.3.4小结4559.3.5参考资料455推荐语ThisbookcontainsabsolutelyeverythingyouneedtoknowabouthowallthepiecesofNode.js'C++codeworkandinteract,explainingthenecessaryconceptswithoutneedingpriorknowledgeabouttheinternalsofV8,libuvorotherpiecesofNode.js.ItshowswellhowNode.js'ownbuilt-inmodulesareconstructedusingtheAPIsprovidedbyV8,sothattheyareusablefromJavaScript,andhowyoucancreatethesamekindofmodulesfromscratch.Afterhavingreadthisbook,youwillbeabletowriteaproduction-quality,future-proofC++extensionforNode.jsifyouneedtodothat,ormaybeevenmakechangesNode.jsitselfifyou'reinterestedinthat!这本书包含了所有你需要了解的有关于Node.jsC++代码是如何运行和交互的知识，解释了一些你不需要知道V8的内部机制就能理解的必要概念，另外该书还介绍了libuv以及其他一些内容的方方面面。这本书还展示了Node.js的内置模块是如何使用V8的API进行构建并在JavaScript层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。读完这本书，你将学到如何写出产品级质量的、面向未来的Node.jsC++扩展。感兴趣的话，你甚至可以对Node.js自身进行修改！——安娜·亨宁森（AnnaHenningsen,addaleax），Node.js技术指导委员会成员（Node.jsTSC）Node.js不是第一个将JavaScript带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于Node.js适逢后端高并发潮流，巧妙结合Reactor模型和JavaScript所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合JavaScript和前端工程师的一套生态和工具链，Node.js刚好成为前端JavaScript最易上手掌握的命令行环境。在Node.js发展这么火热之后，Node.js的开发体验在不断提升，上手门槛也在不断降低。然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解Node.js的底层机制，去学习写一些Node.js的扩展。从Node.js的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用C++写一个扩展很有意思也很简单。作为Node.js工程师/爱好者的你，值得拥有本书。——曹力（ShiningRay），酷链科技CEO，前暴走漫画CTO，前糗事百科联合创始人，高级Node.js技术专家，《JavaScript高级程序设计》译者NativemoduleisoneofthemostunderappreciatedfeaturesofNode.js.Butevenintheageofasm.jsandWebAssembly,itisanirreplaceablepartoftheNode.jsecosystemduetoitsversatilityandperformance.XadillaX'sbookprovidesarefreshingintroduction(orreintroduction),andisamust-readforalllow-levelNode.jsengineers.原生模块是Node.js中最被低估的功能之一。因为它的性能和多样性，使其即使是在asm.js和WebAssembly时代，仍旧能作为Node.js生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js工程师必读之物。——顾天骋（TimothyGu），pug、ejs前Maintainer，Node.jsCoreCollaborator之一本书全面讲解了V8、libuv的原理并且手把手教你编写一打Node.js的C++扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解Node.js的实现原理，除了熟读内置API文档之外，阅读这本书会是一个很好的选择。——雷宗民（老雷），《Node.js实战》作者之一这是一本角度刁钻的Node.js相关书籍，与市面上大多数的Node.js书籍定位不同。它借为Node.js开发C++扩展为基石，顺带介绍了ChromeV8和libuv的内容，填补了市场上这一类书籍的空白，值得一读。——李启雷博士，趣链科技CTO死月一直把实战贯穿在整本书之内，无论是基础部分的V8练习，还是使用Node.js经典的Addon开发、用NAN来改写，或是libuv里的WatchDog案例、EFSW的封装，甚至在第八章里还特意剖析了两个C++模块，把之前讲解的基础知识部分综合起来，可以边学边练。这本《Node.js：来一打C++扩展》，在如今追求大而全的时代，单纯的讲Node.js的某一个方面，而且讲的特别棒的书，真的难得。——刘琥（响马），西祠胡同创始人，fibjs作者当你掌握了Node.js的上层使用，下一步进阶的方向就是研究Node.js的底层原理。本书为学习Node.js的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（HandleScope）等概念直接来自于源码，对于阅读Node.js及V8的源码具有极高的参考价值。——潘旻琦（pmq20），Node.js技术专家，Node.jsCollaborator之一，RubyConf讲师之一国内Node.js偏向于原理的书目前只有朴灵的《深入浅出Node.js》一本，至今4年过去了，Node.js已经从v0.10发展到v9版本，中间再没有这样的系统的有深度的书籍。很高兴死月的新书弥补了这一遗憾。本书以C++为主线，涵盖Node.js最核心的libuv和V8，对理解Node.js原理有极大的好处。当然最大的好处在于使用C++编写Node.jsAddon可以让Node.js有更广阔的应用空间。我们都知道Node.js擅长的是I/O密集型任务，对于CPU密集型运算这是极好的弥补。特别推荐大家阅读此书，Node.js应用极其广泛的今天，使用C++编写Node.jsAddon是更出彩的部分，你值得拥有。——桑世龙（狼叔），StuQ明星讲师，Node.js技术布道者，《更了不起的Node.js》作者死月对Node.js底层机制有非常深入的了解。阅读本书，除了学习C++扩展开发，还会跟随死月了解V8、libuv，相信读后大家对于Node.js的理解会更上一层楼。——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长C++扩展其实是从外在，用C++的角度去观察Node.js内在的形式。因为Node.js整个系统自身几乎就是构建在C/C++之上的，只是内部称之为built-in，在user-land则称之Addon，它们本质上其实没有区别。死月凭借他在C/C++的深厚积累，选择从C++扩展作为突破口，带大家领略Node.js底层的风光，在书里，你能看到真正发挥巨大价值的V8、libuv亦是精彩纷呈。死月将C++扩展写得这么透，我是服的。——田永强（朴灵），高级Node.js技术专家，《深入浅出Node.js》作者开发C++扩展，可以扩充Node.js平台的本地API，扩充Node.js应用的能力。这本书详细介绍了包括libuv、V8在内的各种必要知识，是该领域不可多得的好书。对C++开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。——王文睿博士（RogerWang），node-webkit和NW.js项目创始人和维护者，因特尔软件架构师清晰记得手写的第一个Node.jsC++扩展模块，在Node.js0.6.9跑通的那种愉悦感。随着应用升级到Node.js0.8，依赖的C++扩展模块无法安装编译成功，最后发现是V8的API变化导致不兼容，从此对C++扩展模块产生抗拒。后来看到《Node.js：来一打C++扩展》，从实现原理，到V8基础概念的一系列介绍，让我重新对C++扩展模块产生兴趣。参考书里的实战例子，以及NAN的辅助下，现在编写一个跨Node.js版本的C++扩展已经不是什么困难的事情。通过最后一章节，可以了解到Node.js官方的N-API计划，让C++扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。——袁锋（fengmk2），Node.js技术专家",
      "time": "2018.06.1418:27:17"
    }
  ]
}