{
  "hotArticleList": [
    {
      "source": "jianshu",
      "id": "eqcbzcihfo8",
      "author": "简书",
      "time": "",
      "title": "公告：关于暂停用户发布功能，并全面清查平台内容",
      "url": "https://www.jianshu.com/p/65f83aa86db8",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "6d3up6jsdsw0",
      "author": "陌上红裙",
      "time": "",
      "title": "简书一年，我找到了一份好工作",
      "url": "https://www.jianshu.com/p/7031752823e7",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "1m6fyhx50w4g",
      "author": "Rose的肉丝儿",
      "time": "",
      "title": "简书一年，我出版了人生第一本书——给想出书的朋友们",
      "url": "https://www.jianshu.com/p/bf10d5d3c7cf",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "621yjstvnxc0",
      "author": "有备而来的路人甲大萌",
      "time": "",
      "title": "《二十岁的年纪，做八十岁想起来都会嘴角上扬的事》",
      "url": "https://www.jianshu.com/p/675bf3a17d54",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "5a8z35k32zw0",
      "author": "",
      "time": "3年前",
      "title": "Node入门 » 一本全面的Node.js教程",
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "1kwyaz7xw34w",
      "author": "sing1ee",
      "time": "1年前",
      "title": "Node 在有赞的实践",
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "1t1e2qv2m5sw",
      "author": "",
      "time": "9月前",
      "title": "Node - 从0基础到实战企业官网",
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "am5jwslyxv4",
      "author": "有赞技术",
      "time": "2年前",
      "title": "Node 爬虫入门",
      "url": "https://juejin.im/post/592ed10a2f301e00571966b2",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "4l6cs8xghli0",
      "author": "简书",
      "time": "",
      "title": "公告：关于暂停用户发布功能，并全面清查平台内容",
      "url": "https://www.jianshu.com/p/65f83aa86db8",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "6ts37rxvyzg0",
      "author": "陌上红裙",
      "time": "",
      "title": "简书一年，我找到了一份好工作",
      "url": "https://www.jianshu.com/p/7031752823e7",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "6bmok4soebs0",
      "author": "Rose的肉丝儿",
      "time": "",
      "title": "简书一年，我出版了人生第一本书——给想出书的朋友们",
      "url": "https://www.jianshu.com/p/bf10d5d3c7cf",
      "detail": ""
    },
    {
      "source": "jianshu",
      "id": "5qgyq7eweog0",
      "author": "有备而来的路人甲大萌",
      "time": "",
      "title": "《二十岁的年纪，做八十岁想起来都会嘴角上扬的事》",
      "url": "https://www.jianshu.com/p/675bf3a17d54",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "2183dj1p28dc",
      "author": "",
      "time": "3年前",
      "title": "Node入门 » 一本全面的Node.js教程",
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "3ue3hw025t00",
      "author": "sing1ee",
      "time": "1年前",
      "title": "Node 在有赞的实践",
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "zexdvrk39ps",
      "author": "",
      "time": "9月前",
      "title": "Node - 从0基础到实战企业官网",
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "detail": ""
    },
    {
      "source": "juejin",
      "id": "4tcuzt8n6ay0",
      "author": "有赞技术",
      "time": "2年前",
      "title": "Node 爬虫入门",
      "url": "https://juejin.im/post/592ed10a2f301e00571966b2",
      "detail": ""
    }
  ],
  "articleDetail": [
    {
      "source": "jianshu",
      "id": "eqcbzcihfo8",
      "content": "<p>亲爱的简书用户</p><p>「简书」因个别上传作品用户违反《中华人民共和国网络安全法》《互联网信息服务管理办法》《互联网新闻信息服务管理规定》《互联网用户公众账号信息服务管理规定》《移动互联网应用程序信息服务管理规定》等相关法律法规，平台审核不严，传播了违法违规信息，在此表示不安和歉意。根据主管部门要求，从2019年8月29日16时至9月28日16时，暂停所有用户发布功能，并对平台上内容进行全面彻底清理整顿。</p><p>「简书」致力于打造一个优质内容创作社区。为维护良好的社区氛围，希望所有用户自觉遵守<a href=\"https://www.jianshu.com/p/1011f0cdefee\" target=\"_blank\">《简书社区管理规则》</a>。所有简书用户均可以通过举报按钮对违反规则行为进行举报，「简书」也会按照规则对违规用户采取更改、锁定、删除用户发布的内容，暂停或终止用户使用简书产品的权利等措施，共同营造清朗的网络社区空间。</p>",
      "time": "2019.08.29 18:38:08"
    },
    {
      "source": "jianshu",
      "id": "6d3up6jsdsw0",
      "content": "<h4></h4><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.64%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"853\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3301720-db890fabf626e0ac.jpg\" data-original-width=\"1280\" data-original-height=\"853\" data-original-format data-original-filesize=\"837152\" data-image-index=\"0\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">图片发自简书App</div>\n</div><p><b>\n\n这是我的亲身经历，没有虚构，虽然它听起来不像真的。</b></p><hr><p>2017年11月7日  星期二 晴</p><p>说起来很惭愧，在简书写了一年的文，至今，我还是原来的我，既没有签约，也没有写出爆文，甚至连一篇像样点的、拿得出手的文字也没有。</p><p>相反，嘲笑和挖苦的话倒是听了不少。当面的，背后的，直接了当的，含沙射影的，比比皆是。</p><p>所有这些，都曾伤透了我的心，我苦恼、彷徨，为自己因为在简书写文而越来越不受人待见而痛苦不堪。</p><p>于是，我萌生了将简书卸载，从简书里逃跑的念头。</p><p>然而每每打开简书，却是万般的不舍和难离。我想按下删除键，但手指却不听使唤，还是习惯性地敲打出心中喜爱的文字——已然将自己的逃跑计划忘到脑后。</p><p>逃跑未成，只好硬着头皮往前走，这一走，竟走过了秋、冬、春、夏。</p><p>这一年，我的思绪，我的喜怒哀乐，都变成了一个叫<a href=\"https://www.jianshu.com/u/0aba71a90d02\" target=\"_blank\">陌上红裙</a>的简书用户笔端的文字。</p><p>尽管这些文字不华丽，不精美，没有内涵，没有深刻的寓意，但是，它们是我内心真情的表达。是一个打小就喜爱文字的女子对文字不渝的追随；是一个宁愿放弃美食，放弃聚会，放弃休闲度假的已过不惑之年的大妈的逆向选择。</p><p>这个选择，带给我的除了心灵的那份愉悦，从中确实再也找不出还有什么东西，可以让我自豪、可以让别人停止对我的鄙视。</p><p>我像一棵小草，在凛冽的寒风中，顽强地站立着，不敢趴下。</p><p>我知道，一旦趴下，我就再也无法在风中直起腰身。</p><p>很多个夜晚，很多个清晨，每一点的碎片时间，我都将自己置身于文字中。</p><p><b>结果会怎样？未来会怎样？全然不去考虑，我只告诉自己：为心中的那份愉悦，坚持！</b></p><p>万万没想到的是，简书一年后，我却得到了一个意外的收获——有好几家单位向我抛出了橄榄枝，好几个不错的岗位任我挑选。</p><p>这是我自2013年从国企下岗后，第一次被礼遇，第一次被当作“人才”而被多家单位争相聘请。</p><p>我听到有人愤愤不平地说：“哼！她居然成了香饽饽！”</p><p>“不就会写几篇文章么？”</p><p>……</p><p>此刻，我已离开小城巢湖，坐在省城一个装潢考究、环境优雅的写字楼里。</p><p>先进的办公设备，良好的工作氛围，一个富有朝气的团队，我荣幸地成为他们其中的一员。</p><p><b>没有后台，没有背景，如果有，那就是简书，还有我在简书上用真心书写的二十多万原创文字。</b></p><p>去年，也是这样的秋季，只是不似这般阳光明媚。连日的阴雨，让人愁肠百结……</p><p>土豆在长沙读大学，他爹经常出差，家里时常只剩下我一个人。</p><p>放心不下乡下年迈的父亲和破旧的老屋，我对他们的牵挂愈发浓烈，心中有千言万语想要说出来。</p><p>我写了一篇又一篇日记，可是，越写，越觉得孤独、难受。</p><p>直到那天，我误打误撞地闯进简书后，才发现，这里，才是写作人的“理想王国”。</p><p>“简单书写！”我喜欢简书的这个宣传语。</p><p>没有功利，没有企求，只求简简单单地将自己的真实感受写出来，写出一个热爱文字的人的点点滴滴。</p><p>对故乡的思念，是我初入简书时急于想表达的情感。</p><p>其时，我的九旬老父亲还健在，每次回乡下，我都会坐在他老人家身边，听他讲过去的事情。</p><p>天气好的时候，我会陪着父亲在村里转转。</p><p>一个个或苍老或弱小的身影从我的身边走过，我努力想认出他们，却怎么也想不起来他们是谁。</p><p>村里那些曾经光彩夺目的小洋楼，在岁月的风雨中变得黯然失色，好多人家的门前，杂草丛生，院落荒芜，门上的铁锁已锈迹斑斑……</p><p>回到城里，心情久久不能平静的我，写下了《故乡的回忆》系列。平淡的文字，灼热的情感，有很多简友为我点赞，我不知道是否真的感动了他们，但他们的鼓励却给了我莫大的鼓舞，我有了写下去的动力。</p><p>刚开始，我只有零星的几位简友，记得最早关注我的是<a href=\"https://www.jianshu.com/u/fe3ba6ead306\" target=\"_blank\">铁妩</a>、<a href=\"https://www.jianshu.com/u/71cc10acdae2\" target=\"_blank\">小豆利子</a>、<a href=\"https://www.jianshu.com/u/c9372cacba1d\" target=\"_blank\">高桥美纱</a>、<a href=\"https://www.jianshu.com/u/b627ac0f93b4\" target=\"_blank\">红尘老街</a>、<a href=\"https://www.jianshu.com/u/a75ad8b244e6\" target=\"_blank\">残阳物语</a><a href=\"https://www.jianshu.com/u/b5cc6f248eac\" target=\"_blank\">、</a><a href=\"https://www.jianshu.com/u/b5cc6f248eac\" target=\"_blank\">金源涛、</a><a href=\"https://www.jianshu.com/u/fd696af052d4\" target=\"_blank\">寻找梦想的鱼</a>等兄弟姐妹。</p><p>还有一位和我家土豆同龄的东北女孩<a href=\"https://www.jianshu.com/u/59c141c586ef\" target=\"_blank\">小猪子499</a>，她是我在简书上的第一个读者，第一个给我留言的人，我们成了忘年交，她一直亲热地叫我“红裙阿姨”。</p><p>凭良心说，我那时的文字比现在还要拙劣，但他们没有嫌弃我，反而给予我很多的夸奖，有时也真诚地提出批评。我能走到今天，与他们的鼓励和支持是分不开的。</p><p>无知者无畏，那时，凭着对文字的热爱，对简书的喜欢，各个专题的征文我都参加。我不敢奢望获奖，只把它们当成一篇篇命题作文，力求不偏题，倘若偶尔能有写出彩的则更好。</p><p>那段时间，可谓是我创作热情最高的时期，也是我连连获奖的时期（捂脸——大都数是三等奖，有的还是优秀奖）。</p><p>我的简友越来越多（下一篇我专门写我的简友们，题目都想好了）。简友们都叫我“红裙子”，我也喜欢他们这样叫我，他们说我是简书里的一条快乐的红裙子。</p><p>我的快乐来自于简书，只要走进简书，我的烦恼就会消失，我的脸上就会春风荡漾。</p><p>可现实生活中，我的处境非常不好。</p><p>冷落、排挤、各种风凉话，铺天盖地地向我袭来，我只有招架的功，没有还手的力，我成了熟人们茶余饭后的“谈资”。</p><p>很多人在朋友圈将我屏蔽，有的人甚至拉黑了我，原因是不想读到我发在朋友圈的文字。</p><p>我成了一个尴尬的人，随时随地、毫无征兆地就会遭到别人的讥讽，而这一切，竟然是因为我比他们会写几篇“文章”。</p><p>今年6月份的时候，因为要照顾和陪伴生命垂危的老父亲，我辞职离开了原先那个不待见我的单位和那些不待见我的人。</p><p>父亲最后的日子，我日夜守护在他的身边，和我共同守护的，除了我的兄妹，还有我最爱的简书。</p><p>乡下的夜，静谧、漫长，父亲的气息越来越弱，我的文字也越来越低沉……</p><p>父亲安详地离去了……那个给我关爱最多，对我一生影响最大的人，从此成了我遥不可及的思念，我们兄妹悲痛欲绝。</p><p>我一遍又一遍地回看我以前写的关于父亲的文字，从今往后，我将不忍再写，我不想让痛失父亲的悲伤席卷我……</p><p><b>感谢简书，让我在我父亲健在的日子，用文字表达了我对他老人家的崇敬和爱！</b></p><p>处理好父亲的后事，我伤心地离开了那个叫“马颈”的小山村，回到城里的我，再度成了一个失业人员。</p><p>转机却从这里开始。</p><p>回到家后，陆续接到很多电话，都是邀请我去上班的，他们的缘由是：</p><p>“我们需要一个会写文章的财务人员！”</p><p>“一个能写出那么多感人至深的文章的人，人品一定不会差！”</p><p>“你的文笔很美，我们公司欢迎你！”</p><p>“您好，我们是中小学辅导班，拜读了您在简书上发表的文章，想请您来教孩子们写作文……您可以兼职，也可以专职……”</p><p>……</p><p>我诚惶诚恐地接着每一个电话，感觉是幻觉，又觉得是奇迹。</p><p>又一次打开简书，心头涌起了无限的感慨：一年来，我的那些个“文章”，不知引来了多少人的口诛笔伐，他们用最恶毒的词语贬低我，说我是“神经病”……</p><p>他们那刺耳的、不怀好意的笑声，仍在我的耳边回荡……</p><p>可是，现在一下子却有这么多好岗位等着我，这是怎么回事呢？</p><p>我有点懵，傻乎乎地问电话那端的人，那端传来一个个热情的、坚定的声音：“我们公司欢迎您！”</p><p>稳定了一下既惊喜又慌乱的情绪，在众多的邀请单位里，我选择了现在就职的这家公司，我要继续往前远行。</p><p>远方有多远，我不知道，但眼前的路已渐渐趋于平坦，虽然依旧没有鲜花，没有掌声，只有我未变的初心和对文字永远的热爱！</p><hr><p>我是陌上红裙，感谢简书，感谢你！</p>",
      "time": "2017.11.07 22:00:25"
    },
    {
      "source": "jianshu",
      "id": "1m6fyhx50w4g",
      "content": "<p>翻看文集，才发现来到简书已经一年了。</p><p>第一篇文章发表与2017年7月24日，从那时起，我便开始了在简书定期写作更新的历程。至今总共发布了一百多篇文章，除去被我隐藏的文章，累计字数十七万字，积累粉丝近六万。在这段写作的过程里，我成为了旅行专题板块的“旅行达人”，开通了付费连载<b><a href=\"https://www.jianshu.com/nb/15153544\" target=\"_blank\">《远行·西藏》</a>，</b>还获得了简书版权中心的签约机会。</p><p>记得有一部讲西藏的影片《冈仁波齐》很是火了一段时间，跟着一起火的还有这么一句话：人生没有白走的路，每一步都算数。</p><p>事实的确如此。写作的时候只要抱着尽力写好每一句话的念头去写就是了，相信一路坚持下来，终会收获属于自己的果实。</p><p>在简书写作一年以后，我出版了人生第一本书：<b>《远行·西藏》</b>。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 588px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 84.11%;\"></div>\n<div class=\"image-view\" data-width=\"1561\" data-height=\"1313\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-16bd31b30bff0a71.png\" data-original-width=\"1561\" data-original-height=\"1313\" data-original-format=\"image/png\" data-original-filesize=\"2215265\" data-image-index=\"0\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><h1>如何出版一本书？</h1><p>书出版以后，很多朋友纷纷问我：“要怎样才能出一本书啊？”今天就这个话题来说一说我的体会。</p><blockquote><p><b>量变成就质变</b></p></blockquote><p>对于想知道如何出版一本书的朋友，我通常都会回答他们：“首先你要有可以出版的素材啊。”</p><p>这看起来是个没什么用的答案，但实际上却往往切中要害。因为很多人都还没开始写，就在想着怎么出版。</p><p>虽然说不想当将军的士兵不是好兵，不想出书的写作者也不会是个好的写作者。可是，量的积累是不可或缺的。如果你想出版一本小说，那么至少要有过一段创作经历，而且已经有一定量的小说积累了。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 678px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 96.93%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"727\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-74e7905bac163446.jpeg\" data-original-width=\"750\" data-original-height=\"727\" data-original-format=\"image/jpeg\" data-original-filesize=\"180030\" data-image-index=\"1\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p>我的写作是从记录自己的旅行见闻开始的。实际上，在来到简书之前我已经在自己的公众号写作了将近一年。简书上的文章很多都是我在原有基础上二次修改重新发布的。</p><p>当时写下这些文字，虽然也抱着有一天能出版成书的梦想，但更多还是想着怎样把每一篇文章写好。或许，对于那时的我来说，出书还是一件遥不可及的事吧。</p><p>所以，如果你想知道怎么才能出书，不妨先看看自己已经写了多少字，更了多少篇文。因为没有量的积累，就不会有质的突变。</p><blockquote><p><b>确定一个方向，深耕细作</b></p></blockquote><p>对不少人来说，写作是一种乐趣，写作是一种放松的方式，或者写作是一种习惯。但如果是要出书，那么写作就应该是一个目标。</p><p>为了这个目标，你要确定什么衡量文字的标准，什么是好文章，什么只是普通文字？更重要的是，你要为自己确立一个方向，是虚构还是非虚构？是游记还是散文？是小说还是剧本？</p><p>一旦确定了写作方向，就要在这方面持续地努力，专注地对这一类型的文章反复练习。只有这样集中火力朝一个方向深挖，才是最有效率也最能太高写作能力的。</p><p>有人今天写写鸡汤文章，过两天又改写小说，写着写着又跑去写散文，这样的写法就像猴子摘玉米，一边摘一边掉，最后手里一个都没有。</p><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 527px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 70.83%;\"></div>\n<div class=\"image-view\" data-width=\"744\" data-height=\"527\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-361c20e22b995bfc.jpeg\" data-original-width=\"744\" data-original-height=\"527\" data-original-format=\"image/jpeg\" data-original-filesize=\"182255\" data-image-index=\"2\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><blockquote><p><b>找到你的个人风格</b></p></blockquote><p>对于每一个热爱写作的人来说，这是最好的时代，但也可能是最坏的时代。</p><p>说是最好的时代，是因为网络媒体的发达，为每个人都提供了表达自我的平台。自己写出的文字，想要让更多人看到，变得比以往任何时候都容易了。</p><p>然而，这样便利发达的自媒体时代，也导致了文字泛滥，声音刚一发出便淹没在洪流中。因此，想要让自己的文字出版成书，个人的特色就变得至关重要了。</p><p>简单直白地说，就是你写的东西要跟别人的不一样。这种不一样，可以是文字风格，可以是题材内容，也可以是主题的选择。总之，只有与众不同才会被人注意到，并且留下印象。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 687px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 91.60000000000001%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"687\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-736c738bece6ed6c.jpeg\" data-original-width=\"750\" data-original-height=\"687\" data-original-format=\"image/jpeg\" data-original-filesize=\"212585\" data-image-index=\"3\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><blockquote><p><b>写公号文≠出书</b></p></blockquote><p>在考虑朝出版书籍方向努力之前，你首先需要弄清楚的就是文字发表的各种形式之间的区别。</p><p>图书、报纸、杂志、公众号，不同的形式对文章的要求也不一样。以现在最火热的公号文为例，要求对热点反应迅速，语言富有煽动性，要么就要搞笑有趣，善于吐槽。这类文章的寿命大多不长，发布二十四小时后基本也就被遗忘了。</p><p>而图书这一形态，则要求文章要具有一定的深度和整体性。这里并不是对二者作孰优孰劣的比较，而是客观列出它们各自的特点。</p><p>公号文讲究的就是一个时效性，因为碎片阅读的特性决定了，人们只会花几分钟甚至几秒钟快速地掠过。而书籍要求的是比较专注的阅读，相对而言这更花时间，也更费力，因为读者一边读还会一边进行思考。</p><p>明白了这些不同形态的区别，你自然就知道怎样的文字能够出版成书，而什么样的文字只适合发表在网络平台上。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 346px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 46.19%;\"></div>\n<div class=\"image-view\" data-width=\"749\" data-height=\"346\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-80894cc52c17faf1.jpeg\" data-original-width=\"749\" data-original-height=\"346\" data-original-format=\"image/jpeg\" data-original-filesize=\"121691\" data-image-index=\"4\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p>除了以上这些经验之谈，还有很重要的一点，当然就是要选择一个优质的平台，和一个专业的出版经理人。</p><p>关于这一点，我要再次感谢简书。自从简书版权中心的<a href=\"https://www.jianshu.com/u/d562831f4171\" target=\"_blank\">Ric庆余</a>跟我谈过签约的事宜后，接下来的操作细节我就再也没有操心过，从找出版社到签合同到最终到最终出版，一切都有条不紊地进行着。这对于创作者来说简直是个福音，因为你只需要专心写作就可以了，其余的事都可以放心地交由版权中心来帮你处理。</p><p>接下来，我还会在简书继续更文，继续写作，争取有新的作品能够出版问世。</p><p>找到一条属于自己的道路不容易，让我们不忘初心，砥砺前行。</p><blockquote>\n<p><b>关于新书的相关链接：</b></p>\n<p><a href=\"https://www.jianshu.com/p/0c58db0aee19\" target=\"_blank\"><b>带着速写本去西藏，一段边走边画的旅行——简书作者肉丝新书《远行·西藏》上市</b></a></p>\n</blockquote>",
      "time": "2018.08.29 17:18:47"
    },
    {
      "source": "jianshu",
      "id": "621yjstvnxc0",
      "content": "<p>二十岁出头，正好处在一个尴尬的年纪。似乎看透了生活，实质却依旧单纯；似乎应有尽有，实质却一无所有；内心身怀雄心壮志，却又不得不脚踏实地。<br></p><p><b>身处二十岁这个尴尬的年龄，确实会有些迷茫，也会有些无奈。但是每当背起行囊的那一刻，我就明白有些事情现在不去做，再也不会去做了。</b></p><p>有人经常会问我，你认为旅行的意义是什么？你在路上都做什么？<br></p><p>我不能告诉你旅行的意义是什么，或许旅行本身就没有意义。不过既然有人问后面一个问题，那我借此机会来分享下我在旅途中经常会做的十件事。</p><p>因为，我觉得这些都是到八十岁之后想起来都会笑的事情。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 597px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 63.99%;\"></div>\n<div class=\"image-view\" data-width=\"933\" data-height=\"597\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-fdf30bf7e301a6e9.jpg\" data-original-width=\"933\" data-original-height=\"597\" data-original-format=\"image/jpeg\" data-original-filesize=\"183902\" data-image-index=\"0\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">《庆幸可以在旅途中遇见》</div>\n</div><p>                        旅 途 中 的 十 件 事 情</p><p><b>01、走很远很远</b><b>的路</b></p><p>每次去旅行，走路大概是必须的一件事。比起去那些到哪都在路上伸手拦出租车，然后和这个城市擦肩而过的方式，我还是更喜欢用自己的双脚去丈量这个世界。</p><p>曾二十八天徒搭于广袤无垠的西藏，也穿越在神秘色彩的鳌太，还行走于美丽的大西北这片炙热的土地上。</p><p>或者漫步在一个城市的街道上，感受一个城市和其它地方不一样的氛围。只有这样从容的方式才有机会撞见不同的人，去发现发生在身边意外的惊喜。</p><p><b>用自己的脚步去行走，这样可以在想停下来的时候停下来，也可以兴奋的想要奔跑时也能随时狂欢。</b></p><p><b>然后，我会把每一天走的步数都捐出去。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 69.57%;\"></div>\n<div class=\"image-view\" data-width=\"920\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1fdafb80f75908a4.jpg\" data-original-width=\"920\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"123515\" data-image-index=\"1\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">一条路</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 400px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"400\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e0947c5d9b0c555a.jpg\" data-original-width=\"600\" data-original-height=\"400\" data-original-format=\"image/jpeg\" data-original-filesize=\"87884\" data-image-index=\"2\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">出发，在路上</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.12%;\"></div>\n<div class=\"image-view\" data-width=\"852\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-54ca4c10fe17d0a0.jpg\" data-original-width=\"852\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"102546\" data-image-index=\"3\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">一个人</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5fc6ac4b657980b1.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"294742\" data-image-index=\"4\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">路在脚下</div>\n</div><p><b>02、搭乘最大众的交通工具</b></p><p>在旅行的时候，你绝对不会像我一样去做这样的“蠢事”：为了听一对母子有趣的对话，到站了不下车一直听到他们下车为止。<br></p><p>你应该也没有体会过一个人背着（60+10）L的大背包去挤没有座位的公交车，像外星人一样被人从起点看到了终点。</p><p><b>其实，乘坐大众交通工具可以带我到不同的区域，这样你可以观察到最真实的“当地人”。</b></p><p>比如，乘坐地铁时，你会看到早晨匆忙去公司的上班族，也会遇见很时髦的类似要去参加party的年轻人们，还可以看看不同国家的人在车上滑着手机。</p><p>有人下车，有人上来，有时候人们的脸上浮现的是笑容亦或皱着眉头在担忧，用一个车厢、一段路的时间好好捕捉这些城市百态。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 599px; max-height: 360px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.099999999999994%;\"></div>\n<div class=\"image-view\" data-width=\"599\" data-height=\"360\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-7e8afd59af3b6166.jpg\" data-original-width=\"599\" data-original-height=\"360\" data-original-format=\"image/jpeg\" data-original-filesize=\"62965\" data-image-index=\"5\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">慢生活</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 599px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.38%;\"></div>\n<div class=\"image-view\" data-width=\"992\" data-height=\"599\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0da2fd37b7bd2d0a.jpg\" data-original-width=\"992\" data-original-height=\"599\" data-original-format=\"image/jpeg\" data-original-filesize=\"235827\" data-image-index=\"6\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">遇见自己</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 431px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 61.62%;\"></div>\n<div class=\"image-view\" data-width=\"1248\" data-height=\"769\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a6b6fb358299562e.jpg\" data-original-width=\"1248\" data-original-height=\"769\" data-original-format=\"image/jpeg\" data-original-filesize=\"237616\" data-image-index=\"7\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">有始有终去看一座城</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-dbcea8b292aaf731.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"225400\" data-image-index=\"8\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">疲惫的面孔</div>\n</div><p></p><p><b>3、去寻觅舌尖上的美味</b></p><p>你知道你发现没有，当我们在一个城市旅行的时候。在某一个特定的区域里，你总会看到有些当地人会在下班回家时顺手提的袋子。</p><p>如果这样你就不要犹豫，那肯定是让人每天都想吃的美食。就像去你重庆就要吃一次真正的火锅，西安要吃肉夹馍，去红河一定要吃烤豆腐一样……</p><p><b>其实，每个城市都有属于自己的味道。而这些很有可能都是日后让你念念不忘，一闻到相似味道回忆就涌上心头的好滋味。</b></p><p>也许我是一个吃货，一说到吃总会忍不住想去吃，想再次上路去寻觅。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0195e9b8f2cee4dd.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"89794\" data-image-index=\"9\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">重庆火锅</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 532px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.5%;\"></div>\n<div class=\"image-view\" data-width=\"800\" data-height=\"532\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c9b962e2c955da7a.jpg\" data-original-width=\"800\" data-original-height=\"532\" data-original-format=\"image/jpeg\" data-original-filesize=\"71921\" data-image-index=\"10\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">过桥米线</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c0d813694e713bf2.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"256128\" data-image-index=\"11\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">烧饵块</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 451px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 64.45%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"825\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-4941ac76822404bd.jpg\" data-original-width=\"1280\" data-original-height=\"825\" data-original-format=\"image/jpeg\" data-original-filesize=\"295977\" data-image-index=\"12\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">建水烧豆腐</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 400px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"400\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f6d3fd95b57e6774.jpg\" data-original-width=\"600\" data-original-height=\"400\" data-original-format=\"image/jpeg\" data-original-filesize=\"76392\" data-image-index=\"13\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">辣椒酱</div>\n</div><p><b>4、找一家不错的青旅或客栈</b><br></p><p>旅行中最有趣的事情之一，便是与来自世界各地的旅人聊天，成为朋友。</p><p>而最好的方式大概就是找上一家评价不错，环境还可以的青旅。然后可以一个人坐在里面静静的发上一下午的呆，又或者加入那些有说又笑的小团伙里面。如果一拍即合，第二天你也有了通行的小伙伴了。</p><p><b>这样的过程，都让一趟旅程因为温暖的人心而变得更有意义。你会发现有些人即使一辈子和自己身处不同的国度，心竟是如此相似与靠近。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 548px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 64.24%;\"></div>\n<div class=\"image-view\" data-width=\"853\" data-height=\"548\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-fabe3dfe2dbd02a3.jpg\" data-original-width=\"853\" data-original-height=\"548\" data-original-format=\"image/jpeg\" data-original-filesize=\"117415\" data-image-index=\"14\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">我和法国行者</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-89260ee739f1b41d.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"336776\" data-image-index=\"15\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">青旅的猫</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5eb2c6970758887b.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"661234\" data-image-index=\"16\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">静静发呆</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 460px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.73%;\"></div>\n<div class=\"image-view\" data-width=\"1751\" data-height=\"1151\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-78c59b32459111be.jpg\" data-original-width=\"1751\" data-original-height=\"1151\" data-original-format=\"image/jpeg\" data-original-filesize=\"274906\" data-image-index=\"17\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">那个姑娘</div>\n</div><p><b>5、早起去看日出或独自看日落</b></p><p>很多人去旅行，每天早上都会起的特别晚。而我不会所有美好的早晨都拿来睡觉，如果天气允许，我都会选择有去看日出。感受一个地方或者一座城市的第一缕阳光。</p><p>抑或是在一个微风徐徐的傍晚，我会一个人走很远的路，找一个没人的地方。亲眼去见证太阳消失在地平线的那一刻。</p><p><b>日出，是一种能让人兴奋的瞬间，随之红日东升，冲破云霄，大地开始升腾，那是生命的喧嚣。而日落，则是一天结束，那是一种归属感。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 398px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"398\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e65db51dd74e517c.jpg\" data-original-width=\"600\" data-original-height=\"398\" data-original-format=\"image/jpeg\" data-original-filesize=\"37108\" data-image-index=\"18\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">敦煌沙漠日出</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 664px; max-height: 442px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.57%;\"></div>\n<div class=\"image-view\" data-width=\"664\" data-height=\"442\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-b26600670ec1c31d.jpg\" data-original-width=\"664\" data-original-height=\"442\" data-original-format=\"image/jpeg\" data-original-filesize=\"34799\" data-image-index=\"19\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">太白日落</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f649c79d7eb46958.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"52752\" data-image-index=\"20\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">昆明日出</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-75a3938e23d93787.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"87629\" data-image-index=\"21\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">青海湖日出</div>\n</div><p><b>6、寻找那些“不热门”的景点</b><br></p><p>不知道这是不是国人的通病，还是其他什么原因，反正生活里经常听到这样的声音，说是某某某地方商业化太严重了，某某某地方人太多了，某某某地方太没意思了……可是，即使这样到最后不想去的地方都去了。<br></p><p>但去完这些地方之后，我通常还会想办法去找一些人不太多的地方走走逛逛吃吃。</p><p>比如坐公交车路过一个看着不错的地方，下一站立马下车走回来看个究竟，或者看似一家能挖宝的二手店，又或者集结当地文艺青年的咖啡厅……</p><p><b>它们也许不有名，却绝对是你在旅行中最美好的偶遇。</b></p><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f119310e7456d24a.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"370524\" data-image-index=\"22\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">不期而遇的美好</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 427px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.72%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"427\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-93beb9e5be64c32d.jpg\" data-original-width=\"640\" data-original-height=\"427\" data-original-format=\"image/jpeg\" data-original-filesize=\"57522\" data-image-index=\"23\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">天空之境</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 480px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"480\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1f0a85581c1742ec.jpg\" data-original-width=\"640\" data-original-height=\"480\" data-original-format=\"image/jpeg\" data-original-filesize=\"90682\" data-image-index=\"24\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">轮回</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ab3ca2d68ca4de8a.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"517858\" data-image-index=\"25\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">无人的山头</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 458px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.44%;\"></div>\n<div class=\"image-view\" data-width=\"1768\" data-height=\"1157\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ef07eedba7a3f79e.jpg\" data-original-width=\"1768\" data-original-height=\"1157\" data-original-format=\"image/jpeg\" data-original-filesize=\"449856\" data-image-index=\"26\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">无人的小镇</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 479px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 68.49%;\"></div>\n<div class=\"image-view\" data-width=\"1752\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5a42a06304483c0b.jpg\" data-original-width=\"1752\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"492086\" data-image-index=\"27\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">图文艺的咖啡馆</div>\n</div><p><b>7、拍下只一眼就忘不掉的陌生人</b></p><p>曾经行走在路上，一个年近七旬的老人和我说：“孩子，出发什么时候都不晚，但是发现自己需要趁早。”也记得走在苏州的街道上，被一个奶奶喊着说我像好人，她手机坏了急着打电话看我能不能弄好。还记得那个24个小时硬座火车上的小女孩………</p><p><b>其实在见到他们的那一刻，我明显感受到，此生和这些人或许真的就只有这一面之缘。但是有的人你遇见就记住了，记住了就再也忘不掉了。</b></p><p>因此，我更加珍惜每一次的相遇，其实挺美好的，如果每个都不错过，成为常联系的朋友，反而会缺失那份初见的美妙。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 425px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.41%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"425\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-558ca259bde2fe52.jpg\" data-original-width=\"640\" data-original-height=\"425\" data-original-format=\"image/jpeg\" data-original-filesize=\"88397\" data-image-index=\"28\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">搭车的老奶奶</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 425px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.41%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"425\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-9d0020f046e1115e.jpg\" data-original-width=\"640\" data-original-height=\"425\" data-original-format=\"image/jpeg\" data-original-filesize=\"26599\" data-image-index=\"29\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">纯情基友</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1da96b02cb839e78.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"86261\" data-image-index=\"30\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">中国军人</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.47999999999999%;\"></div>\n<div class=\"image-view\" data-width=\"1083\" data-height=\"720\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-6dacb76c92e36cf7.jpg\" data-original-width=\"1083\" data-original-height=\"720\" data-original-format=\"image/jpeg\" data-original-filesize=\"172279\" data-image-index=\"31\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">宁静</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 1050px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 150.0%;\"></div>\n<div class=\"image-view\" data-width=\"1200\" data-height=\"1800\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c908988b2b1c0476.jpg\" data-original-width=\"1200\" data-original-height=\"1800\" data-original-format=\"image/jpeg\" data-original-filesize=\"279571\" data-image-index=\"32\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">孤独的落幕者</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 490px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 70.12%;\"></div>\n<div class=\"image-view\" data-width=\"1533\" data-height=\"1075\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f7669e7e9abe79c3.jpg\" data-original-width=\"1533\" data-original-height=\"1075\" data-original-format=\"image/jpeg\" data-original-filesize=\"225723\" data-image-index=\"33\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">为梦想也为生活</div>\n</div><p><b>8、尽量去成为一名志愿者</b></p><p>在某个夜晚帐篷被吹飞，一句扎西德勒就收留了我一晚上的藏族妈妈；去做志愿者的时候，听说我要去山区支教，常州的叔叔阿姨下车的时候硬给我塞了两百，让我给孩子们买点吃的………</p><p>有时候，会有人问我为什么别人都在质疑，而你却一再坚持去做这些事情。其实，只是想把自己在路上得到的这些爱，拿出来分点给需要帮助的人。</p><p>所以，去到一个城市之前都会找一些志愿活动，尽自己的微薄之力去温暖一些普通的人。我一直觉得，带上爱出发才是旅行最终的信仰。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 547px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 78.28%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"1002\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-be984ccf1445e7ac.jpg\" data-original-width=\"1280\" data-original-height=\"1002\" data-original-format=\"image/jpeg\" data-original-filesize=\"187453\" data-image-index=\"34\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他是卓玛</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 583px; max-height: 389px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.72%;\"></div>\n<div class=\"image-view\" data-width=\"583\" data-height=\"389\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-2d15ddbb042e76ef.jpg\" data-original-width=\"583\" data-original-height=\"389\" data-original-format=\"image/jpeg\" data-original-filesize=\"38982\" data-image-index=\"35\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">这是扎西</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-179fd2ba58127436.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"244232\" data-image-index=\"36\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他们是我的学生</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-91041caed9760de2.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"168751\" data-image-index=\"37\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他也是</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a6cca153ae5be8ca.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"183660\" data-image-index=\"38\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">帮乡亲们拍照</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-cb19d7acf9c0825d.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"167185\" data-image-index=\"39\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">我们在一起</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 933px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 133.32999999999998%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"1280\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-cc0ae58e9bea1849.jpg\" data-original-width=\"960\" data-original-height=\"1280\" data-original-format=\"image/jpeg\" data-original-filesize=\"530619\" data-image-index=\"40\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">教学生拍照</div>\n</div><p><b>9、写明信片纪录当时的心情</b></p><p>这些年去旅行，这是从未忘记的一件事，向朋友或者陌生人邮寄明信片。可以在一张小小的纸片上分享在另一个城市看到的风景。</p><p><b>写下当时的心情，无关乎是简短的文字，或者温馨感人，或者朴素平淡，或者搞怪幽默，或者富于哲理，都能给远方有相同情愫的人不一样的体验。</b></p><p>而且，我还将这些明信片作为每一本书的书签，这样当我翻阅着书籍，不经意或者常常地，就能看到并回味这样的感动。</p><p>不知道你有没有体会过那种跨越千山万水带来的温暖和感动。如果没有，下次我寄给你。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 686px; max-height: 436px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 63.56%;\"></div>\n<div class=\"image-view\" data-width=\"686\" data-height=\"436\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ee7a8b123ac376a8.jpg\" data-original-width=\"686\" data-original-height=\"436\" data-original-format=\"image/jpeg\" data-original-filesize=\"102598\" data-image-index=\"41\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">给别人也给自己</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 580px; max-height: 353px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.86%;\"></div>\n<div class=\"image-view\" data-width=\"580\" data-height=\"353\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a8221ab85a9e442f.jpg\" data-original-width=\"580\" data-original-height=\"353\" data-original-format=\"image/jpeg\" data-original-filesize=\"46455\" data-image-index=\"42\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">寄出去多一份温暖</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 525px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"960\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a1a71d187b97ea18.jpg\" data-original-width=\"1280\" data-original-height=\"960\" data-original-format=\"image/jpeg\" data-original-filesize=\"359059\" data-image-index=\"43\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">旅途中的心情</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 450px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"450\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-d2a17de07463be79.jpg\" data-original-width=\"600\" data-original-height=\"450\" data-original-format=\"image/jpeg\" data-original-filesize=\"39909\" data-image-index=\"44\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">写出来的才叫分享</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 690px; max-height: 401px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 58.120000000000005%;\"></div>\n<div class=\"image-view\" data-width=\"690\" data-height=\"401\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-86a48a40fd485966.jpg\" data-original-width=\"690\" data-original-height=\"401\" data-original-format=\"image/jpeg\" data-original-filesize=\"90992\" data-image-index=\"45\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">喜欢，没道理</div>\n</div><p>10、去当地的图书馆和校园走走</p><p>自从自己的《遇见101个笑容》开始启动之后，便爱上了去别人的我校园走走，感受不一样的气息，不一样的环境。</p><p><b>大学校园是段美好的旅程：樱花树下读书，落英缤纷的小径，自行车铃声细碎，百年老校，中式典雅...…这些你都可以感受到。</b><br></p><p>而书店则是一座城市的灵魂。一直以来，我对此深以为然。<br></p><p>只是经常会觉得可惜，现在走街串巷，书店越来越少，只有那些中小学的旁边才有书店聚集，其余的地方，城市越发达，似乎，书店消失的越快，当然这也与网络的发达有脱不开的关系，人们足不出户就可购买到想看的书，方便实惠，送货上门。</p><p>所以每到一个地方，我也会去拜访这个城市一些独特的书店。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 68.45%;\"></div>\n<div class=\"image-view\" data-width=\"935\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-eccb14e88b370863.jpg\" data-original-width=\"935\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"115818\" data-image-index=\"46\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在云大遇见你</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.11%;\"></div>\n<div class=\"image-view\" data-width=\"983\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c82ebee002492bc8.jpg\" data-original-width=\"983\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"258057\" data-image-index=\"47\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在同济遇到你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-9a0b085c71b5baef.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"477775\" data-image-index=\"48\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在兰大遇见你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 525px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"4032\" data-height=\"3024\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-68ead19b5abc86f3.jpg\" data-original-width=\"4032\" data-original-height=\"3024\" data-original-format=\"image/jpeg\" data-original-filesize=\"2402502\" data-image-index=\"49\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在川美遇到你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0d84c3e2a7bd948f.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"356877\" data-image-index=\"50\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在武大遇见你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 59.150000000000006%;\"></div>\n<div class=\"image-view\" data-width=\"1082\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e1df0b7ee16d6347.jpg\" data-original-width=\"1082\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"202658\" data-image-index=\"51\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">M60</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 462px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.03%;\"></div>\n<div class=\"image-view\" data-width=\"1737\" data-height=\"1147\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c731fb6c170ca990.jpg\" data-original-width=\"1737\" data-original-height=\"1147\" data-original-format=\"image/jpeg\" data-original-filesize=\"682205\" data-image-index=\"52\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">先锋书店</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 636px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.25%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"636\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-3844349a9c11a7b2.jpg\" data-original-width=\"960\" data-original-height=\"636\" data-original-format=\"image/jpeg\" data-original-filesize=\"127620\" data-image-index=\"53\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">国家图书馆</div>\n</div><p>将来别人问你或是自己回忆起来20岁的你在做什么，21岁在做什么，22岁在做什么的时候。我想我都可以轻描淡写地说起那些自己精挑细选的故事吧</p><p>“噢，20岁背起行囊去徒步旅行啦，21不顾别人反对去山区支教了，22岁……”</p><p><b>旅行是一场修行，在这场修行中，你会遇见美好，会发生故事，你将足迹走在地球的每一片土地时，感受到的，也必将是这片土地的温暖。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 422px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 56.269999999999996%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"422\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-3b81c931d1801c1c.jpg\" data-original-width=\"750\" data-original-height=\"422\" data-original-format=\"image/jpeg\" data-original-filesize=\"41819\" data-image-index=\"54\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">认真的活着</div>\n</div><p>我是有备而来的路人甲大萌，那个对世界上瘾的二逼青年，如果我写过的任何一句话，拍过的每一张照片，做过的任何举动。曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的情愫。</p><p>有时候，虽然素未谋面。</p><p>却已相识很久，很微妙也很知足。</p><p><b>如果你喜欢鄙文和图片，那就在右下角点个喜欢吧，你的鼓励是我最大的动力来源，在此大萌深表感恩。</b></p><p><b>当然巧好你也喜欢我的话，我们可以互相关注，相互学习的哟。</b></p>",
      "time": "2017.03.10 08:11:50"
    },
    {
      "source": "juejin",
      "id": "5a8z35k32zw0",
      "content": null,
      "time": null
    },
    {
      "source": "juejin",
      "id": "1kwyaz7xw34w",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/5b0388006fb9a07aa213ae16\"><meta itemprop=\"headline\" content=\"Node 在有赞的实践\"><meta itemprop=\"keywords\" content=\"Node.js,Java,前端,koa\"><meta itemprop=\"datePublished\" content=\"2018-05-22T03:05:39.310Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"有赞技术\"><meta itemprop=\"url\" content=\"https://juejin.im/user/5a99007bf265da239c7accca\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/5b0388006fb9a07aa213ae16\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/5b0388006fb9a07aa213ae16\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2018-05-22T03:05:39.310Z\" title=\"Tue May 22 2018 11:05:39 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2018年05月22日</time><span class=\"views-count\" data-v-648672b2>阅读 13111</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node 在有赞的实践</h1><div data-id=\"5b038903518825428b391d5c\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><h2 class=\"heading\" data-id=\"heading-0\">一、概述</h2>\n<blockquote>\n<p>4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在 Node 这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">二、Node 基础框架的迭代与演进</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 从 Koa 到 阿童木（Astroboy）</h3>\n<h4 class=\"heading\" data-id=\"heading-3\">（1）Koa + 中间件</h4>\n<p>有赞最早的一个比较完整的 Node 项目是公司内部的一个管理系统，这个系统是用 Node 全栈开发的，主要包括一个给 HR 用的员工管理系统和给小伙伴用的 APP。就像大多数公司一样，我们第一个 Node 项目也是直接用 Koa，然后整合一些开源的中间件，这样就快速的把项目搭建起来了。</p>\n<p>这个项目做了半年之后，我们把 Node 该踩的坑基本也都踩了一遍，所以我们就开始尝试在对外产品上使用 Node了，我们第一个尝试改造的项目是公司的官网，这是最简单的一个项目，基本没什么大的风险。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">（2）脚手架项目模板</h4>\n<p>第二个项目我们不可能再按照之前的方式，简单用 Koa 加上一堆中间件的方式来搭建项目了，因为已经有了之前的经验，所以我们就整理了下这一套方案，抽离出了一个项目模板，每个新项目只要把这个模板克隆下来，然后改一下配置，就可以快速搭建出一个新的项目来。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">（3）阿童木 1.0</h4>\n<p>项目多了之后，这种方式弊端很快就显现出来了，因为模板代码和业务代码是耦合在一起，如果要改模板生成的代码，只能每个项目手动更新，而随着时间的推移，越来越难保持同步了，每个项目的目录结构和代码风格可能也会变得非常不一样，所以，<strong>解耦框架代码和业务代码就非常重要了</strong>。所以我们就在脚手架模板的基础上抽离出了一个框架叫 Astroboy（阿童木），这个框架是在  Koa 的基础上封装的，这样，每个项目都基于这个框架开发，如果框架更新了，项目也只需要更改下框架的版本号。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cc9555a2b18?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1164\" data-height=\"666\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">（4）阿童木 2.0</h4>\n<p>很多项目都开始用 Node 了，新的问题又出现了，因为每个产品的业务场景都不一样，对框架的需求也都不一样。例如某个中间件，产品 A 可能需要，而产品 B 可能根本不需要这个中间件，而这个时候的框架又不支持定制改造。所以对框架来说，又提出了新的挑战，所以在今年年初，对框架做了一次大的重构。</p>\n<p>这次重构在阿童木 1.0 的基础上，加入了很多新特性，主要有以下几点：</p>\n<ul>\n<li>基于 Koa2 开发，性能表现优异</li>\n<li>提供基于 Astroboy 定制上层框架的能力</li>\n<li>高度可扩展的插件机制</li>\n<li>渐进式开发</li>\n</ul>\n<p>首先提供基于 Astroboy 定制上层框架的能力，如下图所示，Youzan Base Framework 是在阿童木的基础上定制的一个有赞最基础的 Node Web 框架，这一层主要集成了一些有赞最基础的服务，像：</p>\n<ul>\n<li>天网系统接入，这是有赞内部的一个日志及业务监控系统</li>\n<li>健康检查，运维监控系统每隔5秒钟，都会检查系统服务可用性</li>\n<li>全链路监控，对于一次 HTTP 请求，一般都会调用多个后端接口，相应的后端接口也会再去调用其他接口，所以整个调用过程实际上是一棵树状的结构，如果碰到性能问题，找出其中性能瓶颈问题就非常重要了，全链路监控就是为了解决这个问题。</li>\n<li>Dubbo 服务调用接入，关于这一点，查看下面关于服务化的介绍。</li>\n</ul>\n<p>有了 Youzan Base Framework 后，我们就需要在上面开发业务了，这个分两种业务场景：对于一些简单单一的业务，直接继承 Youzan Base Framework 开发就可以了；而如果是一些复杂的业务，就可以先在 Youzan Base Framework 的基础上，定制出一个业务框架，像我们有赞原先有一个超大的 PHP 项目（我们叫 Iron），那么服务化拆分后，Node 就承担了原先 PHP 的部分，所以我们新先定制了一个业务级的框架叫 Iron Base Framework，然后再按照业务模块（交易、店铺、用户、营销）拆分成多个子项目。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cd133687115?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"694\"><figcaption></figcaption></figure><p></p>\n<p>其次是支持插件化，关于这一点，可查看下面关于插件的说明。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">2. 框架的几个核心概念</h3>\n<p>以上介绍了有赞 Node 基础框架迭代和演变的过程，下面主要介绍下阿童木2.0 框架的几个核心概念</p>\n<h4 class=\"heading\" data-id=\"heading-8\">（1）应用 Application</h4>\n<p>应用 Application 的概念很好理解，在这里应用就可以理解成一个项目，它是从框架继承下来，并且实例化之后的一个实例，应用也是由一个一个插件构成的。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">（2）框架 Framework</h4>\n<p>Astroboy 框架是在 Koa2 的基础上封装的，关于框架的概念，这里就不再做过多的介绍了。</p>\n<h4 class=\"heading\" data-id=\"heading-10\">（3）插件 Plugin</h4>\n<p>插件化是软件设计中一个很重要的思想，很多软件像 Eclipse 都支持这样的特性，插件化可以让我们的系统解耦，每个模块做到独立开发，而模块之间又不会相互影响，这样的特性对于大型项目来说是非常重要的。</p>\n<p>插件化是 Astroboy 框架中最核心的一个实现，它是服务（Service）、中间件（Middleware）和工具函数库（Lib）等的载体，它本质上还是 NPM 包，只不过是在 NPM 包的基础上，做了更深层次的抽象。基于 Astroboy 的应用，就是由一个一个的 Plugin 组成的，Plugin 就是我们手中的积木，通过 Astroboy 的框架引擎把这些积木组织在一起，就形成了系统。</p>\n<p><strong>那么插件跟普通的 NPM 包有什么区别呢？</strong></p>\n<p>插件约定了目录结构，这样每个插件看起来都是类似的，这对于团队的协作是非常重要，如果每个模块看起来都不一样，那么团队的协作成本就会很高。\n应用启动后，插件的代码是自动注入到整个应用的，只需要在插件的配置文件里面开启这个插件即可。</p>\n<p><strong>一个插件可以包含哪些信息？</strong></p>\n<ul>\n<li>插件元数据，包括插件名称、版本、描述等；</li>\n<li>服务（Service）、中间件（Middleware）以及工具函数库（Lib）等；</li>\n<li>Koa 内置对象的扩展，包括 Context、Application、Request 以及 Response 等；</li>\n</ul>\n<p><strong>插件的管理</strong></p>\n<ul>\n<li>安装插件，通过npm install 命令即可，例如：npm install [<@scope>/]@</li>\n<li>启用插件，安装插件后还需要启用插件，插件才会真正生效。启用插件也很简单，只需要配置 plugin.default.js 即可，如果不同环境插件配置不一样，也只需修改相应* 环境的配置（plugin.${env}.js）即可，这里 env 表示 Node 运行时的环境变量，例如：development、test、production 等。如下代码所示：</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    path: path.resolve(__dirname, <span class=\"hljs-string\">'../plugins/astroboy-cookie'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>enable 设置成 true 就可以开启这个插件，path 表示插件的绝对路径，这种一般适合于还在快速迭代中的插件，如果插件已经很稳定了，你就可以把这个插件打包发布成一个 NPM 包，然后通过 package 声明你的插件即可，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    package: <span class=\"hljs-string\">'astroboy-cookie'</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>禁用插件，禁用插件就更加简单了，只需将 enable 设置成 false 即可。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-11\">三、Node 接入有赞服务化体系的历程</h2>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 为什么要做服务化？</h3>\n<p>随着公司业务的发展，网站应用的规模不断扩大，垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键，所以在这个时候，分布式服务架构就势在必行了。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. 技术栈的选择</h3>\n<p>在介绍技术栈选择之前，先讲一下公司的一些技术背景。</p>\n<blockquote>\n<p>在公司成立初期，为了能够快速开发，把产品快速做出来推出市场，所以我们选择用 PHP 语言，我想这也是大多数创业公司的选择。而随着业务的发展，PHP 越来越难处理复杂的业务。</p>\n</blockquote>\n<p>所以等到了一定时候，我们开始做服务化拆分，那么首先考虑的就是底层技术的选择，我们从下面几点考虑：</p>\n<ul>\n<li>第一个是这门技术的生态是否足够完善，也就是相关的开源软件、工具是否成熟；</li>\n<li>第二个是否能够快速招到你需要的人才。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-14\">3. 服务化拆分之后，每一层职责分别是什么？</h3>\n<p>对于 Node 层，我们的定位是一层很薄的中间层，Node 这一层不会过多地处理业务逻辑，业务逻辑全部都交给 Java 来处理，它只负责下面三件事情：</p>\n<ul>\n<li>模板渲染：模板渲染说的就是 HTML 模板的渲染；</li>\n<li>业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node 就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。</li>\n<li>接口转发：Java 的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node 需要承担接口转发的角色。</li>\n</ul>\n<p>而对于 Java 这一层，就需要承担业务逻辑以及缓存等复杂的操作，这里就不做过多的介绍了。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">4. Node 如何调用 Java 接口？</h3>\n<p>那么服务化拆分之后，首先要解决的一个问题是：Node 如何调用 Java 提供的接口。首先，我们想到的就是 HTTP 的方式，这里说明一下，我们公司采用的分布式服务化框架是阿里开源的 Dubbo 框架，而 Dubbo 框架本身是支持通过添加注解的方式生成 Restful API 的，所以在初期，我们就是采用这个现成的方案。</p>\n<p>而随着应用数目的增加，这种方式的弊端也逐渐显现出来，主要有下面几点：</p>\n<ul>\n<li>如果某个接口需要暴露给 Node 使用，就需要手动再去添加额外的注解。</li>\n<li>每增加一个应用，运维都需要针对每个应用配置域名，不同的环境又需要配置不同的域名，所以随着应用数的增加，应用域名的管理越来越难维护。</li>\n<li>相应的，node 也需要维护一份很长的域名配置文件。</li>\n<li>由于 Java 是直接提供 HTTP 接口，所以性能上相对 RPC 的方式会低一点。</li>\n</ul>\n<p>所以，我们就调研了下，看其他公司在使用 Dubbo 框架时，Node 是如何调用 Java 的？如下图所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce4fa59a7c6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1216\" data-height=\"489\"><figcaption></figcaption></figure><p></p>\n<p>首先，Java 应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是 ETCD 或者 Zookeeper，然后，Node 应用在启动的时候，会先从服务注册中心拉取服务列表，接着 Node 会跟 Java 服务建立一条TCP长链接，除此之外，Node 还需要负责 Hession 协议解析以及负载均衡等。</p>\n<p>不难发现，这种方式 Node 的职责就比较重，而且对 Node 开发的要求会很高。所以，我们对这种方式做了改进，如下图所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce94f18acfa?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1029\" data-height=\"481\"><figcaption></figcaption></figure><p></p>\n<p>我们在 Node 和 Java 之间添加了一层中间代理层 Tether，Tether 是用 Go 语言写的一个本地代理，Tether 会对外暴露一个 HTTP 的服务，对 Node 来说，只需要通过 HTTP 方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由 Tether 来处理。这样，Node 这一层就非常轻量了，那么，最终实现出来，Node 是怎么调用 Java 服务的呢？如下代码所示：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> Service = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../base/BaseService'</span>);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoodsService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span> </span>{\n  <span class=\"hljs-comment\">/**\n   * 根据商品 alias 获取商品详情\n   * @param  {String} alias 商品 alias\n   */</span>\n  <span class=\"hljs-keyword\">async</span> getGoodsDetailByAlias(alias) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">this</span>.invoke(\n      <span class=\"hljs-string\">'com.youzan.ic.service.GoodsService'</span>,\n      <span class=\"hljs-string\">'getGoodsDetailByAlias'</span>,\n      [alias]\n    );\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n}\n<span class=\"hljs-built_in\">module</span>.exports = GoodsService;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>对 Node 来说，调用 Java 服务它只需要关注三个点：</p>\n<ul>\n<li>服务名：服务名是由 Java 的包名 + 类名组成，例如上面的 com.youzan.ic.service.GoodsService</li>\n<li>方法名：Java 类对外暴露的方法，例如上面代码所示的根据商品 alias 查询商品详情的一个方法 getGoodsDetailByAlias</li>\n<li>参数：参数就是传递给 Java 的参数列表</li>\n</ul>\n<p>最后，总结下这种方式都有哪些优点：</p>\n<ul>\n<li>第一个是使用简单，对前端开发非常友好，只需要通过 HTTP 方式调用本地的 Tether 服务即可；</li>\n<li>第二个是多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像 Node 一样，它们都只需要调用本地 Tether 暴露的 HTTP 服务即可，没有额外的开发成本了。</li>\n<li>第三个是后期更方便做协议层的优化，因为这种方式 Tether 其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化 Tether 的性能就可以了。</li>\n</ul>\n<p>那么，看到这里，有人可能又会想，这里 Node 也是通过 HTTP 方式调用 Java 的，性能上是不是也存在问题呢？所以这里我们就做了一些优化，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Agent = require(<span class=\"hljs-string\">'agentkeepalive'</span>);\n\nmodule.exports = new Agent({\n  maxSockets: 100,\n  maxFreeSockets: 10,\n  timeout: 60000,\n  freeSocketKeepAliveTimeout: 30000,\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里，我们引用了一个 agentkeepalive 包，在 HTTP 早期，每个 HTTP 请求都要求打开一个 TCP Socket 连接，并且使用一次之后就断开这个 TCP 连接，使用 keep-alive 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。所以通过使用 keep-alive 机制，就可以减少 TCP 连接建立次数。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">四、参考资料</h2>\n<p>https://github.com/apache/incubator-dubbo\nhttps://github.com/QianmiOpen/dubbo2.js\nhttps://github.com/QianmiOpen/dubbo-node-client\nhttps://github.com/p412726700/node-zookeeper-dubbo\nhttps://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cf039b468ca?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"640\" data-height=\"400\"><figcaption></figcaption></figure><p></p>\n</div>",
      "time": "2018年05月22日"
    },
    {
      "source": "juejin",
      "id": "1t1e2qv2m5sw",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/5c1f8e52f265da6170071e43\"><meta itemprop=\"headline\" content=\"Node - 从0基础到实战企业官网\"><meta itemprop=\"keywords\" content=\"Node.js\"><meta itemprop=\"datePublished\" content=\"2018-12-23T14:01:44.166Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"jsliang\"><meta itemprop=\"url\" content=\"https://juejin.im/user/584613ba128fe10058b3cf68\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/5c1f8e52f265da6170071e43\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/5c1f8e52f265da6170071e43\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2018-12-23T14:01:44.166Z\" title=\"Sun Dec 23 2018 22:01:44 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2018年12月23日</time><span class=\"views-count\" data-v-648672b2>阅读 58716</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node - 从0基础到实战企业官网</h1><div data-id=\"5c1f95486fb9a049d05dbaad\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><blockquote>\n<p>Create by <strong>jsliang</strong> on <strong>2018-11-8 13:42:42</strong><br>\nRecently revised in <strong>2018-12-23 21:59:20</strong></p>\n</blockquote>\n<p>Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<br>\n<p> <span style=\"color:red\">【2019-08-16】Hello 小伙伴们，由于 <strong>jsliang</strong> 对文档库进行了重构，这篇文章的一些链接可能失效，而 <strong>jsliang</strong> 没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的 GitHub 地址，去文档库查看调整后的文章。</span></p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-0\">本文重点内容</h3>\n<ul>\n<li>Node 基础 - 通过对 Node 基础的了解学习，打下 Node 基础</li>\n<li>Node API - 开启服务提供 API 给前端调用</li>\n<li>Node 连接 MySQL - 通过 npm 安装 mysql，从而实现数据库的链接</li>\n<li>Node 实战 - 企业官网从 0 开始，打造能注册、登录以及留言的企业官网</li>\n<li>Node 部署 - 如何通过部署云服务器，让小伙伴们可以查看到你的网站</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">本文延伸链接</h3>\n<ul>\n<li>Node 部署项目、云服务器以及域名的使用：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 基础代码下载地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 成品代码下载地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">本文成品演示</h3>\n<ul>\n<li>Node 项目演示：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fcompany.jsliang.top%2F\" rel=\"nofollow noopener noreferrer\">jsliang 前端有限公司</a></li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47764ad7e47?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"726\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\"><a id=\"chapter-one\" name=\"chapter-one\">一 目录</a></h2>\n<p> <strong>不折腾的前端，和咸鱼有什么区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#chapter-one\">一 目录</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-two\" name=\"catalog-chapter-two\"></a><a href=\"#chapter-two\">二 前言</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-three\" name=\"catalog-chapter-three\"></a><a href=\"#chapter-three\">三 基础学习</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-one\" name=\"catalog-chapter-three-one\"></a><a href=\"#chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-two\" name=\"catalog-chapter-three-two\"></a><a href=\"#chapter-three-two\">3.2 URL 模块</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-three\" name=\"catalog-chapter-three-three\"></a><a href=\"#chapter-three-three\">3.3 CommonJS</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-four\" name=\"catalog-chapter-three-four\"></a><a href=\"#chapter-three-four\">3.4 包与 npm</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-five\" name=\"catalog-chapter-three-five\"></a><a href=\"#chapter-three-five\">3.5 fs 文件管理</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-six\" name=\"catalog-chapter-three-six\"></a><a href=\"#chapter-three-six\">3.6 fs 案例</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-seven\" name=\"catalog-chapter-three-seven\"></a><a href=\"#chapter-three-seven\">3.7 fs 流</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eight\" name=\"catalog-chapter-three-eight\"></a><a href=\"#chapter-three-eight\">3.8 创建 Web 服务器</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-night\" name=\"catalog-chapter-three-night\"></a><a href=\"#chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-ten\" name=\"catalog-chapter-three-ten\"></a><a href=\"#chapter-three-ten\">3.10 get 与 post</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eleven\" name=\"catalog-chapter-three-eleven\"></a><a href=\"#chapter-three-eleven\">3.11 Node 连接 MySQL</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-four\" name=\"catalog-chapter-four\"></a><a href=\"#chapter-four\">四 Web 实战 —— 企业官网</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-one\" name=\"catalog-chapter-four-one\"></a><a href=\"#chapter-four-one\">4.1 编程环境</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-two\" name=\"catalog-chapter-four-two\"></a><a href=\"#chapter-four-two\">4.2 后端接口</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-three\" name=\"catalog-chapter-four-three\"></a><a href=\"#chapter-four-three\">4.3 注册功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-four\" name=\"catalog-chapter-four-four\"></a><a href=\"#chapter-four-four\">4.4 登录功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-five\" name=\"catalog-chapter-four-five\"></a><a href=\"#chapter-four-five\">4.5 留言功能</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-five\" name=\"catalog-chapter-five\"></a><a href=\"#chapter-five\">五 工具整合</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-one\" name=\"catalog-chapter-five-one\"></a><a href=\"#chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-two\" name=\"catalog-chapter-five-two\"></a><a href=\"#chapter-five-two\">5.2 PM2 - Node 进程管理</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-six\" name=\"catalog-chapter-six\"></a><a href=\"#chapter-six\">六 参考资料</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-seven\" name=\"catalog-chapter-seven\"></a><a href=\"#chapter-seven\">七 线上部署</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-eight\" name=\"catalog-chapter-eight\"></a><a href=\"#chapter-eight\">八 归纳总结</a></td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-4\"><a id=\"chapter-two\" name=\"chapter-two\">二 前言</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-two\">返回目录</a></p>\n</blockquote>\n<p> 本文主要目的：</p>\n<ol>\n<li>整合 Node 基础，加深 <strong>jsliang</strong> 对 Node 的学习了解，并且方便日后复习。</li>\n<li>整合 Node 工具，方便查找在 Node 开发中，有哪些工具比较有利于开发。</li>\n<li>给初学 Node 的小伙伴做一个参考，如有疑问还请在 QQ 群：<code>798961601</code> 中咨询。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-5\"><a id=\"chapter-three\" name=\"chapter-three\">三 基础</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-three\">返回目录</a></p>\n</blockquote>\n<p> <strong>万丈高楼平地起，地基还得自己起。</strong></p>\n<h3 class=\"heading\" data-id=\"heading-6\"><a id=\"chapter-three-one\" name=\"chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-one\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>01_http.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 2. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面代码，我们要怎么用呢？</p>\n<p> <strong>首先</strong>，将上面的代码复制粘贴到 <code>01_http.js</code> 中。<br>\n <strong>然后</strong>，启动 VS Code 终端：<code>Ctrl + ~</code>。<br>\n <strong>接着</strong>，输入 <code>node 01_http.js</code> 并回车。<br>\n <strong>最后</strong>，打开 <code>localhost:3000</code>：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47a578759c4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"660\" data-height=\"500\"><figcaption></figcaption></figure><p></p>\n<p> OK，搞定完事，现在我们一一讲解上面代码：</p>\n<ol>\n<li><strong>首先</strong>，我们需要先开启仙人模式。哦，不是，是 HTTP 模式。我们都知道，像 PHP 这类老牌子的后端语言，需要 Apache 或者 Nginx 开启 HTTP 服务。然而我们的 Node 不需要：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li><strong>然后</strong>，开启 HTTP 服务，并设置开启的端口：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 步骤 3 代码\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li><strong>接着</strong>，我们设置 HTTP 头部，并往页面打印值，最后结束响应：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\nres.writeHead(200, {\n  <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n});\n\n// 往页面打印值\nres.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n// 结束响应 \nres.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><strong>最后</strong>，我们往浏览器输入 <code>http://localhost:3000/</code>，将访问到我们开启的 Node 服务，从而往页面渲染页面。</li>\n</ol>\n<p> 至此，小伙伴们是不是也开启了自己的 Node 之旅？</p>\n<h3 class=\"heading\" data-id=\"heading-7\"><a id=\"chapter-three-two\" name=\"chapter-three-two\">3.2 URL 模块</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-two\">返回目录</a></p>\n</blockquote>\n<p> URL 模块是什么呢？<br>\n 我们在控制台（终端）开启 Node 模式，并打印出 <code>url</code> 来看一下：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db481725e04bb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"509\" data-height=\"230\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，它有 <code>Url</code>、<code>parse</code>、<code>resolve</code>、<code>resolveObject</code>、<code>format</code>、<code>URL</code>、<code>URLSearchParams</code>、<code>domainToASCII</code>、<code>domainToUnicode</code> 这么多模块。<br>\n 那么，这些模块都有什么用呢？</p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>02_url.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 4. 获取服务器请求\n  /**\n   * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n   * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n   * /  ?userName=jsliang&userAge=23\n   * /  /favicon.ico\n   * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n   */\n  <span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    \n    // 5. 使用 url 的 parse 方法\n    /**\n     * parse 方法需要两个参数：\n     * 第一个参数是地址\n     * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n     */ \n    var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n    console.log(result);\n    /**\n     * Url {\n     *   protocol: null,\n     *   slashes: null,\n     *   auth: null,\n     *   host: null,\n     *   port: null,\n     *   hostname: null,\n     *   <span class=\"hljs-built_in\">hash</span>: null,\n     *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n     *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n     *   pathname: <span class=\"hljs-string\">'/'</span>,\n     *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n     *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n     */\n\n    console.log(result.query.userName); // jsliang\n\n    console.log(result.query.userAge); // 23\n  }\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的代码中：</p>\n<p> <strong>首先</strong>，我们引入该章节的主角 <code>url</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>然后</strong>，我们引入 <code>http</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>接着</strong>，我们创建 <code>http</code> 模块，因为 <code>url</code> 的监听，需要 <code>http</code> 模块的开启：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 第 4 步、第 5 步代码\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们访问我们给出的地址：<code>http://localhost:3000/?userName=jsliang&userAge=23</code>，并通过它查看 <code>url</code> 的 <code>parse</code> 模块怎么用，输出啥：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 4. 获取服务器请求\n/**\n  * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n  * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n  * /  ?userName=jsliang&userAge=23\n  * /  /favicon.ico\n  * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n  */\n<span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n  \n  // 5. 使用 url 的 parse 方法\n  /**\n    * parse 方法需要两个参数：\n    * 第一个参数是地址\n    * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n    */ \n  var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n  console.log(result);\n  /**\n    * Url {\n    *   protocol: null,\n    *   slashes: null,\n    *   auth: null,\n    *   host: null,\n    *   port: null,\n    *   hostname: null,\n    *   <span class=\"hljs-built_in\">hash</span>: null,\n    *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n    *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n    *   pathname: <span class=\"hljs-string\">'/'</span>,\n    *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n    *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n    */\n\n  console.log(result.query.userName); // jsliang\n\n  console.log(result.query.userAge); // 23\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 从中，我们可以看出，我们可以通过 <code>query</code>，获取到我们想要的路径字段。</p>\n<p> 当然，上面只讲解了 <code>parse</code> 的用法，我们可以将上面代码中 <code>if</code> 语句里面的代码全部清空。然后，输入下面的内容，去学习 <code>url</code> 模块更多的内容：</p>\n<ol>\n<li>url 模块所有内容：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url);\n\n/**\n * Console：\n { \n   Url: [Function: Url],\n    parse: [Function: urlParse], // 获取地址信息\n    resolve: [Function: urlResolve], // 追加或者替换地址\n    resolveObject: [Function: urlResolveObject],\n    format: [Function: urlFormat], // 逆向 parse，根据地址信息获取原 url 信息\n    URL: [Function: URL],\n    URLSearchParams: [Function: URLSearchParams],\n    domainToASCII: [Function: domainToASCII],\n    domainToUnicode: [Function: domainToUnicode] \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>parse 如何使用</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com\"</span>));\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: null,\n    query: null,\n    pathname: <span class=\"hljs-string\">'/'</span>,\n    path: <span class=\"hljs-string\">'/'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>parse 带参数：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com/new?name=zhangsan\"</span>));\n\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n    query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n    pathname: <span class=\"hljs-string\">'/new'</span>,\n    path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><code>format</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.format({\n  protocol: <span class=\"hljs-string\">'http:'</span>,\n  slashes: <span class=\"hljs-literal\">true</span>,\n  auth: null,\n  host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  port: null,\n  hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  <span class=\"hljs-built_in\">hash</span>: null,\n  search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n  query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n  pathname: <span class=\"hljs-string\">'/new'</span>,\n  path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n  href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n}))\n\n// Console：\n// http://www.baidu.com/new?name=zhangsan\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li><code>resolve</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.resolve(<span class=\"hljs-string\">\"http://www.baidu.com/jsliang\"</span>, <span class=\"hljs-string\">\"梁峻荣\"</span>));\n\n// Console：\n// http://www.baidu.com/梁峻荣\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，<code>url</code> 这里我们只讲解了个入门，更多的还请看官网 API：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Furl.html%23url_class_url\" rel=\"nofollow noopener noreferrer\">url | Node.js v10.14.1 文档</a></p>\n<h3 class=\"heading\" data-id=\"heading-8\"><a id=\"chapter-three-three\" name=\"chapter-three-three\">3.3 CommonJS</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-three\">返回目录</a></p>\n</blockquote>\n<ul>\n<li>什么是 CommonJS？</li>\n</ul>\n<p> CommonJS 就是为 JS 的表现来制定规范，因为 JS 没有模块系统、标准库较少、缺乏包管理工具，所以 CommonJS 应运而生，它希望 JS 可以在任何地方运行，而不只是在浏览器中，从而达到 Java、C#、PHP 这些后端语言具备开发大型应用的能力。</p>\n<ul>\n<li>CommonJS 的应用？</li>\n</ul>\n<ol>\n<li>服务器端 JavaScript 应用程序。（Node.js）</li>\n<li>命令行工具</li>\n<li>桌面图形界面应用程序。</li>\n</ol>\n<ul>\n<li>CommonJS 与 Node.js 的关系？</li>\n</ul>\n<p> CommonJS 就是模块化的标准，Node.js 就是 CommonJS（模块化）的实现。</p>\n<ul>\n<li>Node.js 中的模块化？</li>\n</ul>\n<ol>\n<li>在 Node 中，模块分为两类：一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP 模块、URL 模块、FS 模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。</li>\n<li>我们可以将公共的功能抽离出一个单独的 JS 文件存放，然后在需要的情况下，通过 exports 或者 module.exports 将模块导出，并通过 require 引入这些模块。</li>\n</ol>\n<p> 现在，我们通过三种使用方式，来讲解下 Node 中的模块化及 exports/require 的使用。</p>\n<p> 我们先查看下目录：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4838b82f804?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"227\" data-height=\"381\"><figcaption></figcaption></figure><p></p>\n<p> <strong>方法一</strong>：</p>\n<p> 首先，我们新建 <code>03_CommonJS.js</code>、<code>03_tool-add.js</code>、<code>node_modules/03_tool-multiply.js</code>、<code>node_modules/jsliang-module/tools.js</code> 这 4 个文件/文件夹。<br>\n 其中 <code>package.json</code> 我们暂且不理会，稍后会讲解它如何自动生成。</p>\n<p> 在 <code>03_tool-add.js</code> 中：</p>\n<blockquote>\n<p>03_tool-add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 假设我们文件其中有个工具模块\nvar tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\n/**\n * 2. 暴露模块\n * exports.str = str;\n * module.exports = str;\n * 区别：\n * module.exports 是真正的接口\n * exports 是一个辅助工具\n * 如果 module.exports 为空，那么所有的 exports 收集到的属性和方法，都赋值给了 module.exports\n * 如果 module.exports 具有任何属性和方法，则 exports 会被忽略\n */\n\n// exports 使用方法\n// var str = <span class=\"hljs-string\">\"jsliang is very good!\"</span>;\n// exports.str = str; // { str: <span class=\"hljs-string\">'jsliang is very good!'</span> }\n\n// module.exports 使用方法\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面的代码有啥含义呢？<br>\n 第一步，我们定义了个工具库 <code>tools</code>。<br>\n 第二步，我们通过 <code>modules.exports</code> 将 <code>tools</code> 进行了导出。<br>\n 所以，我们在 <code>03_CommonJS.js</code> 可以通过 <code>require</code> 导入使用：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  /**\n   * Console：\n   * 6\n   * 6\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就完成了 <code>exports</code> 与 <code>require</code> 的初次使用。</p>\n<p> <strong>方法二</strong>：</p>\n<p> 当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node 就很靠谱，它规范我们可以将这些文件都放在 <code>node_modules</code> 目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。</p>\n<p> 所以，我们在 <code>node_modules</code> 中新建一个 <code>03_tool-multiply.js</code> 文件，其内容如下：</p>\n<blockquote>\n<p>03_tool-multiply.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在引用方面，我们只需要通过：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\nconsole.log(tools2.multiply(1, 2, 3, 4));\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，就可以成功导入 <code>03_tool-multiply.js</code> 文件了。</p>\n<p> <strong>方法三</strong>：</p>\n<p> 如果全部单个文件丢在 <code>node_modules</code> 上，它会显得杂乱无章，所以我们应该定义个自己的模块：<code>jsliang-module</code>，然后将我们的 <code>tools.js</code> 存放在该目录中：</p>\n<blockquote>\n<p>jsliang-module/tools.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  },\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就定义好了自己的工具库。<br>\n 但是，如果我们通过 <code>var tools3 = require('jsliang-module');</code> 去导入，会发现它报 <code>error</code> 了，所以，我们应该在 <code>jsliang-module</code> 目录下，通过下面命令行生成一个 <code>package.json</code></p>\n<blockquote>\n<p>PS E:\\MyWeb\\node_modules\\jsliang-module> npm init --yes</p>\n</blockquote>\n<p> 这样，在 <code>jsliang-module</code> 中就有了 <code>package.json</code>。<br>\n 而我们在 <code>03_CommonJS.js</code> 就可以引用它了：</p>\n<blockquote>\n<p>03_CommonJS.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\n// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\n/**\n * 通过 package.json 来引用文件\n * 1. 通过在 jsliang-module 中 npm init --yes 来生成 package.json 文件\n * 2. package.json 文件中告诉了程序入口文件为 ：<span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"tools.js\"</span>,\n * 3. Node 通过 require 查找 jsliang-module，发现它有个 package.json\n * 4. Node 执行 tools.js 文件\n */\nvar tools3 = require(<span class=\"hljs-string\">'jsliang-module'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  console.log(tools2.multiply(1, 2, 3, 4));\n  console.log(tools3.add(4, 5, 6));\n  /**\n   * Console：\n   * 6\n   * 24\n   * 15\n   * 6\n   * 24\n   * 15\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 到此，我们就通过三种方法，了解了各种 <code>exports</code> 和 <code>require</code> 的姿势以及 Node 模块化的概念啦~</p>\n<p> 参考文献：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Flittlebirdlbw%2Fp%2F5670633.html\" rel=\"nofollow noopener noreferrer\">CommonJS 规范 | 博客园 - Little Bird</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fchenguangliang%2Fp%2F5856701.html\" rel=\"nofollow noopener noreferrer\">js模块化编程之彻底弄懂CommonJS和AMD/CMD！ | 博客园 - 方便以后复习</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fghostwu%2Fp%2F7298462.html\" rel=\"nofollow noopener noreferrer\">[js高手之路] es6系列教程 - 不定参数与展开运算符(...) | 博客园 - ghostwu</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-9\"><a id=\"chapter-three-four\" name=\"chapter-three-four\">3.4 包与 npm</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-four\">返回目录</a></p>\n</blockquote>\n<p> Node 中除了它自己提供的核心模块之外，还可以自定义模块，以及使用 <strong>第三方模块</strong>。<br>\n Node 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4863f64fe3c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"822\" data-height=\"468\"><figcaption></figcaption></figure><p></p>\n<p> 那么，假如我们需要使用一些第三方模块，应该去哪找呢？</p>\n<ol>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.baidu.com\" rel=\"nofollow noopener noreferrer\">百度</a>。百度查找你需要安装的第三方模块的对应内容。</li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2F\" rel=\"nofollow noopener noreferrer\">npm 官网</a>。如果你已经知道包的名字或者包的作用。那么，直接在 npm 官网上搜索，想必会更快找到想要安装的包。</li>\n</ol>\n<p> 那么，npm 是啥？<br>\n npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。<br>\n 在我们安装 Node 的时候，它默认会顺带给你安装 npm。</p>\n<ul>\n<li><code>npm -v</code>：查看 npm 版本。</li>\n<li><code>npm list</code>：查看当前目录下都安装了哪些 npm 包。</li>\n<li><code>npm info 模块</code>：查看该模块的版本及内容。</li>\n<li><code>npm i 模块@版本号</code>：安装该模块的指定版本。</li>\n</ul>\n<p> 在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识：</p>\n<ul>\n<li><code>i</code>/<code>install</code>：安装。使用 <code>install</code> 或者它的简写 <code>i</code>，都表明你想要下载这个包。</li>\n<li><code>uninstall</code>：卸载。如果你发现这个模块你已经不使用了，那么可以通过 <code>uninstall</code> 卸载它。</li>\n<li><code>g</code>：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。</li>\n<li><code>--save</code>/<code>-S</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>dependencies</code> 中。<code>dependencies</code> 是需要发布在生成环境的。例如：<code>ElementUI</code> 是部署后还需要的，所以通过 <code>-S</code> 形式来安装。</li>\n<li><code>--save-dev</code>/<code>-D</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>devDependencies</code> 中。<code>devDependencies</code> 只在开发环境使用。例如：<code>gulp</code> 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 <code>-D</code> 形式来安装。</li>\n</ul>\n<p> 例子：</p>\n<ul>\n<li><code>cnpm i webpack-cli -D</code></li>\n<li><code>npm install element-ui -S</code></li>\n</ul>\n<p> 那么，这么多的 npm 包，我们通过什么管理呢？<br>\n 答案是 <code>package.json</code>。<br>\n 如果我们需要创建 <code>package.json</code>，那么我们只需要在指定的包管理目录（例如 <code>node_modules</code>）中通过以下命名进行生成：</p>\n<ul>\n<li><code>npm init</code>：按步骤创建 <code>package.json</code>。</li>\n<li><code>npm init --yes</code>：快速创建 <code>package.json</code></li>\n</ul>\n<p> 当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm</p>\n<ul>\n<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-10\"><a id=\"chapter-three-five\" name=\"chapter-three-five\">3.5 fs 文件管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-five\">返回目录</a></p>\n</blockquote>\n<p> 本章节我们讲解下 fs 文件管理：</p>\n<blockquote>\n<p>如需快速找到下面某个内容，请使用 <code>Ctrl + F</code></p>\n</blockquote>\n<ol>\n<li><code>fs.stat</code> 检测是文件还是目录</li>\n<li><code>fs.mkdir</code> 创建目录</li>\n<li><code>fs.writeFile</code> 创建写入文件</li>\n<li><code>fs.appendFile</code> 追加文件</li>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n<li><code>fs.rename</code> 重命名</li>\n<li><code>fs.rmdir</code> 删除目录</li>\n<li><code>fs.unlink</code> 删除文件</li>\n</ol>\n<blockquote>\n<p>此章节文件目录：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4943495aae8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"228\" data-height=\"373\"><figcaption></figcaption></figure><p></p>\n<p> <strong>首先</strong>，我们通过 <code>fs.stat</code> 检查一个读取的是文件还是目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  1. fs.stat\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\nfs.stat(<span class=\"hljs-string\">'index.js'</span>, (error, stats) => {\n  <span class=\"hljs-keyword\">if</span>(error) {\n    console.log(error);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(stats);\n    /**\n     * Console：\n     * Stats {\n     *  dev: 886875,\n     *  mode: 33206,\n     *  nlink: 1,\n     *  uid: 0,\n     *  gid: 0,\n     *  rdev: 0,\n     *  blksize: undefined,\n     *  ino: 844424931461390,\n     *  size: 284,\n     *  blocks: undefined,\n     *  atimeMs: 1542847157494,\n     *  mtimeMs: 1543887546361.2158,\n     *  ctimeMs: 1543887546361.2158,\n     *  birthtimeMs: 1542847157493.663,\n     *  atime: 2018-11-22T00:39:17.494Z,\n     *  mtime: 2018-12-04T01:39:06.361Z,\n     *  ctime: 2018-12-04T01:39:06.361Z,\n     *  birthtime: 2018-11-22T00:39:17.494Z }\n     */\n\n    console.log(`文件：<span class=\"hljs-variable\">${stats.isFile()}</span>`); \n    // Console：文件：<span class=\"hljs-literal\">true</span>\n    \n    console.log(`目录：<span class=\"hljs-variable\">${stats.isDirectory()}</span>`); \n    // Console：目录：<span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>Console</code> 打印出来的信息，我们基础掌握了 <code>fs.stat</code> 的作用。</p>\n<p> <strong>然后</strong>，我们尝试通过 <code>fs.mkdir</code> 创建目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  2. fs.mkdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.mkdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中多了一个 <code>css</code> 文件夹。</p>\n<p> <strong>那么</strong>，有创建就有删除，创建的目录如何删除呢？这里讲解下 <code>fs.rmdir</code>：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  8. fs.rmdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.rmdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中的 <code>css</code> 文件夹被删除了。</p>\n<p> <strong>接着</strong>，我们通过 <code>fs.writeFile</code> 来创建写入文件：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  3. fs.writeFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * filename (String) 文件名称\n * data (String | Buffer) 将要写入的内容，可以是字符串或者 buffer 数据。\n * · encoding (String) 可选。默认 <span class=\"hljs-string\">'utf-8'</span>，当 data 是 buffer 时，该值应该为 ignored。\n * · mode (Number) 文件读写权限，默认 438。\n * · flag (String) 默认值 <span class=\"hljs-string\">'w'</span>。\n * callback { Function } 回调，传递一个异常参数 err。\n */\nfs.writeFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'Hello jsliang'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">'写入成功！'</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加 <code>Hello jsliang</code> 这句话。即：存在即覆盖，不存在即创建。</p>\n<p> 有创建就有删除，感兴趣的可以使用 <code>fs.unlink</code> 进行文件的删除，再次不做过多讲解。</p>\n<p> <strong>既然</strong>，上面的是覆盖文件，那么有没有追加文件呢？有的，使用 <code>fs.appendFile</code> 吧：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  4. fs.appendFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\nfs.appendFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'这段文本是要追加的内容'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"追加成功\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就成功往里面追加了一段话，从而使 <code>index.js</code> 变成了：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Hello jsliang这段文本是要追加的内容\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>在上面</strong>，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了：</p>\n<ul>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n</ul>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 5. fs.readFile\nfs.readFile(<span class=\"hljs-string\">'index.js'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取文件成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取文件成功！\n    // <Buffer 48 65 6c 6c 6f 20 6a 73 6c 69 61 6e 67 e8 bf 99 e6 ae b5 e6 96 87 e6 9c ac e6 98 af e8 a6 81 e8 bf bd e5 8a a0 e7 9a 84 e5 86 85 e5 ae b9>\n  }\n})\n\n// 6. fs.readdir 读取目录\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取目录成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取目录成功！\n    // [ <span class=\"hljs-string\">'03_tool-multiply.js'</span>, <span class=\"hljs-string\">'jsliang-module'</span> ]\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如上，我们成功做到了读取文件和读取目录。</p>\n<p> <strong>最后</strong>，我们再回顾一开始的目标：</p>\n<p><s>1. <code>fs.stat</code> 检测是文件还是目录</s><br>\n<s>2. <code>fs.mkdir</code> 创建目录</s><br>\n<s>3. <code>fs.writeFile</code> 创建写入文件</s><br>\n<s>4. <code>fs.appendFile</code> 追加文件</s><br>\n<s>5. <code>fs.readFile</code> 读取文件</s><br>\n<s>6. <code>fs.readdir</code> 读取目录</s><br>\n7. <code>fs.rename</code> 重命名<br>\n<s>8. <code>fs.rmdir</code> 删除目录</s><br>\n<s>9. <code>fs.unlink</code> 删除文件</s></p>\n<p> 很好，我们就剩下重命名了：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"重命名成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，如果 <code>fs.rename</code> 还有更劲爆的功能：剪切</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'jsliang.js'</span>, <span class=\"hljs-string\">'node_modules/jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"剪切成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> OK，通通搞定，现在目录变成了：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4968b350f54?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"231\" data-height=\"329\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\"><a id=\"chapter-three-six\" name=\"chapter-three-six\">3.6 fs 案例</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-six\">返回目录</a></p>\n</blockquote>\n<p> 在上一章节中，我们了解了 <code>fs</code> 的文件管理。<br>\n 那么，在这里，我们尝试使用 <code>fs</code> 做点小事情：</p>\n<blockquote>\n<p>06_fsDemo.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * 1. fs.stat 检测是文件还是目录\n * 2. fs.mkdir 创建目录\n * 3. fs.writeFile 创建写入文件\n * 4. fs.appendFile 追加文件\n * 5. fs.readFile 读取文件\n * 6. fs.readdir 读取目录\n * 7. fs.rename 重命名\n * 8. fs.rmdir 删除目录\n * 9. fs.unlink 删除文件\n */\n\n// 1. 判断服务器上面有没有 upload 目录，没有就创建这个目录\n// 2. 找出 html 目录下面的所有的目录，然后打印出来\n\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 图片上传\nfs.stat(<span class=\"hljs-string\">'upload'</span>, (err, stats) => {\n  // 判断有没有 upload 目录\n  <span class=\"hljs-keyword\">if</span>(err) {\n    // 如果没有\n    fs.mkdir(<span class=\"hljs-string\">'upload'</span>, (error) => {\n      <span class=\"hljs-keyword\">if</span>(error) {\n        console.log(error);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"创建 upload 目录成功！\"</span>);\n      }\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    // 如果有\n    console.log(stats.isDirectory());\n    console.log(<span class=\"hljs-string\">\"有 upload 目录，你可以做更多操作！\"</span>);\n  }\n})\n\n// 读取目录全部文件\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, files) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    // 判断是目录还是文件夹\n    console.log(files);\n\n    <span class=\"hljs-built_in\">let</span> filesArr = [];\n\n    (<span class=\"hljs-keyword\">function</span> getFile(i) {\n      \n      // 循环结束\n      <span class=\"hljs-keyword\">if</span>(i == files.length) {\n        // 打印出所有目录\n        console.log(<span class=\"hljs-string\">\"目录：\"</span>);\n        console.log(filesArr);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      // 判断目录是文件还是文件夹\n      fs.stat(<span class=\"hljs-string\">'node_modules/'</span> + files[i], (error, stats) => {\n\n        <span class=\"hljs-keyword\">if</span>(stats.isDirectory()) {\n          filesArr.push(files[i]);\n        }\n\n        // 递归调用\n        getFile(i+1);\n        \n      })\n    })(0)\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-12\"><a id=\"chapter-three-seven\" name=\"chapter-three-seven\">3.7 fs 流</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-seven\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，我们了解下 <code>fs</code> 流及其读取：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 新建 fs\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\n// 流的方式读取文件\n<span class=\"hljs-built_in\">let</span> fileReadStream = fs.createReadStream(<span class=\"hljs-string\">'index.js'</span>);\n// 读取次数\n<span class=\"hljs-built_in\">let</span> count = 0;\n// 保存数据\n<span class=\"hljs-built_in\">let</span> str = <span class=\"hljs-string\">''</span>;\n// 开始读取\nfileReadStream.on(<span class=\"hljs-string\">'data'</span>, (chunk) => {\n  console.log(`<span class=\"hljs-variable\">${++count}</span> 接收到：<span class=\"hljs-variable\">${chunk.length}</span>`);\n  // Console：1 接收到：30\n  str += chunk;\n})\n// 读取完成\nfileReadStream.on(<span class=\"hljs-string\">'end'</span>, () => {\n  console.log(<span class=\"hljs-string\">\"——结束——\"</span>);\n  console.log(count);\n  console.log(str);\n\n  // Console：——结束——\n  // 1\n  // console.log(<span class=\"hljs-string\">\"Hello World！\"</span>);\n})\n// 读取失败\nfileReadStream.on(<span class=\"hljs-string\">'error'</span>, (error) => {\n  console.log(error);\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，我们通过 <code>fs</code> 模块的 <code>createReadStream</code> 创建了读取流，然后读取文件 <code>index.js</code>，从而最后在控制台输出了：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">1 接收到：259\n——结束——\n1\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 其中 <code>console.log()</code> 那三行就是 <code>index.js</code> 的文本内容。</p>\n<p> 然后，我们试下流的存入：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-built_in\">let</span> data = <span class=\"hljs-string\">'console.log(\"Hello World! 我要存入数据！\")'</span>;\n\n// 创建一个可以写入的流，写入到文件 index.js 中\n<span class=\"hljs-built_in\">let</span> writeStream = fs.createWriteStream(<span class=\"hljs-string\">'index.js'</span>);\n// 开始写入\nwriteStream.write(data, <span class=\"hljs-string\">'utf8'</span>);\n// 写入完成\nwriteStream.end();\nwriteStream.on(<span class=\"hljs-string\">'finish'</span>, () => {\n  console.log(<span class=\"hljs-string\">'写入完成！'</span>);\n  // Console：写入完成\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们打开 <code>index.js</code>，会发现里面的内容变成了 <code>console.log(\"Hello World! 我要存入数据！\")</code>，依次，我们通过流的形式进行了读取和写入的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-13\"><a id=\"chapter-three-eight\" name=\"chapter-three-eight\">3.8 创建 Web 服务器</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eight\">返回目录</a></p>\n</blockquote>\n<p> 在这里，我们利用 http 模块、url 模块、path 模块、fs 模块创建一个 Web 服务器。</p>\n<p> 什么是 Web 服务器？<br>\n Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。</p>\n<p> 下面，我们使用 Node 来创建一个 Web 服务：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db499027a9b6a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"240\" data-height=\"580\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\nhttp.createServer((req, res) => {\n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        \n        // 如果不存在这个文件\n        \n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(<span class=\"hljs-string\">'./08_WebService/404.html'</span>, (errorNotFound, dataNotFound) => {\n          <span class=\"hljs-keyword\">if</span>(errorNotFound) {\n            console.log(errorNotFound);\n          } <span class=\"hljs-keyword\">else</span> {\n            res.writeHead(200, {\n              <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n            });\n            // 读取写入文件\n            res.write(dataNotFound);\n            // 结束响应\n            res.end();\n          }\n        })\n        <span class=\"hljs-built_in\">return</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n\n        // 返回这个文件\n        \n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们在浏览器输入 <code>localhost:8080</code> 即可以看到：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db49cdf6207cf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1220\" data-height=\"1080\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，感情它就加载了整个 <code>index.html</code> 文件，连 CSS 这些没引入么？<br>\n 所以，下一步，我们要动态加载 <code>html</code>、<code>css</code> 以及 <code>js</code>：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  switch(extName) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.html'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.css'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/css'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.js'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/js'</span>;\n    default: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，当我们再次请求的时候，浏览器就变成了：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4a2ba76f9ad?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"720\"><figcaption></figcaption></figure><p></p>\n<p> 当然，在上面，我们仅仅模拟了 <code>html</code>、<code>css</code>、<code>js</code> 这三种文件类型而已，我们需要模拟更多的文件类型：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Fblob%2Fmaster%2FNodeBase%2F08_ext.json\" rel=\"nofollow noopener noreferrer\"> 08_ext.json</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> 代码详情请点击上面的链接\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的 <code>json</code> 文件中，我们定义了各种的文件类型，此刻文件目录如下所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4ab7f829e99?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"236\" data-height=\"422\"><figcaption></figcaption></figure><p></p>\n<p> 这时候，我们需要修改下我们的 <code>js</code> 文件，让它适应多种请求响应了：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n        console.log(ext);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  // <span class=\"hljs-built_in\">read</span>File 是异步操作，所以需要使用 <span class=\"hljs-built_in\">read</span>FileSync\n  <span class=\"hljs-built_in\">let</span> data = fs.readFileSync(<span class=\"hljs-string\">'./08_ext.json'</span>);\n  <span class=\"hljs-built_in\">let</span> ext = JSON.parse(data.toString());\n  <span class=\"hljs-built_in\">return</span> ext[extName];\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们做了个简单的 Web 服务器。</p>\n<h3 class=\"heading\" data-id=\"heading-14\"><a id=\"chapter-three-night\" name=\"chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-night\">返回目录</a></p>\n</blockquote>\n<p> Java、PHP 或者 .NET 等服务端语言，会为每一个客户端的连接创建一个新的线程。<br>\n Node 不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。<br>\n 当有用户连接了，就会触发一个内部事件，通过非租塞 I/O、事件驱动机制，让 Node 程序宏观上也是并行的。<br>\n 使用 Node，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。</p>\n<p> 在这一章节中，主要解决：</p>\n<ol>\n<li>Node 的非阻塞 I/O 是什么？</li>\n<li>Node events 模块是什么？</li>\n</ol>\n<p> 首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"2\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 2\n * 3\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 但是，事与愿违。<br>\n 我们有时候，会执行一些异步方法（函数）：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\n// console.log(<span class=\"hljs-string\">\"2\"</span>);\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    console.log(<span class=\"hljs-string\">\"2\"</span>);\n  })\n}\ngetExt();\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 3\n * 2\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面代码中，由于 <code>fs.readFile</code> 是 Node 的异步函数。所以，程序先执行了 1 和 3，最后才执行 <code>fs.readFile</code> 的 2 部分。</p>\n<blockquote>\n<p>在这里，可以看出 Node 不会因为一段代码的逻辑错误，从而导致其他代码无法运行。</p>\n</blockquote>\n<p> 这样子，就导致了一个问题：步骤 3 可能拿不到步骤 2 的执行结果了！这就是 Node 的非租塞性 I/O 驱动。<br>\n 那么，我们有没有办法解决这个问题呢？<br>\n 有的！</p>\n<ol>\n<li>通过回调函数</li>\n<li>通过 Node 的 <code>events</code> 模块</li>\n</ol>\n<p> 首先，我们通过回调函数来解决这个异步问题：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\ngetExt = (callback) => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    callback(data);\n  })  \n}\n\ngetExt( (result) => {\n  console.log(result.toString());\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过回调，我们可以将 <code>getExt</code> 的数据提取出来。</p>\n<p> 然后，我们通过 Node 的 <code>events</code> 模块来解决这个异步问题：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n/**\n * Node 事件循环：\n * 1. Node 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。\n * 2. Node 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。\n * 3. Node 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。\n */\n\n// 引入 events 模块\n<span class=\"hljs-built_in\">let</span> events = require(<span class=\"hljs-string\">\"events\"</span>);\n// 实例化事件对象\n<span class=\"hljs-built_in\">let</span> EventEmitter = new events.EventEmitter();\n\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    // 将 data 广播出去\n    EventEmitter.emit(<span class=\"hljs-string\">'data'</span>, data.toString());\n  })  \n};\n\ngetExt();\n\n// 监听 data\nEventEmitter.on(<span class=\"hljs-string\">'data'</span>, (ext) => {\n  console.log(ext);\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，<code>EventEmitter.on</code> 通过监听 <code>data</code> 的形式，获取了 <code>getExt</code> 内部的执行结果。<br>\n 如此，我们就了解了 Node 的 I/O 事件及 <code>events</code> 模块</p>\n<h3 class=\"heading\" data-id=\"heading-15\"><a id=\"chapter-three-ten\" name=\"chapter-three-ten\">3.10 get 与 post</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-ten\">返回目录</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4adefcf3363?imageslim\" data-width=\"970\" data-height=\"618\"><figcaption></figcaption></figure><p></p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 加载 http 模块\nvar http = require(<span class=\"hljs-string\">'http'</span>);\n\n// 虚拟 SQL 读取出来的数据\nvar items = [];\n\n// 创建 http 服务\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  \n  // 设置跨域的域名，* 代表允许任意域名跨域\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  // 判断请求\n  switch (req.method) {\n    \n    // post 请求时，浏览器会先发一次 options 请求，如果请求通过，则继续发送正式的 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'OPTIONS'</span>:\n      res.statusCode = 200;\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n    \n      // 如果是 get 请求，则直接返回 items 数组\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'GET'</span>:\n      <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n      res.write(data);\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n      \n    // 如果是 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'POST'</span>:\n      <span class=\"hljs-built_in\">let</span> item = <span class=\"hljs-string\">''</span>;\n      // 读取每次发送的数据\n      req.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n        item += chunk;\n      });\n      // 数据发送完成\n      req.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 存入\n        item = JSON.parse(item);\n        items.push(item.item);\n        // 将数据返回到客户端\n        <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n        res.write(data);\n        res.end();\n      });\n      <span class=\"hljs-built_in\">break</span>;\n  }\n}).listen(3000)\n\nconsole.log(<span class=\"hljs-string\">'http server is start...'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们加载了 <code>http</code> 模块，并创建了服务。<br>\n <strong>然后</strong>，我们设置了跨域的处理方式，允许进行跨域。<br>\n <strong>接着</strong>，我们进行了请求的判断处理，由于只做简单演练，故只判断是 <code>get</code> 请求还是 <code>post</code> 请求。<br>\n <strong>最后</strong>，我们将请求的结果返回给客户端。</p>\n<p> 在上面，我们进行了后端 Node 的部署，那么前端页面要怎么做呢？</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-⌃-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>Node Web</title>\n\n</head>\n\n<body>\n\n  <div id=<span class=\"hljs-string\">\"app\"</span>>\n    <h1>Todo List</h1>\n    <ul>\n      <li v-for=<span class=\"hljs-string\">\"(item, index) in items\"</span> :key=<span class=\"hljs-string\">\"index\"</span>>{{ item }}</li>\n    </ul>\n    <input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> v-model=<span class=\"hljs-string\">\"item\"</span>>\n    <button @click=<span class=\"hljs-string\">\"postApi\"</span>>添加</button>\n  </div>\n\n  <!-- cdn 引用：Vue 和 Node -->\n  <script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"https://unpkg.com/axios/dist/axios.min.js\"</span>></script>\n  \n  <script>\n    new Vue({\n      el: document.getElementById(<span class=\"hljs-string\">'app'</span>),\n      data: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        <span class=\"hljs-built_in\">return</span> {\n          items: [],\n          item: <span class=\"hljs-string\">''</span>,\n        }\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-title\">created</span></span>() {\n        // 进入页面请求数据\n        axios.get(<span class=\"hljs-string\">'http://localhost:3000/'</span>).then(res => {\n          console.log(<span class=\"hljs-string\">\"\\n【API - get 数据】\"</span>);\n          console.log(res);\n          this.items = res.data;\n        }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err)\n        })\n      },\n      methods: {\n        // 点击按钮提交数据\n        <span class=\"hljs-function\"><span class=\"hljs-title\">postApi</span></span>() {\n          axios.post(<span class=\"hljs-string\">'http://localhost:3000/'</span>, {\n            item: this.item\n          }).then(res => {\n            console.log(<span class=\"hljs-string\">\"\\n【API - post 数据】\"</span>)\n            console.log(res);\n            this.items = res.data;\n          }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err)\n          })\n        }\n      }\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们通过 Vue 进行了布局，通过 Axios 进行了接口的请求。从而完成了对数据的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-16\"><a id=\"chapter-three-eleven\" name=\"chapter-three-eleven\">3.11 Node 连接 MySQL</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eleven\">返回目录</a></p>\n</blockquote>\n<blockquote>\n<p>关于 MySQL 的安装，可以查看 <strong>jsliang</strong> 写的：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">MySQL 安装及图形化工具</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们通过可视化工具进行表的设计：</p>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>age</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>然后</strong>，我们进行表的填充：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>jslliang</td>\n<td>23</td>\n</tr>\n<tr>\n<td>2</td>\n<td>梁峻荣</td>\n<td>23</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>接着</strong>，我们安装 Node 连接 MySQL 的包：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm i mysql -D\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>再来</strong>，我们编写 Node 的 <code>index.js</code>：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\nconnection.query(<span class=\"hljs-string\">'SELECT * FROM user'</span>, <span class=\"hljs-keyword\">function</span> (error, results, fields) {\n  <span class=\"hljs-keyword\">if</span> (error) throw error;\n  console.log(results);\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，打开该服务：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[ RowDataPacket { id: 1, name: <span class=\"hljs-string\">'jsliang'</span>, age: <span class=\"hljs-string\">'23'</span> },\n  RowDataPacket { id: 2, name: <span class=\"hljs-string\">'梁峻荣'</span>, age: <span class=\"hljs-string\">'23'</span> } ]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们便完成了 Node 连接 MySQL。</p>\n<p> ———————华丽分割线———————</p>\n<p> 当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。</p>\n<p> 先看目录：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b034ab5dc8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"178\" data-height=\"261\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>新增表字段</strong></li>\n</ul>\n<blockquote>\n<p>add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\n<span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(id,name,age) VALUES(0,?,?)\"</span>;\n<span class=\"hljs-built_in\">let</span> addSqlParams = [<span class=\"hljs-string\">\"jsliang\"</span>, <span class=\"hljs-string\">\"23\"</span>];\n\nconnection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"新增成功：\"</span>);\n    console.log(res);\n  }\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们只需要直接 <code>node add.js</code>，就能往数据库中新增数据了。</p>\n<ul>\n<li><strong>删除表字段</strong></li>\n</ul>\n<blockquote>\n<p>delete.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\nvar delSql = <span class=\"hljs-string\">'DELETE FROM user where id = 2'</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(delSql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"删除错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"删除成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>修改表字段</strong></li>\n</ul>\n<blockquote>\n<p>update.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> updateSql = <span class=\"hljs-string\">\"UPDATE user SET name = ?,age = ? WHERE Id = ?\"</span>;\n<span class=\"hljs-built_in\">let</span> updateSqlParams = [<span class=\"hljs-string\">\"LiangJunrong\"</span>, <span class=\"hljs-string\">\"23\"</span>, 1];\n\n// 连接 SQL 并实施语句\nconnection.query(updateSql, updateSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"修改错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"修改成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>查询表字段</strong></li>\n</ul>\n<blockquote>\n<p>read.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) throw err;\n  console.log(res);\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 以上，我们打通了 Node 与 MySQL 的壁垒，实现了数据的增删改查。</p>\n<h2 class=\"heading\" data-id=\"heading-17\"><a id=\"chapter-four\" name=\"chapter-four\">四 Web 实战 —— 企业官网</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-four\">返回目录</a></p>\n</blockquote>\n<p> 在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo 制作、ico 制作、icon 挑选等……</p>\n<p> 下面这些都是 <strong>jsliang</strong> 平时碰到的，小伙伴有需要的可以 mark 啦~</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.uugai.com%2Flogoa%2Fwenzi.php\" rel=\"nofollow noopener noreferrer\">logo 制作</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.bitbug.net%2F\" rel=\"nofollow noopener noreferrer\">ico 制作</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.iconfont.cn%2Fhome%2Findex\" rel=\"nofollow noopener noreferrer\">icon 挑选</a></li>\n</ul>\n<p> 另外，由于 HTML 与 CSS 没什么好讲的，所以本章节的前提静态页面 <strong>jsliang</strong> 已经写好了，小伙伴们在学习前可以预先下载：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">本文静态页面代码地址</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-18\"><a id=\"chapter-four-one\" name=\"chapter-four-one\">4.1 编程环境</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-one\">返回目录</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们查看下我们的前端基本代码：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">地址</a></p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b22a71f82d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1010\" data-height=\"340\"><figcaption></figcaption></figure><p></p>\n<p> 如上，我们仅需要了解 FrontEndCode 目录以及 NodeWeb 目录即可，其他目录为上面章节练习参考。</p>\n<p> <strong>然后</strong>，我们进行后端功能分析：</p>\n<ol>\n<li>留言板。用户点击 <strong>留言板</strong> 的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到 <strong>登录页</strong>；如果用户登录了，则显示 <strong>留言板页面</strong>。</li>\n</ol>\n<p> 在 <strong>留言板页面</strong> 中，存在两个接口：</p>\n<ul>\n<li><strong>获取留言内容</strong>：调取 <code>getMessage</code> 接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。</li>\n<li><strong>提交留言内容</strong>：调取 <code>sendMessage</code> 接口，将用户名、用户 id、留言内容发送给后端。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b629555859?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1219\" data-height=\"828\"><figcaption></figcaption></figure><p></p>\n<ol start=\"2\">\n<li>在 <strong>登录页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>登录</strong>：调取 <code>login</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4eac593083f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1180\" data-height=\"810\"><figcaption></figcaption></figure><p></p>\n<ol start=\"3\">\n<li>在 <strong>注册页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>注册</strong>：调取 <code>register</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db50d7d913be2?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1200\" data-height=\"800\"><figcaption></figcaption></figure><p></p>\n<p> 由此，我们可以设计下前后端的接口结合：</p>\n<blockquote>\n<p>接口文档</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>类型</th>\n<th>参数</th>\n<th>返回信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getMessage</code>：获取留言信息</td>\n<td>get</td>\n<td>无参</td>\n<td>n 条记录：id(用户 id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间)</td>\n</tr>\n<tr>\n<td><code>sendMessage</code>：提交留言信息</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_message(用户留言内容)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>login</code>：登录</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>register</code>：注册</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>最后</strong>，我们进行 MySQL 数据库的表设计：</p>\n<blockquote>\n<p>user 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_password</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>message 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_message</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>varchar</td>\n<td>255</td>\n<td>外键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-19\"><a id=\"chapter-four-two\" name=\"chapter-four-two\">4.2 后端接口</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-two\">返回目录</a></p>\n</blockquote>\n<p> 在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个 <code>test</code> 文件夹，里面放一个 <code>index.html</code> 以及一个 <code>index.js</code> 来测试一下。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">- text\n - index.html\n - index.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们就 4.1 提到的接口，提前进行后端接口的设置：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL：先安装 npm i mysql -D\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'nodebase'</span>\n});\n// 开始连接\nconnection.connect();\n\n// 引入 http 模块：http 是提供 Web 服务的基础\nconst http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 url 模块：url 是对用户提交的路径进行解析\nconst url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 qs 模块：qs 是对路径进行 json 化或者将 json 转换为 string 路径\nconst qs = require(<span class=\"hljs-string\">\"querystring\"</span>);\n\n// 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 设置 cors 跨域\n  res.setHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"hljs-string\">\"*\"</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"POST\"</span>) { // 接口 POST 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【POST 形式】\"</span>);\n\n    // 获取前端发来的路由地址\n    <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    // 接收发送过来的参数\n    <span class=\"hljs-built_in\">let</span> tempResult = <span class=\"hljs-string\">\"\"</span>;\n\n    // 数据接入中\n    req.addListener(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n      tempResult += chunk;\n    });\n\n    // 数据接收完成\n    req.addListener(<span class=\"hljs-string\">\"end\"</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n      var result = JSON.stringify(qs.parse(tempResult));\n      console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n      console.log(result);\n\n      <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n      }\n      // 接口信息处理完毕\n    })\n    // 数据接收完毕\n\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"GET\"</span>) { // 接口 GET 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【GET 形式】\"</span>);\n\n    // 解析 url 接口\n    <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n      console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n      res.writeHead(200, {\n        <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n      });\n\n      res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n      res.end();\n    }\n\n  }\n\n}).listen(8888); // 监听的端口\n\n// 获取当前时间\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getNowFormatDate</span></span>() {\n  var date = new Date();\n  var year = date.getFullYear(); // 年\n  var month = date.getMonth() + 1; // 月\n  var strDate = date.getDate(); // 日\n  var hour = date.getHours(); // 时\n  var minute = date.getMinutes(); // 分\n  var second = date.getMinutes(); // 秒\n  <span class=\"hljs-keyword\">if</span> (month >= 1 && month <= 9) {\n    month = <span class=\"hljs-string\">\"0\"</span> + month;\n  }\n  <span class=\"hljs-keyword\">if</span> (strDate >= 0 && strDate <= 9) {\n    strDate = <span class=\"hljs-string\">\"0\"</span> + strDate;\n  }\n  // 返回 yyyy-mm-dd hh:mm:ss 形式\n  var currentdate = year + <span class=\"hljs-string\">\"-\"</span> + month + <span class=\"hljs-string\">\"-\"</span> + strDate + <span class=\"hljs-string\">\" \"</span> + hour + <span class=\"hljs-string\">\":\"</span> + minute + <span class=\"hljs-string\">\":\"</span> + second;\n  <span class=\"hljs-built_in\">return</span> currentdate;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过判断 <code>req.method</code> 属于 <code>GET</code> 还是 <code>POST</code> 形式，从而确定加载的接口：</p>\n<ul>\n<li>在 <code>POST</code> 中，判断是属于 <strong>提交留言信息</strong>、<strong>登录</strong> 还是 <strong>注册</strong>；</li>\n<li>在 <code>GET</code> 中，判断是不是 <strong>获取留言信息</strong>。</li>\n</ul>\n<p> <strong>同时</strong>，我们在其中定义了 MySQL 的连接以及一个 <code>getNowFormatDate</code> 用来获取当前时间，格式为：<code>2018-12-21 10:03:59</code></p>\n<p> <strong>然后</strong>，我们通过一个前端页面来演示我们的接口是否能使用：</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>演示代码</title>\n</head>\n\n<body>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"user\"</span>>用户名</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> id=<span class=\"hljs-string\">\"user\"</span>>\n  </div>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"password\"</span>>密&nbsp;&nbsp;&nbsp;码</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"password\"</span> id=<span class=\"hljs-string\">\"password\"</span>>\n  </div>\n  <div>\n    <button id=<span class=\"hljs-string\">\"register\"</span>>注册</button>\n  </div>\n\n  <script src=<span class=\"hljs-string\">\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      // 测试 get 接口\n      $.ajax({\n        url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n        <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n        data: {\n          username: <span class=\"hljs-string\">\"jsliang\"</span>\n        },\n        success: <span class=\"hljs-keyword\">function</span> (res) {\n          console.log(res);\n        },\n        error: <span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err);\n        }\n      })\n\n      $(<span class=\"hljs-string\">\"#register\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 测试 post 接口\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n          data: {\n            username: $(<span class=\"hljs-string\">\"#user\"</span>).val(),\n            password: $(<span class=\"hljs-string\">\"#password\"</span>).val()\n          },\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      })\n    });\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，并打开 <code>index.html</code>，通过 <code>F12</code> 控制台查看我们的接口是否正常：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db510727a4435?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"684\" data-height=\"662\"><figcaption></figcaption></figure><p></p>\n<p> 可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这 4 个接口的设计了。</p>\n<blockquote>\n<p>如果小伙伴们觉得每次更新 Node 代码后，又要重启一遍 <code>node index.js</code> 觉得麻烦，可以通过 <code>supervisor</code> 来监听 Node 代码的改动，<code>supervisor</code> 的安装使用：<a href=\"#chapter-five-one\">supervisor</a></p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-20\"></h3></div>",
      "time": "2018年12月23日"
    },
    {
      "source": "juejin",
      "id": "am5jwslyxv4",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/592ed10a2f301e00571966b2\"><meta itemprop=\"headline\" content=\"Node 爬虫入门\"><meta itemprop=\"keywords\" content=\"Node.js\"><meta itemprop=\"datePublished\" content=\"2017-05-31T14:31:12.820Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"小虫巨蟹\"><meta itemprop=\"url\" content=\"https://juejin.im/user/590842f0b123db3ee49105bb\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/592ed10a2f301e00571966b2\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/592ed10a2f301e00571966b2\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2017-05-31T14:31:12.820Z\" title=\"Wed May 31 2017 22:31:12 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2017年05月31日</time><span class=\"views-count\" data-v-648672b2>阅读 8730</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node 爬虫入门</h1><div data-id=\"592ed3b00ce463006b558c2a\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><blockquote>\n<p>边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章<br>为了验证“<strong><em>简书上，经验总结、资料归集类技术文章更容易上热榜</em></strong>”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的文章如果不是资料归集的话，多半就属于谈源码实现的了）</p>\n</blockquote>\n<h2 id=\"-\" data-id=\"heading-0\">目录</h2>\n<ul>\n<li><a href=\"#1\" target=\"_blank\">知识点</a></li>\n<li><a href=\"#2\" target=\"_blank\">实现步骤</a><ul>\n<li><a href=\"#2.1\" target=\"_blank\">拉取页面列表</a></li>\n<li><a href=\"#2.2\" target=\"_blank\">拉取页面详情，分析统计</a></li>\n<li><a href=\"#2.3\" target=\"_blank\">生成统计页面</a></li>\n</ul>\n</li>\n<li><a href=\"#3\" target=\"_blank\">总结</a></li>\n</ul>\n<p></p><h2 id=\"1\" data-id=\"heading-1\">知识点</h2><p></p>\n<ol>\n<li>http.request：node http 模块的request方法可以作为http client向服务器发起http请求，爬虫需要向目标链接发起http请求来获得页面信息</li>\n<li>cheerio：通过 http 请求到的页面信息，由于缺乏浏览器的dom解析，看起来就是一段凌乱的字符串，实在糟糕。好在我们可以使用 cheerio 库将其解析为 dom ，这样我们就可以使用类似 jquery 的语法去分析页面信息</li>\n<li>promise：由于 node 单线程的特性，不可避免的需要用到大量异步编程的写法，层层嵌套的回调写法已经 low 了，来试试 promise 的写法</li>\n</ol>\n<p></p><h2 id=\"2\" data-id=\"heading-2\">实现步骤</h2><p></p>\n<p></p><h3 id=\"2.1\" data-id=\"heading-3\">拉取页面列表</h3><br>首先需要拿到程序员专题热门列表的请求链接<p></p>\n<p></p><figure><img atr=\"列表链接\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/13a5acb99dd86163df80dfe5860acc45?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\"><figcaption>列表链接</figcaption></figure><p></p>\n<p>ajax请求，需要使用chrome dev tools，拉到底部还能加载更多：</p>\n<pre><code class=\"hljs javascript copyable\"><span class=\"hljs-comment\">//order_by=likes_count 表示按照热门进行排序</span>\n<span class=\"hljs-comment\">//page是分页参数，每页9条，我们可以通过改变page=0~100来拉取900篇文章</span>\nhttp:<span class=\"hljs-comment\">//www.jianshu.com/collections/16/notes?order_by=likes_count&page=2</span><span class=\"copy-code-btn\">复制代码</span></code></pre><p>下一步通过这个链接拉取列表数据</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     - 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com/collections/16/notes?order_by=likes_count&page='</span> + i,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                resolve(data);\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以创建一个promise对象来发起request请求（request的封装就不贴出来了，实验证明，代码块太多的文章不容易上热榜~~）</p>\n<p>起初我的做法是同时创建拉取1~100页数据的100个promise对象，同时异步的发起100个request请求，然而这样的做法会有几十个请求请求失败（兴许是简书那边做了限制），所以，还是耐心点，每次发起5个请求，直到100页都请求成功</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 递归的请求，每次并发的请求5个\n     */</span>\n    Seek.prototype.seek = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n        times++;\n        <span class=\"hljs-keyword\">var</span> ot = times;\n        <span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-built_in\">Promise</span>.all([\n            self.createPromise(times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times)\n        ]);\n        promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">result</span>) </span>{\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"seekList totals:\"</span> + times);\n            pages = pages.concat(result);\n            <span class=\"hljs-keyword\">if</span> (times < totalPage) {\n                self.seek(callback);\n            } <span class=\"hljs-keyword\">else</span> {\n                callback(pages);\n            }\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p>拿到所有的列表数据之后，就可以使用cheerio库来分析列表页面，抓取文章详情链接(在这一步之前你同样需要使用chrome dev tools工具分析页面结构)</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 使用cheerio载入列表页面\n     */</span>\n    Analyse.prototype.load = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, i</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n            <span class=\"hljs-keyword\">var</span> pages = [];\n            <span class=\"hljs-keyword\">var</span> els = $(<span class=\"hljs-string\">'.article-list li'</span>);\n            <span class=\"hljs-keyword\">if</span>(els.length === <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'load error page:'</span> + i );\n                resolve([]);\n            }\n            els.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">index</span>) </span>{\n                <span class=\"hljs-keyword\">if</span> ($(<span class=\"hljs-keyword\">this</span>).attr(<span class=\"hljs-string\">'class'</span>) === <span class=\"hljs-string\">'have-img'</span>) {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                } <span class=\"hljs-keyword\">else</span> {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'div'</span>).children(<span class=\"hljs-string\">'.title'</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                }\n\n                <span class=\"hljs-keyword\">if</span>(index === els.length - <span class=\"hljs-number\">1</span>) {\n                    resolve(pages);\n                }\n            });\n        });\n\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><h3 id=\"2.2\" data-id=\"heading-4\">拉取页面详情，分析统计</h3><br>从上一步中拿到900篇热门文章的地址之后，需要再次去抓取文章详情页面，同样的每次查5篇，使用chrome dev tools分析得知，简书文章的代码块使用的都是<code><code></code></code>标签，统计此标签出现的数量就可以了<p></p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">url</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com'</span> + url,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n                <span class=\"hljs-comment\">//页面标题</span>\n                <span class=\"hljs-keyword\">var</span> title = $(<span class=\"hljs-string\">'h1.title'</span>).text();\n                <span class=\"hljs-comment\">//代码块数量</span>\n                <span class=\"hljs-keyword\">var</span> codes = $(<span class=\"hljs-string\">'code'</span>).length;\n                <span class=\"hljs-keyword\">if</span>(codes === <span class=\"hljs-number\">0</span>) {<span class=\"hljs-comment\">//代码块为0的总数</span>\n                    zeroCount++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">10</span>) {<span class=\"hljs-comment\">//代码块为<=10的总数</span>\n                    oneToTen++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">20</span>) {<span class=\"hljs-comment\">//代码块<=20的总数</span>\n                    elToTwo++;\n                } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//代码块>20的总数</span>\n                    beyondTwo++;\n                }\n                resolve({\n                    <span class=\"hljs-attr\">title</span>: title,\n                    <span class=\"hljs-attr\">codes</span>: codes\n                });\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><h3 id=\"2.3\" data-id=\"heading-5\">生成统计页面</h3><br>数据总需要一个展示的地方，使用nunjucks作为页面模板，注入抓取到的数据，在使用echarts生成统计图表，就是这个feel，<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzengwenfu.github.io%2Fjian-analyse%2Fapp%2Fviews%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">结果页面</a><p></p>\n<p></p><figure><img atr=\"统计结果\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/8d76e15d56e4cd4328bc8428c77f7cdb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\"><figcaption>统计结果</figcaption></figure><p></p>\n<p></p><h3 id=\"3\" data-id=\"heading-6\">总结</h3><br>开发爬虫是一件很酷的事情，在这个过程中还能学到知识，提升学习兴趣，从爬虫做起~~<br><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzengwenfu%2Fjian-analyse\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">源码</a><p></p>\n<p><strong>下一篇文章讲 Node 爬虫进阶，敬请关注</strong></p>\n<blockquote>\n<p>补充说明：代码大半年前些的，简书的接口和页面结构已经做了改版，可能抓取不到想要的结果，如果感兴趣，可以按照思路和步骤改造现在的代码，自己动手丰衣足食</p>\n</blockquote>\n</div>",
      "time": "2017年05月31日"
    },
    {
      "source": "jianshu",
      "id": "4l6cs8xghli0",
      "content": "<p>亲爱的简书用户</p><p>「简书」因个别上传作品用户违反《中华人民共和国网络安全法》《互联网信息服务管理办法》《互联网新闻信息服务管理规定》《互联网用户公众账号信息服务管理规定》《移动互联网应用程序信息服务管理规定》等相关法律法规，平台审核不严，传播了违法违规信息，在此表示不安和歉意。根据主管部门要求，从2019年8月29日16时至9月28日16时，暂停所有用户发布功能，并对平台上内容进行全面彻底清理整顿。</p><p>「简书」致力于打造一个优质内容创作社区。为维护良好的社区氛围，希望所有用户自觉遵守<a href=\"https://www.jianshu.com/p/1011f0cdefee\" target=\"_blank\">《简书社区管理规则》</a>。所有简书用户均可以通过举报按钮对违反规则行为进行举报，「简书」也会按照规则对违规用户采取更改、锁定、删除用户发布的内容，暂停或终止用户使用简书产品的权利等措施，共同营造清朗的网络社区空间。</p>",
      "time": "2019.08.29 18:38:08"
    },
    {
      "source": "jianshu",
      "id": "6ts37rxvyzg0",
      "content": "<h4></h4><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.64%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"853\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3301720-db890fabf626e0ac.jpg\" data-original-width=\"1280\" data-original-height=\"853\" data-original-format data-original-filesize=\"837152\"></div>\n</div>\n<div class=\"image-caption\">图片发自简书App</div>\n</div><p><b>\n\n这是我的亲身经历，没有虚构，虽然它听起来不像真的。</b></p><hr><p>2017年11月7日  星期二 晴</p><p>说起来很惭愧，在简书写了一年的文，至今，我还是原来的我，既没有签约，也没有写出爆文，甚至连一篇像样点的、拿得出手的文字也没有。</p><p>相反，嘲笑和挖苦的话倒是听了不少。当面的，背后的，直接了当的，含沙射影的，比比皆是。</p><p>所有这些，都曾伤透了我的心，我苦恼、彷徨，为自己因为在简书写文而越来越不受人待见而痛苦不堪。</p><p>于是，我萌生了将简书卸载，从简书里逃跑的念头。</p><p>然而每每打开简书，却是万般的不舍和难离。我想按下删除键，但手指却不听使唤，还是习惯性地敲打出心中喜爱的文字——已然将自己的逃跑计划忘到脑后。</p><p>逃跑未成，只好硬着头皮往前走，这一走，竟走过了秋、冬、春、夏。</p><p>这一年，我的思绪，我的喜怒哀乐，都变成了一个叫<a href=\"https://www.jianshu.com/u/0aba71a90d02\" target=\"_blank\">陌上红裙</a>的简书用户笔端的文字。</p><p>尽管这些文字不华丽，不精美，没有内涵，没有深刻的寓意，但是，它们是我内心真情的表达。是一个打小就喜爱文字的女子对文字不渝的追随；是一个宁愿放弃美食，放弃聚会，放弃休闲度假的已过不惑之年的大妈的逆向选择。</p><p>这个选择，带给我的除了心灵的那份愉悦，从中确实再也找不出还有什么东西，可以让我自豪、可以让别人停止对我的鄙视。</p><p>我像一棵小草，在凛冽的寒风中，顽强地站立着，不敢趴下。</p><p>我知道，一旦趴下，我就再也无法在风中直起腰身。</p><p>很多个夜晚，很多个清晨，每一点的碎片时间，我都将自己置身于文字中。</p><p><b>结果会怎样？未来会怎样？全然不去考虑，我只告诉自己：为心中的那份愉悦，坚持！</b></p><p>万万没想到的是，简书一年后，我却得到了一个意外的收获——有好几家单位向我抛出了橄榄枝，好几个不错的岗位任我挑选。</p><p>这是我自2013年从国企下岗后，第一次被礼遇，第一次被当作“人才”而被多家单位争相聘请。</p><p>我听到有人愤愤不平地说：“哼！她居然成了香饽饽！”</p><p>“不就会写几篇文章么？”</p><p>……</p><p>此刻，我已离开小城巢湖，坐在省城一个装潢考究、环境优雅的写字楼里。</p><p>先进的办公设备，良好的工作氛围，一个富有朝气的团队，我荣幸地成为他们其中的一员。</p><p><b>没有后台，没有背景，如果有，那就是简书，还有我在简书上用真心书写的二十多万原创文字。</b></p><p>去年，也是这样的秋季，只是不似这般阳光明媚。连日的阴雨，让人愁肠百结……</p><p>土豆在长沙读大学，他爹经常出差，家里时常只剩下我一个人。</p><p>放心不下乡下年迈的父亲和破旧的老屋，我对他们的牵挂愈发浓烈，心中有千言万语想要说出来。</p><p>我写了一篇又一篇日记，可是，越写，越觉得孤独、难受。</p><p>直到那天，我误打误撞地闯进简书后，才发现，这里，才是写作人的“理想王国”。</p><p>“简单书写！”我喜欢简书的这个宣传语。</p><p>没有功利，没有企求，只求简简单单地将自己的真实感受写出来，写出一个热爱文字的人的点点滴滴。</p><p>对故乡的思念，是我初入简书时急于想表达的情感。</p><p>其时，我的九旬老父亲还健在，每次回乡下，我都会坐在他老人家身边，听他讲过去的事情。</p><p>天气好的时候，我会陪着父亲在村里转转。</p><p>一个个或苍老或弱小的身影从我的身边走过，我努力想认出他们，却怎么也想不起来他们是谁。</p><p>村里那些曾经光彩夺目的小洋楼，在岁月的风雨中变得黯然失色，好多人家的门前，杂草丛生，院落荒芜，门上的铁锁已锈迹斑斑……</p><p>回到城里，心情久久不能平静的我，写下了《故乡的回忆》系列。平淡的文字，灼热的情感，有很多简友为我点赞，我不知道是否真的感动了他们，但他们的鼓励却给了我莫大的鼓舞，我有了写下去的动力。</p><p>刚开始，我只有零星的几位简友，记得最早关注我的是<a href=\"https://www.jianshu.com/u/fe3ba6ead306\" target=\"_blank\">铁妩</a>、<a href=\"https://www.jianshu.com/u/71cc10acdae2\" target=\"_blank\">小豆利子</a>、<a href=\"https://www.jianshu.com/u/c9372cacba1d\" target=\"_blank\">高桥美纱</a>、<a href=\"https://www.jianshu.com/u/b627ac0f93b4\" target=\"_blank\">红尘老街</a>、<a href=\"https://www.jianshu.com/u/a75ad8b244e6\" target=\"_blank\">残阳物语</a><a href=\"https://www.jianshu.com/u/b5cc6f248eac\" target=\"_blank\">、</a><a href=\"https://www.jianshu.com/u/b5cc6f248eac\" target=\"_blank\">金源涛、</a><a href=\"https://www.jianshu.com/u/fd696af052d4\" target=\"_blank\">寻找梦想的鱼</a>等兄弟姐妹。</p><p>还有一位和我家土豆同龄的东北女孩<a href=\"https://www.jianshu.com/u/59c141c586ef\" target=\"_blank\">小猪子499</a>，她是我在简书上的第一个读者，第一个给我留言的人，我们成了忘年交，她一直亲热地叫我“红裙阿姨”。</p><p>凭良心说，我那时的文字比现在还要拙劣，但他们没有嫌弃我，反而给予我很多的夸奖，有时也真诚地提出批评。我能走到今天，与他们的鼓励和支持是分不开的。</p><p>无知者无畏，那时，凭着对文字的热爱，对简书的喜欢，各个专题的征文我都参加。我不敢奢望获奖，只把它们当成一篇篇命题作文，力求不偏题，倘若偶尔能有写出彩的则更好。</p><p>那段时间，可谓是我创作热情最高的时期，也是我连连获奖的时期（捂脸——大都数是三等奖，有的还是优秀奖）。</p><p>我的简友越来越多（下一篇我专门写我的简友们，题目都想好了）。简友们都叫我“红裙子”，我也喜欢他们这样叫我，他们说我是简书里的一条快乐的红裙子。</p><p>我的快乐来自于简书，只要走进简书，我的烦恼就会消失，我的脸上就会春风荡漾。</p><p>可现实生活中，我的处境非常不好。</p><p>冷落、排挤、各种风凉话，铺天盖地地向我袭来，我只有招架的功，没有还手的力，我成了熟人们茶余饭后的“谈资”。</p><p>很多人在朋友圈将我屏蔽，有的人甚至拉黑了我，原因是不想读到我发在朋友圈的文字。</p><p>我成了一个尴尬的人，随时随地、毫无征兆地就会遭到别人的讥讽，而这一切，竟然是因为我比他们会写几篇“文章”。</p><p>今年6月份的时候，因为要照顾和陪伴生命垂危的老父亲，我辞职离开了原先那个不待见我的单位和那些不待见我的人。</p><p>父亲最后的日子，我日夜守护在他的身边，和我共同守护的，除了我的兄妹，还有我最爱的简书。</p><p>乡下的夜，静谧、漫长，父亲的气息越来越弱，我的文字也越来越低沉……</p><p>父亲安详地离去了……那个给我关爱最多，对我一生影响最大的人，从此成了我遥不可及的思念，我们兄妹悲痛欲绝。</p><p>我一遍又一遍地回看我以前写的关于父亲的文字，从今往后，我将不忍再写，我不想让痛失父亲的悲伤席卷我……</p><p><b>感谢简书，让我在我父亲健在的日子，用文字表达了我对他老人家的崇敬和爱！</b></p><p>处理好父亲的后事，我伤心地离开了那个叫“马颈”的小山村，回到城里的我，再度成了一个失业人员。</p><p>转机却从这里开始。</p><p>回到家后，陆续接到很多电话，都是邀请我去上班的，他们的缘由是：</p><p>“我们需要一个会写文章的财务人员！”</p><p>“一个能写出那么多感人至深的文章的人，人品一定不会差！”</p><p>“你的文笔很美，我们公司欢迎你！”</p><p>“您好，我们是中小学辅导班，拜读了您在简书上发表的文章，想请您来教孩子们写作文……您可以兼职，也可以专职……”</p><p>……</p><p>我诚惶诚恐地接着每一个电话，感觉是幻觉，又觉得是奇迹。</p><p>又一次打开简书，心头涌起了无限的感慨：一年来，我的那些个“文章”，不知引来了多少人的口诛笔伐，他们用最恶毒的词语贬低我，说我是“神经病”……</p><p>他们那刺耳的、不怀好意的笑声，仍在我的耳边回荡……</p><p>可是，现在一下子却有这么多好岗位等着我，这是怎么回事呢？</p><p>我有点懵，傻乎乎地问电话那端的人，那端传来一个个热情的、坚定的声音：“我们公司欢迎您！”</p><p>稳定了一下既惊喜又慌乱的情绪，在众多的邀请单位里，我选择了现在就职的这家公司，我要继续往前远行。</p><p>远方有多远，我不知道，但眼前的路已渐渐趋于平坦，虽然依旧没有鲜花，没有掌声，只有我未变的初心和对文字永远的热爱！</p><hr><p>我是陌上红裙，感谢简书，感谢你！</p>",
      "time": "2017.11.07 22:00:25"
    },
    {
      "source": "jianshu",
      "id": "6bmok4soebs0",
      "content": "<p>翻看文集，才发现来到简书已经一年了。</p><p>第一篇文章发表与2017年7月24日，从那时起，我便开始了在简书定期写作更新的历程。至今总共发布了一百多篇文章，除去被我隐藏的文章，累计字数十七万字，积累粉丝近六万。在这段写作的过程里，我成为了旅行专题板块的“旅行达人”，开通了付费连载<b><a href=\"https://www.jianshu.com/nb/15153544\" target=\"_blank\">《远行·西藏》</a>，</b>还获得了简书版权中心的签约机会。</p><p>记得有一部讲西藏的影片《冈仁波齐》很是火了一段时间，跟着一起火的还有这么一句话：人生没有白走的路，每一步都算数。</p><p>事实的确如此。写作的时候只要抱着尽力写好每一句话的念头去写就是了，相信一路坚持下来，终会收获属于自己的果实。</p><p>在简书写作一年以后，我出版了人生第一本书：<b>《远行·西藏》</b>。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 588px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 84.11%;\"></div>\n<div class=\"image-view\" data-width=\"1561\" data-height=\"1313\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-16bd31b30bff0a71.png\" data-original-width=\"1561\" data-original-height=\"1313\" data-original-format=\"image/png\" data-original-filesize=\"2215265\" data-image-index=\"0\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><h1>如何出版一本书？</h1><p>书出版以后，很多朋友纷纷问我：“要怎样才能出一本书啊？”今天就这个话题来说一说我的体会。</p><blockquote><p><b>量变成就质变</b></p></blockquote><p>对于想知道如何出版一本书的朋友，我通常都会回答他们：“首先你要有可以出版的素材啊。”</p><p>这看起来是个没什么用的答案，但实际上却往往切中要害。因为很多人都还没开始写，就在想着怎么出版。</p><p>虽然说不想当将军的士兵不是好兵，不想出书的写作者也不会是个好的写作者。可是，量的积累是不可或缺的。如果你想出版一本小说，那么至少要有过一段创作经历，而且已经有一定量的小说积累了。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 678px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 96.93%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"727\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-74e7905bac163446.jpeg\" data-original-width=\"750\" data-original-height=\"727\" data-original-format=\"image/jpeg\" data-original-filesize=\"180030\" data-image-index=\"1\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p>我的写作是从记录自己的旅行见闻开始的。实际上，在来到简书之前我已经在自己的公众号写作了将近一年。简书上的文章很多都是我在原有基础上二次修改重新发布的。</p><p>当时写下这些文字，虽然也抱着有一天能出版成书的梦想，但更多还是想着怎样把每一篇文章写好。或许，对于那时的我来说，出书还是一件遥不可及的事吧。</p><p>所以，如果你想知道怎么才能出书，不妨先看看自己已经写了多少字，更了多少篇文。因为没有量的积累，就不会有质的突变。</p><blockquote><p><b>确定一个方向，深耕细作</b></p></blockquote><p>对不少人来说，写作是一种乐趣，写作是一种放松的方式，或者写作是一种习惯。但如果是要出书，那么写作就应该是一个目标。</p><p>为了这个目标，你要确定什么衡量文字的标准，什么是好文章，什么只是普通文字？更重要的是，你要为自己确立一个方向，是虚构还是非虚构？是游记还是散文？是小说还是剧本？</p><p>一旦确定了写作方向，就要在这方面持续地努力，专注地对这一类型的文章反复练习。只有这样集中火力朝一个方向深挖，才是最有效率也最能太高写作能力的。</p><p>有人今天写写鸡汤文章，过两天又改写小说，写着写着又跑去写散文，这样的写法就像猴子摘玉米，一边摘一边掉，最后手里一个都没有。</p><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 527px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 70.83%;\"></div>\n<div class=\"image-view\" data-width=\"744\" data-height=\"527\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-361c20e22b995bfc.jpeg\" data-original-width=\"744\" data-original-height=\"527\" data-original-format=\"image/jpeg\" data-original-filesize=\"182255\" data-image-index=\"2\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><blockquote><p><b>找到你的个人风格</b></p></blockquote><p>对于每一个热爱写作的人来说，这是最好的时代，但也可能是最坏的时代。</p><p>说是最好的时代，是因为网络媒体的发达，为每个人都提供了表达自我的平台。自己写出的文字，想要让更多人看到，变得比以往任何时候都容易了。</p><p>然而，这样便利发达的自媒体时代，也导致了文字泛滥，声音刚一发出便淹没在洪流中。因此，想要让自己的文字出版成书，个人的特色就变得至关重要了。</p><p>简单直白地说，就是你写的东西要跟别人的不一样。这种不一样，可以是文字风格，可以是题材内容，也可以是主题的选择。总之，只有与众不同才会被人注意到，并且留下印象。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 687px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 91.60000000000001%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"687\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-736c738bece6ed6c.jpeg\" data-original-width=\"750\" data-original-height=\"687\" data-original-format=\"image/jpeg\" data-original-filesize=\"212585\" data-image-index=\"3\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><blockquote><p><b>写公号文≠出书</b></p></blockquote><p>在考虑朝出版书籍方向努力之前，你首先需要弄清楚的就是文字发表的各种形式之间的区别。</p><p>图书、报纸、杂志、公众号，不同的形式对文章的要求也不一样。以现在最火热的公号文为例，要求对热点反应迅速，语言富有煽动性，要么就要搞笑有趣，善于吐槽。这类文章的寿命大多不长，发布二十四小时后基本也就被遗忘了。</p><p>而图书这一形态，则要求文章要具有一定的深度和整体性。这里并不是对二者作孰优孰劣的比较，而是客观列出它们各自的特点。</p><p>公号文讲究的就是一个时效性，因为碎片阅读的特性决定了，人们只会花几分钟甚至几秒钟快速地掠过。而书籍要求的是比较专注的阅读，相对而言这更花时间，也更费力，因为读者一边读还会一边进行思考。</p><p>明白了这些不同形态的区别，你自然就知道怎样的文字能够出版成书，而什么样的文字只适合发表在网络平台上。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 346px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 46.19%;\"></div>\n<div class=\"image-view\" data-width=\"749\" data-height=\"346\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5303650-80894cc52c17faf1.jpeg\" data-original-width=\"749\" data-original-height=\"346\" data-original-format=\"image/jpeg\" data-original-filesize=\"121691\" data-image-index=\"4\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p>除了以上这些经验之谈，还有很重要的一点，当然就是要选择一个优质的平台，和一个专业的出版经理人。</p><p>关于这一点，我要再次感谢简书。自从简书版权中心的<a href=\"https://www.jianshu.com/u/d562831f4171\" target=\"_blank\">Ric庆余</a>跟我谈过签约的事宜后，接下来的操作细节我就再也没有操心过，从找出版社到签合同到最终到最终出版，一切都有条不紊地进行着。这对于创作者来说简直是个福音，因为你只需要专心写作就可以了，其余的事都可以放心地交由版权中心来帮你处理。</p><p>接下来，我还会在简书继续更文，继续写作，争取有新的作品能够出版问世。</p><p>找到一条属于自己的道路不容易，让我们不忘初心，砥砺前行。</p><blockquote>\n<p><b>关于新书的相关链接：</b></p>\n<p><a href=\"https://www.jianshu.com/p/0c58db0aee19\" target=\"_blank\"><b>带着速写本去西藏，一段边走边画的旅行——简书作者肉丝新书《远行·西藏》上市</b></a></p>\n</blockquote>",
      "time": "2018.08.29 17:18:47"
    },
    {
      "source": "jianshu",
      "id": "5qgyq7eweog0",
      "content": "<p>二十岁出头，正好处在一个尴尬的年纪。似乎看透了生活，实质却依旧单纯；似乎应有尽有，实质却一无所有；内心身怀雄心壮志，却又不得不脚踏实地。<br></p><p><b>身处二十岁这个尴尬的年龄，确实会有些迷茫，也会有些无奈。但是每当背起行囊的那一刻，我就明白有些事情现在不去做，再也不会去做了。</b></p><p>有人经常会问我，你认为旅行的意义是什么？你在路上都做什么？<br></p><p>我不能告诉你旅行的意义是什么，或许旅行本身就没有意义。不过既然有人问后面一个问题，那我借此机会来分享下我在旅途中经常会做的十件事。</p><p>因为，我觉得这些都是到八十岁之后想起来都会笑的事情。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 597px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 63.99%;\"></div>\n<div class=\"image-view\" data-width=\"933\" data-height=\"597\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-fdf30bf7e301a6e9.jpg\" data-original-width=\"933\" data-original-height=\"597\" data-original-format=\"image/jpeg\" data-original-filesize=\"183902\" data-image-index=\"0\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">《庆幸可以在旅途中遇见》</div>\n</div><p>                        旅 途 中 的 十 件 事 情</p><p><b>01、走很远很远</b><b>的路</b></p><p>每次去旅行，走路大概是必须的一件事。比起去那些到哪都在路上伸手拦出租车，然后和这个城市擦肩而过的方式，我还是更喜欢用自己的双脚去丈量这个世界。</p><p>曾二十八天徒搭于广袤无垠的西藏，也穿越在神秘色彩的鳌太，还行走于美丽的大西北这片炙热的土地上。</p><p>或者漫步在一个城市的街道上，感受一个城市和其它地方不一样的氛围。只有这样从容的方式才有机会撞见不同的人，去发现发生在身边意外的惊喜。</p><p><b>用自己的脚步去行走，这样可以在想停下来的时候停下来，也可以兴奋的想要奔跑时也能随时狂欢。</b></p><p><b>然后，我会把每一天走的步数都捐出去。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 69.57%;\"></div>\n<div class=\"image-view\" data-width=\"920\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1fdafb80f75908a4.jpg\" data-original-width=\"920\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"123515\" data-image-index=\"1\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">一条路</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 400px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"400\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e0947c5d9b0c555a.jpg\" data-original-width=\"600\" data-original-height=\"400\" data-original-format=\"image/jpeg\" data-original-filesize=\"87884\" data-image-index=\"2\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">出发，在路上</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.12%;\"></div>\n<div class=\"image-view\" data-width=\"852\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-54ca4c10fe17d0a0.jpg\" data-original-width=\"852\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"102546\" data-image-index=\"3\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">一个人</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5fc6ac4b657980b1.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"294742\" data-image-index=\"4\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">路在脚下</div>\n</div><p><b>02、搭乘最大众的交通工具</b></p><p>在旅行的时候，你绝对不会像我一样去做这样的“蠢事”：为了听一对母子有趣的对话，到站了不下车一直听到他们下车为止。<br></p><p>你应该也没有体会过一个人背着（60+10）L的大背包去挤没有座位的公交车，像外星人一样被人从起点看到了终点。</p><p><b>其实，乘坐大众交通工具可以带我到不同的区域，这样你可以观察到最真实的“当地人”。</b></p><p>比如，乘坐地铁时，你会看到早晨匆忙去公司的上班族，也会遇见很时髦的类似要去参加party的年轻人们，还可以看看不同国家的人在车上滑着手机。</p><p>有人下车，有人上来，有时候人们的脸上浮现的是笑容亦或皱着眉头在担忧，用一个车厢、一段路的时间好好捕捉这些城市百态。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 599px; max-height: 360px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.099999999999994%;\"></div>\n<div class=\"image-view\" data-width=\"599\" data-height=\"360\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-7e8afd59af3b6166.jpg\" data-original-width=\"599\" data-original-height=\"360\" data-original-format=\"image/jpeg\" data-original-filesize=\"62965\" data-image-index=\"5\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">慢生活</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 599px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.38%;\"></div>\n<div class=\"image-view\" data-width=\"992\" data-height=\"599\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0da2fd37b7bd2d0a.jpg\" data-original-width=\"992\" data-original-height=\"599\" data-original-format=\"image/jpeg\" data-original-filesize=\"235827\" data-image-index=\"6\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">遇见自己</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 431px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 61.62%;\"></div>\n<div class=\"image-view\" data-width=\"1248\" data-height=\"769\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a6b6fb358299562e.jpg\" data-original-width=\"1248\" data-original-height=\"769\" data-original-format=\"image/jpeg\" data-original-filesize=\"237616\" data-image-index=\"7\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">有始有终去看一座城</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-dbcea8b292aaf731.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"225400\" data-image-index=\"8\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">疲惫的面孔</div>\n</div><p></p><p><b>3、去寻觅舌尖上的美味</b></p><p>你知道你发现没有，当我们在一个城市旅行的时候。在某一个特定的区域里，你总会看到有些当地人会在下班回家时顺手提的袋子。</p><p>如果这样你就不要犹豫，那肯定是让人每天都想吃的美食。就像去你重庆就要吃一次真正的火锅，西安要吃肉夹馍，去红河一定要吃烤豆腐一样……</p><p><b>其实，每个城市都有属于自己的味道。而这些很有可能都是日后让你念念不忘，一闻到相似味道回忆就涌上心头的好滋味。</b></p><p>也许我是一个吃货，一说到吃总会忍不住想去吃，想再次上路去寻觅。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0195e9b8f2cee4dd.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"89794\" data-image-index=\"9\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">重庆火锅</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 532px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.5%;\"></div>\n<div class=\"image-view\" data-width=\"800\" data-height=\"532\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c9b962e2c955da7a.jpg\" data-original-width=\"800\" data-original-height=\"532\" data-original-format=\"image/jpeg\" data-original-filesize=\"71921\" data-image-index=\"10\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">过桥米线</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c0d813694e713bf2.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"256128\" data-image-index=\"11\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">烧饵块</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 451px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 64.45%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"825\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-4941ac76822404bd.jpg\" data-original-width=\"1280\" data-original-height=\"825\" data-original-format=\"image/jpeg\" data-original-filesize=\"295977\" data-image-index=\"12\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">建水烧豆腐</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 400px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"400\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f6d3fd95b57e6774.jpg\" data-original-width=\"600\" data-original-height=\"400\" data-original-format=\"image/jpeg\" data-original-filesize=\"76392\" data-image-index=\"13\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">辣椒酱</div>\n</div><p><b>4、找一家不错的青旅或客栈</b><br></p><p>旅行中最有趣的事情之一，便是与来自世界各地的旅人聊天，成为朋友。</p><p>而最好的方式大概就是找上一家评价不错，环境还可以的青旅。然后可以一个人坐在里面静静的发上一下午的呆，又或者加入那些有说又笑的小团伙里面。如果一拍即合，第二天你也有了通行的小伙伴了。</p><p><b>这样的过程，都让一趟旅程因为温暖的人心而变得更有意义。你会发现有些人即使一辈子和自己身处不同的国度，心竟是如此相似与靠近。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 548px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 64.24%;\"></div>\n<div class=\"image-view\" data-width=\"853\" data-height=\"548\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-fabe3dfe2dbd02a3.jpg\" data-original-width=\"853\" data-original-height=\"548\" data-original-format=\"image/jpeg\" data-original-filesize=\"117415\" data-image-index=\"14\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">我和法国行者</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-89260ee739f1b41d.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"336776\" data-image-index=\"15\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">青旅的猫</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5eb2c6970758887b.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"661234\" data-image-index=\"16\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">静静发呆</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 460px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.73%;\"></div>\n<div class=\"image-view\" data-width=\"1751\" data-height=\"1151\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-78c59b32459111be.jpg\" data-original-width=\"1751\" data-original-height=\"1151\" data-original-format=\"image/jpeg\" data-original-filesize=\"274906\" data-image-index=\"17\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">那个姑娘</div>\n</div><p><b>5、早起去看日出或独自看日落</b></p><p>很多人去旅行，每天早上都会起的特别晚。而我不会所有美好的早晨都拿来睡觉，如果天气允许，我都会选择有去看日出。感受一个地方或者一座城市的第一缕阳光。</p><p>抑或是在一个微风徐徐的傍晚，我会一个人走很远的路，找一个没人的地方。亲眼去见证太阳消失在地平线的那一刻。</p><p><b>日出，是一种能让人兴奋的瞬间，随之红日东升，冲破云霄，大地开始升腾，那是生命的喧嚣。而日落，则是一天结束，那是一种归属感。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 398px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"398\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e65db51dd74e517c.jpg\" data-original-width=\"600\" data-original-height=\"398\" data-original-format=\"image/jpeg\" data-original-filesize=\"37108\" data-image-index=\"18\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">敦煌沙漠日出</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 664px; max-height: 442px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.57%;\"></div>\n<div class=\"image-view\" data-width=\"664\" data-height=\"442\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-b26600670ec1c31d.jpg\" data-original-width=\"664\" data-original-height=\"442\" data-original-format=\"image/jpeg\" data-original-filesize=\"34799\" data-image-index=\"19\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">太白日落</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f649c79d7eb46958.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"52752\" data-image-index=\"20\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">昆明日出</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-75a3938e23d93787.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"87629\" data-image-index=\"21\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">青海湖日出</div>\n</div><p><b>6、寻找那些“不热门”的景点</b><br></p><p>不知道这是不是国人的通病，还是其他什么原因，反正生活里经常听到这样的声音，说是某某某地方商业化太严重了，某某某地方人太多了，某某某地方太没意思了……可是，即使这样到最后不想去的地方都去了。<br></p><p>但去完这些地方之后，我通常还会想办法去找一些人不太多的地方走走逛逛吃吃。</p><p>比如坐公交车路过一个看着不错的地方，下一站立马下车走回来看个究竟，或者看似一家能挖宝的二手店，又或者集结当地文艺青年的咖啡厅……</p><p><b>它们也许不有名，却绝对是你在旅行中最美好的偶遇。</b></p><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f119310e7456d24a.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"370524\" data-image-index=\"22\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">不期而遇的美好</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 427px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.72%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"427\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-93beb9e5be64c32d.jpg\" data-original-width=\"640\" data-original-height=\"427\" data-original-format=\"image/jpeg\" data-original-filesize=\"57522\" data-image-index=\"23\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">天空之境</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 480px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"480\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1f0a85581c1742ec.jpg\" data-original-width=\"640\" data-original-height=\"480\" data-original-format=\"image/jpeg\" data-original-filesize=\"90682\" data-image-index=\"24\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">轮回</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ab3ca2d68ca4de8a.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"517858\" data-image-index=\"25\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">无人的山头</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 458px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.44%;\"></div>\n<div class=\"image-view\" data-width=\"1768\" data-height=\"1157\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ef07eedba7a3f79e.jpg\" data-original-width=\"1768\" data-original-height=\"1157\" data-original-format=\"image/jpeg\" data-original-filesize=\"449856\" data-image-index=\"26\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">无人的小镇</div>\n</div><p></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 479px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 68.49%;\"></div>\n<div class=\"image-view\" data-width=\"1752\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-5a42a06304483c0b.jpg\" data-original-width=\"1752\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"492086\" data-image-index=\"27\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">图文艺的咖啡馆</div>\n</div><p><b>7、拍下只一眼就忘不掉的陌生人</b></p><p>曾经行走在路上，一个年近七旬的老人和我说：“孩子，出发什么时候都不晚，但是发现自己需要趁早。”也记得走在苏州的街道上，被一个奶奶喊着说我像好人，她手机坏了急着打电话看我能不能弄好。还记得那个24个小时硬座火车上的小女孩………</p><p><b>其实在见到他们的那一刻，我明显感受到，此生和这些人或许真的就只有这一面之缘。但是有的人你遇见就记住了，记住了就再也忘不掉了。</b></p><p>因此，我更加珍惜每一次的相遇，其实挺美好的，如果每个都不错过，成为常联系的朋友，反而会缺失那份初见的美妙。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 425px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.41%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"425\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-558ca259bde2fe52.jpg\" data-original-width=\"640\" data-original-height=\"425\" data-original-format=\"image/jpeg\" data-original-filesize=\"88397\" data-image-index=\"28\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">搭车的老奶奶</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 640px; max-height: 425px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.41%;\"></div>\n<div class=\"image-view\" data-width=\"640\" data-height=\"425\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-9d0020f046e1115e.jpg\" data-original-width=\"640\" data-original-height=\"425\" data-original-format=\"image/jpeg\" data-original-filesize=\"26599\" data-image-index=\"29\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">纯情基友</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-1da96b02cb839e78.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"86261\" data-image-index=\"30\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">中国军人</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.47999999999999%;\"></div>\n<div class=\"image-view\" data-width=\"1083\" data-height=\"720\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-6dacb76c92e36cf7.jpg\" data-original-width=\"1083\" data-original-height=\"720\" data-original-format=\"image/jpeg\" data-original-filesize=\"172279\" data-image-index=\"31\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">宁静</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 1050px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 150.0%;\"></div>\n<div class=\"image-view\" data-width=\"1200\" data-height=\"1800\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c908988b2b1c0476.jpg\" data-original-width=\"1200\" data-original-height=\"1800\" data-original-format=\"image/jpeg\" data-original-filesize=\"279571\" data-image-index=\"32\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">孤独的落幕者</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 490px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 70.12%;\"></div>\n<div class=\"image-view\" data-width=\"1533\" data-height=\"1075\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-f7669e7e9abe79c3.jpg\" data-original-width=\"1533\" data-original-height=\"1075\" data-original-format=\"image/jpeg\" data-original-filesize=\"225723\" data-image-index=\"33\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">为梦想也为生活</div>\n</div><p><b>8、尽量去成为一名志愿者</b></p><p>在某个夜晚帐篷被吹飞，一句扎西德勒就收留了我一晚上的藏族妈妈；去做志愿者的时候，听说我要去山区支教，常州的叔叔阿姨下车的时候硬给我塞了两百，让我给孩子们买点吃的………</p><p>有时候，会有人问我为什么别人都在质疑，而你却一再坚持去做这些事情。其实，只是想把自己在路上得到的这些爱，拿出来分点给需要帮助的人。</p><p>所以，去到一个城市之前都会找一些志愿活动，尽自己的微薄之力去温暖一些普通的人。我一直觉得，带上爱出发才是旅行最终的信仰。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 547px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 78.28%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"1002\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-be984ccf1445e7ac.jpg\" data-original-width=\"1280\" data-original-height=\"1002\" data-original-format=\"image/jpeg\" data-original-filesize=\"187453\" data-image-index=\"34\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他是卓玛</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 583px; max-height: 389px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.72%;\"></div>\n<div class=\"image-view\" data-width=\"583\" data-height=\"389\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-2d15ddbb042e76ef.jpg\" data-original-width=\"583\" data-original-height=\"389\" data-original-format=\"image/jpeg\" data-original-filesize=\"38982\" data-image-index=\"35\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">这是扎西</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-179fd2ba58127436.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"244232\" data-image-index=\"36\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他们是我的学生</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-91041caed9760de2.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"168751\" data-image-index=\"37\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">他也是</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a6cca153ae5be8ca.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"183660\" data-image-index=\"38\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">帮乡亲们拍照</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 465px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.56%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"852\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-cb19d7acf9c0825d.jpg\" data-original-width=\"1280\" data-original-height=\"852\" data-original-format=\"image/jpeg\" data-original-filesize=\"167185\" data-image-index=\"39\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">我们在一起</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 933px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 133.32999999999998%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"1280\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-cc0ae58e9bea1849.jpg\" data-original-width=\"960\" data-original-height=\"1280\" data-original-format=\"image/jpeg\" data-original-filesize=\"530619\" data-image-index=\"40\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">教学生拍照</div>\n</div><p><b>9、写明信片纪录当时的心情</b></p><p>这些年去旅行，这是从未忘记的一件事，向朋友或者陌生人邮寄明信片。可以在一张小小的纸片上分享在另一个城市看到的风景。</p><p><b>写下当时的心情，无关乎是简短的文字，或者温馨感人，或者朴素平淡，或者搞怪幽默，或者富于哲理，都能给远方有相同情愫的人不一样的体验。</b></p><p>而且，我还将这些明信片作为每一本书的书签，这样当我翻阅着书籍，不经意或者常常地，就能看到并回味这样的感动。</p><p>不知道你有没有体会过那种跨越千山万水带来的温暖和感动。如果没有，下次我寄给你。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 686px; max-height: 436px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 63.56%;\"></div>\n<div class=\"image-view\" data-width=\"686\" data-height=\"436\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-ee7a8b123ac376a8.jpg\" data-original-width=\"686\" data-original-height=\"436\" data-original-format=\"image/jpeg\" data-original-filesize=\"102598\" data-image-index=\"41\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">给别人也给自己</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 580px; max-height: 353px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 60.86%;\"></div>\n<div class=\"image-view\" data-width=\"580\" data-height=\"353\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a8221ab85a9e442f.jpg\" data-original-width=\"580\" data-original-height=\"353\" data-original-format=\"image/jpeg\" data-original-filesize=\"46455\" data-image-index=\"42\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">寄出去多一份温暖</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 525px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"1280\" data-height=\"960\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-a1a71d187b97ea18.jpg\" data-original-width=\"1280\" data-original-height=\"960\" data-original-format=\"image/jpeg\" data-original-filesize=\"359059\" data-image-index=\"43\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">旅途中的心情</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 450px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"450\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-d2a17de07463be79.jpg\" data-original-width=\"600\" data-original-height=\"450\" data-original-format=\"image/jpeg\" data-original-filesize=\"39909\" data-image-index=\"44\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">写出来的才叫分享</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 690px; max-height: 401px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 58.120000000000005%;\"></div>\n<div class=\"image-view\" data-width=\"690\" data-height=\"401\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-86a48a40fd485966.jpg\" data-original-width=\"690\" data-original-height=\"401\" data-original-format=\"image/jpeg\" data-original-filesize=\"90992\" data-image-index=\"45\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">喜欢，没道理</div>\n</div><p>10、去当地的图书馆和校园走走</p><p>自从自己的《遇见101个笑容》开始启动之后，便爱上了去别人的我校园走走，感受不一样的气息，不一样的环境。</p><p><b>大学校园是段美好的旅程：樱花树下读书，落英缤纷的小径，自行车铃声细碎，百年老校，中式典雅...…这些你都可以感受到。</b><br></p><p>而书店则是一座城市的灵魂。一直以来，我对此深以为然。<br></p><p>只是经常会觉得可惜，现在走街串巷，书店越来越少，只有那些中小学的旁边才有书店聚集，其余的地方，城市越发达，似乎，书店消失的越快，当然这也与网络的发达有脱不开的关系，人们足不出户就可购买到想看的书，方便实惠，送货上门。</p><p>所以每到一个地方，我也会去拜访这个城市一些独特的书店。</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 68.45%;\"></div>\n<div class=\"image-view\" data-width=\"935\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-eccb14e88b370863.jpg\" data-original-width=\"935\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"115818\" data-image-index=\"46\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在云大遇见你</div>\n</div><p><br></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 65.11%;\"></div>\n<div class=\"image-view\" data-width=\"983\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c82ebee002492bc8.jpg\" data-original-width=\"983\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"258057\" data-image-index=\"47\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在同济遇到你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 466px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"1800\" data-height=\"1200\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-9a0b085c71b5baef.jpg\" data-original-width=\"1800\" data-original-height=\"1200\" data-original-format=\"image/jpeg\" data-original-filesize=\"477775\" data-image-index=\"48\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在兰大遇见你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 525px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 75.0%;\"></div>\n<div class=\"image-view\" data-width=\"4032\" data-height=\"3024\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-68ead19b5abc86f3.jpg\" data-original-width=\"4032\" data-original-height=\"3024\" data-original-format=\"image/jpeg\" data-original-filesize=\"2402502\" data-image-index=\"49\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在川美遇到你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.67%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-0d84c3e2a7bd948f.jpg\" data-original-width=\"960\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"356877\" data-image-index=\"50\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">如果我在武大遇见你</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 640px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 59.150000000000006%;\"></div>\n<div class=\"image-view\" data-width=\"1082\" data-height=\"640\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-e1df0b7ee16d6347.jpg\" data-original-width=\"1082\" data-original-height=\"640\" data-original-format=\"image/jpeg\" data-original-filesize=\"202658\" data-image-index=\"51\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">M60</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 462px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.03%;\"></div>\n<div class=\"image-view\" data-width=\"1737\" data-height=\"1147\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-c731fb6c170ca990.jpg\" data-original-width=\"1737\" data-original-height=\"1147\" data-original-format=\"image/jpeg\" data-original-filesize=\"682205\" data-image-index=\"52\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">先锋书店</div>\n</div><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 636px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 66.25%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"636\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-3844349a9c11a7b2.jpg\" data-original-width=\"960\" data-original-height=\"636\" data-original-format=\"image/jpeg\" data-original-filesize=\"127620\" data-image-index=\"53\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">国家图书馆</div>\n</div><p>将来别人问你或是自己回忆起来20岁的你在做什么，21岁在做什么，22岁在做什么的时候。我想我都可以轻描淡写地说起那些自己精挑细选的故事吧</p><p>“噢，20岁背起行囊去徒步旅行啦，21不顾别人反对去山区支教了，22岁……”</p><p><b>旅行是一场修行，在这场修行中，你会遇见美好，会发生故事，你将足迹走在地球的每一片土地时，感受到的，也必将是这片土地的温暖。</b></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 422px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 56.269999999999996%;\"></div>\n<div class=\"image-view\" data-width=\"750\" data-height=\"422\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/3459828-3b81c931d1801c1c.jpg\" data-original-width=\"750\" data-original-height=\"422\" data-original-format=\"image/jpeg\" data-original-filesize=\"41819\" data-image-index=\"54\" class=\"image-loading\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">认真的活着</div>\n</div><p>我是有备而来的路人甲大萌，那个对世界上瘾的二逼青年，如果我写过的任何一句话，拍过的每一张照片，做过的任何举动。曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的情愫。</p><p>有时候，虽然素未谋面。</p><p>却已相识很久，很微妙也很知足。</p><p><b>如果你喜欢鄙文和图片，那就在右下角点个喜欢吧，你的鼓励是我最大的动力来源，在此大萌深表感恩。</b></p><p><b>当然巧好你也喜欢我的话，我们可以互相关注，相互学习的哟。</b></p>",
      "time": "2017.03.10 08:11:50"
    },
    {
      "source": "juejin",
      "id": "2183dj1p28dc",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/entry/5675217e60b294e7ce8e2a4c\"><meta itemprop=\"headline\" content=\"Node入门 » 一本全面的Node.js教程\"><meta itemprop=\"keywords\" content=\"Node.js,电子书\"><meta itemprop=\"datePublished\" content=\"2015-12-19T09:21:02.646Z\"><meta itemprop=\"image\" content=\"https://lc-gold-cdn.xitu.io/9a256d48cf5845e07f4b.jpg\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"sing1ee\"><meta itemprop=\"url\" content=\"https://juejin.im/user/55502731e4b034bc9c39978b\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><h1 data-v-5d1b3692>Node入门 » 一本全面的Node.js教程</h1><div class=\"entry-public-info\" data-v-5d1b3692><div class=\"text-muted info-item\" data-v-5d1b3692>阅读 18327</div><div class=\"text-muted info-item\" data-v-5d1b3692>收藏 577</div><div class=\"text-muted info-item\" data-v-5d1b3692>2015-12-19</div></div><div class=\"originalUrl\" data-v-5d1b3692>原文链接：<a st:name=\"originLink\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.nodebeginner.org%2Findex-zh-cn.html\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" data-v-5d1b3692>www.nodebeginner.org</a></div><!----><div itemprop=\"articleBody\" class=\"entry-content article-content\" data-v-5d1b3692><div>\n\n\n        \n\n        \n\n        <h2 data-id=\"heading-0\">关于</h2>\n\n        <p>\n            本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-1\">状态</h3>\n\n        <p>\n            你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。\n        </p>\n\n        <p>\n            本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-2\">读者对象</h3>\n\n        <p>\n            本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。\n        </p>\n\n        <p>\n            这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。\n        </p>\n\n        <p>\n            然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-3\">本书结构</h3>\n\n        <p>\n            读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。\n        </p>\n\n        <p>\n            当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。\n        </p>\n\n        <p>\n            本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。\n        </p>\n\n        <p>\n            紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。\n        </p>\n\n        <p>\n            最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。\n        </p>\n\n        <p>\n            可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。\n        </p>\n\n        <p>\n            该应用所有的源代码都可以通过\n            <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FManuelKiessling%2FNodeBeginnerBook%2Ftree%2Fmaster%2Fcode%2Fapplication\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">本书Github代码仓库</a>.\n        </p>\n\n        <div>目录</div>\n        <div>\n            <ul>\n\n                <li><a href=\"#about\">关于</a>\n                    <ul>\n                        <li><a href=\"#status\">状态</a></li>\n                        <li><a href=\"#intended-audience\">读者对象</a></li>\n                        <li><a href=\"#structure\">本书结构</a></li>\n                    </ul>\n                </li>\n\n                <li><a href=\"#javascript-and-nodejs\">JavaScript与Node.js</a>\n                    <ul>\n                        <li><a href=\"#javascript-and-you\">JavaScript与你</a></li>\n                        <li><a href=\"#a-word-of-warning\">简短申明</a></li>\n                        <li><a href=\"#server-side-javascript\">服务器端JavaScript</a></li>\n                        <li><a href=\"#hello-world\">“Hello World”</a></li>\n\n                    </ul>\n                </li>\n                <li><a href=\"#a-full-blown-web-application-with-nodejs\">一个完整的基于Node.js的web应用</a>\n                    <ul>\n                        <li><a href=\"#the-use-cases\">用例</a></li>\n                        <li><a href=\"#the-application-stack\">应用不同模块分析</a></li>\n                    </ul>\n\n                </li>\n                <li><a href=\"#building-the-application-stack\">构建应用的模块</a>\n                    <ul>\n                        <li><a href=\"#a-basic-http-server\">一个基础的HTTP服务器</a></li>\n                        <li><a href=\"#analyzing-our-http-server\">分析HTTP服务器</a></li>\n                        <li><a href=\"#passing-functions-around\">进行函数传递</a></li>\n                        <li><a href=\"#how-function-passing-makes-our-http-server-work\">函数传递是如何让HTTP服务器工作的</a></li>\n\n                        <li><a href=\"#event-driven-callbacks\">基于事件驱动的回调</a></li>\n                        <li><a href=\"#how-our-server-handles-requests\">服务器是如何处理请求的</a></li>\n                        <li><a href=\"#finding-a-place-for-our-server-module\">服务端的模块放在哪里</a>\n                        </li>\n                        <li><a href=\"#whats-needed-to-route-requests\">如何来进行请求的“路由”</a></li>\n                        <li><a href=\"#execution-in-the-kongdom-of-verbs\">行为驱动执行</a></li>\n                        <li><a href=\"#routing-to-real-request-handlers\">路由给真正的请求处理程序</a></li>\n\n                        <li><a href=\"#making-the-request-handlers-respond\">让请求处理程序作出响应</a>\n                            <ul>\n                                <li><a href=\"#how-to-not-do-it\">不好的实现方式</a></li>\n                                <li><a href=\"#blocking-and-non-blocking\">阻塞与非阻塞</a></li>\n                                <li><a href=\"#responding-request-handlers-with-non-blocking-operations\">以非阻塞操作进行请求响应</a>\n                                </li>\n                            </ul>\n\n                        </li>\n                        <li><a href=\"#serving-something-useful\">更有用的场景</a>\n                            <ul>\n                                <li><a href=\"#handling-post-requests\">处理POST请求</a></li>\n                                <li><a href=\"#handling-file-uploads\">处理文件上传</a></li>\n                            </ul>\n                        </li>\n\n                        <li><a href=\"#conclusion-and-outlook\">总结与展望</a></li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n\n        <a></a>\n\n        <h2 data-id=\"heading-4\">JavaScript与Node.js</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-5\">JavaScript与你</h3>\n\n        <p>\n            抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。\n        </p>\n\n        <p>\n            如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。\n        </p>\n\n        <p>\n            而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。\n        </p>\n\n        <p>\n            与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是<em>window.open() </em>那么简单。 .\n        </p>\n\n        <p>\n            不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript<em>用户</em>，而非JavaScript<em>开发者</em>。\n        </p>\n\n        <p>\n            然后，出现了Node.js，服务端的JavaScript，这有多酷啊？\n        </p>\n\n        <p>\n            于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。\n        </p>\n\n        <p>\n            问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。\n        </p>\n\n        <p>\n            因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。\n        </p>\n\n        <p>\n            当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。\n        </p>\n\n        <p>\n            本书的目标就是给你提供指导。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-6\">简短申明</h3>\n\n        <p>\n            业界有非常优秀的JavaScript程序员。而我并非其中一员。\n        </p>\n\n        <p>\n            我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。\n        </p>\n\n        <p>\n            因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。\n        </p>\n\n        <p>\n            如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-7\">服务端JavaScript</h3>\n\n        <p>\n            JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\n        </p>\n\n        <p>\n            Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。\n        </p>\n\n        <p>\n            要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。\n        </p>\n\n        <p>\n            除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。\n        </p>\n\n        <p>\n            因此，Node.js事实上既是一个运行时环境，同时又是一个库。\n        </p>\n\n        <p>\n            要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjoyent%2Fnode%2Fwiki%2FInstallation\" title=\"Building and Installing Node.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方的安装指南</a>。安装完成后，继续回来阅读本书下面的内容。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-8\">“Hello World”</h3>\n\n        <p>\n            好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。\n        </p>\n\n        <p>\n            打开你最喜欢的编辑器，创建一个<em>helloworld.js</em>文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：\n        </p>\n        <pre>console.log(\"Hello World\");</pre>\n        \n        <p>\n            保存该文件，并通过Node.js来执行：\n        </p>\n\n        <pre>node helloworld.js</pre>\n        <p>\n            正常的话，就会在终端输出<em>Hello World</em> 。\n        </p>\n\n        <p>\n            好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。\n        </p>\n\n\n        <a></a>\n\n        <h2 data-id=\"heading-9\">一个完整的基于Node.js的web应用</h2>\n \n        <a></a> \n \n        <h3 data-id=\"heading-10\">用例</h3> \n \n        <p>我们来把目标设定得简单点，不过也要够实际才行：</p>\n\n        <ul>\n        <li>用户可以通过浏览器使用我们的应用。</li>\n        <li>当用户请求<em>http://domain/start</em>时，可以看到一个欢迎页面，页面上有一个文件上传的表单。</li>\n        <li>用户可以选择一个图片并提交表单，随后文件将被上传到<em>http://domain/upload</em>，该页面完成上传后会把图片显示在页面上。</li>\n        </ul>\n\n        <p>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>\n\n        <p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>\n\n        <h3 data-id=\"heading-11\">应用不同模块分析</h3>\n\n        <p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>\n\n        <ul>\n        <li>我们需要提供Web页面，因此需要一个<em>HTTP服务器</em></li>\n        <li>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个<em>路由</em>，用于把请求对应到请求处理程序（request handler）</li>\n        <li>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的<em>请求处理程序</em></li>\n        <li>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要<em>请求数据处理功能</em></li>\n        <li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>\n        <li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>\n        </ul>\n\n        <p>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>\n\n        <p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n\n        <p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>\n\n        <p>现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。</p>\n\n        <a></a>\n\n        <h2 data-id=\"heading-12\">构建应用的模块</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-13\">一个基础的HTTP服务器</h3>\n\n        <p>\n            当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。\n            <br>\n            我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？\n        </p>\n\n        <p>\n\n            实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。\n        </p>\n\n        <p>\n            这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。  \n        </p>\n\n        <p>\n            那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。\n        </p>\n\n        <p>\n\n            在我的印象里，把主文件叫做<em>index.js</em>或多或少是个标准格式。把服务器模块放进叫<em>server.js</em>的文件里则很好理解。\n        </p>\n\n        <p>\n            让我们先从服务器模块开始。在你的项目的根目录下创建一个叫<em>server.js</em>的文件，并写入以下代码：\n        </p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>\n            搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：\n        </p>\n        <pre>node server.js</pre>\n        <p>\n            接下来，打开浏览器访问<a href=\"https://link.juejin.im?target=http%3A%2F%2Flocalhost%3A8888%2F\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a>，你会看到一个写着“Hello World”的网页。 \n        </p>\n\n        <p>\n            这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-14\">分析HTTP服务器</h3>\n\n        <p>\n            那么接下来，让我们分析一下这个HTTP服务器的构成。\n        </p>\n\n        <p>\n            第一行<em>请求（require）</em>Node.js自带的 <em>http</em> 模块，并且把它赋值给 <em>http</em> 变量。\n        </p>\n\n\n        <p>\n            接下来我们调用http模块提供的函数： <em>createServer</em> 。这个函数会返回一个对象，这个对象有一个叫做 <em>listen</em> 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。\n        </p>\n\n        <p>\n            咱们暂时先不管 <em>http.createServer</em> 的括号里的那个函数定义。\n        </p>\n\n        <p>\n            我们本来可以用这样的代码来启动服务器并侦听8888端口：\n        </p>\n        <pre>var http = require(\"http\");var server = http.createServer();server.listen(8888);</pre>\n\n        <p>\n            这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。\n        </p>\n\n        <p>\n            最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 <em>createSever()</em> 的第一个参数，一个函数定义。\n        </p>\n\n        <p>\n            实际上，这个函数定义是 <em>createServer()</em> 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-15\">进行函数传递</h3>\n\n        <p>\n            举例来说，你可以这样做：\n        </p>\n        <pre>function say(word) {  console.log(word);}function execute(someFunction, value) {  someFunction(value);}execute(say, \"Hello\");</pre>\n\n        <p>\n            请仔细阅读这段代码！在这里，我们把 <em>say</em> 函数作为<em>execute</em>函数的第一个变量进行了传递。这里传递的不是 <em>say</em> 的返回值，而是 <em>say</em> 本身！\n        </p>\n\n        <p>\n            这样一来， <em>say</em> 就变成了<em>execute</em> 中的本地变量 <em>someFunction</em> ，execute可以通过调用 <em>someFunction()</em> （带括号的形式）来使用 <em>say</em> 函数。\n        </p>\n\n        <p>\n            当然，因为 <em>say</em> 有一个变量， <em>execute</em> 在调用 <em>someFunction</em> 时可以传递这样一个变量。\n        </p>\n\n        <p>\n            我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n        </p>\n        <pre>function execute(someFunction, value) {  someFunction(value);}execute(function(word){ console.log(word) }, \"Hello\");</pre>\n\n        <p>\n            我们在 <em>execute</em> 接受第一个参数的地方直接定义了我们准备传递给 <em>execute</em> 的函数。\n        </p>\n\n        <p>\n            用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 <em>匿名函数</em> 。\n        </p>\n\n        <p>\n            这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-16\">函数传递是如何让HTTP服务器工作的</h3>\n\n        <p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>现在它看上去应该清晰了很多：我们向 <em>createServer</em> 函数传递了一个匿名函数。  </p>\n\n        <p>用这样的代码也可以达到同样的目的：  </p>\n        <pre>var http = require(\"http\");function onRequest(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);</pre>\n\n        <p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-17\">基于事件驱动的回调</h3>\n\n        <p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。  </p>\n\n        <p>你也许会想花点时间读一下Felix Geisendörfer的大作<a href=\"https://link.juejin.im?target=http%3A%2F%2Fdebuggable.com%2Fposts%2Funderstanding-node-js%3A4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding node.js</a>，它介绍了一些背景知识。  </p>\n\n        <p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。  </p>\n\n        <p>当我们使用 <em>http.createServer</em> 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。  </p>\n\n        <p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。  </p>\n\n        <p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。  </p>\n\n        <p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？  </p>\n\n        <p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。  </p>\n\n        <p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。  </p>\n\n        <p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。  </p>\n\n        <p>这个就是传说中的 <em>回调</em> 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 <em>回调</em> 。  </p>\n\n        <p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。  </p>\n\n        <p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：  </p>\n\n        <pre>var http = require(\"http\");function onRequest(request, response) {  console.log(\"Request received.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);console.log(\"Server has started.\");</pre>\n\n        <p>注意：在 <em>onRequest</em> （我们的回调函数）触发的地方，我用 <em>console.log</em> 输出了一段文本。在HTTP服务器开始工作<em>之后</em>，也输出一段文本。  </p>\n\n        <p>\n            当我们与往常一样，运行它<em>node server.js</em>时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href=\"https://link.juejin.im?target=http%3A%2F%2Flocalhost%3A8888%2F\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a> ），“Request received.”这条消息就会在命令行中出现。\n        </p>\n\n        <p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>\n\n        <p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /时尝试读取 http://localhost:8888/favicon.ico )</p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-18\">服务器是如何处理请求的</h3>\n\n        <p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 <em>onRequest()</em> 的主体部分。  </p>\n\n        <p>当回调启动，我们的 <em>onRequest()</em> 函数被触发的时候，有两个参数被传入： <em>request</em> 和 <em>response</em> 。  </p>\n\n        <p>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。  </p>\n\n        <p>所以我们的代码就是：当收到请求时，使用 <em>response.writeHead()</em> 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 <em>response.write()</em> 函数在HTTP相应主体中发送文本“Hello World\"。  </p>\n\n        <p>最后，我们调用 <em>response.end()</em> 完成响应。  </p>\n\n        <p>目前来说，我们对请求的细节并不在意，所以我们没有使用 <em>request</em> 对象。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-19\">服务端的模块放在哪里</h3>\n\n        <p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 <em>server.js</em> 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 <em>index.js</em> 的文件去调用应用的其他模块（比如 <em>server.js</em> 中的HTTP服务器模块）来引导和启动应用。  </p>\n\n        <p>我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 <em>index.js</em> 主文件使用。</p>\n\n        <p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：  </p>\n        <pre>var http = require(\"http\");...http.createServer(...);</pre>\n\n        <p>Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。  </p>\n\n        <p>这把我们的本地变量变成了一个拥有所有 <em>http</em> 模块所提供的公共方法的对象。</p>\n\n        <p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：  </p>\n        <pre>var foo = require(\"http\");...foo.createServer(...);</pre>\n\n        <p>很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？  </p>\n\n        <p>等我们把 <em>server.js</em> 变成一个真正的模块，你就能搞明白了。  </p>\n\n        <p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 <em>导出</em> 到请求这个模块的脚本。  </p>\n\n        <p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。  </p>\n\n        <p>我们把我们的服务器脚本放到一个叫做 <em>start</em> 的函数里，然后我们会导出这个函数。  </p>\n        <pre>var http = require(\"http\");function start() {  function onRequest(request, response) {    console.log(\"Request received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>这样，我们现在就可以创建我们的主文件 <em>index.js</em> 并在其中启动我们的HTTP了，虽然服务器的代码还在 <em>server.js</em> 中。  </p>\n\n        <p>创建 <em>index.js</em> 文件并写入以下内容：  </p>\n        <pre>var server = require(\"./server\");server.start();</pre>\n\n        <p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>\n\n        <p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>\n        <pre>node index.js</pre>\n\n        <p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。  </p>\n\n        <p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。  </p>\n\n        <p>对于一个非常简单的应用来说，你可以直接在回调函数 <em>onRequest()</em> 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。  </p>\n\n        <p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 <em>路由</em> 的模块吧。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-20\">如何来进行请求的“路由”</h3> \n\n         <p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>\n\n        <p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n\n        <p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>\n<pre>                               url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n</pre>\n\n        <p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>\n\n        <p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start() {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>\n\n        <p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n\n        <p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>\n        <pre>function route(pathname) {  console.log(\"About to route a request for \" + pathname);}exports.route = route;</pre>\n\n        <p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n\n        <p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href=\"https://link.juejin.im?target=http%3A%2F%2Fmartinfowler.com%2Farticles%2Finjection.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>\n\n        <p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(pathname);    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");server.start(router.route);</pre>\n\n        <p>在这里，我们传递的函数依旧什么也没做。</p>\n\n        <p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n\n        <pre>bash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo</pre>\n\n        <p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>\n \n        <a></a> \n \n        <h3 data-id=\"heading-21\">行为驱动执行</h3> \n\n        <p>请允许我再次脱离主题，在这里谈一谈函数式编程。</p>\n\n        <p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将<em>router</em>对象传递进去，服务器随后可以调用这个对象的<em>route</em>函数。</p>\n\n        <p>就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？</p>\n\n        <p>但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要<em>名词</em>，你需要<em>动词</em>。</p>\n\n        <p>理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</p>\n\n        <p>我是在读了Steve Yegge的大作<a href=\"https://link.juejin.im?target=http%3A%2F%2Fsteve-yegge.blogspot.com%2F2006%2F03%2Fexecution-in-kingdom-of-nouns.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">名词王国中的死刑</a>之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件</p></div></div>",
      "time": null
    },
    {
      "source": "juejin",
      "id": "3ue3hw025t00",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/5b0388006fb9a07aa213ae16\"><meta itemprop=\"headline\" content=\"Node 在有赞的实践\"><meta itemprop=\"keywords\" content=\"Node.js,Java,前端,koa\"><meta itemprop=\"datePublished\" content=\"2018-05-22T03:05:39.310Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"有赞技术\"><meta itemprop=\"url\" content=\"https://juejin.im/user/5a99007bf265da239c7accca\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/5b0388006fb9a07aa213ae16\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/5b0388006fb9a07aa213ae16\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2018-05-22T03:05:39.310Z\" title=\"Tue May 22 2018 11:05:39 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2018年05月22日</time><span class=\"views-count\" data-v-648672b2>阅读 13111</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node 在有赞的实践</h1><div data-id=\"5b038903518825428b391d5c\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><h2 class=\"heading\" data-id=\"heading-0\">一、概述</h2>\n<blockquote>\n<p>4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在 Node 这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">二、Node 基础框架的迭代与演进</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 从 Koa 到 阿童木（Astroboy）</h3>\n<h4 class=\"heading\" data-id=\"heading-3\">（1）Koa + 中间件</h4>\n<p>有赞最早的一个比较完整的 Node 项目是公司内部的一个管理系统，这个系统是用 Node 全栈开发的，主要包括一个给 HR 用的员工管理系统和给小伙伴用的 APP。就像大多数公司一样，我们第一个 Node 项目也是直接用 Koa，然后整合一些开源的中间件，这样就快速的把项目搭建起来了。</p>\n<p>这个项目做了半年之后，我们把 Node 该踩的坑基本也都踩了一遍，所以我们就开始尝试在对外产品上使用 Node了，我们第一个尝试改造的项目是公司的官网，这是最简单的一个项目，基本没什么大的风险。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">（2）脚手架项目模板</h4>\n<p>第二个项目我们不可能再按照之前的方式，简单用 Koa 加上一堆中间件的方式来搭建项目了，因为已经有了之前的经验，所以我们就整理了下这一套方案，抽离出了一个项目模板，每个新项目只要把这个模板克隆下来，然后改一下配置，就可以快速搭建出一个新的项目来。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">（3）阿童木 1.0</h4>\n<p>项目多了之后，这种方式弊端很快就显现出来了，因为模板代码和业务代码是耦合在一起，如果要改模板生成的代码，只能每个项目手动更新，而随着时间的推移，越来越难保持同步了，每个项目的目录结构和代码风格可能也会变得非常不一样，所以，<strong>解耦框架代码和业务代码就非常重要了</strong>。所以我们就在脚手架模板的基础上抽离出了一个框架叫 Astroboy（阿童木），这个框架是在  Koa 的基础上封装的，这样，每个项目都基于这个框架开发，如果框架更新了，项目也只需要更改下框架的版本号。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cc9555a2b18?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1164\" data-height=\"666\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">（4）阿童木 2.0</h4>\n<p>很多项目都开始用 Node 了，新的问题又出现了，因为每个产品的业务场景都不一样，对框架的需求也都不一样。例如某个中间件，产品 A 可能需要，而产品 B 可能根本不需要这个中间件，而这个时候的框架又不支持定制改造。所以对框架来说，又提出了新的挑战，所以在今年年初，对框架做了一次大的重构。</p>\n<p>这次重构在阿童木 1.0 的基础上，加入了很多新特性，主要有以下几点：</p>\n<ul>\n<li>基于 Koa2 开发，性能表现优异</li>\n<li>提供基于 Astroboy 定制上层框架的能力</li>\n<li>高度可扩展的插件机制</li>\n<li>渐进式开发</li>\n</ul>\n<p>首先提供基于 Astroboy 定制上层框架的能力，如下图所示，Youzan Base Framework 是在阿童木的基础上定制的一个有赞最基础的 Node Web 框架，这一层主要集成了一些有赞最基础的服务，像：</p>\n<ul>\n<li>天网系统接入，这是有赞内部的一个日志及业务监控系统</li>\n<li>健康检查，运维监控系统每隔5秒钟，都会检查系统服务可用性</li>\n<li>全链路监控，对于一次 HTTP 请求，一般都会调用多个后端接口，相应的后端接口也会再去调用其他接口，所以整个调用过程实际上是一棵树状的结构，如果碰到性能问题，找出其中性能瓶颈问题就非常重要了，全链路监控就是为了解决这个问题。</li>\n<li>Dubbo 服务调用接入，关于这一点，查看下面关于服务化的介绍。</li>\n</ul>\n<p>有了 Youzan Base Framework 后，我们就需要在上面开发业务了，这个分两种业务场景：对于一些简单单一的业务，直接继承 Youzan Base Framework 开发就可以了；而如果是一些复杂的业务，就可以先在 Youzan Base Framework 的基础上，定制出一个业务框架，像我们有赞原先有一个超大的 PHP 项目（我们叫 Iron），那么服务化拆分后，Node 就承担了原先 PHP 的部分，所以我们新先定制了一个业务级的框架叫 Iron Base Framework，然后再按照业务模块（交易、店铺、用户、营销）拆分成多个子项目。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cd133687115?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"694\"><figcaption></figcaption></figure><p></p>\n<p>其次是支持插件化，关于这一点，可查看下面关于插件的说明。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">2. 框架的几个核心概念</h3>\n<p>以上介绍了有赞 Node 基础框架迭代和演变的过程，下面主要介绍下阿童木2.0 框架的几个核心概念</p>\n<h4 class=\"heading\" data-id=\"heading-8\">（1）应用 Application</h4>\n<p>应用 Application 的概念很好理解，在这里应用就可以理解成一个项目，它是从框架继承下来，并且实例化之后的一个实例，应用也是由一个一个插件构成的。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">（2）框架 Framework</h4>\n<p>Astroboy 框架是在 Koa2 的基础上封装的，关于框架的概念，这里就不再做过多的介绍了。</p>\n<h4 class=\"heading\" data-id=\"heading-10\">（3）插件 Plugin</h4>\n<p>插件化是软件设计中一个很重要的思想，很多软件像 Eclipse 都支持这样的特性，插件化可以让我们的系统解耦，每个模块做到独立开发，而模块之间又不会相互影响，这样的特性对于大型项目来说是非常重要的。</p>\n<p>插件化是 Astroboy 框架中最核心的一个实现，它是服务（Service）、中间件（Middleware）和工具函数库（Lib）等的载体，它本质上还是 NPM 包，只不过是在 NPM 包的基础上，做了更深层次的抽象。基于 Astroboy 的应用，就是由一个一个的 Plugin 组成的，Plugin 就是我们手中的积木，通过 Astroboy 的框架引擎把这些积木组织在一起，就形成了系统。</p>\n<p><strong>那么插件跟普通的 NPM 包有什么区别呢？</strong></p>\n<p>插件约定了目录结构，这样每个插件看起来都是类似的，这对于团队的协作是非常重要，如果每个模块看起来都不一样，那么团队的协作成本就会很高。\n应用启动后，插件的代码是自动注入到整个应用的，只需要在插件的配置文件里面开启这个插件即可。</p>\n<p><strong>一个插件可以包含哪些信息？</strong></p>\n<ul>\n<li>插件元数据，包括插件名称、版本、描述等；</li>\n<li>服务（Service）、中间件（Middleware）以及工具函数库（Lib）等；</li>\n<li>Koa 内置对象的扩展，包括 Context、Application、Request 以及 Response 等；</li>\n</ul>\n<p><strong>插件的管理</strong></p>\n<ul>\n<li>安装插件，通过npm install 命令即可，例如：npm install [<@scope>/]@</li>\n<li>启用插件，安装插件后还需要启用插件，插件才会真正生效。启用插件也很简单，只需要配置 plugin.default.js 即可，如果不同环境插件配置不一样，也只需修改相应* 环境的配置（plugin.${env}.js）即可，这里 env 表示 Node 运行时的环境变量，例如：development、test、production 等。如下代码所示：</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    path: path.resolve(__dirname, <span class=\"hljs-string\">'../plugins/astroboy-cookie'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>enable 设置成 true 就可以开启这个插件，path 表示插件的绝对路径，这种一般适合于还在快速迭代中的插件，如果插件已经很稳定了，你就可以把这个插件打包发布成一个 NPM 包，然后通过 package 声明你的插件即可，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    package: <span class=\"hljs-string\">'astroboy-cookie'</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>禁用插件，禁用插件就更加简单了，只需将 enable 设置成 false 即可。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-11\">三、Node 接入有赞服务化体系的历程</h2>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 为什么要做服务化？</h3>\n<p>随着公司业务的发展，网站应用的规模不断扩大，垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键，所以在这个时候，分布式服务架构就势在必行了。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. 技术栈的选择</h3>\n<p>在介绍技术栈选择之前，先讲一下公司的一些技术背景。</p>\n<blockquote>\n<p>在公司成立初期，为了能够快速开发，把产品快速做出来推出市场，所以我们选择用 PHP 语言，我想这也是大多数创业公司的选择。而随着业务的发展，PHP 越来越难处理复杂的业务。</p>\n</blockquote>\n<p>所以等到了一定时候，我们开始做服务化拆分，那么首先考虑的就是底层技术的选择，我们从下面几点考虑：</p>\n<ul>\n<li>第一个是这门技术的生态是否足够完善，也就是相关的开源软件、工具是否成熟；</li>\n<li>第二个是否能够快速招到你需要的人才。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-14\">3. 服务化拆分之后，每一层职责分别是什么？</h3>\n<p>对于 Node 层，我们的定位是一层很薄的中间层，Node 这一层不会过多地处理业务逻辑，业务逻辑全部都交给 Java 来处理，它只负责下面三件事情：</p>\n<ul>\n<li>模板渲染：模板渲染说的就是 HTML 模板的渲染；</li>\n<li>业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node 就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。</li>\n<li>接口转发：Java 的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node 需要承担接口转发的角色。</li>\n</ul>\n<p>而对于 Java 这一层，就需要承担业务逻辑以及缓存等复杂的操作，这里就不做过多的介绍了。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">4. Node 如何调用 Java 接口？</h3>\n<p>那么服务化拆分之后，首先要解决的一个问题是：Node 如何调用 Java 提供的接口。首先，我们想到的就是 HTTP 的方式，这里说明一下，我们公司采用的分布式服务化框架是阿里开源的 Dubbo 框架，而 Dubbo 框架本身是支持通过添加注解的方式生成 Restful API 的，所以在初期，我们就是采用这个现成的方案。</p>\n<p>而随着应用数目的增加，这种方式的弊端也逐渐显现出来，主要有下面几点：</p>\n<ul>\n<li>如果某个接口需要暴露给 Node 使用，就需要手动再去添加额外的注解。</li>\n<li>每增加一个应用，运维都需要针对每个应用配置域名，不同的环境又需要配置不同的域名，所以随着应用数的增加，应用域名的管理越来越难维护。</li>\n<li>相应的，node 也需要维护一份很长的域名配置文件。</li>\n<li>由于 Java 是直接提供 HTTP 接口，所以性能上相对 RPC 的方式会低一点。</li>\n</ul>\n<p>所以，我们就调研了下，看其他公司在使用 Dubbo 框架时，Node 是如何调用 Java 的？如下图所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce4fa59a7c6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1216\" data-height=\"489\"><figcaption></figcaption></figure><p></p>\n<p>首先，Java 应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是 ETCD 或者 Zookeeper，然后，Node 应用在启动的时候，会先从服务注册中心拉取服务列表，接着 Node 会跟 Java 服务建立一条TCP长链接，除此之外，Node 还需要负责 Hession 协议解析以及负载均衡等。</p>\n<p>不难发现，这种方式 Node 的职责就比较重，而且对 Node 开发的要求会很高。所以，我们对这种方式做了改进，如下图所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce94f18acfa?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1029\" data-height=\"481\"><figcaption></figcaption></figure><p></p>\n<p>我们在 Node 和 Java 之间添加了一层中间代理层 Tether，Tether 是用 Go 语言写的一个本地代理，Tether 会对外暴露一个 HTTP 的服务，对 Node 来说，只需要通过 HTTP 方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由 Tether 来处理。这样，Node 这一层就非常轻量了，那么，最终实现出来，Node 是怎么调用 Java 服务的呢？如下代码所示：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> Service = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../base/BaseService'</span>);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoodsService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span> </span>{\n  <span class=\"hljs-comment\">/**\n   * 根据商品 alias 获取商品详情\n   * @param  {String} alias 商品 alias\n   */</span>\n  <span class=\"hljs-keyword\">async</span> getGoodsDetailByAlias(alias) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">this</span>.invoke(\n      <span class=\"hljs-string\">'com.youzan.ic.service.GoodsService'</span>,\n      <span class=\"hljs-string\">'getGoodsDetailByAlias'</span>,\n      [alias]\n    );\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n}\n<span class=\"hljs-built_in\">module</span>.exports = GoodsService;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>对 Node 来说，调用 Java 服务它只需要关注三个点：</p>\n<ul>\n<li>服务名：服务名是由 Java 的包名 + 类名组成，例如上面的 com.youzan.ic.service.GoodsService</li>\n<li>方法名：Java 类对外暴露的方法，例如上面代码所示的根据商品 alias 查询商品详情的一个方法 getGoodsDetailByAlias</li>\n<li>参数：参数就是传递给 Java 的参数列表</li>\n</ul>\n<p>最后，总结下这种方式都有哪些优点：</p>\n<ul>\n<li>第一个是使用简单，对前端开发非常友好，只需要通过 HTTP 方式调用本地的 Tether 服务即可；</li>\n<li>第二个是多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像 Node 一样，它们都只需要调用本地 Tether 暴露的 HTTP 服务即可，没有额外的开发成本了。</li>\n<li>第三个是后期更方便做协议层的优化，因为这种方式 Tether 其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化 Tether 的性能就可以了。</li>\n</ul>\n<p>那么，看到这里，有人可能又会想，这里 Node 也是通过 HTTP 方式调用 Java 的，性能上是不是也存在问题呢？所以这里我们就做了一些优化，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Agent = require(<span class=\"hljs-string\">'agentkeepalive'</span>);\n\nmodule.exports = new Agent({\n  maxSockets: 100,\n  maxFreeSockets: 10,\n  timeout: 60000,\n  freeSocketKeepAliveTimeout: 30000,\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里，我们引用了一个 agentkeepalive 包，在 HTTP 早期，每个 HTTP 请求都要求打开一个 TCP Socket 连接，并且使用一次之后就断开这个 TCP 连接，使用 keep-alive 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。所以通过使用 keep-alive 机制，就可以减少 TCP 连接建立次数。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">四、参考资料</h2>\n<p>https://github.com/apache/incubator-dubbo\nhttps://github.com/QianmiOpen/dubbo2.js\nhttps://github.com/QianmiOpen/dubbo-node-client\nhttps://github.com/p412726700/node-zookeeper-dubbo\nhttps://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cf039b468ca?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"640\" data-height=\"400\"><figcaption></figcaption></figure><p></p>\n</div>",
      "time": "2018年05月22日"
    },
    {
      "source": "juejin",
      "id": "zexdvrk39ps",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/5c1f8e52f265da6170071e43\"><meta itemprop=\"headline\" content=\"Node - 从0基础到实战企业官网\"><meta itemprop=\"keywords\" content=\"Node.js\"><meta itemprop=\"datePublished\" content=\"2018-12-23T14:01:44.166Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"jsliang\"><meta itemprop=\"url\" content=\"https://juejin.im/user/584613ba128fe10058b3cf68\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/5c1f8e52f265da6170071e43\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/5c1f8e52f265da6170071e43\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2018-12-23T14:01:44.166Z\" title=\"Sun Dec 23 2018 22:01:44 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2018年12月23日</time><span class=\"views-count\" data-v-648672b2>阅读 58716</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node - 从0基础到实战企业官网</h1><div data-id=\"5c1f95486fb9a049d05dbaad\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><blockquote>\n<p>Create by <strong>jsliang</strong> on <strong>2018-11-8 13:42:42</strong><br>\nRecently revised in <strong>2018-12-23 21:59:20</strong></p>\n</blockquote>\n<p>Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<br>\n<p> <span style=\"color:red\">【2019-08-16】Hello 小伙伴们，由于 <strong>jsliang</strong> 对文档库进行了重构，这篇文章的一些链接可能失效，而 <strong>jsliang</strong> 没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的 GitHub 地址，去文档库查看调整后的文章。</span></p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-0\">本文重点内容</h3>\n<ul>\n<li>Node 基础 - 通过对 Node 基础的了解学习，打下 Node 基础</li>\n<li>Node API - 开启服务提供 API 给前端调用</li>\n<li>Node 连接 MySQL - 通过 npm 安装 mysql，从而实现数据库的链接</li>\n<li>Node 实战 - 企业官网从 0 开始，打造能注册、登录以及留言的企业官网</li>\n<li>Node 部署 - 如何通过部署云服务器，让小伙伴们可以查看到你的网站</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">本文延伸链接</h3>\n<ul>\n<li>Node 部署项目、云服务器以及域名的使用：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 基础代码下载地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 成品代码下载地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">本文成品演示</h3>\n<ul>\n<li>Node 项目演示：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fcompany.jsliang.top%2F\" rel=\"nofollow noopener noreferrer\">jsliang 前端有限公司</a></li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47764ad7e47?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"726\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\"><a id=\"chapter-one\" name=\"chapter-one\">一 目录</a></h2>\n<p> <strong>不折腾的前端，和咸鱼有什么区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#chapter-one\">一 目录</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-two\" name=\"catalog-chapter-two\"></a><a href=\"#chapter-two\">二 前言</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-three\" name=\"catalog-chapter-three\"></a><a href=\"#chapter-three\">三 基础学习</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-one\" name=\"catalog-chapter-three-one\"></a><a href=\"#chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-two\" name=\"catalog-chapter-three-two\"></a><a href=\"#chapter-three-two\">3.2 URL 模块</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-three\" name=\"catalog-chapter-three-three\"></a><a href=\"#chapter-three-three\">3.3 CommonJS</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-four\" name=\"catalog-chapter-three-four\"></a><a href=\"#chapter-three-four\">3.4 包与 npm</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-five\" name=\"catalog-chapter-three-five\"></a><a href=\"#chapter-three-five\">3.5 fs 文件管理</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-six\" name=\"catalog-chapter-three-six\"></a><a href=\"#chapter-three-six\">3.6 fs 案例</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-seven\" name=\"catalog-chapter-three-seven\"></a><a href=\"#chapter-three-seven\">3.7 fs 流</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eight\" name=\"catalog-chapter-three-eight\"></a><a href=\"#chapter-three-eight\">3.8 创建 Web 服务器</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-night\" name=\"catalog-chapter-three-night\"></a><a href=\"#chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-ten\" name=\"catalog-chapter-three-ten\"></a><a href=\"#chapter-three-ten\">3.10 get 与 post</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eleven\" name=\"catalog-chapter-three-eleven\"></a><a href=\"#chapter-three-eleven\">3.11 Node 连接 MySQL</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-four\" name=\"catalog-chapter-four\"></a><a href=\"#chapter-four\">四 Web 实战 —— 企业官网</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-one\" name=\"catalog-chapter-four-one\"></a><a href=\"#chapter-four-one\">4.1 编程环境</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-two\" name=\"catalog-chapter-four-two\"></a><a href=\"#chapter-four-two\">4.2 后端接口</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-three\" name=\"catalog-chapter-four-three\"></a><a href=\"#chapter-four-three\">4.3 注册功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-four\" name=\"catalog-chapter-four-four\"></a><a href=\"#chapter-four-four\">4.4 登录功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-five\" name=\"catalog-chapter-four-five\"></a><a href=\"#chapter-four-five\">4.5 留言功能</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-five\" name=\"catalog-chapter-five\"></a><a href=\"#chapter-five\">五 工具整合</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-one\" name=\"catalog-chapter-five-one\"></a><a href=\"#chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-two\" name=\"catalog-chapter-five-two\"></a><a href=\"#chapter-five-two\">5.2 PM2 - Node 进程管理</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-six\" name=\"catalog-chapter-six\"></a><a href=\"#chapter-six\">六 参考资料</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-seven\" name=\"catalog-chapter-seven\"></a><a href=\"#chapter-seven\">七 线上部署</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-eight\" name=\"catalog-chapter-eight\"></a><a href=\"#chapter-eight\">八 归纳总结</a></td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-4\"><a id=\"chapter-two\" name=\"chapter-two\">二 前言</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-two\">返回目录</a></p>\n</blockquote>\n<p> 本文主要目的：</p>\n<ol>\n<li>整合 Node 基础，加深 <strong>jsliang</strong> 对 Node 的学习了解，并且方便日后复习。</li>\n<li>整合 Node 工具，方便查找在 Node 开发中，有哪些工具比较有利于开发。</li>\n<li>给初学 Node 的小伙伴做一个参考，如有疑问还请在 QQ 群：<code>798961601</code> 中咨询。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-5\"><a id=\"chapter-three\" name=\"chapter-three\">三 基础</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-three\">返回目录</a></p>\n</blockquote>\n<p> <strong>万丈高楼平地起，地基还得自己起。</strong></p>\n<h3 class=\"heading\" data-id=\"heading-6\"><a id=\"chapter-three-one\" name=\"chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-one\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>01_http.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 2. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面代码，我们要怎么用呢？</p>\n<p> <strong>首先</strong>，将上面的代码复制粘贴到 <code>01_http.js</code> 中。<br>\n <strong>然后</strong>，启动 VS Code 终端：<code>Ctrl + ~</code>。<br>\n <strong>接着</strong>，输入 <code>node 01_http.js</code> 并回车。<br>\n <strong>最后</strong>，打开 <code>localhost:3000</code>：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47a578759c4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"660\" data-height=\"500\"><figcaption></figcaption></figure><p></p>\n<p> OK，搞定完事，现在我们一一讲解上面代码：</p>\n<ol>\n<li><strong>首先</strong>，我们需要先开启仙人模式。哦，不是，是 HTTP 模式。我们都知道，像 PHP 这类老牌子的后端语言，需要 Apache 或者 Nginx 开启 HTTP 服务。然而我们的 Node 不需要：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li><strong>然后</strong>，开启 HTTP 服务，并设置开启的端口：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 步骤 3 代码\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li><strong>接着</strong>，我们设置 HTTP 头部，并往页面打印值，最后结束响应：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\nres.writeHead(200, {\n  <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n});\n\n// 往页面打印值\nres.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n// 结束响应 \nres.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><strong>最后</strong>，我们往浏览器输入 <code>http://localhost:3000/</code>，将访问到我们开启的 Node 服务，从而往页面渲染页面。</li>\n</ol>\n<p> 至此，小伙伴们是不是也开启了自己的 Node 之旅？</p>\n<h3 class=\"heading\" data-id=\"heading-7\"><a id=\"chapter-three-two\" name=\"chapter-three-two\">3.2 URL 模块</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-two\">返回目录</a></p>\n</blockquote>\n<p> URL 模块是什么呢？<br>\n 我们在控制台（终端）开启 Node 模式，并打印出 <code>url</code> 来看一下：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db481725e04bb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"509\" data-height=\"230\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，它有 <code>Url</code>、<code>parse</code>、<code>resolve</code>、<code>resolveObject</code>、<code>format</code>、<code>URL</code>、<code>URLSearchParams</code>、<code>domainToASCII</code>、<code>domainToUnicode</code> 这么多模块。<br>\n 那么，这些模块都有什么用呢？</p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>02_url.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 4. 获取服务器请求\n  /**\n   * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n   * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n   * /  ?userName=jsliang&userAge=23\n   * /  /favicon.ico\n   * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n   */\n  <span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    \n    // 5. 使用 url 的 parse 方法\n    /**\n     * parse 方法需要两个参数：\n     * 第一个参数是地址\n     * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n     */ \n    var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n    console.log(result);\n    /**\n     * Url {\n     *   protocol: null,\n     *   slashes: null,\n     *   auth: null,\n     *   host: null,\n     *   port: null,\n     *   hostname: null,\n     *   <span class=\"hljs-built_in\">hash</span>: null,\n     *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n     *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n     *   pathname: <span class=\"hljs-string\">'/'</span>,\n     *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n     *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n     */\n\n    console.log(result.query.userName); // jsliang\n\n    console.log(result.query.userAge); // 23\n  }\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的代码中：</p>\n<p> <strong>首先</strong>，我们引入该章节的主角 <code>url</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>然后</strong>，我们引入 <code>http</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>接着</strong>，我们创建 <code>http</code> 模块，因为 <code>url</code> 的监听，需要 <code>http</code> 模块的开启：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 第 4 步、第 5 步代码\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们访问我们给出的地址：<code>http://localhost:3000/?userName=jsliang&userAge=23</code>，并通过它查看 <code>url</code> 的 <code>parse</code> 模块怎么用，输出啥：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 4. 获取服务器请求\n/**\n  * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n  * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n  * /  ?userName=jsliang&userAge=23\n  * /  /favicon.ico\n  * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n  */\n<span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n  \n  // 5. 使用 url 的 parse 方法\n  /**\n    * parse 方法需要两个参数：\n    * 第一个参数是地址\n    * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n    */ \n  var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n  console.log(result);\n  /**\n    * Url {\n    *   protocol: null,\n    *   slashes: null,\n    *   auth: null,\n    *   host: null,\n    *   port: null,\n    *   hostname: null,\n    *   <span class=\"hljs-built_in\">hash</span>: null,\n    *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n    *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n    *   pathname: <span class=\"hljs-string\">'/'</span>,\n    *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n    *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n    */\n\n  console.log(result.query.userName); // jsliang\n\n  console.log(result.query.userAge); // 23\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 从中，我们可以看出，我们可以通过 <code>query</code>，获取到我们想要的路径字段。</p>\n<p> 当然，上面只讲解了 <code>parse</code> 的用法，我们可以将上面代码中 <code>if</code> 语句里面的代码全部清空。然后，输入下面的内容，去学习 <code>url</code> 模块更多的内容：</p>\n<ol>\n<li>url 模块所有内容：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url);\n\n/**\n * Console：\n { \n   Url: [Function: Url],\n    parse: [Function: urlParse], // 获取地址信息\n    resolve: [Function: urlResolve], // 追加或者替换地址\n    resolveObject: [Function: urlResolveObject],\n    format: [Function: urlFormat], // 逆向 parse，根据地址信息获取原 url 信息\n    URL: [Function: URL],\n    URLSearchParams: [Function: URLSearchParams],\n    domainToASCII: [Function: domainToASCII],\n    domainToUnicode: [Function: domainToUnicode] \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>parse 如何使用</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com\"</span>));\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: null,\n    query: null,\n    pathname: <span class=\"hljs-string\">'/'</span>,\n    path: <span class=\"hljs-string\">'/'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>parse 带参数：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com/new?name=zhangsan\"</span>));\n\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n    query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n    pathname: <span class=\"hljs-string\">'/new'</span>,\n    path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><code>format</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.format({\n  protocol: <span class=\"hljs-string\">'http:'</span>,\n  slashes: <span class=\"hljs-literal\">true</span>,\n  auth: null,\n  host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  port: null,\n  hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  <span class=\"hljs-built_in\">hash</span>: null,\n  search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n  query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n  pathname: <span class=\"hljs-string\">'/new'</span>,\n  path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n  href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n}))\n\n// Console：\n// http://www.baidu.com/new?name=zhangsan\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li><code>resolve</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.resolve(<span class=\"hljs-string\">\"http://www.baidu.com/jsliang\"</span>, <span class=\"hljs-string\">\"梁峻荣\"</span>));\n\n// Console：\n// http://www.baidu.com/梁峻荣\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，<code>url</code> 这里我们只讲解了个入门，更多的还请看官网 API：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Furl.html%23url_class_url\" rel=\"nofollow noopener noreferrer\">url | Node.js v10.14.1 文档</a></p>\n<h3 class=\"heading\" data-id=\"heading-8\"><a id=\"chapter-three-three\" name=\"chapter-three-three\">3.3 CommonJS</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-three\">返回目录</a></p>\n</blockquote>\n<ul>\n<li>什么是 CommonJS？</li>\n</ul>\n<p> CommonJS 就是为 JS 的表现来制定规范，因为 JS 没有模块系统、标准库较少、缺乏包管理工具，所以 CommonJS 应运而生，它希望 JS 可以在任何地方运行，而不只是在浏览器中，从而达到 Java、C#、PHP 这些后端语言具备开发大型应用的能力。</p>\n<ul>\n<li>CommonJS 的应用？</li>\n</ul>\n<ol>\n<li>服务器端 JavaScript 应用程序。（Node.js）</li>\n<li>命令行工具</li>\n<li>桌面图形界面应用程序。</li>\n</ol>\n<ul>\n<li>CommonJS 与 Node.js 的关系？</li>\n</ul>\n<p> CommonJS 就是模块化的标准，Node.js 就是 CommonJS（模块化）的实现。</p>\n<ul>\n<li>Node.js 中的模块化？</li>\n</ul>\n<ol>\n<li>在 Node 中，模块分为两类：一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP 模块、URL 模块、FS 模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。</li>\n<li>我们可以将公共的功能抽离出一个单独的 JS 文件存放，然后在需要的情况下，通过 exports 或者 module.exports 将模块导出，并通过 require 引入这些模块。</li>\n</ol>\n<p> 现在，我们通过三种使用方式，来讲解下 Node 中的模块化及 exports/require 的使用。</p>\n<p> 我们先查看下目录：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4838b82f804?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"227\" data-height=\"381\"><figcaption></figcaption></figure><p></p>\n<p> <strong>方法一</strong>：</p>\n<p> 首先，我们新建 <code>03_CommonJS.js</code>、<code>03_tool-add.js</code>、<code>node_modules/03_tool-multiply.js</code>、<code>node_modules/jsliang-module/tools.js</code> 这 4 个文件/文件夹。<br>\n 其中 <code>package.json</code> 我们暂且不理会，稍后会讲解它如何自动生成。</p>\n<p> 在 <code>03_tool-add.js</code> 中：</p>\n<blockquote>\n<p>03_tool-add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 假设我们文件其中有个工具模块\nvar tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\n/**\n * 2. 暴露模块\n * exports.str = str;\n * module.exports = str;\n * 区别：\n * module.exports 是真正的接口\n * exports 是一个辅助工具\n * 如果 module.exports 为空，那么所有的 exports 收集到的属性和方法，都赋值给了 module.exports\n * 如果 module.exports 具有任何属性和方法，则 exports 会被忽略\n */\n\n// exports 使用方法\n// var str = <span class=\"hljs-string\">\"jsliang is very good!\"</span>;\n// exports.str = str; // { str: <span class=\"hljs-string\">'jsliang is very good!'</span> }\n\n// module.exports 使用方法\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面的代码有啥含义呢？<br>\n 第一步，我们定义了个工具库 <code>tools</code>。<br>\n 第二步，我们通过 <code>modules.exports</code> 将 <code>tools</code> 进行了导出。<br>\n 所以，我们在 <code>03_CommonJS.js</code> 可以通过 <code>require</code> 导入使用：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  /**\n   * Console：\n   * 6\n   * 6\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就完成了 <code>exports</code> 与 <code>require</code> 的初次使用。</p>\n<p> <strong>方法二</strong>：</p>\n<p> 当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node 就很靠谱，它规范我们可以将这些文件都放在 <code>node_modules</code> 目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。</p>\n<p> 所以，我们在 <code>node_modules</code> 中新建一个 <code>03_tool-multiply.js</code> 文件，其内容如下：</p>\n<blockquote>\n<p>03_tool-multiply.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在引用方面，我们只需要通过：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\nconsole.log(tools2.multiply(1, 2, 3, 4));\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，就可以成功导入 <code>03_tool-multiply.js</code> 文件了。</p>\n<p> <strong>方法三</strong>：</p>\n<p> 如果全部单个文件丢在 <code>node_modules</code> 上，它会显得杂乱无章，所以我们应该定义个自己的模块：<code>jsliang-module</code>，然后将我们的 <code>tools.js</code> 存放在该目录中：</p>\n<blockquote>\n<p>jsliang-module/tools.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  },\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就定义好了自己的工具库。<br>\n 但是，如果我们通过 <code>var tools3 = require('jsliang-module');</code> 去导入，会发现它报 <code>error</code> 了，所以，我们应该在 <code>jsliang-module</code> 目录下，通过下面命令行生成一个 <code>package.json</code></p>\n<blockquote>\n<p>PS E:\\MyWeb\\node_modules\\jsliang-module> npm init --yes</p>\n</blockquote>\n<p> 这样，在 <code>jsliang-module</code> 中就有了 <code>package.json</code>。<br>\n 而我们在 <code>03_CommonJS.js</code> 就可以引用它了：</p>\n<blockquote>\n<p>03_CommonJS.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\n// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\n/**\n * 通过 package.json 来引用文件\n * 1. 通过在 jsliang-module 中 npm init --yes 来生成 package.json 文件\n * 2. package.json 文件中告诉了程序入口文件为 ：<span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"tools.js\"</span>,\n * 3. Node 通过 require 查找 jsliang-module，发现它有个 package.json\n * 4. Node 执行 tools.js 文件\n */\nvar tools3 = require(<span class=\"hljs-string\">'jsliang-module'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  console.log(tools2.multiply(1, 2, 3, 4));\n  console.log(tools3.add(4, 5, 6));\n  /**\n   * Console：\n   * 6\n   * 24\n   * 15\n   * 6\n   * 24\n   * 15\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 到此，我们就通过三种方法，了解了各种 <code>exports</code> 和 <code>require</code> 的姿势以及 Node 模块化的概念啦~</p>\n<p> 参考文献：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Flittlebirdlbw%2Fp%2F5670633.html\" rel=\"nofollow noopener noreferrer\">CommonJS 规范 | 博客园 - Little Bird</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fchenguangliang%2Fp%2F5856701.html\" rel=\"nofollow noopener noreferrer\">js模块化编程之彻底弄懂CommonJS和AMD/CMD！ | 博客园 - 方便以后复习</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fghostwu%2Fp%2F7298462.html\" rel=\"nofollow noopener noreferrer\">[js高手之路] es6系列教程 - 不定参数与展开运算符(...) | 博客园 - ghostwu</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-9\"><a id=\"chapter-three-four\" name=\"chapter-three-four\">3.4 包与 npm</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-four\">返回目录</a></p>\n</blockquote>\n<p> Node 中除了它自己提供的核心模块之外，还可以自定义模块，以及使用 <strong>第三方模块</strong>。<br>\n Node 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4863f64fe3c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"822\" data-height=\"468\"><figcaption></figcaption></figure><p></p>\n<p> 那么，假如我们需要使用一些第三方模块，应该去哪找呢？</p>\n<ol>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.baidu.com\" rel=\"nofollow noopener noreferrer\">百度</a>。百度查找你需要安装的第三方模块的对应内容。</li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2F\" rel=\"nofollow noopener noreferrer\">npm 官网</a>。如果你已经知道包的名字或者包的作用。那么，直接在 npm 官网上搜索，想必会更快找到想要安装的包。</li>\n</ol>\n<p> 那么，npm 是啥？<br>\n npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。<br>\n 在我们安装 Node 的时候，它默认会顺带给你安装 npm。</p>\n<ul>\n<li><code>npm -v</code>：查看 npm 版本。</li>\n<li><code>npm list</code>：查看当前目录下都安装了哪些 npm 包。</li>\n<li><code>npm info 模块</code>：查看该模块的版本及内容。</li>\n<li><code>npm i 模块@版本号</code>：安装该模块的指定版本。</li>\n</ul>\n<p> 在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识：</p>\n<ul>\n<li><code>i</code>/<code>install</code>：安装。使用 <code>install</code> 或者它的简写 <code>i</code>，都表明你想要下载这个包。</li>\n<li><code>uninstall</code>：卸载。如果你发现这个模块你已经不使用了，那么可以通过 <code>uninstall</code> 卸载它。</li>\n<li><code>g</code>：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。</li>\n<li><code>--save</code>/<code>-S</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>dependencies</code> 中。<code>dependencies</code> 是需要发布在生成环境的。例如：<code>ElementUI</code> 是部署后还需要的，所以通过 <code>-S</code> 形式来安装。</li>\n<li><code>--save-dev</code>/<code>-D</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>devDependencies</code> 中。<code>devDependencies</code> 只在开发环境使用。例如：<code>gulp</code> 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 <code>-D</code> 形式来安装。</li>\n</ul>\n<p> 例子：</p>\n<ul>\n<li><code>cnpm i webpack-cli -D</code></li>\n<li><code>npm install element-ui -S</code></li>\n</ul>\n<p> 那么，这么多的 npm 包，我们通过什么管理呢？<br>\n 答案是 <code>package.json</code>。<br>\n 如果我们需要创建 <code>package.json</code>，那么我们只需要在指定的包管理目录（例如 <code>node_modules</code>）中通过以下命名进行生成：</p>\n<ul>\n<li><code>npm init</code>：按步骤创建 <code>package.json</code>。</li>\n<li><code>npm init --yes</code>：快速创建 <code>package.json</code></li>\n</ul>\n<p> 当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm</p>\n<ul>\n<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-10\"><a id=\"chapter-three-five\" name=\"chapter-three-five\">3.5 fs 文件管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-five\">返回目录</a></p>\n</blockquote>\n<p> 本章节我们讲解下 fs 文件管理：</p>\n<blockquote>\n<p>如需快速找到下面某个内容，请使用 <code>Ctrl + F</code></p>\n</blockquote>\n<ol>\n<li><code>fs.stat</code> 检测是文件还是目录</li>\n<li><code>fs.mkdir</code> 创建目录</li>\n<li><code>fs.writeFile</code> 创建写入文件</li>\n<li><code>fs.appendFile</code> 追加文件</li>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n<li><code>fs.rename</code> 重命名</li>\n<li><code>fs.rmdir</code> 删除目录</li>\n<li><code>fs.unlink</code> 删除文件</li>\n</ol>\n<blockquote>\n<p>此章节文件目录：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4943495aae8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"228\" data-height=\"373\"><figcaption></figcaption></figure><p></p>\n<p> <strong>首先</strong>，我们通过 <code>fs.stat</code> 检查一个读取的是文件还是目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  1. fs.stat\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\nfs.stat(<span class=\"hljs-string\">'index.js'</span>, (error, stats) => {\n  <span class=\"hljs-keyword\">if</span>(error) {\n    console.log(error);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(stats);\n    /**\n     * Console：\n     * Stats {\n     *  dev: 886875,\n     *  mode: 33206,\n     *  nlink: 1,\n     *  uid: 0,\n     *  gid: 0,\n     *  rdev: 0,\n     *  blksize: undefined,\n     *  ino: 844424931461390,\n     *  size: 284,\n     *  blocks: undefined,\n     *  atimeMs: 1542847157494,\n     *  mtimeMs: 1543887546361.2158,\n     *  ctimeMs: 1543887546361.2158,\n     *  birthtimeMs: 1542847157493.663,\n     *  atime: 2018-11-22T00:39:17.494Z,\n     *  mtime: 2018-12-04T01:39:06.361Z,\n     *  ctime: 2018-12-04T01:39:06.361Z,\n     *  birthtime: 2018-11-22T00:39:17.494Z }\n     */\n\n    console.log(`文件：<span class=\"hljs-variable\">${stats.isFile()}</span>`); \n    // Console：文件：<span class=\"hljs-literal\">true</span>\n    \n    console.log(`目录：<span class=\"hljs-variable\">${stats.isDirectory()}</span>`); \n    // Console：目录：<span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>Console</code> 打印出来的信息，我们基础掌握了 <code>fs.stat</code> 的作用。</p>\n<p> <strong>然后</strong>，我们尝试通过 <code>fs.mkdir</code> 创建目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  2. fs.mkdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.mkdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中多了一个 <code>css</code> 文件夹。</p>\n<p> <strong>那么</strong>，有创建就有删除，创建的目录如何删除呢？这里讲解下 <code>fs.rmdir</code>：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  8. fs.rmdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.rmdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中的 <code>css</code> 文件夹被删除了。</p>\n<p> <strong>接着</strong>，我们通过 <code>fs.writeFile</code> 来创建写入文件：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  3. fs.writeFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * filename (String) 文件名称\n * data (String | Buffer) 将要写入的内容，可以是字符串或者 buffer 数据。\n * · encoding (String) 可选。默认 <span class=\"hljs-string\">'utf-8'</span>，当 data 是 buffer 时，该值应该为 ignored。\n * · mode (Number) 文件读写权限，默认 438。\n * · flag (String) 默认值 <span class=\"hljs-string\">'w'</span>。\n * callback { Function } 回调，传递一个异常参数 err。\n */\nfs.writeFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'Hello jsliang'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">'写入成功！'</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加 <code>Hello jsliang</code> 这句话。即：存在即覆盖，不存在即创建。</p>\n<p> 有创建就有删除，感兴趣的可以使用 <code>fs.unlink</code> 进行文件的删除，再次不做过多讲解。</p>\n<p> <strong>既然</strong>，上面的是覆盖文件，那么有没有追加文件呢？有的，使用 <code>fs.appendFile</code> 吧：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  4. fs.appendFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\nfs.appendFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'这段文本是要追加的内容'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"追加成功\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就成功往里面追加了一段话，从而使 <code>index.js</code> 变成了：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Hello jsliang这段文本是要追加的内容\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>在上面</strong>，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了：</p>\n<ul>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n</ul>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 5. fs.readFile\nfs.readFile(<span class=\"hljs-string\">'index.js'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取文件成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取文件成功！\n    // <Buffer 48 65 6c 6c 6f 20 6a 73 6c 69 61 6e 67 e8 bf 99 e6 ae b5 e6 96 87 e6 9c ac e6 98 af e8 a6 81 e8 bf bd e5 8a a0 e7 9a 84 e5 86 85 e5 ae b9>\n  }\n})\n\n// 6. fs.readdir 读取目录\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取目录成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取目录成功！\n    // [ <span class=\"hljs-string\">'03_tool-multiply.js'</span>, <span class=\"hljs-string\">'jsliang-module'</span> ]\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如上，我们成功做到了读取文件和读取目录。</p>\n<p> <strong>最后</strong>，我们再回顾一开始的目标：</p>\n<p><s>1. <code>fs.stat</code> 检测是文件还是目录</s><br>\n<s>2. <code>fs.mkdir</code> 创建目录</s><br>\n<s>3. <code>fs.writeFile</code> 创建写入文件</s><br>\n<s>4. <code>fs.appendFile</code> 追加文件</s><br>\n<s>5. <code>fs.readFile</code> 读取文件</s><br>\n<s>6. <code>fs.readdir</code> 读取目录</s><br>\n7. <code>fs.rename</code> 重命名<br>\n<s>8. <code>fs.rmdir</code> 删除目录</s><br>\n<s>9. <code>fs.unlink</code> 删除文件</s></p>\n<p> 很好，我们就剩下重命名了：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"重命名成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，如果 <code>fs.rename</code> 还有更劲爆的功能：剪切</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'jsliang.js'</span>, <span class=\"hljs-string\">'node_modules/jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"剪切成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> OK，通通搞定，现在目录变成了：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4968b350f54?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"231\" data-height=\"329\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\"><a id=\"chapter-three-six\" name=\"chapter-three-six\">3.6 fs 案例</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-six\">返回目录</a></p>\n</blockquote>\n<p> 在上一章节中，我们了解了 <code>fs</code> 的文件管理。<br>\n 那么，在这里，我们尝试使用 <code>fs</code> 做点小事情：</p>\n<blockquote>\n<p>06_fsDemo.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * 1. fs.stat 检测是文件还是目录\n * 2. fs.mkdir 创建目录\n * 3. fs.writeFile 创建写入文件\n * 4. fs.appendFile 追加文件\n * 5. fs.readFile 读取文件\n * 6. fs.readdir 读取目录\n * 7. fs.rename 重命名\n * 8. fs.rmdir 删除目录\n * 9. fs.unlink 删除文件\n */\n\n// 1. 判断服务器上面有没有 upload 目录，没有就创建这个目录\n// 2. 找出 html 目录下面的所有的目录，然后打印出来\n\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 图片上传\nfs.stat(<span class=\"hljs-string\">'upload'</span>, (err, stats) => {\n  // 判断有没有 upload 目录\n  <span class=\"hljs-keyword\">if</span>(err) {\n    // 如果没有\n    fs.mkdir(<span class=\"hljs-string\">'upload'</span>, (error) => {\n      <span class=\"hljs-keyword\">if</span>(error) {\n        console.log(error);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"创建 upload 目录成功！\"</span>);\n      }\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    // 如果有\n    console.log(stats.isDirectory());\n    console.log(<span class=\"hljs-string\">\"有 upload 目录，你可以做更多操作！\"</span>);\n  }\n})\n\n// 读取目录全部文件\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, files) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    // 判断是目录还是文件夹\n    console.log(files);\n\n    <span class=\"hljs-built_in\">let</span> filesArr = [];\n\n    (<span class=\"hljs-keyword\">function</span> getFile(i) {\n      \n      // 循环结束\n      <span class=\"hljs-keyword\">if</span>(i == files.length) {\n        // 打印出所有目录\n        console.log(<span class=\"hljs-string\">\"目录：\"</span>);\n        console.log(filesArr);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      // 判断目录是文件还是文件夹\n      fs.stat(<span class=\"hljs-string\">'node_modules/'</span> + files[i], (error, stats) => {\n\n        <span class=\"hljs-keyword\">if</span>(stats.isDirectory()) {\n          filesArr.push(files[i]);\n        }\n\n        // 递归调用\n        getFile(i+1);\n        \n      })\n    })(0)\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-12\"><a id=\"chapter-three-seven\" name=\"chapter-three-seven\">3.7 fs 流</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-seven\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，我们了解下 <code>fs</code> 流及其读取：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 新建 fs\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\n// 流的方式读取文件\n<span class=\"hljs-built_in\">let</span> fileReadStream = fs.createReadStream(<span class=\"hljs-string\">'index.js'</span>);\n// 读取次数\n<span class=\"hljs-built_in\">let</span> count = 0;\n// 保存数据\n<span class=\"hljs-built_in\">let</span> str = <span class=\"hljs-string\">''</span>;\n// 开始读取\nfileReadStream.on(<span class=\"hljs-string\">'data'</span>, (chunk) => {\n  console.log(`<span class=\"hljs-variable\">${++count}</span> 接收到：<span class=\"hljs-variable\">${chunk.length}</span>`);\n  // Console：1 接收到：30\n  str += chunk;\n})\n// 读取完成\nfileReadStream.on(<span class=\"hljs-string\">'end'</span>, () => {\n  console.log(<span class=\"hljs-string\">\"——结束——\"</span>);\n  console.log(count);\n  console.log(str);\n\n  // Console：——结束——\n  // 1\n  // console.log(<span class=\"hljs-string\">\"Hello World！\"</span>);\n})\n// 读取失败\nfileReadStream.on(<span class=\"hljs-string\">'error'</span>, (error) => {\n  console.log(error);\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，我们通过 <code>fs</code> 模块的 <code>createReadStream</code> 创建了读取流，然后读取文件 <code>index.js</code>，从而最后在控制台输出了：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">1 接收到：259\n——结束——\n1\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 其中 <code>console.log()</code> 那三行就是 <code>index.js</code> 的文本内容。</p>\n<p> 然后，我们试下流的存入：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-built_in\">let</span> data = <span class=\"hljs-string\">'console.log(\"Hello World! 我要存入数据！\")'</span>;\n\n// 创建一个可以写入的流，写入到文件 index.js 中\n<span class=\"hljs-built_in\">let</span> writeStream = fs.createWriteStream(<span class=\"hljs-string\">'index.js'</span>);\n// 开始写入\nwriteStream.write(data, <span class=\"hljs-string\">'utf8'</span>);\n// 写入完成\nwriteStream.end();\nwriteStream.on(<span class=\"hljs-string\">'finish'</span>, () => {\n  console.log(<span class=\"hljs-string\">'写入完成！'</span>);\n  // Console：写入完成\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们打开 <code>index.js</code>，会发现里面的内容变成了 <code>console.log(\"Hello World! 我要存入数据！\")</code>，依次，我们通过流的形式进行了读取和写入的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-13\"><a id=\"chapter-three-eight\" name=\"chapter-three-eight\">3.8 创建 Web 服务器</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eight\">返回目录</a></p>\n</blockquote>\n<p> 在这里，我们利用 http 模块、url 模块、path 模块、fs 模块创建一个 Web 服务器。</p>\n<p> 什么是 Web 服务器？<br>\n Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。</p>\n<p> 下面，我们使用 Node 来创建一个 Web 服务：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db499027a9b6a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"240\" data-height=\"580\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\nhttp.createServer((req, res) => {\n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        \n        // 如果不存在这个文件\n        \n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(<span class=\"hljs-string\">'./08_WebService/404.html'</span>, (errorNotFound, dataNotFound) => {\n          <span class=\"hljs-keyword\">if</span>(errorNotFound) {\n            console.log(errorNotFound);\n          } <span class=\"hljs-keyword\">else</span> {\n            res.writeHead(200, {\n              <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n            });\n            // 读取写入文件\n            res.write(dataNotFound);\n            // 结束响应\n            res.end();\n          }\n        })\n        <span class=\"hljs-built_in\">return</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n\n        // 返回这个文件\n        \n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们在浏览器输入 <code>localhost:8080</code> 即可以看到：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db49cdf6207cf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1220\" data-height=\"1080\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，感情它就加载了整个 <code>index.html</code> 文件，连 CSS 这些没引入么？<br>\n 所以，下一步，我们要动态加载 <code>html</code>、<code>css</code> 以及 <code>js</code>：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  switch(extName) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.html'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.css'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/css'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.js'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/js'</span>;\n    default: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，当我们再次请求的时候，浏览器就变成了：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4a2ba76f9ad?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"720\"><figcaption></figcaption></figure><p></p>\n<p> 当然，在上面，我们仅仅模拟了 <code>html</code>、<code>css</code>、<code>js</code> 这三种文件类型而已，我们需要模拟更多的文件类型：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Fblob%2Fmaster%2FNodeBase%2F08_ext.json\" rel=\"nofollow noopener noreferrer\"> 08_ext.json</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> 代码详情请点击上面的链接\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的 <code>json</code> 文件中，我们定义了各种的文件类型，此刻文件目录如下所示：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4ab7f829e99?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"236\" data-height=\"422\"><figcaption></figcaption></figure><p></p>\n<p> 这时候，我们需要修改下我们的 <code>js</code> 文件，让它适应多种请求响应了：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n        console.log(ext);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  // <span class=\"hljs-built_in\">read</span>File 是异步操作，所以需要使用 <span class=\"hljs-built_in\">read</span>FileSync\n  <span class=\"hljs-built_in\">let</span> data = fs.readFileSync(<span class=\"hljs-string\">'./08_ext.json'</span>);\n  <span class=\"hljs-built_in\">let</span> ext = JSON.parse(data.toString());\n  <span class=\"hljs-built_in\">return</span> ext[extName];\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们做了个简单的 Web 服务器。</p>\n<h3 class=\"heading\" data-id=\"heading-14\"><a id=\"chapter-three-night\" name=\"chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-night\">返回目录</a></p>\n</blockquote>\n<p> Java、PHP 或者 .NET 等服务端语言，会为每一个客户端的连接创建一个新的线程。<br>\n Node 不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。<br>\n 当有用户连接了，就会触发一个内部事件，通过非租塞 I/O、事件驱动机制，让 Node 程序宏观上也是并行的。<br>\n 使用 Node，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。</p>\n<p> 在这一章节中，主要解决：</p>\n<ol>\n<li>Node 的非阻塞 I/O 是什么？</li>\n<li>Node events 模块是什么？</li>\n</ol>\n<p> 首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"2\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 2\n * 3\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 但是，事与愿违。<br>\n 我们有时候，会执行一些异步方法（函数）：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\n// console.log(<span class=\"hljs-string\">\"2\"</span>);\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    console.log(<span class=\"hljs-string\">\"2\"</span>);\n  })\n}\ngetExt();\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 3\n * 2\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面代码中，由于 <code>fs.readFile</code> 是 Node 的异步函数。所以，程序先执行了 1 和 3，最后才执行 <code>fs.readFile</code> 的 2 部分。</p>\n<blockquote>\n<p>在这里，可以看出 Node 不会因为一段代码的逻辑错误，从而导致其他代码无法运行。</p>\n</blockquote>\n<p> 这样子，就导致了一个问题：步骤 3 可能拿不到步骤 2 的执行结果了！这就是 Node 的非租塞性 I/O 驱动。<br>\n 那么，我们有没有办法解决这个问题呢？<br>\n 有的！</p>\n<ol>\n<li>通过回调函数</li>\n<li>通过 Node 的 <code>events</code> 模块</li>\n</ol>\n<p> 首先，我们通过回调函数来解决这个异步问题：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\ngetExt = (callback) => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    callback(data);\n  })  \n}\n\ngetExt( (result) => {\n  console.log(result.toString());\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过回调，我们可以将 <code>getExt</code> 的数据提取出来。</p>\n<p> 然后，我们通过 Node 的 <code>events</code> 模块来解决这个异步问题：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n/**\n * Node 事件循环：\n * 1. Node 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。\n * 2. Node 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。\n * 3. Node 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。\n */\n\n// 引入 events 模块\n<span class=\"hljs-built_in\">let</span> events = require(<span class=\"hljs-string\">\"events\"</span>);\n// 实例化事件对象\n<span class=\"hljs-built_in\">let</span> EventEmitter = new events.EventEmitter();\n\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    // 将 data 广播出去\n    EventEmitter.emit(<span class=\"hljs-string\">'data'</span>, data.toString());\n  })  \n};\n\ngetExt();\n\n// 监听 data\nEventEmitter.on(<span class=\"hljs-string\">'data'</span>, (ext) => {\n  console.log(ext);\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，<code>EventEmitter.on</code> 通过监听 <code>data</code> 的形式，获取了 <code>getExt</code> 内部的执行结果。<br>\n 如此，我们就了解了 Node 的 I/O 事件及 <code>events</code> 模块</p>\n<h3 class=\"heading\" data-id=\"heading-15\"><a id=\"chapter-three-ten\" name=\"chapter-three-ten\">3.10 get 与 post</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-ten\">返回目录</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4adefcf3363?imageslim\" data-width=\"970\" data-height=\"618\"><figcaption></figcaption></figure><p></p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 加载 http 模块\nvar http = require(<span class=\"hljs-string\">'http'</span>);\n\n// 虚拟 SQL 读取出来的数据\nvar items = [];\n\n// 创建 http 服务\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  \n  // 设置跨域的域名，* 代表允许任意域名跨域\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  // 判断请求\n  switch (req.method) {\n    \n    // post 请求时，浏览器会先发一次 options 请求，如果请求通过，则继续发送正式的 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'OPTIONS'</span>:\n      res.statusCode = 200;\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n    \n      // 如果是 get 请求，则直接返回 items 数组\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'GET'</span>:\n      <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n      res.write(data);\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n      \n    // 如果是 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'POST'</span>:\n      <span class=\"hljs-built_in\">let</span> item = <span class=\"hljs-string\">''</span>;\n      // 读取每次发送的数据\n      req.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n        item += chunk;\n      });\n      // 数据发送完成\n      req.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 存入\n        item = JSON.parse(item);\n        items.push(item.item);\n        // 将数据返回到客户端\n        <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n        res.write(data);\n        res.end();\n      });\n      <span class=\"hljs-built_in\">break</span>;\n  }\n}).listen(3000)\n\nconsole.log(<span class=\"hljs-string\">'http server is start...'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们加载了 <code>http</code> 模块，并创建了服务。<br>\n <strong>然后</strong>，我们设置了跨域的处理方式，允许进行跨域。<br>\n <strong>接着</strong>，我们进行了请求的判断处理，由于只做简单演练，故只判断是 <code>get</code> 请求还是 <code>post</code> 请求。<br>\n <strong>最后</strong>，我们将请求的结果返回给客户端。</p>\n<p> 在上面，我们进行了后端 Node 的部署，那么前端页面要怎么做呢？</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-⌃-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>Node Web</title>\n\n</head>\n\n<body>\n\n  <div id=<span class=\"hljs-string\">\"app\"</span>>\n    <h1>Todo List</h1>\n    <ul>\n      <li v-for=<span class=\"hljs-string\">\"(item, index) in items\"</span> :key=<span class=\"hljs-string\">\"index\"</span>>{{ item }}</li>\n    </ul>\n    <input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> v-model=<span class=\"hljs-string\">\"item\"</span>>\n    <button @click=<span class=\"hljs-string\">\"postApi\"</span>>添加</button>\n  </div>\n\n  <!-- cdn 引用：Vue 和 Node -->\n  <script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"https://unpkg.com/axios/dist/axios.min.js\"</span>></script>\n  \n  <script>\n    new Vue({\n      el: document.getElementById(<span class=\"hljs-string\">'app'</span>),\n      data: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        <span class=\"hljs-built_in\">return</span> {\n          items: [],\n          item: <span class=\"hljs-string\">''</span>,\n        }\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-title\">created</span></span>() {\n        // 进入页面请求数据\n        axios.get(<span class=\"hljs-string\">'http://localhost:3000/'</span>).then(res => {\n          console.log(<span class=\"hljs-string\">\"\\n【API - get 数据】\"</span>);\n          console.log(res);\n          this.items = res.data;\n        }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err)\n        })\n      },\n      methods: {\n        // 点击按钮提交数据\n        <span class=\"hljs-function\"><span class=\"hljs-title\">postApi</span></span>() {\n          axios.post(<span class=\"hljs-string\">'http://localhost:3000/'</span>, {\n            item: this.item\n          }).then(res => {\n            console.log(<span class=\"hljs-string\">\"\\n【API - post 数据】\"</span>)\n            console.log(res);\n            this.items = res.data;\n          }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err)\n          })\n        }\n      }\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们通过 Vue 进行了布局，通过 Axios 进行了接口的请求。从而完成了对数据的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-16\"><a id=\"chapter-three-eleven\" name=\"chapter-three-eleven\">3.11 Node 连接 MySQL</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eleven\">返回目录</a></p>\n</blockquote>\n<blockquote>\n<p>关于 MySQL 的安装，可以查看 <strong>jsliang</strong> 写的：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">MySQL 安装及图形化工具</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们通过可视化工具进行表的设计：</p>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>age</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>然后</strong>，我们进行表的填充：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>jslliang</td>\n<td>23</td>\n</tr>\n<tr>\n<td>2</td>\n<td>梁峻荣</td>\n<td>23</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>接着</strong>，我们安装 Node 连接 MySQL 的包：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm i mysql -D\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>再来</strong>，我们编写 Node 的 <code>index.js</code>：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\nconnection.query(<span class=\"hljs-string\">'SELECT * FROM user'</span>, <span class=\"hljs-keyword\">function</span> (error, results, fields) {\n  <span class=\"hljs-keyword\">if</span> (error) throw error;\n  console.log(results);\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，打开该服务：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[ RowDataPacket { id: 1, name: <span class=\"hljs-string\">'jsliang'</span>, age: <span class=\"hljs-string\">'23'</span> },\n  RowDataPacket { id: 2, name: <span class=\"hljs-string\">'梁峻荣'</span>, age: <span class=\"hljs-string\">'23'</span> } ]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们便完成了 Node 连接 MySQL。</p>\n<p> ———————华丽分割线———————</p>\n<p> 当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。</p>\n<p> 先看目录：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b034ab5dc8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"178\" data-height=\"261\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>新增表字段</strong></li>\n</ul>\n<blockquote>\n<p>add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\n<span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(id,name,age) VALUES(0,?,?)\"</span>;\n<span class=\"hljs-built_in\">let</span> addSqlParams = [<span class=\"hljs-string\">\"jsliang\"</span>, <span class=\"hljs-string\">\"23\"</span>];\n\nconnection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"新增成功：\"</span>);\n    console.log(res);\n  }\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们只需要直接 <code>node add.js</code>，就能往数据库中新增数据了。</p>\n<ul>\n<li><strong>删除表字段</strong></li>\n</ul>\n<blockquote>\n<p>delete.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\nvar delSql = <span class=\"hljs-string\">'DELETE FROM user where id = 2'</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(delSql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"删除错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"删除成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>修改表字段</strong></li>\n</ul>\n<blockquote>\n<p>update.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> updateSql = <span class=\"hljs-string\">\"UPDATE user SET name = ?,age = ? WHERE Id = ?\"</span>;\n<span class=\"hljs-built_in\">let</span> updateSqlParams = [<span class=\"hljs-string\">\"LiangJunrong\"</span>, <span class=\"hljs-string\">\"23\"</span>, 1];\n\n// 连接 SQL 并实施语句\nconnection.query(updateSql, updateSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"修改错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"修改成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>查询表字段</strong></li>\n</ul>\n<blockquote>\n<p>read.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) throw err;\n  console.log(res);\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 以上，我们打通了 Node 与 MySQL 的壁垒，实现了数据的增删改查。</p>\n<h2 class=\"heading\" data-id=\"heading-17\"><a id=\"chapter-four\" name=\"chapter-four\">四 Web 实战 —— 企业官网</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-four\">返回目录</a></p>\n</blockquote>\n<p> 在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo 制作、ico 制作、icon 挑选等……</p>\n<p> 下面这些都是 <strong>jsliang</strong> 平时碰到的，小伙伴有需要的可以 mark 啦~</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.uugai.com%2Flogoa%2Fwenzi.php\" rel=\"nofollow noopener noreferrer\">logo 制作</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.bitbug.net%2F\" rel=\"nofollow noopener noreferrer\">ico 制作</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.iconfont.cn%2Fhome%2Findex\" rel=\"nofollow noopener noreferrer\">icon 挑选</a></li>\n</ul>\n<p> 另外，由于 HTML 与 CSS 没什么好讲的，所以本章节的前提静态页面 <strong>jsliang</strong> 已经写好了，小伙伴们在学习前可以预先下载：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">本文静态页面代码地址</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-18\"><a id=\"chapter-four-one\" name=\"chapter-four-one\">4.1 编程环境</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-one\">返回目录</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们查看下我们的前端基本代码：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2FNode%2Ftree%2FFrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">地址</a></p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b22a71f82d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1010\" data-height=\"340\"><figcaption></figcaption></figure><p></p>\n<p> 如上，我们仅需要了解 FrontEndCode 目录以及 NodeWeb 目录即可，其他目录为上面章节练习参考。</p>\n<p> <strong>然后</strong>，我们进行后端功能分析：</p>\n<ol>\n<li>留言板。用户点击 <strong>留言板</strong> 的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到 <strong>登录页</strong>；如果用户登录了，则显示 <strong>留言板页面</strong>。</li>\n</ol>\n<p> 在 <strong>留言板页面</strong> 中，存在两个接口：</p>\n<ul>\n<li><strong>获取留言内容</strong>：调取 <code>getMessage</code> 接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。</li>\n<li><strong>提交留言内容</strong>：调取 <code>sendMessage</code> 接口，将用户名、用户 id、留言内容发送给后端。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b629555859?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1219\" data-height=\"828\"><figcaption></figcaption></figure><p></p>\n<ol start=\"2\">\n<li>在 <strong>登录页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>登录</strong>：调取 <code>login</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4eac593083f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1180\" data-height=\"810\"><figcaption></figcaption></figure><p></p>\n<ol start=\"3\">\n<li>在 <strong>注册页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>注册</strong>：调取 <code>register</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db50d7d913be2?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1200\" data-height=\"800\"><figcaption></figcaption></figure><p></p>\n<p> 由此，我们可以设计下前后端的接口结合：</p>\n<blockquote>\n<p>接口文档</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>类型</th>\n<th>参数</th>\n<th>返回信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getMessage</code>：获取留言信息</td>\n<td>get</td>\n<td>无参</td>\n<td>n 条记录：id(用户 id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间)</td>\n</tr>\n<tr>\n<td><code>sendMessage</code>：提交留言信息</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_message(用户留言内容)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>login</code>：登录</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>register</code>：注册</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>最后</strong>，我们进行 MySQL 数据库的表设计：</p>\n<blockquote>\n<p>user 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_password</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>message 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_message</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>varchar</td>\n<td>255</td>\n<td>外键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-19\"><a id=\"chapter-four-two\" name=\"chapter-four-two\">4.2 后端接口</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-two\">返回目录</a></p>\n</blockquote>\n<p> 在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个 <code>test</code> 文件夹，里面放一个 <code>index.html</code> 以及一个 <code>index.js</code> 来测试一下。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">- text\n - index.html\n - index.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们就 4.1 提到的接口，提前进行后端接口的设置：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL：先安装 npm i mysql -D\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'nodebase'</span>\n});\n// 开始连接\nconnection.connect();\n\n// 引入 http 模块：http 是提供 Web 服务的基础\nconst http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 url 模块：url 是对用户提交的路径进行解析\nconst url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 qs 模块：qs 是对路径进行 json 化或者将 json 转换为 string 路径\nconst qs = require(<span class=\"hljs-string\">\"querystring\"</span>);\n\n// 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 设置 cors 跨域\n  res.setHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"hljs-string\">\"*\"</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"POST\"</span>) { // 接口 POST 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【POST 形式】\"</span>);\n\n    // 获取前端发来的路由地址\n    <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    // 接收发送过来的参数\n    <span class=\"hljs-built_in\">let</span> tempResult = <span class=\"hljs-string\">\"\"</span>;\n\n    // 数据接入中\n    req.addListener(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n      tempResult += chunk;\n    });\n\n    // 数据接收完成\n    req.addListener(<span class=\"hljs-string\">\"end\"</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n      var result = JSON.stringify(qs.parse(tempResult));\n      console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n      console.log(result);\n\n      <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n      }\n      // 接口信息处理完毕\n    })\n    // 数据接收完毕\n\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"GET\"</span>) { // 接口 GET 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【GET 形式】\"</span>);\n\n    // 解析 url 接口\n    <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n      console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n      res.writeHead(200, {\n        <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n      });\n\n      res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n      res.end();\n    }\n\n  }\n\n}).listen(8888); // 监听的端口\n\n// 获取当前时间\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getNowFormatDate</span></span>() {\n  var date = new Date();\n  var year = date.getFullYear(); // 年\n  var month = date.getMonth() + 1; // 月\n  var strDate = date.getDate(); // 日\n  var hour = date.getHours(); // 时\n  var minute = date.getMinutes(); // 分\n  var second = date.getMinutes(); // 秒\n  <span class=\"hljs-keyword\">if</span> (month >= 1 && month <= 9) {\n    month = <span class=\"hljs-string\">\"0\"</span> + month;\n  }\n  <span class=\"hljs-keyword\">if</span> (strDate >= 0 && strDate <= 9) {\n    strDate = <span class=\"hljs-string\">\"0\"</span> + strDate;\n  }\n  // 返回 yyyy-mm-dd hh:mm:ss 形式\n  var currentdate = year + <span class=\"hljs-string\">\"-\"</span> + month + <span class=\"hljs-string\">\"-\"</span> + strDate + <span class=\"hljs-string\">\" \"</span> + hour + <span class=\"hljs-string\">\":\"</span> + minute + <span class=\"hljs-string\">\":\"</span> + second;\n  <span class=\"hljs-built_in\">return</span> currentdate;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过判断 <code>req.method</code> 属于 <code>GET</code> 还是 <code>POST</code> 形式，从而确定加载的接口：</p>\n<ul>\n<li>在 <code>POST</code> 中，判断是属于 <strong>提交留言信息</strong>、<strong>登录</strong> 还是 <strong>注册</strong>；</li>\n<li>在 <code>GET</code> 中，判断是不是 <strong>获取留言信息</strong>。</li>\n</ul>\n<p> <strong>同时</strong>，我们在其中定义了 MySQL 的连接以及一个 <code>getNowFormatDate</code> 用来获取当前时间，格式为：<code>2018-12-21 10:03:59</code></p>\n<p> <strong>然后</strong>，我们通过一个前端页面来演示我们的接口是否能使用：</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>演示代码</title>\n</head>\n\n<body>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"user\"</span>>用户名</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> id=<span class=\"hljs-string\">\"user\"</span>>\n  </div>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"password\"</span>>密&nbsp;&nbsp;&nbsp;码</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"password\"</span> id=<span class=\"hljs-string\">\"password\"</span>>\n  </div>\n  <div>\n    <button id=<span class=\"hljs-string\">\"register\"</span>>注册</button>\n  </div>\n\n  <script src=<span class=\"hljs-string\">\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      // 测试 get 接口\n      $.ajax({\n        url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n        <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n        data: {\n          username: <span class=\"hljs-string\">\"jsliang\"</span>\n        },\n        success: <span class=\"hljs-keyword\">function</span> (res) {\n          console.log(res);\n        },\n        error: <span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err);\n        }\n      })\n\n      $(<span class=\"hljs-string\">\"#register\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 测试 post 接口\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n          data: {\n            username: $(<span class=\"hljs-string\">\"#user\"</span>).val(),\n            password: $(<span class=\"hljs-string\">\"#password\"</span>).val()\n          },\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      })\n    });\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，并打开 <code>index.html</code>，通过 <code>F12</code> 控制台查看我们的接口是否正常：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db510727a4435?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"684\" data-height=\"662\"><figcaption></figcaption></figure><p></p>\n<p> 可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这 4 个接口的设计了。</p>\n<blockquote>\n<p>如果小伙伴们觉得每次更新 Node 代码后，又要重启一遍 <code>node index.js</code> 觉得麻烦，可以通过 <code>supervisor</code> 来监听 Node 代码的改动，<code>supervisor</code> 的安装使用：<a href=\"#chapter-five-one\">supervisor</a></p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-20\"><a id=\"chapter-four-three\" name=\"chapter-four-three\">4.3 注册功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-three\">返回目录</a></p>\n</blockquote>\n<p> 很好，我们回到仿企业网站的页面上，准备编写接口以及丰富 Node 的接口。</p>\n<p> <strong>首先</strong>，我们开启前端和 Node 服务：</p>\n<ol>\n<li>\n<p>打开命令行/终端</p>\n</li>\n<li>\n<p>开启前端</p>\n</li>\n</ol>\n<ul>\n<li><code>cd FrontEndCode</code></li>\n<li><code>live-server</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>live-server</code>：<code>npm i live-server -g</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>开启后端</li>\n</ol>\n<ul>\n<li><code>cd NodeWeb</code></li>\n<li><code>supervisor index.js</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>supervisor</code>：<code>npm i supervisor -g</code></p>\n</blockquote>\n<p> <strong>然后</strong>，我们在注册页面通过点击事件来触发调接口：</p>\n<blockquote>\n<p>register.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>注册-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  <!-- 省略 body 中代码，有需要的请前往第四章开头下载查看全部代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#register-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val();\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val();\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          // 如果用户输入的没毛病，那就加载接口\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/register\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册成功，前往登录！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./login.html\"</span>;\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>) {\n                alert(<span class=\"hljs-string\">\"用户名已被注册！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，名额已满！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们在用户点击 <strong>注册</strong> 按钮的时候，进行接口的调用，发送数据到了后端，如果成功了，那就弹窗，并跳转到登录页；如果没成功，就弹窗提示。</p>\n<p> <strong>接着</strong>，我们编写 Node，前端调用接口后，Node 判断这两个参数是否为空，如果不为空，则将数据存储到数据库。</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"注册失败，用户名为空。\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) { // 姓名过长\n    res.end(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) { // 密码过长\n    res.end(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 查询 user 表\n    // 使用 Promise 的原因是因为中间调用了两次数据库，而数据库查询是异步的，所以需要用 Promise。\n    new Promise( (resolve, reject) => {\n\n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n      \n      // 连接 SQL 并实施语句\n      connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n        \n        <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n          throw error1;\n        } <span class=\"hljs-keyword\">else</span> {\n          \n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n\n          // 将结果先去掉 RowDataPacket，再转换为 json 对象\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          // 判断姓名重复与否\n          <span class=\"hljs-built_in\">let</span> userNameRepeat = <span class=\"hljs-literal\">false</span>;\n          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> newRes) {\n            <span class=\"hljs-keyword\">if</span>(newRes[item].user_name == username) {\n              userNameRepeat = <span class=\"hljs-literal\">true</span>;\n            }\n          }\n\n          // 如果姓名重复\n          <span class=\"hljs-keyword\">if</span>(userNameRepeat) {\n            res.end(<span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(newRes.length > 300) { // 如果注册名额已满\n            res.end(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> { // 可以注册\n            resolve();\n          }\n          \n        }\n      });\n\n    }).then( () => {\n      \n      console.log(<span class=\"hljs-string\">\"\\n第二步：\"</span>);\n      \n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(user_name,user_password, time) VALUES(?,?,?)\"</span>;\n      <span class=\"hljs-built_in\">let</span> addSqlParams = [result.username, result.password, time];\n\n      // 连接 SQL 并实施语句\n      connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error2, response2) {\n        <span class=\"hljs-keyword\">if</span> (error2) { // 如果 SQL 语句错误\n          console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n          console.log(error2);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n          console.log(response2);\n\n          console.log(<span class=\"hljs-string\">\"\\n注册成功！\"</span>);\n\n          // 返回数据\n          res.write(JSON.stringify({\n            code: <span class=\"hljs-string\">\"0\"</span>,\n            message: <span class=\"hljs-string\">\"注册成功！\"</span>\n          }));\n\n          // 结束响应\n          res.end();\n        }\n      });\n\n    })\n    // Promise 结束\n  }\n  // 注册流程结束\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们在查看下该功能是否成功：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5157604487c?imageslim\" data-width=\"1182\" data-height=\"912\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-21\"><a id=\"chapter-four-four\" name=\"chapter-four-four\">4.4 登录功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-four\">返回目录</a></p>\n</blockquote>\n<p> 在上面，我们完成了注册功能，那么相对来说，登录功能就容易通了，因为查询部分我们已经试过了一次。</p>\n<blockquote>\n<p>login.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>登录-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，有需要的小伙伴请在第四章前言部分下载代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#login-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val(); // 用户名\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val(); // 密码\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                sessionStorage.setItem(<span class=\"hljs-string\">\"id\"</span>, res.data.id);\n                sessionStorage.setItem(<span class=\"hljs-string\">\"userName\"</span>, res.data.userName);\n                alert(<span class=\"hljs-string\">\"登录成功！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./messageBoard.html\"</span>;\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"1\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码错误！\"</span>);\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"不存在该用户！\"</span>) {\n                alert(<span class=\"hljs-string\">\"不存在该用户！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 编写完前端的代码后，我们进行 Node 代码的编辑：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) {\n    res.end(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) {\n    res.end(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> { \n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user WHERE user_name  = '\"</span> + username + <span class=\"hljs-string\">\"'\"</span>;\n\n    // 连接 SQL 并实施语句\n    connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) {\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">if</span>(response1 == undefined || response1.length == 0) { // 不存在用户\n          res.end(<span class=\"hljs-string\">\"\\n不存在该用户！\"</span>);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> { // 存在用户\n          console.log(<span class=\"hljs-string\">\"\\n存在该用户！\"</span>);\n\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          <span class=\"hljs-keyword\">if</span>(newRes[0].user_password == password) { // 密码正确\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"0\"</span>,\n              message: <span class=\"hljs-string\">\"登录成功！\"</span>,\n              data: {\n                id: newRes[0].id,\n                userName: newRes[0].user_name\n              }\n            }));\n\n            res.end();\n          } <span class=\"hljs-keyword\">else</span> { // 密码错误\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"1\"</span>,\n              message: <span class=\"hljs-string\">\"登录失败，密码错误！\"</span>\n            }));\n\n            res.end();\n          }\n          // 判断密码正确与否完毕\n        }\n        // 存在用户处理结束\n      }\n    });\n  }\n  // 登录步骤结束\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 很好，前端和后端都编写完毕，是时候查验下功能是否实现了：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db52440fdaf7f?imageslim\" data-width=\"1182\" data-height=\"912\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-22\"><a id=\"chapter-four-five\" name=\"chapter-four-five\">4.5 留言功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-five\">返回目录</a></p>\n</blockquote>\n<p> 现在，我们就剩下留言功能了，一鼓作气做好它吧！</p>\n<blockquote>\n<p>messageBoard.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!-- 留言板 -->\n<!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>留言板-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，基础代码请前往本章节前言下载 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      \n      <span class=\"hljs-built_in\">let</span> userName = sessionStorage.getItem(<span class=\"hljs-string\">\"userName\"</span>);\n      <span class=\"hljs-built_in\">let</span> userId = sessionStorage.getItem(<span class=\"hljs-string\">\"id\"</span>);\n      \n      // 查询留言板\n      <span class=\"hljs-keyword\">if</span>(userName && userId) { // 如果有存储\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'get'</span>,\n          dataType: <span class=\"hljs-string\">'json'</span>,\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n            <span class=\"hljs-built_in\">let</span> li = ``;\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> res.data) {\n              li = li + `\n                <li>\n                  <span class=<span class=\"hljs-string\">\"text-warning font-bold\"</span>>☆ </span>\n                  <span class=<span class=\"hljs-string\">\"user-message\"</span>><span class=\"hljs-variable\">${res.data[item].user_message}</span></span>\n                  <span>—— </span>\n                  <span class=<span class=\"hljs-string\">\"user-name\"</span>><span class=\"hljs-variable\">${res.data[item].user_name}</span> [<span class=\"hljs-variable\">${res.data[item].user_id}</span>]</span>\n                  <span class=<span class=\"hljs-string\">\"message-time\"</span>><span class=\"hljs-variable\">${res.data[item].time}</span></span>\n                </li>\n              `;\n            }\n            $(<span class=\"hljs-string\">\"#message-board-ul\"</span>).append(li);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      } <span class=\"hljs-keyword\">else</span> { // 如果没有存储\n        window.location.href = <span class=\"hljs-string\">\"../login.html\"</span>;\n      }\n\n      // 提交留言\n      $(<span class=\"hljs-string\">\"#message-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-built_in\">let</span> messageText = $(<span class=\"hljs-string\">\"#message\"</span>).val()\n        <span class=\"hljs-keyword\">if</span>(!messageText) {\n          alert(<span class=\"hljs-string\">\"留言内容不能为空\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n          alert(<span class=\"hljs-string\">\"留言长度不能超过 140 位！\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/sendMessage\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              userid: userId,\n              username: userName,\n              message: messageText\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span>(res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"新增成功！\"</span>);\n                window.location.reload();\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err);\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n      })\n\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 接着编写下 Node 后端：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> id = result.userid; // id\n  <span class=\"hljs-built_in\">let</span> userName = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> messageText = result.message; // 留言内容\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span>(!messageText) {\n    res.end(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n    res.end(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO message(user_message, user_id, user_name, time) VALUES(?, ?, ?, ?)\"</span>;\n    <span class=\"hljs-built_in\">let</span> addSqlParams = [messageText, id, userName, time];\n\n    // 连接 SQL 并实施语句\n    connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"\\n新增成功！\"</span>);\n\n        // 返回数据\n        res.write(JSON.stringify({\n          code: <span class=\"hljs-string\">\"0\"</span>,\n          message: <span class=\"hljs-string\">\"新增成功！\"</span>\n        }));\n\n        // 结束响应\n        res.end();\n      }\n    })\n  }\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n\n\n\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n  // 解析 url 参数部分\n  <span class=\"hljs-built_in\">let</span> params = url.parse(req.url, <span class=\"hljs-literal\">true</span>).query;\n\n  console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n  console.log(params);\n\n  // 新增的 SQL 语句及新增的字段信息\n  <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM message\"</span>;\n\n  // 连接 SQL 并实施语句\n  connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n    <span class=\"hljs-keyword\">if</span> (error1) {\n      throw error1; \n    } <span class=\"hljs-keyword\">else</span> {\n      \n      <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n      console.log(newRes);\n\n      // 返回数据\n      res.write(JSON.stringify({\n        code: <span class=\"hljs-string\">\"1\"</span>,\n        message: <span class=\"hljs-string\">\"查询成功！\"</span>,\n        data: newRes\n      }));\n\n      // 结束响应\n      res.end();\n    }\n  });\n  // 查询完毕\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n  res.end();\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 敲完代码再看下功能是否实现：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5280acce0c8?imageslim\" data-width=\"1182\" data-height=\"912\"><figcaption></figcaption></figure><p></p>\n<p> 综上，我们完成了所有的功能模块：注册、登录以及留言。</p>\n<h2 class=\"heading\" data-id=\"heading-23\"><a id=\"chapter-five\" name=\"chapter-five\">五 工具整合</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-five\">返回目录</a></p>\n</blockquote>\n<p> <strong>工欲善其事，必先利其器。</strong><br>\n 掌控好了工具，可以方便你更快地进行开发。</p>\n<h3 class=\"heading\" data-id=\"heading-24\"><a id=\"chapter-five-one\" name=\"chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-one\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.supervisord.org%2F\" rel=\"nofollow noopener noreferrer\">supervisor 官网</a></li>\n</ul>\n<p> 正如其官网所说，它是一个进行控制系统：</p>\n<ol>\n<li>安装插件：<code>npm i supervisor -g</code></li>\n<li>运行文件：<code>supervisor app.js</code></li>\n<li>查看运行：<code>localhost:3000</code></li>\n</ol>\n<p> 平时，我们 <code>node app.js</code> 后，当我们修改了 <code>app.js</code> 的内容，就需要关闭 node 命令行再执行 <code>node app.js</code>。<br>\n 而我们使用 <code>supervisor</code> 后，我们修改了 <code>app.js</code> 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。</p>\n<p> 关于这个工具，网上更详细的攻略有：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F6d84e5efe99d\" rel=\"nofollow noopener noreferrer\">详细版：用Supervisor守护你的Node.js进程 | 简书 - Mike的读书季</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-25\"><a id=\"chapter-five-two\" name=\"chapter-five-two\">5.2 PM2 - Node 进程管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-two\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fpm2\" rel=\"nofollow noopener noreferrer\">PM2 - npm</a></li>\n</ul>\n<p> PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>\n<p> 下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置：</p>\n<ol>\n<li>全局安装 PM2：<code>npm i pm2 -g</code></li>\n<li>监听应用：<code>pm2 start index.js</code></li>\n<li>查看所有进程：<code>pm2 list</code></li>\n<li>查看某个进程：<code>pm2 describe App name/id</code></li>\n<li>停止某个进程：<code>pm2 stop App name/id</code>。例如：</li>\n</ol>\n<blockquote>\n<p>先通过 <code>pm2 list</code> 查看：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>App name</th>\n<th>id</th>\n<th>status</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>0</td>\n<td>online</td>\n</tr>\n</tbody>\n</table>\n<p> 只需要执行 <code>pm2 stop index</code> 或者 <code>pm2 stop 0</code> 即可。</p>\n<ol start=\"6\">\n<li>停止所有进程：<code>pm2 stop all</code></li>\n<li>重启某个进程：<code>pm2 restart App name/id</code></li>\n<li>删除某个进程：<code>pm2 delete App name/id</code></li>\n</ol>\n<p> 如上，如果说我们的 <code>supervisor</code> 是监听单个进程的话，那么 <code>PM2</code> 就是监听多个进程。</p>\n<p> 更多攻略：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fpm2.io%2Fdoc%2Fen%2Fruntime%2Fquick-start%2F%3Futm_source%3Dpm2%26amp%3Butm_medium%3Dwebsite%26amp%3Butm_campaign%3Drebranding\" rel=\"nofollow noopener noreferrer\">PM2 官网</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ff640450bd120\" rel=\"nofollow noopener noreferrer\">PM2 用法简介 | 简书 - LeavesLife</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fchyingp%2Fp%2Fpm2-documentation.html\" rel=\"nofollow noopener noreferrer\">PM2实用入门指南 | 博客园 - 程序猿小卡</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-26\"><a id=\"chapter-six\" name=\"chapter-six\">六 参考资料</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-six\">返回目录</a></p>\n</blockquote>\n<p> 在编写这篇文章的过程中，有一些参考资料是值得保留阅读的：</p>\n<ol>\n<li><strong>经典：该类值得我们研读</strong></li>\n</ol>\n<blockquote>\n<p>经典，就是随着时间流逝，它还是那么有参考价值。</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fapi%2F\" rel=\"nofollow noopener noreferrer\">API 文档 | Node.js 中文网</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html\" rel=\"nofollow noopener noreferrer\">Node.js 教程 | 菜鸟教程</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.expressjs.com.cn%2F\" rel=\"nofollow noopener noreferrer\">Express 文档 | Express 中文网</a></li>\n</ul>\n<ol start=\"2\">\n<li><strong>尝试：该类值得我们参考借鉴</strong></li>\n</ol>\n<blockquote>\n<p>Node 基础模块</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FwhiteMu%2Fp%2F5986297.html\" rel=\"nofollow noopener noreferrer\">nodejs之querystring模块 | 博客园 - whiteMu</a></li>\n</ul>\n<blockquote>\n<p>Node 编写接口</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.php.cn%2Fjs-tutorial-406242.html\" rel=\"nofollow noopener noreferrer\">用Node编写RESTful API接口 | php 中文网 - 不言</a></li>\n</ul>\n<blockquote>\n<p>MySQL 学习</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.runoob.com%2Fmysql%2Fmysql-tutorial.html\" rel=\"nofollow noopener noreferrer\">MySQL 教程 | 菜鸟教程</a></li>\n</ul>\n<blockquote>\n<p>Node 连接数据库</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fby-dxm%2Fp%2F6723039.html\" rel=\"nofollow noopener noreferrer\">node.js前后台交互示例 -- 使用node.js实现用户注册功能 | 博客园 - 返回主页 党兴明</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fbestjarvan%2Farchive%2F2017%2F04%2F08%2F6680857.html\" rel=\"nofollow noopener noreferrer\">node.js实现简单的登录注册页面 - 博客园 - 返回主页 bestjarvan</a></li>\n</ul>\n<blockquote>\n<p>Node 仿 Express</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Ftiantangyouzui%2Farticle%2Fdetails%2F70184959\" rel=\"nofollow noopener noreferrer\">nodejs模块：简单http请求路由，仿express | CSDN - TTUZ</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.html-js.com%2Farticle%2F1603\" rel=\"nofollow noopener noreferrer\">初学nodejs一：别被Express的API搞晕了 | 前端乱炖 - 飞天小黑神猪</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf227a751882516be2ec124\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（一） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf4e46a6fb9a049f153d2ae\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（二） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwallaceyuan%2Fyuan-express\" rel=\"nofollow noopener noreferrer\">仿 Express | Github - wallaceyuan</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fcckevincyh%2Farticle%2Fdetails%2F78695177\" rel=\"nofollow noopener noreferrer\">Node.js 封装仿照 express 的路由 | CSDN - c.</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FBadWaka%2Fnode-express-middleware-study\" rel=\"nofollow noopener noreferrer\">学习node中express框架中间件的相关知识及实践 | Github - BadWaka</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-27\"><a id=\"chapter-seven\" name=\"chapter-seven\">七 线上部署</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-seven\">返回目录</a></p>\n</blockquote>\n<p> 关于线上部署及域名、服务器相关的配置，<strong>jsliang</strong> 在另外一篇文章有所交代：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">云服务器建站</a>。</p>\n<p> 如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 <strong>jsliang</strong> QQ：<code>1741020489</code> 咨询，下面是一些优惠推广：</p>\n<p> <strong>腾讯云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fredirect.php%3Fredirect%3D1025%26amp%3Bcps_key%3D49f647c99fce1a9f0b4e1eeb1be484c9%26amp%3Bfrom%3Dconsole\" rel=\"nofollow noopener noreferrer\">新客户无门槛 2775 元代金券</a>\n<figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c70d0376e68?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1040\" data-height=\"100\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fredirect.php%3Fredirect%3D1014%26amp%3Bcps_key%3D49f647c99fce1a9f0b4e1eeb1be484c9%26amp%3Bfrom%3Dconsole\" rel=\"nofollow noopener noreferrer\">12 月优惠低至 168 元/年</a>\n<figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c7d4e1ea4f0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1040\" data-height=\"100\"><figcaption></figcaption></figure></li>\n</ul>\n<br>\n<p> <strong>阿里云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fpromotion.aliyun.com%2Fntms%2Fyunparter%2Finvite.html%3FuserCode%3Dw7hismrh\" rel=\"nofollow noopener noreferrer\">新用户云产品 1888 通用代金券</a>\n<figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c84a3c2cde4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"720\" data-height=\"100\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fpromotion.aliyun.com%2Fntms%2Fact%2Fqwbk.html%3FuserCode%3Dw7hismrh\" rel=\"nofollow noopener noreferrer\">高性能云服务器 - 低至 293元/年</a>\n<figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c8c17693c71?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1200\" data-height=\"100\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买企业级云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fpromotion.aliyun.com%2Fntms%2Fact%2Fenterprise-discount.html%3FuserCode%3Dw7hismrh\" rel=\"nofollow noopener noreferrer\">企业级高性能云服务器</a>\n<figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c934dada38a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1000\" data-height=\"90\"><figcaption></figcaption></figure></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-28\"><a id=\"chapter-eight\" name=\"chapter-eight\">八 归纳总结</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-eight\">返回目录</a></p>\n</blockquote>\n<p> 综上，搞定一切！<br>\n 兴许在前面代码的摧残下，能看到这里的小伙伴已经寥寥无几了，但我坚信我该交代的基本都交代了，不该交代的也交代了~<br>\n 所以，如果小伙伴看完真觉得不错，那就点个赞或者给个 star 吧！你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<p> 如果小伙伴看完这里要评论的话，可以加个暗语：<code>Node 基础，***</code>，这样 <strong>jsliang</strong> 看到必回，哈哈~</p>\n<ul>\n<li>Node 基础，我完成了！</li>\n<li>Node 基础，我想说 jsliang 肯定还偷懒了，没写成最完美的，我不管我打赏了你赶紧给我完善下！</li>\n<li>……</li>\n</ul>\n<p> <strong>so, that's all, thanks~</strong></p>\n<p><em>-----------------------</em></p>\n<h2 class=\"heading\" data-id=\"heading-29\">后记</h2>\n<p><strong>撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~</strong></p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5346ad6c037?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"320\" data-height=\"320\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db537a115c675?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"320\" data-height=\"320\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nc-sa%2F4.0%2F\" rel=\"nofollow noopener noreferrer\" target=\"_blank\"><img style=\"border-width:0\" alt=\"知识共享许可协议\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167d9537f3e29c99?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"88\" data-height=\"31\"></a><br><a><strong>jsliang</strong> 的文档库</a> 由 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">梁峻荣</a> 采用 <a href=\"https://link.juejin.im?target=http%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nc-sa%2F4.0%2F\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br>基于<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FLiangJunrong%2Fdocument-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.om/LiangJunron…</a>上的作品创作。<br>本许可协议授权之外的使用权限可以从 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nc-sa%2F2.5%2Fcn%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">creativecommons.org/licenses/by…</a> 处获得。</p>\n</blockquote>\n</div>",
      "time": "2018年12月23日"
    },
    {
      "source": "juejin",
      "id": "4tcuzt8n6ay0",
      "content": "<meta itemprop=\"url\" content=\"https://juejin.im/post/592ed10a2f301e00571966b2\"><meta itemprop=\"headline\" content=\"Node 爬虫入门\"><meta itemprop=\"keywords\" content=\"Node.js\"><meta itemprop=\"datePublished\" content=\"2017-05-31T14:31:12.820Z\"><meta itemprop=\"image\" content=\"https://b-gold-cdn.xitu.io/icon/icon-128.png\"><div itemprop=\"author\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Person\"><meta itemprop=\"name\" content=\"小虫巨蟹\"><meta itemprop=\"url\" content=\"https://juejin.im/user/590842f0b123db3ee49105bb\"></div><div itemprop=\"publisher\" itemscope=\"itemscope\" itemtype=\"http://schema.org/Organization\"><meta itemprop=\"name\" content=\"掘金\"><div itemprop=\"logo\" itemscope=\"itemscope\" itemtype=\"https://schema.org/ImageObject\"><meta itemprop=\"url\" content=\"https://b-gold-cdn.xitu.io/icon/icon-white-180.png\"><meta itemprop=\"width\" content=\"180\"><meta itemprop=\"height\" content=\"180\"></div></div><div class=\"author-info-block\" data-v-648672b2><a href=\"/post/592ed10a2f301e00571966b2\" target=\"_blank\" rel class=\"avatar-link\" data-v-648672b2><div data-src=\"https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg\" class=\"lazy avatar avatar\" style=\"background-image:none;\" data-v-25c4c3d5 data-v-a1d2a72e data-v-648672b2></div></a><div class=\"author-info-box\" data-v-648672b2><a href=\"/post/592ed10a2f301e00571966b2\" target=\"_blank\" rel class=\"username username ellipsis\" data-v-46d4aafc data-v-648672b2><!----></a><div class=\"meta-box\" data-v-648672b2><time datetime=\"2017-05-31T14:31:12.820Z\" title=\"Wed May 31 2017 22:31:12 GMT+0800 (China Standard Time)\" class=\"time\" data-v-648672b2>2017年05月31日</time><span class=\"views-count\" data-v-648672b2>阅读 8730</span><!----></div></div><!----></div><!----><h1 class=\"article-title\" data-v-648672b2>Node 爬虫入门</h1><div data-id=\"592ed3b00ce463006b558c2a\" itemprop=\"articleBody\" class=\"article-content\" data-v-648672b2><blockquote>\n<p>边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章<br>为了验证“<strong><em>简书上，经验总结、资料归集类技术文章更容易上热榜</em></strong>”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的文章如果不是资料归集的话，多半就属于谈源码实现的了）</p>\n</blockquote>\n<h2 id=\"-\" data-id=\"heading-0\">目录</h2>\n<ul>\n<li><a href=\"#1\" target=\"_blank\">知识点</a></li>\n<li><a href=\"#2\" target=\"_blank\">实现步骤</a><ul>\n<li><a href=\"#2.1\" target=\"_blank\">拉取页面列表</a></li>\n<li><a href=\"#2.2\" target=\"_blank\">拉取页面详情，分析统计</a></li>\n<li><a href=\"#2.3\" target=\"_blank\">生成统计页面</a></li>\n</ul>\n</li>\n<li><a href=\"#3\" target=\"_blank\">总结</a></li>\n</ul>\n<p></p><h2 id=\"1\" data-id=\"heading-1\">知识点</h2><p></p>\n<ol>\n<li>http.request：node http 模块的request方法可以作为http client向服务器发起http请求，爬虫需要向目标链接发起http请求来获得页面信息</li>\n<li>cheerio：通过 http 请求到的页面信息，由于缺乏浏览器的dom解析，看起来就是一段凌乱的字符串，实在糟糕。好在我们可以使用 cheerio 库将其解析为 dom ，这样我们就可以使用类似 jquery 的语法去分析页面信息</li>\n<li>promise：由于 node 单线程的特性，不可避免的需要用到大量异步编程的写法，层层嵌套的回调写法已经 low 了，来试试 promise 的写法</li>\n</ol>\n<p></p><h2 id=\"2\" data-id=\"heading-2\">实现步骤</h2><p></p>\n<p></p><h3 id=\"2.1\" data-id=\"heading-3\">拉取页面列表</h3><br>首先需要拿到程序员专题热门列表的请求链接<p></p>\n<p></p><figure><img atr=\"列表链接\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/13a5acb99dd86163df80dfe5860acc45?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\"><figcaption>列表链接</figcaption></figure><p></p>\n<p>ajax请求，需要使用chrome dev tools，拉到底部还能加载更多：</p>\n<pre><code class=\"hljs javascript copyable\"><span class=\"hljs-comment\">//order_by=likes_count 表示按照热门进行排序</span>\n<span class=\"hljs-comment\">//page是分页参数，每页9条，我们可以通过改变page=0~100来拉取900篇文章</span>\nhttp:<span class=\"hljs-comment\">//www.jianshu.com/collections/16/notes?order_by=likes_count&page=2</span><span class=\"copy-code-btn\">复制代码</span></code></pre><p>下一步通过这个链接拉取列表数据</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     - 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com/collections/16/notes?order_by=likes_count&page='</span> + i,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                resolve(data);\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以创建一个promise对象来发起request请求（request的封装就不贴出来了，实验证明，代码块太多的文章不容易上热榜~~）</p>\n<p>起初我的做法是同时创建拉取1~100页数据的100个promise对象，同时异步的发起100个request请求，然而这样的做法会有几十个请求请求失败（兴许是简书那边做了限制），所以，还是耐心点，每次发起5个请求，直到100页都请求成功</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 递归的请求，每次并发的请求5个\n     */</span>\n    Seek.prototype.seek = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n        times++;\n        <span class=\"hljs-keyword\">var</span> ot = times;\n        <span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-built_in\">Promise</span>.all([\n            self.createPromise(times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times)\n        ]);\n        promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">result</span>) </span>{\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"seekList totals:\"</span> + times);\n            pages = pages.concat(result);\n            <span class=\"hljs-keyword\">if</span> (times < totalPage) {\n                self.seek(callback);\n            } <span class=\"hljs-keyword\">else</span> {\n                callback(pages);\n            }\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p>拿到所有的列表数据之后，就可以使用cheerio库来分析列表页面，抓取文章详情链接(在这一步之前你同样需要使用chrome dev tools工具分析页面结构)</p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 使用cheerio载入列表页面\n     */</span>\n    Analyse.prototype.load = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, i</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n            <span class=\"hljs-keyword\">var</span> pages = [];\n            <span class=\"hljs-keyword\">var</span> els = $(<span class=\"hljs-string\">'.article-list li'</span>);\n            <span class=\"hljs-keyword\">if</span>(els.length === <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'load error page:'</span> + i );\n                resolve([]);\n            }\n            els.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">index</span>) </span>{\n                <span class=\"hljs-keyword\">if</span> ($(<span class=\"hljs-keyword\">this</span>).attr(<span class=\"hljs-string\">'class'</span>) === <span class=\"hljs-string\">'have-img'</span>) {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                } <span class=\"hljs-keyword\">else</span> {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'div'</span>).children(<span class=\"hljs-string\">'.title'</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                }\n\n                <span class=\"hljs-keyword\">if</span>(index === els.length - <span class=\"hljs-number\">1</span>) {\n                    resolve(pages);\n                }\n            });\n        });\n\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><h3 id=\"2.2\" data-id=\"heading-4\">拉取页面详情，分析统计</h3><br>从上一步中拿到900篇热门文章的地址之后，需要再次去抓取文章详情页面，同样的每次查5篇，使用chrome dev tools分析得知，简书文章的代码块使用的都是<code><code></code></code>标签，统计此标签出现的数量就可以了<p></p>\n<pre><code class=\"hljs javascript copyable\">    <span class=\"hljs-comment\">/**\n     * 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">url</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com'</span> + url,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n                <span class=\"hljs-comment\">//页面标题</span>\n                <span class=\"hljs-keyword\">var</span> title = $(<span class=\"hljs-string\">'h1.title'</span>).text();\n                <span class=\"hljs-comment\">//代码块数量</span>\n                <span class=\"hljs-keyword\">var</span> codes = $(<span class=\"hljs-string\">'code'</span>).length;\n                <span class=\"hljs-keyword\">if</span>(codes === <span class=\"hljs-number\">0</span>) {<span class=\"hljs-comment\">//代码块为0的总数</span>\n                    zeroCount++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">10</span>) {<span class=\"hljs-comment\">//代码块为<=10的总数</span>\n                    oneToTen++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">20</span>) {<span class=\"hljs-comment\">//代码块<=20的总数</span>\n                    elToTwo++;\n                } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//代码块>20的总数</span>\n                    beyondTwo++;\n                }\n                resolve({\n                    <span class=\"hljs-attr\">title</span>: title,\n                    <span class=\"hljs-attr\">codes</span>: codes\n                });\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><h3 id=\"2.3\" data-id=\"heading-5\">生成统计页面</h3><br>数据总需要一个展示的地方，使用nunjucks作为页面模板，注入抓取到的数据，在使用echarts生成统计图表，就是这个feel，<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzengwenfu.github.io%2Fjian-analyse%2Fapp%2Fviews%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">结果页面</a><p></p>\n<p></p><figure><img atr=\"统计结果\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/8d76e15d56e4cd4328bc8428c77f7cdb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\"><figcaption>统计结果</figcaption></figure><p></p>\n<p></p><h3 id=\"3\" data-id=\"heading-6\">总结</h3><br>开发爬虫是一件很酷的事情，在这个过程中还能学到知识，提升学习兴趣，从爬虫做起~~<br><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzengwenfu%2Fjian-analyse\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">源码</a><p></p>\n<p><strong>下一篇文章讲 Node 爬虫进阶，敬请关注</strong></p>\n<blockquote>\n<p>补充说明：代码大半年前些的，简书的接口和页面结构已经做了改版，可能抓取不到想要的结果，如果感兴趣，可以按照思路和步骤改造现在的代码，自己动手丰衣足食</p>\n</blockquote>\n</div>",
      "time": "2017年05月31日"
    }
  ],
  "searchList": []
}