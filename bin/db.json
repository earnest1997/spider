{
  "searchResList": [
    {
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "k": "juejin",
      "id": "5g2zxxr5ods0",
      "author": "sing1ee",
      "title": "Node入门 » 一本全面的Node.js教程",
      "time": "3年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<div>\n\n\n        \n\n        \n\n        <h2 data-id=\"heading-0\">关于</h2>\n\n        <p>\n            本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-1\">状态</h3>\n\n       ..."
    },
    {
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "k": "juejin",
      "id": "4q42z5xe10u0",
      "author": "有赞技术",
      "title": "Node 在有赞的实践",
      "time": "1年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">一、概述</h2>\n<blockquote>\n<p>4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在 Node 这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。</p>\n</blockquote>\n<h2 class=\"heading..."
    },
    {
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "k": "juejin",
      "id": "5i9rpf0nsqk0",
      "author": "jsliang",
      "title": "Node - 从0基础到实战企业官网",
      "time": "10月前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>Create by <strong>jsliang</strong> on <strong>2018-11-8 13:42:42</strong><br>\nRecently revised in <strong>2018-12-23 21:59:20</strong></p>\n</blockquote>\n<p>Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blan..."
    },
    {
      "url": "https://www.jianshu.com/p/f3e10a011381",
      "k": "jianshu",
      "id": "1w0tcl55n2w0",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "time": "\n            4 个月前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 383px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 38.690000000000005%;\"></div>\n<div class=\"image-view\" data-w..."
    },
    {
      "url": "https://www.jianshu.com/p/f8b105bb2b13",
      "k": "jianshu",
      "id": "2tka21f8v9u0",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "time": "\n            1 年前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 350px; max-height: 350px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 100.0%;\"></div>\n<div class=\"image-view\" data-width=\"350\" da..."
    }
  ],
  "hotArticleDetailList": [
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-2\">2.css3的新特性</h4>\n<blockquote>\n<p>transtion\ntransition-property 规定设置过渡效果的 CSS 属性的名称。</p>\n</blockquote>\n<blockquote>\n<p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p>\n</blockquote>\n<blockquote>\n<p>transition-timing-function 规定速度效果的速度曲线。</p>\n</blockquote>\n<blockquote>\n<p>transition-delay 定义过渡效果何时开始。</p>\n</blockquote>\n<blockquote>\n<p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p>\n</blockquote>\n<blockquote>\n<p>ainimation实现动画效果主要由两部分组成：</p>\n</blockquote>\n<blockquote>\n<p>通过类似Flash动画中的帧来声明一个动画；</p>\n</blockquote>\n<blockquote>\n<p>在animation属性中调用关键帧声明的动画。</p>\n</blockquote>\n<blockquote>\n<p>translate 3D建模效果</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-3\">3.img中alt和title的区别</h4>\n<blockquote>\n<p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。</p>\n</blockquote>\n<blockquote>\n<p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-4\">4.用纯CSS创建一个三角形</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n    div {\n        width: 0;\n        height: 0;\n        border-top: 40px solid transparent;\n        border-left: 40px solid transparent;\n        border-right: 40px solid transparent;\n        border-bottom: 40px solid <span class=\"hljs-comment\">#ff0000;</span>\n    }\n    </style>\n</head>\n<body>\n  <div></div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-5\">5.如何理解CSS的盒子模型？</h4>\n<blockquote>\n<p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p>\n</blockquote>\n<blockquote>\n<p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-6\">6.如何让一个div水平居中</h4>\n<blockquote>\n<p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p>\n</blockquote>\n<blockquote>\n<p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-7\">7.如何让一个div水平垂直居中</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">div {\nposition: relative / fixed; /* 相对定位或绝对定位均可 */\nwidth:500px;\nheight:300px;\ntop: 50%;\nleft: 50%;\nmargin-top:-150px;\nmargin-left:-250px;\n 外边距为自身宽高的一半 */\nbackground-color: pink; /* 方便看效果 */\n }\n\n.container {\ndisplay: flex;\nalign-items: center; /* 垂直居中 */\njustify-content: center; /* 水平居中 */\n \n}\n.container div {\nwidth: 100px; /* 可省 */\nheight: 100px; /* 可省 */\nbackground-color: pink; /* 方便看效果 */\n}  \n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-8\">8.如何清除浮动？</h4>\n<blockquote>\n<p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式\n{clear:both;height:0;overflow:hidden;}</p>\n</blockquote>\n<blockquote>\n<p>给浮动元素父级设置高度</p>\n</blockquote>\n<blockquote>\n<p>父级同时浮动（需要给父级同级元素添加浮动）</p>\n</blockquote>\n<blockquote>\n<p>父级设置成inline-block，其margin: 0 auto居中方式失效</p>\n</blockquote>\n<blockquote>\n<p>给父级添加overflow:hidden 清除浮动方法</p>\n</blockquote>\n<blockquote>\n<p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">float_div:after{\ncontent:<span class=\"hljs-string\">\".\"</span>;\nclear:both;\ndisplay:block;\nheight:0;\noverflow:hidden;\nvisibility:hidden;\n}\n.float_div{\nzoom:1\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-9\">9.css3实现三栏布局，左右固定，中间自适应</h4>\n<blockquote>\n<p>圣杯布局/双飞翼布局</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .middle,\n        .left,\n        .right {\n            position: relative;\n            <span class=\"hljs-built_in\">float</span>: left;\n            min-height: 130px;\n        }\n        .container {\n            padding: 0 220px 0 200px;\n            overflow: hidden;\n        }\n        .left {\n            margin-left: -100%;\n            left: -200px;\n            width: 200px;\n            background: red;\n        }\n        .right {\n            margin-left: -220px;\n            right: -220px;\n            width: 220px;\n            background: green;\n        }\n        .middle {\n            width: 100%;\n            background: blue;\n            word-break: <span class=\"hljs-built_in\">break</span>-all;\n        }\n    </style>\n</head>\n<body>\n    <div class=<span class=\"hljs-string\">'container'</span>>\n        <div class=<span class=\"hljs-string\">'middle'</span>></div>\n        <div class=<span class=\"hljs-string\">'left'</span>></div>\n        <div class=<span class=\"hljs-string\">'right'</span>></div>\n    </div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">10.display:none 和 visibility: hidden的区别</h4>\n<blockquote>\n<p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>\n</blockquote>\n<blockquote>\n<p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-11\">11.CSS中 link 和@import 的区别是？</h4>\n<blockquote>\n<p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p>\n</blockquote>\n<blockquote>\n<p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p>\n</blockquote>\n<blockquote>\n<p>link方式的样式的权重 高于@import的权重.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-12\">12.position的absolute与fixed共同点与不同点</h4>\n<blockquote>\n<p>共同点：\n改变行内元素的呈现方式，display被置为block\n让元素脱离普通流，不占据空间\n默认会覆盖到非定位元素上</p>\n</blockquote>\n<blockquote>\n<p>不同点：\nabsolute的”根元素“是可以设置的\nfixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-13\">13..transition和animation的区别</h4>\n<blockquote>\n<p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</p>\n</blockquote>\n<blockquote>\n<p>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始\nanimation  指定要绑定到选择器的关键帧的名称</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-14\">14.CSS优先级</h4>\n<pre><code class=\"copyable\">不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性\n\t1.属性后面加!import 会覆盖页面内任何位置定义的元素样式\n\t2.作为style属性写在元素内的样式\n\t3.id选择器\n\t4.类选择器\n\t5.标签选择器\n\t6.通配符选择器（*）\n\t7.浏览器自定义或继承\n**同一级别：后写的会覆盖先写的**\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-15\">15.雪碧图：</h4>\n<pre><code class=\"copyable\">        多个图片集成在一个图片中的图\n\t使用雪碧图可以减少网络请求的次数，加快允许的速度\n\t通过background-position，去定位图片在屏幕的哪个位置\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-16\">二、JS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-17\">1.typeof和instance of 检测数据类型有什么区别？</h4>\n<blockquote>\n<p>相同点：\n都常用来判断一个变量是否为空，或者是什么类型的。</p>\n</blockquote>\n<blockquote>\n<p>不同点：\ntypeof\t\t返回值是一个字符串，用来说明变量的数据类型\ninstanceof        用于判断一个变量是否属于某个对象的实例.</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-18\">16.使元素消失的方法</h4>\n<pre><code class=\"copyable\">visibility:hidden、display:none、z-index=-1、opacity：0\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发\n2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-19\">.谈一谈深克隆和浅克隆？</h4>\n<blockquote>\n<p>浅克隆:\n只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p>\n</blockquote>\n<blockquote>\n<p>深克隆：\n创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\nJSON.parse、JSON.stringify()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-20\">3.es6的新特性都有哪些？</h4>\n<blockquote>\n<p>let定义块级作用域变量\n没有变量的提升，必须先声明后使用\nlet声明的变量，不能与前面的let，var，conset声明的变量重名</p>\n</blockquote>\n<blockquote>\n<p>const 定义只读变量\nconst声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改\nconst声明变量也是一个块级作用域变量\nconst声明的变量没有“变量的提升”，必须先声明后使用\nconst声明的变量不能与前面的let， var ， const声明的变量重\nconst定义的对象\\数组中的属性值可以修改,基础数据类型不可以</p>\n</blockquote>\n<blockquote>\n<p>ES6可以给形参函数设置默认值</p>\n</blockquote>\n<blockquote>\n<p>在数组之前加上三个点（...）展开运算符</p>\n</blockquote>\n<blockquote>\n<p>数组的解构赋值、对象的解构赋值</p>\n</blockquote>\n<blockquote>\n<p>箭头函数的特点\n箭头函数相当于匿名函数，是不能作为构造函数的，不能被new\n箭头函数没有arguments实参集合,取而代之用...剩余运算符解决\n箭头函数没有自己的this。他的this是继承当前上下文中的this\n箭头函数没有函数原型\n箭头函数不能当做Generator函数，不能使用yield关键字\n不能使用call、apply、bind改变箭头函数中this指向\nSet数据结构，数组去重</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-21\">4.==和===区别是什么？</h4>\n<blockquote>\n<p>=赋值</p>\n</blockquote>\n<blockquote>\n<p>==返回一个布尔值；相等返回true，不相等返回false；\n允许不同数据类型之间的比较；\n如果是不同类型的数据进行，会默认进行数据类型之间的转换；\n如果是对象数据类型的比较，比较的是空间地址</p>\n</blockquote>\n<blockquote>\n<p>=== 只要数据类型不一样，就返回false；</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-22\">5.常见的设计模式有哪些？</h4>\n<pre><code class=\"copyable\">1、js工厂模式\n2、js构造函数模式\n3、js原型模式\n4、构造函数+原型的js混合模式\n5、构造函数+原型的动态原型模式\n6、观察者模式\n7、发布订阅模式\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-23\">6.call bind apply 的区别？</h4>\n<blockquote>\n<p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p>\n</blockquote>\n<blockquote>\n<p>call()和apply()的区别就在于，两者之间的参数。</p>\n</blockquote>\n<blockquote>\n<p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p>\n</blockquote>\n<blockquote>\n<p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。\nbind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是\t直接执行该函数。他的参数和call()相同。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-24\">7.js继承方式有哪些？</h4>\n<blockquote>\n<p>原型链继承\n核心： 将父类的实例作为子类的原型</p>\n</blockquote>\n<blockquote>\n<p>构造继承\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>\n</blockquote>\n<blockquote>\n<p>实例继承\n核心：为父类实例添加新特性，作为子类实例返回</p>\n</blockquote>\n<blockquote>\n<p>拷贝继承</p>\n</blockquote>\n<blockquote>\n<p>组合继承\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现\t函数复用</p>\n</blockquote>\n<blockquote>\n<p>寄生组合继承\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实\t例方法/属性，避免的组合继承的缺点</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-25\">8.你怎样看待闭包？</h4>\n<blockquote>\n<p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-26\">9.你是如何理解原型和原型链的？</h4>\n<blockquote>\n<p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-27\">10.浏览器渲染的主要流程是什么?</h4>\n<blockquote>\n<p>将html代码按照深度优先遍历来生成DOM树。\ncss文件下载完后也会进行渲染，生成相应的CSSOM。\n当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。\n接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。\n最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-28\">11.从输入url地址到页面相应都发生了什么？</h4>\n<pre><code class=\"copyable\">1、浏览器的地址栏输入URL并按下回车。\n2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。\n4、根据IP建立TCP连接（三次握手）。\n5、HTTP发起请求。\n6、服务器处理请求，浏览器接收HTTP响应。\n7、渲染页面，构建DOM树。\n8、关闭TCP连接（四次挥手）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-29\">12.session、cookie、localStorage的区别</h4>\n<blockquote>\n<p>相同点\n都是保存在浏览器端，且同源的。</p>\n</blockquote>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li>\n<li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>\n<li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。\n存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>\n<li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>\n<li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li>\n<li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-30\">13.js中跨域方法</h4>\n<blockquote>\n<p>同源策略（协议+端口号+域名要相同）</p>\n</blockquote>\n<blockquote>\n<p>1、jsonp跨域(只能解决get）\n原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p>\n<blockquote>\n<p>步骤：\n1).去创建一个script标签\n2).script的src属性设置接口地址\n3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据\n4).通过定义函数名去接受返回的数据</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>2、document.domain 基础域名相同 子域名不同</p>\n</blockquote>\n<blockquote>\n<p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p>\n</blockquote>\n<blockquote>\n<p>4、服务器设置对CORS的支持\n原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>\n</blockquote>\n<blockquote>\n<p>5、利用h5新特性window.postMessage()</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-31\">14.前端有哪些页面优化方法?</h4>\n<ul>\n<li>减少 HTTP请求数</li>\n<li>从设计实现层面简化页面</li>\n<li>合理设置 HTTP缓存</li>\n<li>资源合并与压缩</li>\n<li>合并 CSS图片，减少请求数的又一个好办法。</li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li>\n<li>多图片网页使用图片懒加载。</li>\n<li>在js中尽量减少闭包的使用</li>\n<li>尽量合并css和js文件</li>\n<li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li>\n<li>减少对DOM的操作</li>\n<li>在JS中避免“嵌套循环”和 “死循环”</li>\n<li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-32\">15.Ajax的四个步骤</h4>\n<blockquote>\n<p>1.创建ajax实例</p>\n</blockquote>\n<blockquote>\n<p>2.执行open 确定要访问的链接 以及同步异步</p>\n</blockquote>\n<blockquote>\n<p>3.监听请求状态</p>\n</blockquote>\n<blockquote>\n<p>4.发送请求</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-33\">16.数组去重的方法</h4>\n<blockquote>\n<p>ES6的set对象\n先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> unique(arr){\n    var arr2 = arr.sort();\n    var res = [arr2[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr2.length;i++){\n        <span class=\"hljs-keyword\">if</span>(arr2[i] !== res[res.length-1]){\n        res.push(arr2[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> res;\n}\n利用下标查询\n <span class=\"hljs-keyword\">function</span> unique(arr){\n    var newArr = [arr[0]];\n    <span class=\"hljs-keyword\">for</span>(var i=1;i<arr.length;i++){\n        <span class=\"hljs-keyword\">if</span>(newArr.indexOf(arr[i]) == -1){\n        newArr.push(arr[i]);\n    }\n}\n<span class=\"hljs-built_in\">return</span> newArr;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-34\">17.ajax中get和post请求的区别</h4>\n<ul>\n<li>get 一般用于获取数据</li>\n<li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li>\n<li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li>\n<li>get安全性较低</li>\n<li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li>\n<li>post 一般用于发送数据</li>\n<li>post传递参数，需要把参数放进请求体中，发送给服务器；</li>\n<li>post请求参数放进了请求体中，对大小没有要求；</li>\n<li>post安全性比较高；</li>\n<li>post请求不会走缓存；</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-35\">18.ajax的状态码</h4>\n<blockquote>\n<p>2开头</p>\n</blockquote>\n<ul>\n<li>200 : 代表请求成功；</li>\n</ul>\n<blockquote>\n<p>3开头</p>\n</blockquote>\n<ul>\n<li>301 : 永久重定向；</li>\n<li>302: 临时转移</li>\n<li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li>\n<li>307:临时重定向</li>\n</ul>\n<blockquote>\n<p>以4开头的都是客户端的问题；</p>\n</blockquote>\n<ul>\n<li>400 :数据/格式错误</li>\n<li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li>\n<li>404 : 路径错误，找不到文件</li>\n</ul>\n<blockquote>\n<p>以5开头都是服务端的问题</p>\n</blockquote>\n<ul>\n<li>500 : 服务器的问题</li>\n<li>503: 超负荷；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-36\">19.移动端的兼容问题</h4>\n<ul>\n<li>给移动端添加点击事件会有300S的延迟\n如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟\n一般在移动端用ontouchstart、ontouchmove、ontouchend</li>\n<li>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上\n尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。\n用fastclick，<a target=\"_blank\" href=\"https://github.com/ftlabs/fastclick\" rel=\"nofollow noopener noreferrer\">github.com/ftlabs/fast…</a>\n用preventDefault阻止a标签的click\n消除 IE10 里面的那个叉号\ninput:-ms-clear{display:none;}</li>\n<li>设置缓存\n手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</li>\n</ul>\n\n<ul>\n<li>圆角BUG\n某些Android手机圆角失效\nbackground-clip: padding-box;\n防止手机中网页放大和缩小\n这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</li>\n</ul>\n\n<ul>\n<li>设置用户截止缩放，一般写视口的时候就已经写好了。</li>\n<li></li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-37\">20.JS中同步和异步,以及js的事件流</h4>\n<blockquote>\n<p>同步：在同一时间内做一件事情</p>\n</blockquote>\n<blockquote>\n<p>异步：在同一时间内做多个事情\nJS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-38\">21.JS中常见的异步任务</h4>\n<blockquote>\n<p>定时器、ajax、事件绑定、回调函数、async await、promise</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-39\">22.TCP的三次握手和四次挥手</h4>\n<blockquote>\n<p>三次握手</p>\n</blockquote>\n<ul>\n<li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li>\n<li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li>\n<li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li>\n</ul>\n<blockquote>\n<p>四次挥手</p>\n</blockquote>\n<ul>\n<li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li>\n<li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li>\n<li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li>\n<li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-40\">23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4>\n<blockquote>\n<blockquote>\n<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-41\">24.DOM diff原理</h4>\n<blockquote>\n<ul>\n<li>如果元素类型发生变化，直接替换</li>\n<li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-42\">25.作用域</h4>\n<blockquote>\n<p>全局作用域</p>\n</blockquote>\n<ul>\n<li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域\n一个页面只有一个全局作用域，全局作用域下有一个window对象\nwindow是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下）\n如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值\n如果变量只被var过，那么存储值是undefined\n在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li>\n</ul>\n<blockquote>\n<p>私有作用域</p>\n</blockquote>\n<ul>\n<li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域）\n私有作用域在全局作用域中形成，具有包含的关系；\n在一个全局作用域中，可以有很多个私有作用域\n在私有作用域下定义的变量都是私有变量\n形参也是私有变量\n函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li>\n</ul>\n<blockquote>\n<p>块级作用域</p>\n</blockquote>\n<ul>\n<li>es6中新引入的一种作用域\n在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域\nvar obj = {} //对象的大括号不是块级作用域\n块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错）\n作用域链</li>\n</ul>\n<blockquote>\n<p>上级作用域</p>\n</blockquote>\n<ul>\n<li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系\n作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链\n当前作用域没有的，则会继续向上一级作用域查找\n当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-43\">26.Promise处理异步</h4>\n<blockquote>\n<p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式”\nnew Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)==\nPromise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行\nPromise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法)\nthen()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject\najax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-44\">27.map和forEach的区别</h4>\n<blockquote>\n<p>相同点</p>\n</blockquote>\n<ul>\n<li>都是循环遍历数组中的每一项\nforEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个\n匿名函数中的this都是指向window\n只能遍历数组</li>\n</ul>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。)\nmap()方法不会改变原始数组\nmap()方法不会对空数组进行检测\nforEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-45\">28.async await函数</h4>\n<blockquote>\n<p>async/await函数是异步代码的新方式</p>\n</blockquote>\n<blockquote>\n<p>async/await是基于promise实现的</p>\n</blockquote>\n<blockquote>\n<p>async/await使异步代码更像同步代码</p>\n</blockquote>\n<blockquote>\n<p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p>\n</blockquote>\n<blockquote>\n<p>默认返回一个promise实例，不能被改变</p>\n</blockquote>\n<blockquote>\n<p>await下面的代码是异步，后面的代码是同步的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-46\">29.this指向</h4>\n<blockquote>\n<ul>\n<li>全局作用域下的this指向window</li>\n<li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li>\n<li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li>\n<li>自执行函数中的this永远指向window</li>\n<li>定时器中函数的this指向window</li>\n<li>构造函数中的this指向当前的实例</li>\n<li>call、apply、bind可以改变函数的this指向</li>\n<li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-47\">30.原型</h4>\n<blockquote>\n<blockquote>\n<p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象\nprototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类\n所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p>\n</blockquote>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-48\">31.异步回调（如何解决回调地狱）</h4>\n<pre><code class=\"copyable\">promise、generator、async/await\n\npromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理\n\t  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱\n\t  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）\n\t  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败\n\t\tpromise.all() 里面状态都改变，那就会输出，得到一个数组\n\t\tpromise.race() 里面只有一个状态变为rejected或者fulfilled即输出\n\t\tpromis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-49\">32.前端事件流</h4>\n<pre><code class=\"copyable\">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。\n      3、冒泡阶段：事件又传播回文档\n   阻止冒泡事件event.stopPropagation()\n\t  function stopBubble(e) {\n    \t\tif (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器\n      \t\te.stopPropagation()\n    \t\t} else {\n      \t\twindow.event.cancelBubble = true //IE方式阻止冒泡\n    \t      }\n  \t\t   }\n   阻止默认行为event.preventDefault()\n function stopDefault(e) {\n    if (e && e.preventDefault) {\n      e.preventDefault()\n    } else {\n      // IE浏览器阻止函数器默认动作的行为\n      window.event.returnValue = false\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-50\">33.事件如何先捕获后冒泡？</h4>\n<blockquote>\n<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，\n对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>\n</blockquote>\n<ul>\n<li>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter\n焦点事件：blur focus\nUI事件：scroll resize</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-51\">34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4>\n<pre><code class=\"copyable\">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。\n对于引用类型：除function，都返回object   null返回object。</p>\n</blockquote>\n<blockquote>\n<p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p>\n</blockquote>\n<blockquote>\n<p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>\n</blockquote>\n<blockquote>\n<p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p>\n</blockquote>\n<blockquote>\n<p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-52\">35.setTimeout 和 setInterval的机制</h4>\n<pre><code class=\"copyable\">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的\n待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-53\">36.splice和slice、map和forEach、 filter()、reduce()的区别</h4>\n<pre><code class=\"copyable\"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，\n 包含从start到end（不包含该元素）的数组方法\n\t注意：该方法不会更新原数组，而是返回一个子数组\n 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）\n\tsplice(index, howmany,item1,...itemx)\n\t\t·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置\n\t\t·howmany参数：必须，要删除的数量，\n\t\t·item1..itemx:可选，向数组添加新项目\n3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据\n4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素\n5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值\n6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-54\">VUE问题</h1>\n<h4 class=\"heading\" data-id=\"heading-55\">1.聊聊对vue的理解</h4>\n<blockquote>\n<p>vue是一个渐进式的JS框架。他易用，灵活，高效；\n可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用；\n他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-56\">2.V-model的原理是什么？</h4>\n<blockquote>\n<p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。\n数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。\n在数据变动时作你想做的事</p>\n<ul>\n<li>原理\n通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新\n在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-57\">3.谈谈对生命周期的理解</h4>\n<ul>\n<li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li>\n<li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li>\n<li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li>\n<li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li>\n<li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li>\n<li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li>\n<li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li>\n<li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-58\">4.VUE和REACT有什么区别？</h4>\n<blockquote>\n<p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p>\n</blockquote>\n<blockquote>\n<p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-59\">5.vuex的流程</h4>\n<pre><code class=\"copyable\">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。\nmutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中\n通过mapGetter来动态获取state中的值\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-60\">6.vuex有哪几种状态和属性</h4>\n<blockquote>\n<ul>\n<li>state中保存着共有数据，数据是响应式的</li>\n<li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li>\n<li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li>\n<li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li>\n<li>modules：模块化vuex</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-61\">7.vue路由的两种模式</h4>\n<blockquote>\n<ul>\n<li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算）\nhash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li>\n<li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li>\n</ul>\n<p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-62\">8.vue中 key 值的作用</h4>\n<blockquote>\n<p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。\n如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>\n</blockquote>\n<blockquote>\n<p>key的作用主要是为了高效的更新虚拟DOM。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-63\">9<code>$route</code>和<code>$router</code>的区别</h4>\n<blockquote>\n<ul>\n<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>\n<li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>\n</ul>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-64\">10.vue-router守卫</h4>\n<blockquote>\n<ul>\n<li>导航守卫 router.beforeEach 全局前置守卫</li>\n</ul>\n</blockquote>\n<ul>\n<li>to: Route: 即将要进入的目标（路由对象）</li>\n<li>from: Route: 当前导航正要离开的路由</li>\n<li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）\n执行效果依赖 next 方法的调用参数。</li>\n<li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li>\n<li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// main.js 入口文件\n    import router from <span class=\"hljs-string\">'./router'</span>; // 引入路由\n    router.beforeEach((to, from, next) => { \n      next();\n    });\n    router.beforeResolve((to, from, next) => {\n      next();\n    });\n    router.afterEach((to, from) => {\n      console.log(<span class=\"hljs-string\">'afterEach 全局后置钩子'</span>);\n    });\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const router = new VueRouter({\n  routes: [\n    {\n      path: <span class=\"hljs-string\">'/foo'</span>,\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开\n    // 可以访问组件实例 `this`\n    // 比如还未保存草稿，或者在用户离开前，\n    将<span class=\"hljs-built_in\">set</span>Interval销毁，防止离开之后，定时器还在调用。\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-65\">11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4>\n<blockquote>\n<p>请求后台资源的模块。</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">$ npm install axios -S装好\n<span class=\"copy-code-btn\">复制代码</span></code></pre><blockquote>\n<p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。\njs中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-66\">12.vue修饰符</h4>\n<ul>\n<li>stop：阻止事件的冒泡</li>\n<li>prevent：阻止事件的默认行为</li>\n<li>once：只触发一次</li>\n<li>self：只触发自己的事件行为时，才会执行</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-67\">13.vue项目中的性能优化</h4>\n<blockquote>\n<p>1.不要在模板里面写过多表达式</p>\n</blockquote>\n<blockquote>\n<p>2.循环调用子组件时添加key</p>\n</blockquote>\n<blockquote>\n<p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p>\n</blockquote>\n<blockquote>\n<p>4.尽量少用float，可以用flex</p>\n</blockquote>\n<blockquote>\n<p>5.按需加载，可以用require或者import()按需加载需要的组件</p>\n</blockquote>\n<blockquote>\n<p>6.路由懒加载</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-68\">14.vue.extend和vue.component</h4>\n<blockquote>\n<ul>\n<li>extend\n是构造一个组件的语法器。\n然后这个组件你可以作用到Vue.component这个全局注册方法里\n还可以在任意vue模板里使用组件。\n也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li>\n<li>Vue.component\n你可以创建 ，也可以取组件。</li>\n</ul>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-69\">常见的兼容问题</h3>\n<blockquote>\n<p>png24位的图片在iE6浏览器上出现背景\n解决方案是做成PNG8.也可以引用一段脚本处理.</p>\n</blockquote>\n<blockquote>\n<p>浏览器默认的margin和padding不同。\n解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>\n</blockquote>\n<blockquote>\n<p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>\n</blockquote>\n<blockquote>\n<p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-70\">React问题</h1>\n<h4 class=\"heading\" data-id=\"heading-71\">1.react和vue的区别</h4>\n<pre><code class=\"copyable\">   =>  相同点：\n\t1.数据驱动页面，提供响应式的试图组件\n\t2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n\t3.数据流动单向，都支持服务器的渲染SSR\n\t4.都有支持native的方法，react有React native， vue有wexx\n=>  不同点：\n\t1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n\t2.数据渲染：大规模的数据渲染，react更快\n\t3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n\t4.开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\t\t    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-72\">2.redux中的reducer（纯函数）</h4>\n<pre><code class=\"copyable\">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）\n更新state(这个state可以理解为上下累加器的结果）\n每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),\n进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-73\">3.react的refs</h4>\n<pre><code class=\"copyable\">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，\n它将接受地城dom元素或组件的已挂在实例，作为第一个参数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-74\">4.react中的keys</h4>\n<pre><code class=\"copyable\">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-75\">5.React的生命周期</h4>\n<pre><code class=\"copyable\">三个状态：Mounting(已插入真实的DOM）\n\t  Updating(正在被重新渲染)\n\t  Unmounting(已移除真实的DOM)\ncomponentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，\ncomponentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-76\">6.React子组件向父组件传值</h4>\n<pre><code class=\"copyable\">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-77\">7.为什么虚拟DOM会提高性能 <a target=\"_blank\" href=\"https://www.zhihu.com/question/29504639?sort=created\" rel=\"nofollow noopener noreferrer\">www.zhihu.com/question/29…</a></h4>\n<pre><code class=\"copyable\">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能\n具体实现步骤：\n\t·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中\n        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异\n\t·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-78\">8.diff算法</h4>\n<pre><code class=\"copyable\">1.把树形结构按照层级分解，只比较同级元素\n2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记\n3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面\nVritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用\nreact只会匹配相同的class的component（这里的class指的是组件的名字）\n合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制\n4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-79\">9.简述下flux的思想</h4>\n<pre><code class=\"copyable\">flux的最大特点，就是数据的‘单向流动’\n1.用户访问View\n2.View发出用户的Action\n3.Dispatcher收到Action,要求state进行相应的更新\n4.store更新后，发出一个‘change’事件后，更新页面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-80\">10.reac性能优化是哪个周期函</h4>\n<pre><code class=\"copyable\">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，\n如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-81\">11.react怎么划分业务组件和技术组件</h4>\n<pre><code class=\"copyable\">根据组件的职责通常把组件分为UI组件和容器组件\nUI组件负责UI的呈现，容器组件负责管理数据和逻辑\n两者通过React-redux提供connect方法联系起来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-82\">12.setState</h4>\n<pre><code class=\"copyable\">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列\n而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值\t\n那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误\n\n同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state\n\n同步更新state:\n\tsetState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。\n\t第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行\n\t也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步\n\n例子：componentDidMount() {\n\n\tfetch('https://test.com')\n    \n\t.then((res) => res.json())\n    \n\t.then(\n    (data) => {\nthis.setState({ data:data });\n\t\t\tStatusBar.setNetworkActivityIndicatorVisible(false);\n        }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-83\">性能优化</h1>\n<h4 class=\"heading\" data-id=\"heading-84\">一、webpack打包文件体积过大？（最终打包为一个js文件）</h4>\n<pre><code class=\"copyable\">1.异步加载模块\n2.提取第三库\n3.代码压缩\n4.去除不必要的插件\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-85\">二、如何优化webpack构建的性能</h4>\n<pre><code class=\"copyable\">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积\n\t\t 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理\n\t\t 3.对一些组件库采用按需加载，避免无用的代码\n二、减少目录检索范围\n\t\t ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度\n\t\n三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-86\">三、移动端的性能优化</h4>\n<pre><code class=\"copyable\">  1、首屏加载和按需加载，懒加载\n  2、资源预加载\n  3、图片压缩处理，使用base64内嵌图片\n  4、合理缓存dom对象\n  5、使用touchstart代替click（click 300毫秒的延迟）\n  6、利用transform:translateZ(0)，开启硬件GUP加速\n  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明\n  8、使用viewport固定屏幕渲染，加速页面渲染内容\n  9、尽量使用事件代理，避免直接事件绑定\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-87\">四、Vue的SPA 如何优化加载速度</h4>\n<pre><code class=\"copyable\">1.减少入口文件体积\n2.静态资源本地缓存\n3.开启Gzip压缩\n4.使用SSR,nuxt.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-88\">五、移动端300ms延迟</h4>\n<pre><code class=\"copyable\">由来：\n300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，\n当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作\n因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕\n       \n解决方案：1.禁用缩放，设置meta标签 user-scalable=no\n\t  2.fastclick.js\n\t\t原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即\n\t\t      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉\nfastclick.js还可以解决穿透问题\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-89\">六、页面的重构；</h4>\n<blockquote>\n<p>在不改变外部行为的前提下，简化结构、添加可读性</p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-90\">服务器端</h1>\n<h4 class=\"heading\" data-id=\"heading-91\">一、状态码：</h4>\n<pre><code class=\"copyable\">  2XX（成功处理了请求状态）\n      200 服务器已经成功处理请求，并提供了请求的网页\n      201 用户新建或修改数据成功\n      202 一个请求已经进入后台\n      204 用户删除成功\n  3XX（每次请求使用的重定向不要超过5次）\n      304 网页上次请求没有更新，节省带宽和开销\n  4XX（表示请求可能出错，妨碍了服务器的处理）\n      400 服务器不理解请求的语法\n      401 用户没有权限（用户名，密码输入错误）\n      403 用户得到授权（401相反），但是访问被禁止\n      404 服务器找不到请求的网页，\n  5XX（表示服务器在处理请求的时候发生内部错误）\n      500 服务器遇到错误，无法完成请求\n      503 服务器目前无法使用（超载或停机维护）     \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-92\">二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4>\n<pre><code class=\"copyable\">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）\n2.304是\tHTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件\n3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A\n\t并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304\n\nlast-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间\n\t\t客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，\n\t\t询问该事件之后文件是否被修改，没修改返回304\n\n 有了Last-Modified，为什么还要用ETag？\n  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）\n  2、某些服务器不能精确的得到文件的最后修改时间\n  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get\n\nETag，为什么还要用Last-Modified？\n  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改\n  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。\n\n\nETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）\n  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-93\">三、get/post的区别</h4>\n<pre><code class=\"copyable\">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提交的数据放在http包的Body中\n2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制\n3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值\n4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-94\">四、http协议的理解</h4>\n<pre><code class=\"copyable\">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议\n2.基于TCP/IP通信协议来传递数据（HTML，图片资源）\n3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统\n4.http请求信息request：\n\t请求行（request line）、请求头部（header）,空行和请求数据四部分构成\n\n\t请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\t请求头部，用来说明服务器要使用的附加信息\n\t空行，请求头部后面的空行是必须的\n\t请求数据也叫主体，可以添加任意的其他数据。\n5.http相应信息Response\n\t状态行、消息报头、空行和响应正文\n\n\t状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成\n\t消息报头，用来说明客户端要使用的一些附加信息\n\t空行，消息报头后面的空行是必须的\n\t响应正文，服务器返回给客户端的文本信息。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-95\">五、http和https</h4>\n<pre><code class=\"copyable\">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密\nhttp：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-96\">六、http1.0 1.1 2.0的区别</h4>\n<pre><code class=\"copyable\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-97\">七、web缓存</h4>\n<pre><code class=\"copyable\">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本\n2.缓存的好处\n        （1）减少不必要的请求\n    （2）降低服务器的压力，减少服务器的消耗\n    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-98\">八、常见的web安全及防护原理</h4>\n<pre><code class=\"copyable\">1.sql注入原理：通郭sql命令插入到web表单递交或者输入活命，达到欺骗服务器执行的恶意sql命令\n\t\t防范：1.对用户输入进行校验\n\t\t       2.不适用动态拼接sql\n2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。\n\t\t        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息\n\t\t\t防范：1.尽量采用post而不使用get提交表单\n\t\t\t      2.避免cookie中泄漏用户的隐式\n3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求\n\t\t\t举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据\n\t\t\t防范：在客服端页面增加伪随机数，通过验证码\nXSS和CSRF的区别：\n   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包\n   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-99\">九、CDN（内容分发网络）</h4>\n<pre><code class=\"copyable\">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。\n2.关键技术：内容存储和分发技术中\n3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术\n\t    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-100\">十、TCP三次握手\t(客服端和服务器端都需要确认各自可收发）</h4>\n<pre><code class=\"copyable\">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。\n第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段\n第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段\n第三次握手： 服务器端确认客服端收到了自己发送的报文段\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-101\">十一、从输入url到获取页面的完整过程  <a target=\"_blank\" href=\"https://blog.csdn.net/samjustin1/article/details/52650520\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/samjustin1/…</a></h4>\n<pre><code class=\"copyable\">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存\n2.浏览器与服务器建立tcp链接（三次握手）\n3.浏览器向服务器发送http请求(请求和传输数据）\n4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器\n5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤\n6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-102\">十二、浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print</h4>\n<pre><code class=\"copyable\">流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树\n概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树\n      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）\n      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置\n      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点\n\n重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上\n\t触发重绘的条件：改变元素外观属性。如：color，background-color等\n\t重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观\n注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局\n\n重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。\n\t每个页面都需要一次回流，就是页面第一次渲染的时候\n\n重排一定会影响重绘，但是重绘不一定会影响重排\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-103\">十三、为什么css放在顶部而js写在后面</h4>\n<pre><code class=\"copyable\">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了\n2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。\n3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验\n\n但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-104\">十四、存储方式与传输方式</h4>\n<pre><code class=\"copyable\">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m\n2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响\n3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）\n4.localStroage: h5的本地存储，数据永久保存在客服端\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-105\">cookie，sessionStorage，localStorage</h4>\n<p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上\n实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象\nsession存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据\n2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id\nsessionStorage，localStorage仅在本地保存\n3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB\n4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭\nsessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储）\nlocalStorage始终有效</p>\n<p>SessionStorage和localStorage区别：\n1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中）\n并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存\n2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p>\n<h4 class=\"heading\" data-id=\"heading-106\">token、cookie、session三者的理解？？？！！！</h4>\n<pre><code class=\"copyable\">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）\n    用户身份的验证方式    \n\n2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名\n    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）\n\n3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）\n    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-107\">基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4>\n<pre><code class=\"copyable\">  1、用户通过用户名和密码发送请求\n  2、服务器端验证\n  3、服务器端返回一个带签名的token，给客户端\n  4、客户端储存token，并且每次用于发送请求\n  5、服务器验证token并且返回数据\n  每一次请求都需要token\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-108\">cookie与session区别</h4>\n<pre><code class=\"copyable\">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。\n  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-109\">session与token区别</h4>\n<pre><code class=\"copyable\">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App\n  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，\n     token不能转移到其他的App，也不能转到其他用户上。（适用于App）\n  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-110\">Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4>\n<pre><code class=\"copyable\">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）\n  2、安全性问题。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-111\">设计模式</h1>\n<blockquote>\n<p>一、观察者模式：<a target=\"_blank\" href=\"https://juejin.im/post/5a14e9edf265da4312808d86\" rel>juejin.im/post/5a14e9…</a>   <a target=\"_blank\" href=\"https://juejin.im/post/5af05d406fb9a07a9e4d2799\" rel>juejin.im/post/5af05d…</a>\n在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系\n简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p>\n</blockquote>\n<blockquote>\n<p>二、发布-订阅者  有一个信息中介，过滤 耦合性低\n它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p>\n</blockquote>\n<ul>\n<li>-两者的区别：\n1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信\n2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。\n3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（）\n4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-112\">数据结构和算法</h1>\n<h4 class=\"heading\" data-id=\"heading-113\">一、两个栈实现一个队列，两个队列实现一个栈 <a target=\"_blank\" href=\"https://www.cnblogs.com/MrListening/p/5697459.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/MrListening…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-114\">二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a target=\"_blank\" href=\"https://juejin.im/post/5a27c6946fb9a04509096248\" rel>juejin.im/post/5a27c6…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-115\">三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a target=\"_blank\" href=\"https://juejin.im/post/5a2ff8c651882533d0230a85\" rel>juejin.im/post/5a2ff8…</a></h4>\n<h4 class=\"heading\" data-id=\"heading-116\">四、十大排序</h4>\n<pre><code class=\"copyable\">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。\n  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个\n\t    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n\t    3.针对所有的元素重复以上的步骤，除了最后一个\n\t    4.重复步骤1-3，直到排序完成。\n2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾\n  实现过程：\n\n3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入\n  实现过程：1.从第一个元素开始，该元素可以认为已经被排序\n\t    2.取出下一个元素，在已排序的元素序列中冲后向前扫描\n\t    3.如果该元素（以排序）大于新元素，将元素向后移一位\n\t    4.在取出一个元素，比较之前的，直到找到自己合适的位置\n\n4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序\n\n1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现\n  实现过程：1.从数组中挑出一个元素，成为一个基准\n\t    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）\n\t\t这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。\n\t    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序\n算法实现： function quickSort (arr) {\n\t\tif （arr.length <= 1） {return arr}\n\t\tvar destIndex = Math.floor(arr.length/2)\n\t\tvar left = [], right = [];\n\t\tvar dest = arr.splice(destIndex,1)[0];\n\t\tfor (var i =0;i<arr.length;i++){\n\t\t\tif (arr[i]<dest) {\n\t\t\tleft.push(arr[i])\n\t\t\t} else {\n\t\t\tright.push(arr[i]) }\n\t\treturn quickSort(left).concat([dest],quickSort(right)\n\t\t\t\n\n2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。\n  实现过程：1.\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-117\">五、数组去重 <a target=\"_blank\" href=\"https://juejin.im/post/5aed6110518825671b026bed#heading-6\" rel>juejin.im/post/5aed61…</a></h4>\n<pre><code class=\"copyable\">1.双重循环\n2.indexOf\n3.数组排序去重 最快你Olong\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-118\">六、字符串</h4>\n<pre><code class=\"copyable\">判断回文字符串：（递归的思想）\n\t1.字符串分隔，倒转，聚合[...obj].reverse().join('')\n\t2.字符串头部和尾部，逐次向中间检测 \n\t\t实现：function isPalindrome(line) {\n\t\t\tline += '';\n\t\t\tfor (var i=0,j=line.length-1;i<j;i++,j--) {\n\t\t\t\tif (line.chartAt(i) !== line.chartAt(j) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t3.递归\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-119\">七、二分查找（有序数组的查找）</h4>\n<pre><code class=\"copyable\"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数\n (1) 一开始,数据范围覆盖整个数组。\n (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。\n (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T\n代码实现：function binarySearch (data, dest, start, end){\n\t\tvar end = end || data.length-1;\n\t\tvar start = start || 0;\n\t\tvar m = Math.floor((start+end)/2);\n\t\tif (dest<data[m]){\n\t\t\treturn binarySearch(data, dest, 0, m-1)\n\t\t} else {\n\t\t\treturn binarySearch(data, dest, m+1, end)\n\t\t}}\n\t\treturn false\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 class=\"heading\" data-id=\"heading-120\">手写代码</h1>\n<h4 class=\"heading\" data-id=\"heading-121\">一、动手实现一个bind（原理通过apply，call）</h4>\n<pre><code class=\"copyable\">一句话概括：1.bind()返回一个新函数，并不会立即执行。\n\t    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数\n\t    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Function.prototype.bind = <span class=\"hljs-keyword\">function</span> (obj, arg) {\n   var arg = Array.prototype.slice.call(arguments, 1);\n   var context = this;\n   var bound = <span class=\"hljs-keyword\">function</span> (newArg) {\n   arg = arg.concat(Array.prototype.slice.call(newArg);\n   <span class=\"hljs-built_in\">return</span> context.apply(obj, arg)\n}\n  var F =  <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {}  // 在new一个<span class=\"hljs-built_in\">bind</span>会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程\n  F.prototype = context.prototype;\n  bound.prototype =  new F();\n  <span class=\"hljs-built_in\">return</span> bound;\n}\t\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-122\">二、 AJAX （异步的javascript和xml）</h4>\n<pre><code class=\"copyable\">ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。\n优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载\n      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带\n劣势：不支持back。对搜索引擎的支持比较弱；不容易调试\t\n怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，\n解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> getData(url) {\n    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象\n    xhr.open(<span class=\"hljs-string\">'get'</span>, url, <span class=\"hljs-literal\">true</span>)  // 设置一个http请求，设置请求的方式，url以及验证身份\n    xhr.send() //发送一个http请求\n    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  //设置一个http请求状态的函数\n      <span class=\"hljs-keyword\">if</span> (xhr.readyState == 4 && xhr.status ==200) {\n        console.log(xhr.responseText)  // 获取异步调用返回的数据\n      }\n    }\n  }\n  Promise(getData(url)).resolve(data => data)\n\n\t AJAX状态码：0 - （未初始化）还没有调用send()方法\n\t\t     1 - （载入）已调用send方法，正在发送请求\n\t\t     2 - （载入完成呢）send()方法执行完成\n\t\t     3 - （交互）正在解析相应内容\n\t\t     4 - （完成）响应内容解析完成，可以在客户端调用了\n```\n\n<span class=\"hljs-comment\">#### 三、函数节流（throttle）</span>\n```\n <span class=\"hljs-keyword\">function</span> throttle (func, <span class=\"hljs-built_in\">wait</span>) {\n        var timeout;\n        var previous = 0;\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n            context = this;\n            args = arguments;\n            <span class=\"hljs-keyword\">if</span> (!timeout) {\n                timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                    timeout = null;\n                    func.apply(context,args)\n                }, <span class=\"hljs-built_in\">wait</span>);\n            }\n        }\n    }\n     \n}\n```\n\n<span class=\"hljs-comment\">#### 四、函数防抖（dobounce）</span>\n```\n <span class=\"hljs-keyword\">function</span> debounce (func, <span class=\"hljs-built_in\">wait</span>) {\n         var timeout;\n         <span class=\"hljs-built_in\">return</span> <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n             var context = this;\n             var args = arguments;\n             clearTimeout(timeout);\n             timeout = <span class=\"hljs-built_in\">set</span>Timeout(() => {\n                 func.apply(context,args)\n             }, <span class=\"hljs-built_in\">wait</span>);\n         }\n     }\n```\n\n<span class=\"hljs-comment\">#### 五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span>\n```    \n    Object.prototype.clone = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> e <span class=\"hljs-keyword\">in</span> this) { //遍历对象的属性 <span class=\"hljs-keyword\">in</span>  this[e]\n        newObject[e] = typeof this[e] === <span class=\"hljs-string\">'object'</span> ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型\n      }\n      <span class=\"hljs-built_in\">return</span> newObject\n    }\n```\n \n<span class=\"hljs-comment\">#### 六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab</span>\n```\nclass Promise {\n  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。\n    this.status = <span class=\"hljs-string\">'pending'</span>,\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功存放的数组\n    this.onResolvedCallbacks = [];\n     // 失败存放法数组\n     this.onRejectedCallbacks = [];\n    <span class=\"hljs-built_in\">let</span> resolve = (value) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'resolve'</span>;\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n\n    <span class=\"hljs-built_in\">let</span> reject = (reason) => {\n      <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n        this.status = <span class=\"hljs-string\">'reject'</span>;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  } \n  <span class=\"hljs-keyword\">then</span> (onFullFilled,onRejected) {\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'resolved'</span>) {\n      onFullFilled(this.value)\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'rejectd'</span>) {\n      onRejected(this.reason);\n    }\n    <span class=\"hljs-keyword\">if</span> (this.status == <span class=\"hljs-string\">'pending'</span>) {\n      this.onResolvedCallbacks.push(()=>{\n        onFullFilled(this.value);\n      })\n      this.onRejectedCallbacks.push(()=> {\n          onRejected(this.reason);\n      })\n  }\n   \n  }\n}\n\nconst p = new Promise((resolve, reject) => {\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n      resolve(<span class=\"hljs-string\">'hello world'</span>)\n  }, 1000);\n})\np.then((data) =>{\n  console.log(data)\n},(err) =>{\n  console.log(err);\n})\n```\n\n<span class=\"hljs-comment\">#### 七、发布订阅者模式（观察者模式）</span>\n```\nvar event = {}; // 发布者\nevent.clientList = [] //发布者的缓存列表\n\nevent.listen = <span class=\"hljs-keyword\">function</span> (fn) {  // 增加订阅者函数\n  this.clientList.push(fn)\n}\n\nevent.trigger = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {  // 发布信息\n  <span class=\"hljs-keyword\">for</span> (var i =0;i<this.clientList.length;i++) {\n    var fn = this.clientList[i];\n    fn.apply(this, arguments);\n  }\n}\n\nevent.listen (<span class=\"hljs-keyword\">function</span>(time) {\n  console.log(<span class=\"hljs-string\">'正式上班时间为：'</span> +time)\n})\nevent.trigger (<span class=\"hljs-string\">'2018/7'</span>)\n```\n\n<span class=\"hljs-comment\">#### 八、手动写一个node服务器</span>\n```\nconst http = require(<span class=\"hljs-string\">'http'</span>);\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\nconst server = http.createServer((req,res) => {\n\t<span class=\"hljs-keyword\">if</span> (reu.url == <span class=\"hljs-string\">'/'</span>) {\n\tconst indexFile = fs.createReadStream(<span class=\"hljs-string\">'./index.html'</span>)\n\treq.writeHead(200,{<span class=\"hljs-string\">'context-Type'</span>:<span class=\"hljs-string\">'text/html;charset = utf8})\n\tindexFile.pipe(res)\n}\nserver.listen(8080)\n```</span><span class=\"copy-code-btn\">复制代码</span></code></pre>",
      "id": "42ou4p218z40",
      "author": "第一名的小蝌蚪",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>灰色的天</p>\n<p>妳的脸</p>\n<p>说分手的语气斩钉截铁</p>\n<p>小蝌蚪：“能不走吗”</p>\n<p>女神：“不能”</p>\n<p>小蝌蚪：“那个男人有什么好”</p>\n<p>女神：“他说话好听，长得帅，还有钱”</p>\n<p>小蝌蚪：“我没房没车没存款，但我有一颗爱妳的心”</p>\n<p>高富帅出现：“我有房有车有存款，我也有一颗爱她的心”</p>\n<p>小蝌蚪：“我能跑十公里去为她买宵夜”</p>\n<p>高富帅：“我开兰博基尼去为她买宵夜”</p>\n<p>小蝌蚪：“我一分钟能敲5000行代码”</p>\n<p>高富帅：“你们公司的老板，是我爸”</p>\n<p>小蝌蚪：“这。。。”</p>\n<p>在金钱力量面前，一切言语都显得那么苍白无力</p>\n<p>小蝌蚪跪在地上，望着高富帅远去的尾灯，消失在地平线</p>\n<p>失恋第三十天，小蝌蚪上山拜佛</p>\n<p>小蝌蚪：“伟大的佛，为何我感情如此失败”</p>\n<p>佛曰：“因为你不够渣，一次只爱一个人，下次同时爱一百个试试？”</p>\n<p>小蝌蚪若有所悟</p>\n<p>小蝌蚪：“伟大的佛，那我如何才能成为江湖第一的渣男”</p>\n<p>佛说：“想要成为顶级渣男，你要闯过三关”</p>\n<p>佛：“第一关我们称之为<富婆>”</p>\n<p>佛：“一位顶级渣男，他需要有雄厚的资金来源，才能浪迹天涯，而富婆是这资金流的关键”</p>\n<h3 class=\"heading\" data-id=\"heading-0\">第一关<富婆></h3>\n<p>得到佛主的指点，小蝌蚪来到国际大酒店</p>\n<p>楼顶正举行富婆八十大寿生日宴</p>\n<p>富婆坐在轮椅上，望着舞池里的妹纸</p>\n<p>满眼都是自己十八岁的样子</p>\n<p>小蝌蚪出现：“女士，您好，我叫小蝌蚪”</p>\n<p>富婆：“有何贵干”</p>\n<p>小蝌蚪：“我想要得到妳的包养”</p>\n<p>富婆的假牙差点从嘴里喷了出来</p>\n<p>富婆：“我的包养，不是你想要，想要就能要”</p>\n<p>小蝌蚪就地表演了一段舌头碎大石</p>\n<p>富婆压制住内心的狂喜，说道：“这还不够，还差了点”</p>\n<p>小蝌蚪：“我一分钟能敲5000行代码，手速奇快”</p>\n<p>富婆大惊：“你就是我唯一的真爱~！”</p>\n<h3 class=\"heading\" data-id=\"heading-1\">第二关<渣女></h3>\n<p>成功拿下富婆后，来到第二关</p>\n<p>佛曰：“你需要撩到一个名叫 '夜魔' 的顶级渣女，通过她身上的《绝世婊技》，你才能悟出传说中的《渣男心经》”</p>\n<p>夜魔常年混迹于夜店</p>\n<p>斡旋在多名富二代之间</p>\n<p>夜魔的座右铭：“肾走多了，才明白走心的可贵”</p>\n<p>“渣男收割机”、“夜店王中王”、“叱咤级渣皇”</p>\n<p>都是她曾用的小名</p>\n<p>一位被她玩死的富二代</p>\n<p>去世前曾留下遗言：</p>\n<p>“</p>\n<p>别爱上她，相信我</p>\n<p>你只是寂寞的晚上</p>\n<p>她想要缠绵的</p>\n<p>小玩具</p>\n<p>”</p>\n<p>夜魔位列年度渣女榜榜首</p>\n<p>小蝌蚪的任务，猎杀夜魔</p>\n<p>凌晨一点，夜店</p>\n<p>小蝌蚪：“小姐姐，您好，我叫小蝌蚪”</p>\n<p>夜魔爱搭不理</p>\n<p>鲁迅说过：“在金钱面前，一切渣女都是纸老虎”</p>\n<p>小蝌蚪故意不经意间露出兰博基尼车钥匙（富婆八十大寿赠）</p>\n<p>夜魔大喜：“哥哥，请坐！”</p>\n<p>夜魔：“哥哥想喝点什么”</p>\n<p>小蝌蚪：“想喝点妳的酒窝”</p>\n<p>面对搭讪，夜魔故作脸红，假装羞涩</p>\n<p>让你觉得她是一个清纯走心的小姐姐</p>\n<p>夜魔：“我看哥哥挺有钱，哥哥职业是什么”</p>\n<p>小蝌蚪：“我的职业是职业渣男”</p>\n<p>一个低端富二代都是炫耀自己多有钱，爸爸多厉害</p>\n<p>但一个顶级富二代，从来都是说自己是渣男</p>\n<p>夜魔：“哥哥有喜欢的人吗”</p>\n<p>小蝌蚪：“有，她在别人的床上”</p>\n<p>小蝌蚪开始打感情牌，宣扬自己受过情伤</p>\n<p>唤母爱，博同情</p>\n<p>夜魔：“哥哥来找我什么事？”</p>\n<p>小蝌蚪：“想借用妳的美色和媚术，帮我攻破一个男人”</p>\n<p>夜魔：“谁？”</p>\n<p>小蝌蚪：“我”</p>\n<p>这是一个调情套路</p>\n<p>面对渣女，你要表现的比她更渣</p>\n<p>妳渣任妳渣，反正都没我渣</p>\n<p>小蝌蚪不再周旋，直接强攻</p>\n<p>小蝌蚪：“明人不说暗话，我想和妳结婚”</p>\n<p>夜魔是远近闻名的渣女，男人们只想和她暧昧</p>\n<p>面对突如其来的‘结婚’，开始手无足措</p>\n<p>小蝌蚪抓住时机，放大招</p>\n<p>谈笑间侧露价值180万的金表（富婆八十大寿赠）</p>\n<p>夜魔大惊</p>\n<p>菊花一紧，虎躯一震</p>\n<p>无数道圣光冲击她的天灵盖</p>\n<p>夜魔热泪盈眶</p>\n<p>满意的点了点头</p>\n<p>酒后三巡，意乱情迷之际</p>\n<p>小蝌蚪带她去找了妈妈</p>\n<p>深藏功与名</p>\n<h3 class=\"heading\" data-id=\"heading-2\">第三关：报复</h3>\n<p>最后一关</p>\n<p>佛曰：“第三关，报仇。报复当初甩掉你的女神和高富帅”</p>\n<p>“好的”，蝌蚪微笑，召唤出了夜魔</p>\n<p>晚八点，高档餐厅</p>\n<p>女神和高富帅在激情派对上亲亲我我</p>\n<p>夜魔出现，上台拿起话筒：</p>\n<p>“台下的小哥哥，请放下女朋友的手，你们被我包围了”</p>\n<p>现场一片哗然</p>\n<p>夜魔：“不是我针对谁，论美色，在座的各位，都是垃圾”</p>\n<p>所有人被夜魔的顶配神颜惊呆</p>\n<p>夜魔：“我会随机抽一个男人，明天和我一起起床”</p>\n<p>鲁迅说过：“我想和妳睡觉，是耍流氓。我想和妳起床，是徐志摩”</p>\n<p>男人们像疯狗一样欢呼和跪舔</p>\n<p>夜魔锁定目标</p>\n<p>径直走向高富帅：“小哥哥，你长得好像我下一任男朋友”</p>\n<p>高富帅惊慌失措：“我我我。。。已经。。。”</p>\n<p>夜魔强撩：“谈恋爱吗？二缺一”</p>\n<p>高富帅捂住心脏：“糟糕，是心动的感觉”</p>\n<p>一旁的女神暴怒：“我xx妳个xx，勾引我男人”</p>\n<p>夜魔一副柔弱装纯的样子：“我只是把他当哥哥～”</p>\n<p>女神继续：“我xx妳个xx”</p>\n<p>夜魔无辜的看着高富帅：“都怪我，害你女朋友生气了”</p>\n<p>高富帅沦陷：“不要理会那八婆”</p>\n<p>女神：“我xx妳个xx”</p>\n<p>夜魔：“她好凶，我好怕”</p>\n<p>高富帅：“不要怕，我的小心心，紫薯于妳”</p>\n<p>鲁迅说过：“渣女装纯，天下无敌”</p>\n<p>高富帅沦为了夜魔的裆下亡魂</p>\n<p>女神跪下，掩面痛哭</p>\n<p>这一切，都是小蝌蚪的精心策划</p>\n<p>佛主出现：“恭喜小蝌蚪，你成为了一位顶级渣男”</p>\n<p>小蝌蚪：“佛心四大皆空，贫僧尘念已结”</p>\n<p>佛曰：“我现赐予你法号——渣佛”</p>\n<p>佛曰：“希望你今后，随老衲去夜店降妖除魔，还人间一片净土”</p>\n<p>小蝌蚪：“哦咪陀佛”</p>\n<p>小蝌蚪终于成为了江湖第一的渣男</p>\n<p>手段虽然残忍</p>\n<p>但我们不要怪渣男渣</p>\n<p>因为每个渣男背后，都有一段刻骨铭心的虐恋</p>\n<p>每一位渣男，都曾是折翼的天使</p>\n<p>甩掉女神那天晚上</p>\n<p>小蝌蚪的肩膀上靠着富婆</p>\n<p>车里循环了一首歌：</p>\n<p>“</p>\n<p>i lost myself again</p>\n<p>我又一次迷失了自己</p>\n<p>but i still remember you</p>\n<p>脑海中的妳依然那么深刻</p>\n<p>don't come back</p>\n<p>别回头看我，那些伤还未愈合</p>\n<p>our love is six feet under</p>\n<p>我们的爱已深埋殆尽</p>\n<p>i can't help but wonder</p>\n<p>不能自己的我很想知道</p>\n<p>if our grave was watered by the rain</p>\n<p>滂沱大雨后，埋葬我们爱的地方</p>\n<p>would rose bloom</p>\n<p>是否会有玫瑰，悄然绽放</p>\n<p>————《six feet under》</p>\n<p>”</p>\n<h3 class=\"heading\" data-id=\"heading-3\">完</h3>\n<blockquote>\n<p>作者：第一名的小蝌蚪</p>\n</blockquote>\n<blockquote>\n<p>微信公众号：前端屌丝</p>\n</blockquote>\n<blockquote>\n<p>github： <a target=\"_blank\" href=\"https://github.com/airuikun/blog\" rel=\"nofollow noopener noreferrer\">github.com/airuikun/bl…</a></p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-4\">《 蝌蚪传记：200行代码实现前端无痕埋点 》</h2>\n<h3 class=\"heading\" data-id=\"heading-5\">背景</h3>\n<p>上次公开演讲结束后，很多小伙伴对无痕埋点很感兴趣</p>\n<p>那这次就讲讲前端无痕埋点的原理与实现吧。</p>\n<p>鲁迅说过：“一切不放源码的技术文章都是耍流氓”</p>\n<p>所以无痕埋点源码：<a target=\"_blank\" href=\"https://github.com/airuikun/smart-tracker\" rel=\"nofollow noopener noreferrer\">smart-tracker</a></p>\n<h3 class=\"heading\" data-id=\"heading-6\">什么是无痕埋点</h3>\n<p>简单来说，就是当引入无痕埋点的库以后</p>\n<p>用户在浏览器里所有行为和操作都会被自动记录下来</p>\n<p>并将信息发送到后端进行统计和分析</p>\n<p>传统的埋点形式，都是手动埋点</p>\n<p>在指定的元素上绑定事件</p>\n<p>将用户行为信息发送到服务端进行统计</p>\n<p>假设如果有一万个点需要前端狗去埋，惊喜不惊喜，意外不意外</p>\n<h3 class=\"heading\" data-id=\"heading-7\">我们为什么要做无痕埋点</h3>\n<p>提高工作效率，解放双手</p>\n<p>屌丝的双手得到解放以后</p>\n<p>就有更多的时间拿双手来取悦自己</p>\n<p>嘻嘻</p>\n<h3 class=\"heading\" data-id=\"heading-8\">无痕埋点原理</h3>\n<p>原理很简单，这里只讲click的无痕埋点原理</p>\n<p>当用户点击了页面上某一个元素</p>\n<p>我们要把当前元素到body之间整个dom的路径记录下来，作为这个元素的唯一标识，我们称之为domPath</p>\n<p>这个domPath不仅是这个元素唯一标识</p>\n<p>还可以通过document.querySelector(domPath)去唯一选择和定位到这个元素</p>\n<p>当用户点击一次这个元素，就会将埋点数据上传到服务器</p>\n<p>服务器上这个domPath对应的统计数据加一</p>\n<h3 class=\"heading\" data-id=\"heading-9\">无痕埋点代码实现</h3>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    <span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">'click'</span>,  (event) => {\n        <span class=\"hljs-keyword\">const</span> eventFix = getEvent(event);\n        <span class=\"hljs-keyword\">if</span> (!eventFix) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">this</span>._handleEvent(eventFix);\n    }, <span class=\"hljs-literal\">false</span>)\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>首先在document的body上监听和绑定全局click事件，捕获用户所有的点击事件。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> getDomPath = <span class=\"hljs-function\">(<span class=\"hljs-params\">element, useClass = <span class=\"hljs-literal\">false</span></span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (!(element <span class=\"hljs-keyword\">instanceof</span> HTMLElement)) {\n        <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'input is not a HTML element!'</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>;\n    }\n    <span class=\"hljs-keyword\">let</span> domPath = [];\n    <span class=\"hljs-keyword\">let</span> elem = element;\n    <span class=\"hljs-keyword\">while</span> (elem) {\n        <span class=\"hljs-keyword\">let</span> domDesc = getDomDesc(elem, useClass);\n        <span class=\"hljs-keyword\">if</span> (!domDesc) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        domPath.unshift(domDesc);\n        <span class=\"hljs-keyword\">if</span> (querySelector(domPath.join(<span class=\"hljs-string\">'>'</span>)) === element || domDesc.indexOf(<span class=\"hljs-string\">'body'</span>) >= <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        domPath.shift();\n        <span class=\"hljs-keyword\">const</span> children = elem.parentNode.children;\n        <span class=\"hljs-keyword\">if</span> (children.length > <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < children.length; i++) {\n                <span class=\"hljs-keyword\">if</span> (children[i] === elem) {\n                    domDesc += <span class=\"hljs-string\">`:nth-child(<span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>)`</span>;\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n        }\n        domPath.unshift(domDesc);\n        <span class=\"hljs-keyword\">if</span> (querySelector(domPath.join(<span class=\"hljs-string\">'>'</span>)) === element) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        elem = elem.parentNode;\n    }\n    <span class=\"hljs-keyword\">return</span> domPath.join(<span class=\"hljs-string\">'>'</span>);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这段代码是关键，获取元素唯一标识domPath</p>\n<p>getDomPath函数传入的是用户点击事件的target对象: getDomPath(event.target)。</p>\n<p>主要思路是找到当前元素event.target</p>\n<p>然后不断的去循环找它的父节点parentNode</p>\n<p>将父节点的tagName当做domPath路径上的节点</p>\n<p>如果当前元素有id，那就取消所有路径的循环，直接讲id赋值给domPath</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    <span class=\"hljs-keyword\">const</span> children = elem.parentNode.children;\n    <span class=\"hljs-keyword\">if</span> (children.length > <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < children.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (children[i] === elem) {\n                domDesc += <span class=\"hljs-string\">`:nth-child(<span class=\"hljs-subst\">${i + <span class=\"hljs-number\">1</span>}</span>)`</span>;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n    }\n    domPath.unshift(domDesc);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>getDomPath函数中的这段代码</p>\n<p>意思是在同一级上出现了多个相同tagName元素</p>\n<p>那我们要定位到这个event.target这个元素在这一级里的第几个</p>\n<p>假设这个div是同一级的第三个，那返回的就是div:nth-child(3)</p>\n<p>这样就可以在document.querySelector(domPath)里唯一定位到这个元素</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    _handleEvent(event) {\n        <span class=\"hljs-keyword\">const</span> domPath = getDomPath(event.target);\n        <span class=\"hljs-keyword\">const</span> rect = getBoundingClientRect(event.target);\n        <span class=\"hljs-keyword\">if</span> (rect.width == <span class=\"hljs-number\">0</span> || rect.height == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-built_in\">document</span>.documentElement || <span class=\"hljs-built_in\">document</span>.body.parentNode;\n        <span class=\"hljs-keyword\">const</span> scrollX = (t && <span class=\"hljs-keyword\">typeof</span> t.scrollLeft == <span class=\"hljs-string\">'number'</span> ? t : <span class=\"hljs-built_in\">document</span>.body).scrollLeft;\n        <span class=\"hljs-keyword\">const</span> scrollY = (t && <span class=\"hljs-keyword\">typeof</span> t.scrollTop == <span class=\"hljs-string\">'number'</span> ? t : <span class=\"hljs-built_in\">document</span>.body).scrollTop;\n        <span class=\"hljs-keyword\">const</span> pageX = event.pageX || event.clientX + scrollX;\n        <span class=\"hljs-keyword\">const</span> pageY = event.pageY || event.clientY + scrollY;\n        <span class=\"hljs-keyword\">const</span> data = {\n            <span class=\"hljs-attr\">domPath</span>: <span class=\"hljs-built_in\">encodeURIComponent</span>(domPath),\n            <span class=\"hljs-attr\">trackingType</span>: event.type,\n            <span class=\"hljs-attr\">offsetX</span>: ((pageX - rect.left - scrollX) / rect.width).toFixed(<span class=\"hljs-number\">6</span>),\n            <span class=\"hljs-attr\">offsetY</span>: ((pageY - rect.top - scrollY) / rect.height).toFixed(<span class=\"hljs-number\">6</span>),\n        };\n        <span class=\"hljs-keyword\">this</span>.send(data);\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这段代码就是得到用户点击某个元素的相对位置的横向位置和竖向位置比例</p>\n<p>得到这个位置的值，就可以反向从埋点数据中得到用户点击元素的具体位置</p>\n<p>因为是个比例值，所以在反向推导中还能自适应页面大小的改变</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">    send(data = {}) {\n        <span class=\"hljs-keyword\">const</span> image = <span class=\"hljs-keyword\">new</span> Image(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);\n        image.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n            image = <span class=\"hljs-literal\">null</span>;\n        };\n        image.src = <span class=\"hljs-string\">`/?<span class=\"hljs-subst\">${stringify(data)}</span>`</span>;\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>得到了用户点击的位置信息和唯一标识domPath</p>\n<p>就可以将数据发送到服务端进行统计了</p>\n<p>用image的src，将数据进行传输</p>\n<p>用image的src有个好处就是轻量，并且还支持跨域</p>\n<p>打点基本上都用的这个方法进行发送数据</p>\n<h3 class=\"heading\" data-id=\"heading-10\">结尾</h3>\n<p>两个多月没写文章了，因为在忙着晋升</p>\n<p>这次晋升最大的感悟就是，如果你只一心专注业务，是很难晋升成功的</p>\n<p>需要在日常工作中做一些技术型需求</p>\n<p>而无痕埋点，是一个不错的选择</p>\n<p>但是这篇文章仅仅只是无痕埋点的一个简单实现</p>\n<p>对整个无痕埋点体系来说，这些只是冰山一角</p>\n<p>真正的无痕埋点，还需要做统计、分析、差量预测、标记策略、智能降噪、可视化无痕、无痕分桶、反向推导热力图、大数据中台等等\n涉及到前端、后端、运维、DBA和算法</p>\n<p>一起干下来，那你就是江湖顶级的前端渣男了</p>\n<p>以上就是文章的全部了，谢谢你能全部看完</p>\n<p>最后，祝你过上幸福快乐的生活</p>\n<blockquote>\n<p>作者：第一名的小蝌蚪</p>\n</blockquote>\n<blockquote>\n<p>微信公众号：前端屌丝</p>\n</blockquote>\n<blockquote>\n<p>github： <a target=\"_blank\" href=\"https://github.com/airuikun/blog\" rel=\"nofollow noopener noreferrer\">github.com/airuikun/bl…</a></p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-11\">往期文章</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/6\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：端口转发——夜店传说</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/5\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：git时光穿梭机——女神的侧颜</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/airuikun/blog/issues/1\" rel=\"nofollow noopener noreferrer\">小蝌蚪传记：PNG图片压缩原理——屌丝的眼泪</a></li>\n</ul>\n",
      "id": "5dagssi80f80",
      "author": "云中桥",
      "title": "小蝌蚪传记：200行代码实现前端无痕埋点",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做<code>长列表</code>。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>\n<p>在<a target=\"_blank\" href=\"https://juejin.im/post/5d76f469f265da039a28aff7\" rel>高性能渲染十万条数据(时间分片)</a>一文中，提到了可以使用<code>时间分片</code>的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用<code>虚拟列表</code>的方式，来同时加载大量数据。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">为什么需要使用虚拟列表</h2>\n<p>假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"button\"</span>></span>button<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">br</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"container\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">ul</span>></span>  \n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'button'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// 记录任务开始时间</span>\n    <span class=\"hljs-keyword\">let</span> now = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-comment\">// 插入一万条数据</span>\n    <span class=\"hljs-keyword\">const</span> total = <span class=\"hljs-number\">10000</span>;\n    <span class=\"hljs-comment\">// 获取容器</span>\n    <span class=\"hljs-keyword\">let</span> ul = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'container'</span>);\n    <span class=\"hljs-comment\">// 将数据插入容器中</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < total; i++) {\n        <span class=\"hljs-keyword\">let</span> li = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'li'</span>);\n        li.innerText = ~~(<span class=\"hljs-built_in\">Math</span>.random() * total)\n        ul.appendChild(li);\n    }\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'JS运行时间：'</span>,<span class=\"hljs-built_in\">Date</span>.now() - now);\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=></span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'总运行时间：'</span>,<span class=\"hljs-built_in\">Date</span>.now() - now);\n    },<span class=\"hljs-number\">0</span>)\n\n    <span class=\"hljs-comment\">// print JS运行时间： 38</span>\n    <span class=\"hljs-comment\">// print 总运行时间： 957 </span>\n  })\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为<code>38ms</code>,但渲染完成后的总时间为<code>957ms</code>。</p>\n<p>简单说明一下，为何两次<code>console.log</code>的结果时间差异巨大，并且是如何简单来统计<code>JS运行时间</code>和<code>总渲染时间</code>：</p>\n<ul>\n<li>在 JS 的<code>Event Loop</code>中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</li>\n<li>第一个<code>console.log</code>的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li>\n<li>第二个<code>console.log</code>是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次<code>Event Loop</code>中执行的</li>\n</ul>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" rel>关于Event Loop的详细内容请参见这篇文章--></a></p>\n<p>然后，我们通过<code>Chrome</code>的<code>Performance</code>工具来详细的分析这段代码的性能瓶颈在哪里：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1518f6871e6c6?imageslim\" data-width=\"1280\" data-height=\"519\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"519\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>从<code>Performance</code>可以看出，代码从执行到渲染结束，共消耗了<code>960.8ms</code>,其中的主要时间消耗如下：</p>\n<ul>\n<li>Event(click) : <code>40.84ms</code></li>\n<li>Recalculate Style : <code>105.08ms</code></li>\n<li>Layout : <code>731.56ms</code></li>\n<li>Update Layer Tree : <code>58.87ms</code></li>\n<li>Paint : <code>15.32ms</code></li>\n</ul>\n<p>从这里我们可以看出，我们的代码的执行过程中，消耗时间最多的两个阶段是<code>Recalculate Style</code>和<code>Layout</code>。</p>\n<ul>\n<li><code>Recalculate Style</code>：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。</li>\n<li><code>Layout</code>：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。</li>\n</ul>\n<p>在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。</p>\n<p>那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在<code>Recalculate Style</code>和<code>Layout</code>阶段消耗大量的时间。</p>\n<p>而<code>虚拟列表</code>就是解决这一问题的一种实现。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">什么是虚拟列表</h2>\n<p><code>虚拟列表</code>其实是按需显示的一种实现，即只对<code>可见区域</code>进行渲染，对<code>非可见区域</code>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p>\n<p>假设有1万条记录需要同时渲染，我们屏幕的<code>可见区域</code>的高度为<code>500px</code>,而列表项的高度为<code>50px</code>，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e15195cf16a558?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"506\" data-height=\"642\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"506\" height=\"642\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕<code>可见区域</code>应该显示的列表项。</p>\n<p>假设滚动发生，滚动条距顶部的位置为<code>150px</code>,则我们可得知在<code>可见区域</code>内的列表项为<code>第4项</code>至`第13项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e15197c273cbd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"506\" data-height=\"677\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"506\" height=\"677\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">实现</h2>\n<p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载<code>可视区域</code>内需要的列表项，当滚动发生时，动态通过计算获得<code>可视区域</code>内的列表项，并将<code>非可视区域</code>内存在的列表项删除。</p>\n<ul>\n<li>计算当前<code>可视区域</code>起始数据索引(<code>startIndex</code>)</li>\n<li>计算当前<code>可视区域</code>结束数据索引(<code>endIndex</code>)</li>\n<li>计算当前<code>可视区域的</code>数据，并渲染到页面中</li>\n<li>计算<code>startIndex</code>对应的数据在整个列表中的偏移位置<code>startOffset</code>并设置到列表上</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1519a393dee2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"719\" data-height=\"677\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"719\" height=\"677\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>由于只是对<code>可视区域</code>内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-container\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-phantom\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list\"</span>></span>\n      <span class=\"hljs-comment\"><!-- item-1 --></span>\n      <span class=\"hljs-comment\"><!-- item-2 --></span>\n      <span class=\"hljs-comment\"><!-- ...... --></span>\n      <span class=\"hljs-comment\"><!-- item-n --></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><code>infinite-list-container</code> 为<code>可视区域</code>的容器</li>\n<li><code>infinite-list-phantom</code> 为容器内的占位，高度为总列表高度，用于形成滚动条</li>\n<li><code>infinite-list</code> 为列表项的<code>渲染区域</code></li>\n</ul>\n<p>接着，监听<code>infinite-list-container</code>的<code>scroll</code>事件，获取滚动位置<code>scrollTop</code></p>\n<ul>\n<li>假定<code>可视区域</code>高度固定，称之为<code>screenHeight</code></li>\n<li>假定<code>列表每项</code>高度固定，称之为<code>itemSize</code></li>\n<li>假定<code>列表数据</code>称之为<code>listData</code></li>\n<li>假定<code>当前滚动位置</code>称之为<code>scrollTop</code></li>\n</ul>\n<p>则可推算出：</p>\n<ul>\n<li>列表总高度<code>listHeight</code> = listData.length * itemSize</li>\n<li>可显示的列表项数<code>visibleCount</code> = Math.ceil(screenHeight / itemSize)</li>\n<li>数据的起始索引<code>startIndex</code> = Math.floor(scrollTop / itemSize)</li>\n<li>数据的结束索引<code>endIndex</code> = startIndex + visibleCount</li>\n<li>列表显示数据为<code>visibleData</code> = listData.slice(startIndex,endIndex)</li>\n</ul>\n<p>当滚动后，由于<code>渲染区域</code>相对于<code>可视区域</code>已经发生了偏移，此时我需要获取一个偏移量<code>startOffset</code>，通过样式控制将<code>渲染区域</code>偏移至<code>可视区域</code>中。</p>\n<ul>\n<li>偏移量<code>startOffset</code> = scrollTop - (scrollTop % itemSize);</li>\n</ul>\n<p>最终的<code>简易代码</code>如下：</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"list\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-container\"</span> @<span class=\"hljs-attr\">scroll</span>=<span class=\"hljs-string\">\"scrollEvent($event)\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-phantom\"</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ height: listHeight + 'px' }\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list\"</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ transform: getTransform }\"</span>></span>\n      <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"items\"</span>\n        <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"infinite-list-item\"</span>\n        <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in visibleData\"</span>\n        <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>\n        <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{ height: itemSize + 'px',lineHeight: itemSize + 'px' }\"</span>\n      ></span>{{ item.value }}<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">'VirtualList'</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-comment\">//所有列表数据</span>\n    listData:{\n      <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">default</span>:<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=></span>[]\n    },\n    <span class=\"hljs-comment\">//每项高度</span>\n    itemSize: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>:<span class=\"hljs-number\">200</span>\n    }\n  },\n  <span class=\"hljs-attr\">computed</span>:{\n    <span class=\"hljs-comment\">//列表总高度</span>\n    listHeight(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.listData.length * <span class=\"hljs-keyword\">this</span>.itemSize;\n    },\n    <span class=\"hljs-comment\">//可显示的列表项数</span>\n    visibleCount(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.ceil(<span class=\"hljs-keyword\">this</span>.screenHeight / <span class=\"hljs-keyword\">this</span>.itemSize)\n    },\n    <span class=\"hljs-comment\">//偏移量对应的style</span>\n    getTransform(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`translate3d(0,<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.startOffset}</span>px,0)`</span>;\n    },\n    <span class=\"hljs-comment\">//获取真实显示列表数据</span>\n    visibleData(){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.listData.slice(<span class=\"hljs-keyword\">this</span>.start, <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.end,<span class=\"hljs-keyword\">this</span>.listData.length));\n    }\n  },\n  mounted() {\n    <span class=\"hljs-keyword\">this</span>.screenHeight = <span class=\"hljs-keyword\">this</span>.$el.clientHeight;\n    <span class=\"hljs-keyword\">this</span>.start = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.end = <span class=\"hljs-keyword\">this</span>.start + <span class=\"hljs-keyword\">this</span>.visibleCount;\n  },\n  data() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-comment\">//可视区域高度</span>\n      screenHeight:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//偏移量</span>\n      startOffset:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//起始索引</span>\n      start:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-comment\">//结束索引</span>\n      end:<span class=\"hljs-literal\">null</span>,\n    };\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    scrollEvent() {\n      <span class=\"hljs-comment\">//当前滚动位置</span>\n      <span class=\"hljs-keyword\">let</span> scrollTop = <span class=\"hljs-keyword\">this</span>.$refs.list.scrollTop;\n      <span class=\"hljs-comment\">//此时的开始索引</span>\n      <span class=\"hljs-keyword\">this</span>.start = <span class=\"hljs-built_in\">Math</span>.floor(scrollTop / <span class=\"hljs-keyword\">this</span>.itemSize);\n      <span class=\"hljs-comment\">//此时的结束索引</span>\n      <span class=\"hljs-keyword\">this</span>.end = <span class=\"hljs-keyword\">this</span>.start + <span class=\"hljs-keyword\">this</span>.visibleCount;\n      <span class=\"hljs-comment\">//此时的偏移量</span>\n      <span class=\"hljs-keyword\">this</span>.startOffset = scrollTop - (scrollTop % <span class=\"hljs-keyword\">this</span>.itemSize);\n    }\n  }\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist-1-rp8pi\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151e017d7bba3?imageslim\" data-width=\"1270\" data-height=\"427\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1270\" height=\"427\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">列表项动态高度</h2>\n<p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p>\n<p>比如这种情况：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e1519f1e121be9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"417\" data-height=\"702\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"417\" height=\"702\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>在虚拟列表中应用动态高度的解决方案一般有如下三种：</p>\n<blockquote>\n<p>1.对组件属性<code>itemSize</code>进行扩展，支持传递类型为<code>数字</code>、<code>数组</code>、<code>函数</code></p>\n</blockquote>\n<ul>\n<li>可以是一个固定值，如 100，此时列表项是固高的</li>\n<li>可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, ...]</li>\n<li>可以是一个根据列表项索引返回其高度的函数：(index: number): number</li>\n</ul>\n<p>这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。</p>\n<blockquote>\n<p>2.将列表项<code>渲染到屏幕外</code>，对其高度进行测量并缓存，然后再将其渲染至可视区域内。</p>\n</blockquote>\n<p>由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。</p>\n<blockquote>\n<p>3.以<code>预估高度</code>先行渲染，然后获取真实高度并缓存。</p>\n</blockquote>\n<p>这是我选择的实现方式，可以避免前两种方案的不足。</p>\n<p>接下来，来看如何简易的实现：</p>\n<p>定义组件属性<code>estimatedItemSize</code>,用于接收<code>预估高度</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">props: {\n  <span class=\"hljs-comment\">//预估高度</span>\n  estimatedItemSize:{\n    <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Number</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>定义<code>positions</code>，用于列表项渲染后存储<code>每一项的高度以及位置</code>信息，</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">this</span>.positions = [\n  <span class=\"hljs-comment\">// {</span>\n  <span class=\"hljs-comment\">//   top:0,</span>\n  <span class=\"hljs-comment\">//   bottom:100,</span>\n  <span class=\"hljs-comment\">//   height:100</span>\n  <span class=\"hljs-comment\">// }</span>\n];\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>并在初始时根据<code>estimatedItemSize</code>对<code>positions</code>进行初始化。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">initPositions(){\n  <span class=\"hljs-keyword\">this</span>.positions = <span class=\"hljs-keyword\">this</span>.listData.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item,index</span>)=></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      index,\n      <span class=\"hljs-attr\">height</span>:<span class=\"hljs-keyword\">this</span>.estimatedItemSize,\n      <span class=\"hljs-attr\">top</span>:index * <span class=\"hljs-keyword\">this</span>.estimatedItemSize,\n      <span class=\"hljs-attr\">bottom</span>:(index + <span class=\"hljs-number\">1</span>) * <span class=\"hljs-keyword\">this</span>.estimatedItemSize\n    }\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于列表项高度不定，并且我们维护了<code>positions</code>，用于记录每一项的位置，而<code>列表高度</code>实际就等于列表中最后一项的底部距离列表顶部的位置。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//列表总高度</span>\nlistHeight(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.positions[<span class=\"hljs-keyword\">this</span>.positions.length - <span class=\"hljs-number\">1</span>].bottom;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于需要在<code>渲染完成</code>后，获取列表每项的位置信息并缓存，所以使用钩子函数<code>updated</code>来实现：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">updated(){\n  <span class=\"hljs-keyword\">let</span> nodes = <span class=\"hljs-keyword\">this</span>.$refs.items;\n  nodes.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>)=></span>{\n    <span class=\"hljs-keyword\">let</span> rect = node.getBoundingClientRect();\n    <span class=\"hljs-keyword\">let</span> height = rect.height;\n    <span class=\"hljs-keyword\">let</span> index = +node.id.slice(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">let</span> oldHeight = <span class=\"hljs-keyword\">this</span>.positions[index].height;\n    <span class=\"hljs-keyword\">let</span> dValue = oldHeight - height;\n    <span class=\"hljs-comment\">//存在差值</span>\n    <span class=\"hljs-keyword\">if</span>(dValue){\n      <span class=\"hljs-keyword\">this</span>.positions[index].bottom = <span class=\"hljs-keyword\">this</span>.positions[index].bottom - dValue;\n      <span class=\"hljs-keyword\">this</span>.positions[index].height = height;\n      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k = index + <span class=\"hljs-number\">1</span>;k<<span class=\"hljs-keyword\">this</span>.positions.length; k++){\n        <span class=\"hljs-keyword\">this</span>.positions[k].top = <span class=\"hljs-keyword\">this</span>.positions[k<span class=\"hljs-number\">-1</span>].bottom;\n        <span class=\"hljs-keyword\">this</span>.positions[k].bottom = <span class=\"hljs-keyword\">this</span>.positions[k].bottom - dValue;\n      }\n    }\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>滚动后获取列表<code>开始索引</code>的方法修改为通过<code>缓存</code>获取：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//获取列表起始索引</span>\ngetStartIndex(scrollTop = <span class=\"hljs-number\">0</span>){\n  <span class=\"hljs-keyword\">let</span> item = <span class=\"hljs-keyword\">this</span>.positions.find(<span class=\"hljs-function\"><span class=\"hljs-params\">i</span> =></span> i && i.bottom > scrollTop);\n  <span class=\"hljs-keyword\">return</span> item.index;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>由于我们的缓存数据，本身就是有顺序的，所以获取<code>开始索引</code>的方法可以考虑通过<code>二分查找</code>的方式来降低检索次数：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">//获取列表起始索引</span>\ngetStartIndex(scrollTop = <span class=\"hljs-number\">0</span>){\n  <span class=\"hljs-comment\">//二分法查找</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.binarySearch(<span class=\"hljs-keyword\">this</span>.positions,scrollTop)\n},\n<span class=\"hljs-comment\">//二分法查找</span>\nbinarySearch(list,value){\n  <span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> end = list.length - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> tempIndex = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">while</span>(start <= end){\n    <span class=\"hljs-keyword\">let</span> midIndex = <span class=\"hljs-built_in\">parseInt</span>((start + end)/<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">let</span> midValue = list[midIndex].bottom;\n    <span class=\"hljs-keyword\">if</span>(midValue === value){\n      <span class=\"hljs-keyword\">return</span> midIndex + <span class=\"hljs-number\">1</span>;\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(midValue < value){\n      start = midIndex + <span class=\"hljs-number\">1</span>;\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(midValue > value){\n      <span class=\"hljs-keyword\">if</span>(tempIndex === <span class=\"hljs-literal\">null</span> || tempIndex > midIndex){\n        tempIndex = midIndex;\n      }\n      end = end - <span class=\"hljs-number\">1</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> tempIndex;\n},\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>滚动后将<code>偏移量</code>的获取方式变更：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">scrollEvent() {\n  <span class=\"hljs-comment\">//...省略</span>\n  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.start >= <span class=\"hljs-number\">1</span>){\n    <span class=\"hljs-keyword\">this</span>.startOffset = <span class=\"hljs-keyword\">this</span>.positions[<span class=\"hljs-keyword\">this</span>.start - <span class=\"hljs-number\">1</span>].bottom\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">this</span>.startOffset = <span class=\"hljs-number\">0</span>;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>通过<a target=\"_blank\" href=\"https://github.com/marak/Faker.js/\" rel=\"nofollow noopener noreferrer\">faker.js</a> 来创建一些<code>随机数据</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span> data = [];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span>; id < <span class=\"hljs-number\">10000</span>; id++) {\n  data.push({\n    id,\n    <span class=\"hljs-attr\">value</span>: faker.lorem.sentences() <span class=\"hljs-comment\">// 长文本</span>\n  })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist2-1bqk6\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151e96584b690?imageslim\" data-width=\"360\" data-height=\"655\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"360\" height=\"655\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>从演示效果上看，我们实现了基于<code>文字内容动态撑高列表项</code>情况下的<code>虚拟列表</code>，但是我们可能会发现，当滚动过快时，会出现短暂的<code>白屏现象</code>。</p>\n<p>为了使页面平滑滚动，我们还需要在<code>可见区域</code>的上方和下方渲染额外的项目，在滚动时给予一些<code>缓冲</code>，所以将屏幕分为三个区域：</p>\n<ul>\n<li>可视区域上方：<code>above</code></li>\n<li>可视区域：<code>screen</code></li>\n<li>可视区域下方：<code>below</code></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151a59317cae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"461\" data-height=\"493\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"461\" height=\"493\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>定义组件属性<code>bufferScale</code>,用于接收<code>缓冲区数据</code>与<code>可视区数据</code>的<code>比例</code></p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">props: {\n  <span class=\"hljs-comment\">//缓冲区比例</span>\n  bufferScale:{\n    <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-attr\">default</span>:<span class=\"hljs-number\">1</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可视区上方渲染条数<code>aboveCount</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">aboveCount(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.start,<span class=\"hljs-keyword\">this</span>.bufferScale * <span class=\"hljs-keyword\">this</span>.visibleCount)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可视区下方渲染条数<code>belowCount</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">belowCount(){\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.min(<span class=\"hljs-keyword\">this</span>.listData.length - <span class=\"hljs-keyword\">this</span>.end,<span class=\"hljs-keyword\">this</span>.bufferScale * <span class=\"hljs-keyword\">this</span>.visibleCount);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>真实渲染数据<code>visibleData</code>获取方式如下：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">visibleData(){\n  <span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-keyword\">this</span>.start - <span class=\"hljs-keyword\">this</span>.aboveCount;\n  <span class=\"hljs-keyword\">let</span> end = <span class=\"hljs-keyword\">this</span>.end + <span class=\"hljs-keyword\">this</span>.belowCount;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>._listData.slice(start, end);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><a target=\"_blank\" href=\"https://codesandbox.io/s/virtuallist-3-i3h9v\" rel=\"nofollow noopener noreferrer\">点击查看在线DEMO及完整代码</a></p>\n<p>最终效果如下：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e151ee0eb0fc89?imageslim\" data-width=\"360\" data-height=\"636\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"360\" height=\"636\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>基于这个方案，个人开发了一个基于Vue2.x的虚拟列表组件：<a target=\"_blank\" href=\"https://github.com/chenqf/vue-virtual-listview\" rel=\"nofollow noopener noreferrer\">vue-virtual-listview</a>,可<a target=\"_blank\" href=\"https://github.com/chenqf/vue-virtual-listview\" rel=\"nofollow noopener noreferrer\">点击查看完整代码</a>。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-5\">面向未来</h2>\n<p>在前文中我们使用<code>监听scroll事件</code>的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成<code>重复计算</code>的问题，从性能上来说无疑存在浪费的情况。</p>\n<p>可以使用<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\" rel=\"nofollow noopener noreferrer\">IntersectionObserver</a>替换监听scroll事件，<code>IntersectionObserver</code>可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且<code>IntersectionObserver</code>的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">遗留问题</h2>\n<p>我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。</p>\n<p>这种情况下，如果我们能监听列表项的大小变化就能获取其真正的高度了。我们可以使用<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\" rel=\"nofollow noopener noreferrer\">ResizeObserver</a>来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。</p>\n<p>不过遗憾的是，在撰写本文的时候，仅有少数<a target=\"_blank\" href=\"https://www.caniuse.com/#search=ResizeObserver\" rel=\"nofollow noopener noreferrer\">浏览器支持</a><code>ResizeObserver</code>。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">参考</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/dwqs/blog/issues/70\" rel=\"nofollow noopener noreferrer\">浅说虚拟列表的实现原理</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/dwqs/blog/issues/72\" rel=\"nofollow noopener noreferrer\">react-virtualized组件的虚拟列表实现</a></li>\n<li><a target=\"_blank\" href=\"https://itsze.ro/blog/2017/04/09/infinite-list-and-react.html\" rel=\"nofollow noopener noreferrer\">React和无限列表</a></li>\n<li><a target=\"_blank\" href=\"https://zhuanlan.zhihu.com/p/34585166\" rel=\"nofollow noopener noreferrer\">再谈前端虚拟列表的实现</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-8\">写在最后</h2>\n<ul>\n<li>文中如有错误，欢迎在评论区指正，如果这篇文章帮到了你，欢迎<code>点赞</code>和<code>关注</code></li>\n<li>本文同步首发与<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog\" rel=\"nofollow noopener noreferrer\">github</a>，可在<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog\" rel=\"nofollow noopener noreferrer\">github</a>中找到更多精品文章，欢迎<code>Watch</code> & <code>Star ★</code></li>\n<li>后续文章参见：<a target=\"_blank\" href=\"https://github.com/chenqf/frontEndBlog/blob/master/PLAN.md\" rel=\"nofollow noopener noreferrer\">计划</a></li>\n</ul>\n<blockquote>\n<p>欢迎关注微信公众号<code>【前端小黑屋】</code>，每周1-3篇精品优质文章推送，助你走上进阶之旅</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/10/16d18aa76b8ad582?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>同时欢迎加我好友，回复<code>加群</code>，拉你入群，和我一起学前端~</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb2f7ddf918f64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"268\" data-height=\"268\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"268\" height=\"268\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2zxb1dwpeok0",
      "author": "Void_0",
      "title": "「前端进阶」高性能渲染十万条数据(虚拟列表)",
      "baseClassName": "article-content"
    },
    {
      "content": "<h3 class=\"heading\" data-id=\"heading-0\">项目初衷</h3>\n<p>开发一个H5的通用架子，让前端同学开箱即用，迅速投入战斗。</p>\n<blockquote>\n<p>截止到2019-10-29 10:25，已经被fork了34次，如果您在使用过程中还希望能给我提<a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/issues\" rel=\"nofollow noopener noreferrer\">issue</a>,或者直接加我微信13216698987 ❤️ ❤️ ❤️</p>\n</blockquote>\n<hr>\n<ul>\n<li>扫码预览：\n<figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf63d281fabe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"260\" data-height=\"260\" src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf63d281fabe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><br>\n<strong>项目源码在文章结尾处，记得查收哦~</strong></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">主要功能</h3>\n<ol>\n<li>常用目录别名</li>\n<li>Vant/Rem适配</li>\n<li>scss支持、_mixin.scss、_variables.scss</li>\n<li>页面切换动画+keepAlive</li>\n<li>页面标题</li>\n<li>自动注册：自动注册路由表/自动注册Vuex/svg图标引入</li>\n<li>mock server</li>\n<li>axios封装、api管理</li>\n<li>用户鉴权</li>\n<li>vuex-loading</li>\n<li>vo-pages/dayjs/vconsole</li>\n<li>生产环境优化</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-2\">常用目录别名</h3>\n<p></p><figure><img alt=\"alias配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbbc7d2dc664?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"737\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"737\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-3\">Vant/Rem适配</h3>\n<p>按照Vant官网推荐自动按需引入组件，同样，Vant官网中也有对Rem适配的推荐配置，按照官网说明的使用。需要注意的是postcss的配置中，autoprefixer下的<code>browsers</code>需要替换成<code>overrideBrowserslist</code>，否则会有报错信息。具体如图<br>\n</p><figure><img alt=\"postcss配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaee5e8e497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"777\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"777\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">scss支持、_mixin.scss、_variables.scss</h3>\n<p>选择scss作为css预处理，并对mixin、variables、common.scss作全局引入。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">css: {\n    <span class=\"hljs-comment\">// 是否使用css分离插件 ExtractTextPlugin</span>\n    extract: !!IS_PRODUCTION,\n    <span class=\"hljs-comment\">// 开启 CSS source maps?</span>\n    sourceMap: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-comment\">// css预设器配置项</span>\n    <span class=\"hljs-comment\">// 启用 CSS modules for all css / pre-processor files.</span>\n    modules: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">loaderOptions</span>: {\n      <span class=\"hljs-attr\">sass</span>: {\n        <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'@import \"style/_mixin.scss\";@import \"style/_variables.scss\";@import \"style/common.scss\";'</span> <span class=\"hljs-comment\">// 全局引入</span>\n      }\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">页面切换动画+keepAlive</h3>\n<p>利用vuex存取/更新页面切换方向，配合vue的transition做页面切换动画，router设置keepAlive判断页面是否需要缓冲。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// vuex中</span>\nstate: {\n  <span class=\"hljs-attr\">direction</span>: <span class=\"hljs-string\">'forward'</span> <span class=\"hljs-comment\">// 页面切换方向</span>\n},\n<span class=\"hljs-attr\">mutations</span>: {\n  <span class=\"hljs-comment\">// 更新页面切换方向</span>\n  updateDirection (state, direction) {\n    state.direction = direction\n  }\n},\n<span class=\"hljs-comment\">// App.vue</span>\n<template>\n  <div id=\"app\">\n    <transition :name=\"transitionName\">\n      <keep-alive v-if=\"$route.meta.keepAlive\">\n        <router-view class=\"router\"></router-view>\n      </keep-alive>\n      <router-view class=\"router\" v-else></router-view>\n    </transition>\n  </div>\n</template>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">页面标题</h3>\n<p>在vue-router页面配置中添加meta的title信息，配合<code>vue-router</code>的<code>beforeEach</code>注册一个前置守卫用户获取到页面配置的title</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// get-page-title.js</span>\n<span class=\"hljs-keyword\">import</span> defaultSettings <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/settings'</span>\n\n<span class=\"hljs-keyword\">const</span> title = defaultSettings.title || <span class=\"hljs-string\">'H5Vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getPageTitle</span> (<span class=\"hljs-params\">pageTitle</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (pageTitle) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${pageTitle}</span> - <span class=\"hljs-subst\">${title}</span>`</span>\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${title}</span>`</span>\n}\n<span class=\"hljs-comment\">// permission.js</span>\nrouter.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =></span> {\n  <span class=\"hljs-comment\">// set page title</span>\n  <span class=\"hljs-built_in\">document</span>.title = getPageTitle(to.meta.title)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">自动注册</h3>\n<p>先来了解一下<code>require.context()</code>:</p>\n<blockquote>\n<p>你可以通过 <code>require.context()</code> 函数来创建自己的 context。</p>\n<p>可以给这个函数传入三个参数：一个要搜索的目录，一个标记表示是否还搜索其子目录， 以及一个匹配文件的正则表达式。</p>\n<p>webpack 会在构建中解析代码中的 <code>require.context()</code> 。</p>\n</blockquote>\n<p>上面的是官网原话，可能你跟我一样没太看懂，说白了，他可以用来导入模块。</p>\n<p>来看一下如何使用，我的router下的文件结构是这样的：<br></p>\n<p></p><figure><img alt=\"router-tree\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbae89d4fb5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"286\" data-height=\"220\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"286\" height=\"220\"></svg>\"><figcaption></figcaption></figure><br><p></p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 利用require.context()自动引入article.js和user.js</span>\n<span class=\"hljs-keyword\">const</span> routerContext = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">'./'</span>, <span class=\"hljs-literal\">true</span>, /\\.js$/)\nrouterContext.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =></span> {\n  <span class=\"hljs-comment\">// 如果是根目录的 index.js 、不处理</span>\n  <span class=\"hljs-keyword\">if</span> (route.startsWith(<span class=\"hljs-string\">'./index'</span>)) {\n    <span class=\"hljs-keyword\">return</span>\n  }\n  <span class=\"hljs-keyword\">const</span> routerModule = routerContext(route)\n  <span class=\"hljs-comment\">/**\n   * 兼容 import export 和 require module.export 两种规范\n   */</span>\n  routes = routes.concat(routerModule.default || routerModule)\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>需要额外注意的是，404页面需要在自动引入后向路由数组concat上去，否则会提前匹配到404页面。</p>\n<p>对于vuex也同样引入，记得把引入的vuex按照文件名注册为对应的模块中。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">mock server</h3>\n<p>Mock server部分可直接参看<a target=\"_blank\" href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/essentials/mock-api.html\" rel=\"nofollow noopener noreferrer\">vue-element-admin</a>的mock方案</p>\n<h3 class=\"heading\" data-id=\"heading-9\">axios封装</h3>\n<p>axios部分，配置了baseUrl、超时时间，利用拦截器对header添加了用户的Token，方便下一步的用户鉴权，并对错误做了Toast提示。具体错误的code需要视各业务而定，本项目只做为示例参考。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">用户鉴权</h3>\n<p>在<code>vue-router</code>的<code>beforeEach</code>中，添加用户鉴权功能。当用户登录后使用cookie持续化保存用户token，并赋值到vuex，后续可利用token获取用户信息。具体代码如下图：\n</p><figure><img alt=\"permission\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaebd72c9e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1055\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1055\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\">vuex-loading</h3>\n<p>在vuex3.1.0中对<a target=\"_blank\" href=\"https://vuex.vuejs.org/zh/api/#subscribe\" rel=\"nofollow noopener noreferrer\">vuex.subscribeAction</a>做了改动，使其拥有了before/after钩子函数。</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\"><span class=\"hljs-comment\">// subscribeAction官网示例</span>\nstore.subscribeAction({\n  <span class=\"hljs-attr\">before</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, state</span>) =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`before action <span class=\"hljs-subst\">${action.type}</span>`</span>)\n  },\n  <span class=\"hljs-attr\">after</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, state</span>) =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`after action <span class=\"hljs-subst\">${action.type}</span>`</span>)\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>有了它，配合<code>vuex</code>的<a target=\"_blank\" href=\"https://vuex.vuejs.org/zh/guide/plugins.html\" rel=\"nofollow noopener noreferrer\">插件</a>功能，实现对应action的状态监听也不再是难题。</p>\n<p><a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/blob/master/src/utils/vuex-loading.js\" rel=\"nofollow noopener noreferrer\">点击查看具体实现代码</a></p>\n<blockquote>\n<p>参照自<a target=\"_blank\" href=\"https://juejin.im/post/5cdd2457f265da034e7eb2f9#heading-2\" rel>vue 在移动端体验上的优化解决方案</a></p>\n</blockquote>\n<pre><code class=\"hljs vue copyable\" lang=\"vue\">// 使用方法\ncomputed: {\n  ...mapState({\n    loading: state => state['@@loading'].effects['test/onePlusAction']\n  })\n}\n// 其中 test对应的是vuex中的模块名，onePlusAction对应模块内的actions\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>具体效果：<br></p><figure><img alt=\"loading\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaea0ae09cb?imageslim\" data-width=\"248\" data-height=\"248\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"248\" height=\"248\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-12\">列表页（vo-pages的使用）</h3>\n<p>列表页这里，使用了本人自己写的组件<code>vo-pages</code>，详细使用可查看<a target=\"_blank\" href=\"https://juejin.im/post/5d81da4551882556ba55e50e\" rel>一款易用、高可定制的vue翻页组件</a></p>\n<p>实现效果：<br></p>\n<p></p><figure><img alt=\"vo-pages\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bbaf99131ad2?imageslim\" data-width=\"719\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"719\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-13\">生产环境优化</h3>\n<p>上线前，得优化一下资源了，该项目做了如下几步操作</p>\n<ol>\n<li>通用库改用CDN</li>\n<li>关闭sourcemap防止源码泄露</li>\n<li>丑化html/css/js</li>\n<li>生成gzip</li>\n<li>移除掉debugger/console</li>\n<li>利用webpack-bundle-analyzer做资源分析，提供进一步优化的数据分析\n想对性能、资源了解更多的，推荐<a target=\"_blank\" href=\"https://juejin.im/post/5bd2b60e6fb9a05d27794c5e\" rel>Vue SPA 项目webpack打包优化指南</a>这篇文章。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-14\">更多</h3>\n<p>花了不少时间开发了这个项目，希望能提高您的H5开发效率。也欢迎大家跟我一起交流学习。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">相关链接</h3>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue\" rel=\"nofollow noopener noreferrer\">源码地址</a></li>\n<li><a target=\"_blank\" href=\"http://h5vue.cixi518.com\" rel=\"nofollow noopener noreferrer\">在线预览</a></li>\n<li>扫码预览：\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0bf6610401416?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"260\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"260\" height=\"260\"></svg>\"><figcaption></figcaption></figure><br></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-16\">文章参考</h3>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cbf32bc6fb9a03236393379\" rel>基于vue-cli3.0构建功能完善的移动端架子</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bd2b60e6fb9a05d27794c5e\" rel>Vue SPA 项目webpack打包优化指南</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5cdd2457f265da034e7eb2f9\" rel>vue 在移动端体验上的优化解决方案</a></li>\n<li><a target=\"_blank\" href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/\" rel=\"nofollow noopener noreferrer\">vue-element-admin</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/59bb864b5188257e7a427c09\" rel>手摸手，带你优雅的使用 icon</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d81da4551882556ba55e50e\" rel>一款易用、高可定制的vue翻页组件</a></li>\n</ul>\n",
      "id": "3l7uk66lz100",
      "author": "voanit",
      "title": "基于vue+vant搭建H5通用架子",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>Visual Studio Code 是由微软开发的一款免费、跨平台的文本编辑器。由于其卓越的性能和丰富的功能，它很快就受到了大家的喜爱。</p>\n<p>就像大多数 IDE 一样，VSCode 也有一个扩展和主题市场，包含了数以千计质量不同的插件。下面我列出一些VSCode前端必备插件，并配有图文介绍，快来看看你是否都会使用呢？</p>\n<h2 class=\"heading\" data-id=\"heading-0\">VS Code 安装和汉化</h2>\n<p>下载地址：VS Code官网链接\n选择合适的版本，安装即可\n安装完成后如图\n</p><figure><img alt=\"VS Code初始安装完成\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005a3492d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"550\" data-height=\"166\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005a3492d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n如果需要汉化，ctrl + shift + x，打开插件商店，输入 chinese，然后选择第一个，点击 ‘install’\n<figure><img alt=\"中文插件\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005d90b4bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"831\" data-height=\"168\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108005d90b4bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n安装完成后重启软件，显示如下，则汉化完成\n<figure><img alt=\"汉化完成\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080054c5f1d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"728\" data-height=\"83\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080054c5f1d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">插件</h2>\n<p>1.Open-In-Browser</p>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10800596613c2?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>2.Quokka</p>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080057c6e88b?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>3.Faker</p>\n<p>使用流行的 JavaScript 库 – Faker，能够帮你快速的插入用例数据。Faker 可以随机生成姓名、地址、图像、电话号码，或者经典的乱数假文段落，并且每个类别还包含了各种子类别，你可以根据自身的需求来使用这些数据。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10800590b1052?imageslim\" data-width=\"639\" data-height=\"312\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"312\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>4.CSS Peek</p>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080075ea7a9c?imageslim\" data-width=\"639\" data-height=\"267\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"267\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>5.HTML Boilerplate</p>\n<p>通过使用 HTML模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801039a22f2?imageslim\" data-width=\"639\" data-height=\"348\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"348\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>6.Prettier</p>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080075f99516?imageslim\" data-width=\"640\" data-height=\"314\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"314\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>7.Color Info</p>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103b60128?imageslim\" data-width=\"640\" data-height=\"305\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"305\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>8.SVG Viewer</p>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103acda14?imageslim\" data-width=\"639\" data-height=\"323\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"323\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>9.TODO Highlight</p>\n<p>这个插件能够在你的代码中标记出所有的 TODO 注释，以便更容易追踪任何未完成的业务。在默认的情况下，它会查找 TODO 和 FIXME 关键字。当然，你也可以添加自定义表达式。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080103cf7235?imageslim\" data-width=\"640\" data-height=\"316\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"316\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>10.Icon Fonts</p>\n<p>这是一个能够在项目中添加图标字体的插件。该插件支持超过 20 个热门的图标集，包括了 Font Awesome、Ionicons、Glyphicons 和 Material Design Icons。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080120fc1563?imageslim\" data-width=\"639\" data-height=\"289\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"289\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>11.Minify</p>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801210e39ca?imageslim\" data-width=\"640\" data-height=\"308\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"308\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>12.Change Case</p>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108013feee80a?imageslim\" data-width=\"639\" data-height=\"274\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"639\" height=\"274\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>13.Regex Previewer</p>\n<p>这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801510e5376?imageslim\" data-width=\"640\" data-height=\"305\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"305\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>14.Language and Framework Packs</p>\n<p>VSCode 默认支持大量的主流编程语言，但如果你所使用的编程语言不包括在内，也可以通过下载扩展包来自动添加。同时，你还可以添加一些像 React Native 与 Vue 的相关 Web 开发插件包。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080143fa086f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"301\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"301\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>15.Themes</p>\n<p>当然，在众多的实用插件中，岂能少了漂亮的主题呢？你每天都会与你的 VSCode 编辑器进行“亲密的接触”，为何不把它打扮得更漂亮些呢？这里有一些帮助你更改侧边栏的配色方案，以及图标的相关主题，与大家分享：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801402b549f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"301\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"301\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>16.vscode-icons</p>\n<p>各种漂亮的图标\n</p><figure><img alt=\"vscode-icons\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801401948f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"958\" data-height=\"160\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"958\" height=\"160\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>17.filesize</p>\n<p>左下角显示文件大小的插件</p>\n<p></p><figure><img alt=\"filesize显示效果\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080165c6ee25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>18.GitLens</p>\n<p>能显示每一行代码的作者以及提交时间。</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080160eca1d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"928\" data-height=\"134\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"928\" height=\"134\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>19.Git history</p>\n<p>Git 历史</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e1080155c4e7f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"926\" data-height=\"118\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"926\" height=\"118\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>20.Vetur</p>\n<p>Vue多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。vscode官方钦定Vue插件，Vue开发者必备。</p>\n<p></p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108015c7cc81c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1085\" data-height=\"223\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1085\" height=\"223\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>21.React/Redux/react-router Snippets</p>\n<p>React/Redux/react-router语法智能提示</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018099d3c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1156\" data-height=\"298\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1156\" height=\"298\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>22.Path Intellisense</p>\n<p>自动提示文件路径，支持各种快速引入文件</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018084c8bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"480\" data-height=\"270\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"480\" height=\"270\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>23.JavaScript(ES6) code snippets</p>\n<p>ES6语法智能提示，以及快速输入，不仅仅支持.js，还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801ad124bfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1186\" data-height=\"294\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1186\" height=\"294\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>24.HTML Snippets</p>\n<p>智能提示HTML标签，以及标签含义</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018c29690a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"354\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"354\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018f0bd432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1260\" data-height=\"296\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1260\" height=\"296\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>25.HTML CSS Support\n  智能提示CSS类名以及id</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108018cb9cc49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"415\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"415\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801b373eb76?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1196\" data-height=\"278\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1196\" height=\"278\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>26.Debugger for Chrome</p>\n<p>映射vscode上的断点到chrome上，方便调试</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801aec3c32e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1260\" data-height=\"302\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1260\" height=\"302\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>27.Auto Close Tag</p>\n<p>自动闭合HTML/XML标签</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801b382b84d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1162\" data-height=\"288\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1162\" height=\"288\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>28.Auto Rename Tag</p>\n<p>自动完成另一侧标签的同步修改</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801bd134ee0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"521\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"521\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>29.Markdown Preview Enhanced</p>\n<p>实时预览markdown，markdown使用者必备</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d3e35c98?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"265\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"265\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>30.markdownlint</p>\n<p>markdown语法纠错</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d62b2bd1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1158\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1158\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>31.fileheader</p>\n<p>  顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间，快捷键ctrl+alt+i在文件开头自动输入作者信息和修改信息等内容</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801ddd68910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"443\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"443\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>32.Vue VSCode Snippets\n  </p>\n<p>VUE代码自动补全插件</p>\n<p>33.VueHelper</p>\n<p>snippet代码片段</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10801d6cb9881?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"677\" data-height=\"459\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"677\" height=\"459\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>34.Document This(js 和typescript的注释模板)</p>\n<p>ctrl+alt+D，两次（注意：新版的vscode已经原生支持,在function上输入/** tab）<br>\n</p><figure><img alt=\"图片描述\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e108021b8100c9?imageslim\" data-width=\"1280\" data-height=\"970\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"970\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>35.Project Manager</p>\n<p>项目管理工具</p>\n<p>这两种方式对于需要经常切换项目时，比较耗时\n为解决这个问题，vscode提供了Project Manager插件管理，开发时常用的项目</p>\n<p>（1）command+ shift + p打开配置文件，\n输入 Project Manager: Edit Projects</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[\n\t{\n\t\t<span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"nuxtest\"</span>,\n\t\t<span class=\"hljs-string\">\"rootPath\"</span>: <span class=\"hljs-string\">\"/Users/tianer/WebstormProjects/sales-crm-web\"</span>,//添加你的本地项目\n\t\t<span class=\"hljs-string\">\"paths\"</span>: [],\n\t\t<span class=\"hljs-string\">\"group\"</span>: <span class=\"hljs-string\">\"\"</span>\n\t},\n\t{\n\t\t<span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"vuetest\"</span>,\n\t\t<span class=\"hljs-string\">\"rootPath\"</span>: <span class=\"hljs-string\">\"/Users/tianer/WebstormProjects/sales-crm-web\"</span>,//添加你的本地项目\n\t\t<span class=\"hljs-string\">\"paths\"</span>: [],\n\t\t<span class=\"hljs-string\">\"group\"</span>: <span class=\"hljs-string\">\"\"</span>\n\t}\n]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e119eb321797ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"689\" data-height=\"163\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"689\" height=\"163\"></svg>\"><figcaption></figcaption></figure>\n预览\n在左侧图标栏下就会有个小文件夹的选项，点击进去就可以切换项目了。<p></p>\n<p>paths里面可放子项目</p>\n<h2 class=\"heading\" data-id=\"heading-2\">结尾彩蛋</h2>\n<p>欢迎关注前端之阶公众号，获取更多前端知识，加入前端大群，与知名互联网大佬做朋友，开启共同学习新篇章！</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e10ea3bf4d51a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4bymoe296qi0",
      "author": "前端小智",
      "title": "VSCode前端必备插件，有可能你装了却不知道如何使用？",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>作者：Duomly</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong>阿里云服务器很便宜火爆，今年比去年便宜，10.24~11.11购买是1年86元，3年229元，可以点击 下面链接进行参与：</strong>\n<a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBEDBE5CCBE365B176BB470C64C499DD647C88CF896EF535&userCode=pxuujn3r&share_source=copy_link\" rel=\"nofollow noopener noreferrer\">www.aliyun.com/1111/2019/g…</a></p>\n<hr>\n<p>数组是 JS 最常见的一种数据结构，咱们在开发中也经常用到,在这篇文章中,提供一些小技巧,帮助咱们提高开发效率。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">1. 删除数组的重复项</h2>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa852a1d1bf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"314\" src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa852a1d1bf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">2. 替换数组中的特定值</h2>\n<p>有时在创建代码时需要替换数组中的特定值，有一种很好的简短方法可以做到这一点，咱们可以使用<code>.splice(start、value to remove、valueToAdd)</code>，这些参数指定咱们希望从哪里开始修改、修改多少个值和替换新值。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa870084b618?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"261\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"261\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-2\">3. Array.from 达到 .map 的效果</h2>\n<p>咱们都知道 <code>.map()</code> 方法，<code>.from()</code> 方法也可以用来获得类似的效果且代码也很简洁。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa883dfc8695?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"429\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"429\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">4.置空数组</h2>\n<p>有时候我们需要清空数组，一个快捷的方法就是直接让数组的 <code>length</code> 属性为 <code>0</code>，就可以清空数组了。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa89a5b762dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"698\" data-height=\"774\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"774\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">5. 将数组转换为对象</h2>\n<p>有时候，出于某种目的，需要将数组转化成对象，一个简单快速的方法是就使用展开运算符号(<code>...</code>):</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8ac3dc7095?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"324\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"324\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-5\">6. 用数据填充数组</h2>\n<p>在某些情况下，当咱们创建一个数组并希望用一些数据来填充它，这时 <code>.fill()</code>方法可以帮助咱们。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8c58885093?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"225\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"225\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">7. 数组合并</h2>\n<p>使用展开操作符，也可以将多个数组合并起来。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8d766b8ec9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"257\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"257\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-7\">8.求两个数组的交集</h2>\n<p>求两个数组的交集在面试中也是有一定难度的正点，为了找到两个数组的交集，首先使用上面的方法确保所检查数组中的值不重复，接着使用<code>.filter</code> 方法和<code>.includes</code>方法。如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8ec0988182?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"266\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"266\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-8\">9.从数组中删除虚值</h2>\n<p>在 JS 中，虚值有 <code>false</code>, <code>0</code>，<code>''</code>， <code>null</code>, <code>NaN</code>, <code>undefined</code>。咱们可以 <code>.filter()</code> 方法来过滤这些虚值。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa8fdc8fe989?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"298\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"298\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-9\">10. 从数组中获取随机值</h2>\n<p>有时我们需要从数组中随机选择一个值。一种方便的方法是可以根据数组长度获得一个随机索引，如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa9146b84abb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"248\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"248\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">11.反转数组</h2>\n<p>现在，咱们需要反转数组时，没有必要通过复杂的循环和函数来创建它，数组的 <code>reverse</code> 方法就可以做了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa925550abc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"206\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"206\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">12 lastIndexOf() 方法</h2>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa93994c0055?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"355\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"355\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-12\">13.对数组中的所有值求和</h2>\n<p>JS 面试中也经常用 <code>reduce</code> 方法来巧妙的解决问题</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/28/16e0fa94e42554ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"418\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"418\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-13\">总结</h2>\n<p>在本文中，介绍了13个技巧，希望它们可以帮助编写简洁代码，如果你还有更好的办法，欢迎留言讨论。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a target=\"_blank\" href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noopener noreferrer\">Fundebug</a>。</strong></p>\n<p>原文：\n<a target=\"_blank\" href=\"https://dev.to/duomly/13-useful-javascript-array-tips-and-tricks-you-should-know-2jfo\" rel=\"nofollow noopener noreferrer\">dev.to/duomly/13-u…</a></p>\n<h2 class=\"heading\" data-id=\"heading-14\">交流</h2>\n<p>阿里云最近在做活动，低至2折，有兴趣可以看看：<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<p>干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noopener noreferrer\">github.com/qq449245884…</a></p>\n</blockquote>\n<p>因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。</p>\n<p></p><figure><img alt=\"clipboard.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df5ed14ee6d44b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/29/16d7c9e2a5bfb741?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"200\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"200\" height=\"260\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4jxr194oaqk0",
      "author": "极客James",
      "title": "13 个 JS 数组精简技巧，一起来看看",
      "baseClassName": "article-content"
    },
    {
      "content": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"712\" src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-0\">一、写在前面</h3>\n<p>各位掘友久等了,最近在写Vue全家桶+Vant从零开发搭建电商App实战项目,项目基本完结,后面会不定期分享出来,期待各位掘友的关注。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">二、注册登录</h3>\n<p>注册登录,几乎是所有电商App必备模块,正好今天想把这块知识拆出来,详尽的写下来了,用过掘金的小伙伴都知道,掘金PC端的登录界面非常的萌,当你输入账号的时候萌猫会很开心,输入密码的时候,萌猫会捂眼睛,看到这个可爱的设计,着实让我喜欢,所以我就借鉴了掘金的萌猫图写了个登录注册模块,以下是完整UI.</p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1004\" data-height=\"598\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7507e629ee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"998\" data-height=\"600\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb778aa7cce3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-2\">三、整体UI搭建思路</h3>\n<p>UI部分非常的简单,整体就是最外层一个大盒子放一张图片,里面放一张小盒子设备边框圆角,然后把萌猫定位到小盒子的顶部中间位置,然后借助Vant来完成相关输入框,按钮的搭建.</p>\n<h3 class=\"heading\" data-id=\"heading-3\">四、Vant 使用</h3>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/intro\" rel=\"nofollow noopener noreferrer\">Vant</a>是有赞开源的很适合做电商App的UI组件,用起来非常爽,我整个项目都采用Vant UI搭建,风格统一,使用简单方便.\n首先将Vant引入到项目中,建议创建一个单独的文件来管理Vant的组件引入模块,按需加载,原则是用哪个就加载哪个.</p>\n<p>注册登录的切换用到了Vant的标签页组件,快速的实现登录和注册页面的切换。</p>\n<p><a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/tab\" rel=\"nofollow noopener noreferrer\">Vant tab</a>按照文档来,非常的简单和好用。</p>\n<p>输入框用到了Vant的Field组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/field\" rel=\"nofollow noopener noreferrer\">Vant Field</a></p>\n<p>按钮用到了Vant的Button组件<a target=\"_blank\" href=\"https://youzan.github.io/vant/#/zh-CN/button\" rel=\"nofollow noopener noreferrer\">Vant Button</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">五、萌猫切换</h3>\n<p>萌猫根据你所在的输入框不同切换不同的样式,其实就是三张图片的切换,要么一次把三张图片都加载到页面,然后通过<code>v-show</code>的方式来控制他们的显示,这种方式感觉有点麻烦,我采用数据驱动界面的方式,点击到哪个位置,就让<code>img</code>标签来加载哪张图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 改变萌猫\n    changeImage (index) {\n      <span class=\"hljs-keyword\">if</span> (index == 0) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/greeting.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (index == 1) {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/blindfold.png'</span>)\n      } <span class=\"hljs-keyword\">else</span> {\n        this.imageURL = require(<span class=\"hljs-string\">'./../../images/login/normal.png'</span>)\n      }\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">六、倒计时</h3>\n<p>倒计时其实就是个定时器,先设置好总时长,然后每秒减一,直到减到0,然后恢复按钮点击的状态.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> // 发送手机验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">sendVerifyCode</span></span> () {\n      Toast({\n        message: <span class=\"hljs-string\">'发送验证码'</span>,\n        duration: 800\n\n      });\n      this.countDown = 60;\n      this.timeIntervalID = <span class=\"hljs-built_in\">set</span>Interval(() => {\n        this.countDown--;\n        // 如果减到0 则清除定时器\n        <span class=\"hljs-keyword\">if</span> (this.countDown == 0) {\n          clearInterval(this.timeIntervalID);\n        }\n      }, 1000)\n    }\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">七、手机号码正则验证</h3>\n<p>通过计算属性来验证输入的手机号码是否正确,然后在合适的位置调用这个计算属性就可以</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> computed: {\n    // 手机号码正确验证\n    <span class=\"hljs-function\"><span class=\"hljs-title\">phoneNumVerify</span></span> () {\n      <span class=\"hljs-built_in\">return</span> /[1][3,4,5,6,7,8][0-9]{9}$/.test(this.tel_registered);\n    }\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">八、验证码模块</h3>\n<p>验证码其实就是<code>img</code>标签请求接口获取图片,当点击图片的时候再次请求获取最新的图片.</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 切换验证码\n    <span class=\"hljs-function\"><span class=\"hljs-title\">getCaptcha</span></span> () {\n      // 获取验证码的标签\n      <span class=\"hljs-built_in\">let</span> captchaEle = this.<span class=\"hljs-variable\">$refs</span>.captcha;\n      this.<span class=\"hljs-variable\">$set</span>(captchaEle, <span class=\"hljs-string\">'src'</span>, <span class=\"hljs-string\">'http://192.168.0.1/web/xlmc/api/captcha?time='</span> + new Date());\n    },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">九、总结</h3>\n<p>注册登录仅仅是整个项目的一部分,先分享出来,后面会将整个完整的电商项目分享出来,希望大家能点赞加关注,你的点赞能让更多的人一起学习,一起进步😄</p>\n<h3 class=\"heading\" data-id=\"heading-9\">十、完整电商项目</h3>\n<h4 class=\"heading\" data-id=\"heading-10\">首页模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb781663eb60a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"596\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"596\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">分类模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7882d5b9fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1022\" data-height=\"582\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1022\" height=\"582\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-12\">吃什么模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7904fd0405a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1036\" data-height=\"574\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1036\" height=\"574\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-13\">购物车模块</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb79b80990194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1026\" data-height=\"592\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1026\" height=\"592\"></svg>\"><figcaption></figcaption></figure>\n<br><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7a53bb8f4f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"590\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"590\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">个人中心模块</h4>\n<div>\n<img alt=\"图片说明\" height=\"300px\" style=\"padding:5px\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb5f78e4fd55c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"526\" data-height=\"944\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"526\" height=\"944\"></svg>\">\n</div>\n<h3 class=\"heading\" data-id=\"heading-15\">往期分享链接</h3>\n<ul>\n<li>\n<p><strong>Vue甜小白系列专栏</strong>:</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d64f31ae51d4561db5e3a74\" rel>Vue从甜小白到皮大佬系列(一) Vue是个啥?</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d652fb351882505a87a976b\" rel>Vue从甜小白到皮大佬系列(二) v-指令</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6675716fb9a06b10273c1c\" rel>Vue从甜小白到皮大佬系列(三) 生命周期\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d673ad7f265da03934bf266\" rel>Vue从甜小白到皮大佬系列(四) 自定义指令\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d67eac7e51d453c12504e3a\" rel>Vue从甜小白到皮大佬系列(五) 组件\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d699e2b6fb9a06ae3727746\" rel>Vue从甜小白到皮大佬系列(六) 组件通信\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6e6f366fb9a06b32609021\" rel>Vue从甜小白到皮大佬系列(七) Vue Router\n</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6f5801f265da03da24b365\" rel>Vue从甜小白到皮大佬系列(八) Vuex</a></li>\n</ul>\n</li>\n<li>\n<p>每周一道算法题系列</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d6bed3e6fb9a06af372d069\" rel>逆波兰表达式求值</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7505c7f265da03c61e775a\" rel>斐波那契数列</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7e48dbe51d4557dc774f3a\" rel>合并两个有序链表</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>最后感谢您的关注!</strong></p>\n<p><a target=\"_blank\" href=\"https://github.com/Geek-James/Blog\" rel=\"nofollow noopener noreferrer\">我的GitHub</a>,希望能得到你的小星星~</p>\n<blockquote>\n<p>希望我的分享对你能有帮助,有不正确的地方也希望得到您的勘误!本人将不胜感激,另外如果你想获取前端整期学习视频和资料扫一扫下面的二维码,回复<strong>学习</strong>即可,也希望在前端进阶的路上,我们一起成长,一起进步!</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/1/16ceae13d9c4953e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"300\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"300\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "58mvpog3e0g0",
      "author": "非著名程序猿",
      "title": "Vue登录注册-掘金可爱萌猫",
      "baseClassName": "article-content"
    },
    {
      "content": "<h3 class=\"heading\" data-id=\"heading-0\">1 前言</h3>\n<p>随着团队人数的增加，每个人的代码编写喜好不同，代码风格也迥然不同。如果有一个大家的统一的愿意遵守的代码规范，肯定事半功倍，提高效率，避免代码<code>Review</code>和<code>重构</code>。</p>\n<p>其中一部分规则参考了 腾讯<code>alloyteam</code>团队的代码规范，如有错误，请指出，将会非常感谢。</p>\n<p>坚持好的代码风格规范，从你我做起。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">2 命名规范</h3>\n<h4 class=\"heading\" data-id=\"heading-2\">1) 项目命名</h4>\n<p>全部采用小写方式， 以下划线分隔。</p>\n<p>例：<code>my_project_name</code></p>\n<h4 class=\"heading\" data-id=\"heading-3\">2 )目录命名</h4>\n<p>参照项目命名规则；</p>\n<p>有复数结构时，要采用复数命名法。</p>\n<p>例：<code>pages</code>, <code>assets</code>, <code>directives</code>, <code>components</code>, <code>mixins</code>, <code>utils</code></p>\n<h4 class=\"heading\" data-id=\"heading-4\">3)<code>javaScript</code> 文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>account_model.js</code></p>\n<h4 class=\"heading\" data-id=\"heading-5\">4)<code>CSS</code>,<code>less</code>文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>retina_sprites.less</code></p>\n<h4 class=\"heading\" data-id=\"heading-6\">5)HTML文件命名</h4>\n<p>参照项目命名规则。</p>\n<p>例：<code>error_report.html</code></p>\n<h4 class=\"heading\" data-id=\"heading-7\">6) 如果使用<code>Vue</code>或者<code>React</code>技术栈，组件<code>Component</code>命名</h4>\n<p>所有组件名字需要首字母大写，然后驼峰格式</p>\n<p>例：<code>CalendarList.vue</code></p>\n<h3 class=\"heading\" data-id=\"heading-8\">3 HTML</h3>\n<h4 class=\"heading\" data-id=\"heading-9\">1) 语法</h4>\n<ul>\n<li>缩进使用soft tab（4个空格）；</li>\n<li>嵌套的节点应该缩进；</li>\n<li>在属性上，使用双引号，不要使用单引号；</li>\n<li>属性名全小写，用中划线做分隔符；</li>\n<li>不要在自动闭合标签结尾处使用斜线（<a target=\"_blank\" href=\"http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag\" rel=\"nofollow noopener noreferrer\">HTML5 规范</a> 指出他们是可选的）；</li>\n<li>不要忽略可选的关闭标签;</li>\n</ul>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">title</span>></span>Page title<span class=\"hljs-tag\"></<span class=\"hljs-name\">title</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">body</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"images/company_logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Company\"</span> /></span>\n\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"hello-world\"</span>></span>Hello, world!<span class=\"hljs-tag\"></<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">body</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">2) HTML5 doctype</h4>\n<p>在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现；</p>\n<p>虽然doctype不区分大小写，但是按照惯例，doctype大写 （<a target=\"_blank\" href=\"http://stackoverflow.com/questions/15594877/is-there-any-benefits-to-use-uppercase-or-lowercase-letters-with-html5-tagname\" rel=\"nofollow noopener noreferrer\">关于html属性，大写还是小写</a>）。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n\t...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-11\">3) lang属性</h4>\n<p>根据HTML5规范：</p>\n<blockquote>\n<p>应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。</p>\n</blockquote>\n<p>更多关于 <code>lang</code> 属性的说明<a target=\"_blank\" href=\"http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element\" rel=\"nofollow noopener noreferrer\">在这里</a>；</p>\n<p>在sitepoint上可以查到<a target=\"_blank\" href=\"http://reference.sitepoint.com/html/lang-codes\" rel=\"nofollow noopener noreferrer\">语言列表</a>；</p>\n<p>但sitepoint只是给出了语言的大类，例如中文只给出了zh，但是没有区分香港，台湾，大陆。而微软给出了一份更加<a target=\"_blank\" href=\"http://msdn.microsoft.com/en-us/library/ms533052(v=vs.85).aspx\" rel=\"nofollow noopener noreferrer\">详细的语言列表</a>，其中细分了zh-cn, zh-hk, zh-tw。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en-us\"</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-12\">4) 字符编码</h4>\n<p>通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为'UTF-8'。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-13\">5) IE兼容模式</h4>\n<p>用 `` 标签可以指定页面应该用什么版本的IE来渲染；</p>\n<p>如果你想要了解更多，请点击<a target=\"_blank\" href=\"http://stackoverflow.com/questions/6771258/whats-the-difference-if-meta-http-equiv-x-ua-compatible-content-ie-edge-e\" rel=\"nofollow noopener noreferrer\">这里</a>；</p>\n<p>不同doctype在不同浏览器下会触发不同的渲染模式（<a target=\"_blank\" href=\"https://hsivonen.fi/doctype/\" rel=\"nofollow noopener noreferrer\">这篇文章</a>总结的很到位）。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-meta\"><!DOCTYPE html></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">html</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">head</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"IE=Edge\"</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">head</span>></span>\n    ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">html</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-14\">6) 引入CSS, JS</h4>\n<p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 <code>type</code>，因为 <code>text/css</code>和 <code>text/javascript</code> 分别是他们的默认值。</p>\n<p><strong>HTML5 规范链接</strong></p>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element\" rel=\"nofollow noopener noreferrer\">使用link</a></li>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element\" rel=\"nofollow noopener noreferrer\">使用style</a></li>\n<li><a target=\"_blank\" href=\"http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element\" rel=\"nofollow noopener noreferrer\">使用script</a></li>\n</ul>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-comment\"><!-- External CSS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"code_guide.css\"</span>></span>\n\n<span class=\"hljs-comment\"><!-- In-document CSS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"undefined\">\n    ...\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n\n<span class=\"hljs-comment\"><!-- External JS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"code_guide.js\"</span>></span><span class=\"undefined\"></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-comment\"><!-- In-document JS --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span>></span><span class=\"undefined\">\n    ...\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-15\">7) 属性顺序</h4>\n<p>属性应该按照特定的顺序出现以保证易读性；</p>\n<ul>\n<li><code>class</code></li>\n<li><code>id</code></li>\n<li><code>name</code></li>\n<li><code>data-*</code></li>\n<li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code> , <code>max-length</code>, <code>max</code>, <code>min</code>, <code>pattern</code></li>\n<li><code>placeholder</code>, <code>title</code>, <code>alt</code></li>\n<li><code>aria-*</code>, <code>role</code></li>\n<li><code>required</code>, <code>readonly</code>, <code>disabled</code></li>\n</ul>\n<p><code>class</code>是为高可复用组件设计的，所以应处在第一位；</p>\n<p><code>id</code> 具体且应该尽量少使用，所以将它放在第二位。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">data-modal</span>=<span class=\"hljs-string\">\"toggle\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#\"</span>></span>Example link<span class=\"hljs-tag\"></<span class=\"hljs-name\">a</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"form-control\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-16\">8) boolean属性</h4>\n<p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p>\n<p>更多内容可以参考 <a target=\"_blank\" href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes\" rel=\"nofollow noopener noreferrer\">WhatWG section on boolean attributes</a>：</p>\n<blockquote>\n<p>boolean属性的存在表示取值为true，不存在则表示取值为false。</p>\n</blockquote>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">disabled</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">checked</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">select</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">selected</span>></span>1<span class=\"hljs-tag\"></<span class=\"hljs-name\">option</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">select</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-17\">9) JS生成标签</h4>\n<p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">10) 减少标签数量</h4>\n<p>在编写HTML代码时，需要尽量避免多余的父节点；</p>\n<p>很多时候，需要通过迭代和重构来使HTML变得更少。</p>\n<pre><code class=\"hljs html copyable\" lang=\"html\"><span class=\"hljs-comment\"><!-- 不建议这么做 --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"avatar\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n\n<span class=\"hljs-comment\"><!-- 建议这么做 --></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"avatar\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"...\"</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-19\">11) 实用高于完美</h4>\n<p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；</p>\n<p>任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p>\n<h3 class=\"heading\" data-id=\"heading-20\">4 css、less</h3>\n<h4 class=\"heading\" data-id=\"heading-21\">1) 缩进</h4>\n<p>使用soft tab（4个空格）</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">position</span>: absolute;\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">10px</span>;\n\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-22\">2)分号</h4>\n<p>每个属性声明末尾都要加分号。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">20px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">20px</span>;\n\n    <span class=\"hljs-attribute\">background-color</span>: red;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-23\">3)空格</h4>\n<p>以下几种情况不需要空格：</p>\n<ul>\n<li>属性名后</li>\n<li>多个规则的分隔符','前</li>\n<li><code>!important</code> '!'后</li>\n<li>属性值中'('后和')'前</li>\n<li>行末不要有多余的空格</li>\n</ul>\n<p>以下几种情况需要空格：</p>\n<ul>\n<li>属性值前</li>\n<li>选择器'>', '+', '~'前后</li>\n<li>'{'前</li>\n<li><code>!important</code> '!'前</li>\n<li><code>@else</code> 前后</li>\n<li>属性值中的','后</li>\n<li>注释'/<em>'后和'</em>/'前</li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color </span>:red! important;\n    <span class=\"hljs-attribute\">background-color</span>: rgba(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,.<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: red <span class=\"hljs-meta\">!important</span>;\n    <span class=\"hljs-attribute\">background-color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> ,\n<span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span>,\n<span class=\"hljs-selector-class\">.dialog</span> {\n\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span>><span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> > <span class=\"hljs-selector-class\">.dialog</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-variable\">@debug:</span> true;\n\n<span class=\"hljs-selector-tag\">header</span> {\n  <span class=\"hljs-attribute\">background-color</span>: (yellow)when(<span class=\"hljs-variable\">@debug</span> = true);\n}\n\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-tag\">header</span> {\n  <span class=\"hljs-attribute\">background-color</span>: (yellow) when (<span class=\"hljs-variable\">@debug</span> = true);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-24\">4) 空行</h4>\n<p>以下几种情况需要空行：</p>\n<ul>\n<li>文件最后保留一个空行</li>\n<li>'}'后最好跟一个空行，包括scss中嵌套的规则</li>\n<li>属性之间需要适当的空行，具体见<a target=\"_blank\" href=\"http://alloyteam.github.io/CodeGuide/#css-declaration-order\" rel=\"nofollow noopener noreferrer\">属性声明顺序</a></li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n<span class=\"hljs-selector-class\">.dialog</span> {\n    <span class=\"hljs-attribute\">color</span>: red;\n    <span class=\"hljs-selector-tag\">&</span><span class=\"hljs-selector-pseudo\">:after</span> {\n        ...\n    }\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.dialog</span> {\n    <span class=\"hljs-attribute\">color</span>: red;\n\n    <span class=\"hljs-selector-tag\">&</span><span class=\"hljs-selector-pseudo\">:after</span> {\n        ...\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-25\">5) 注释</h4>\n<p>注释统一用'/* */'（scss中也不要用'//'），具体参照右边的写法；</p>\n<p>缩进与下一行代码保持一致；</p>\n<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* Modal header */</span>\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/*\n * Modal header\n */</span>\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.modal-header</span> {\n    <span class=\"hljs-comment\">/* 50px */</span>\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n\n    <span class=\"hljs-attribute\">color</span>: red; <span class=\"hljs-comment\">/* color red */</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-26\">6) 引号</h4>\n<p>最外层统一使用双引号；</p>\n<p>url的内容要用引号；</p>\n<p>属性选择器中的属性值需要引号。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span><span class=\"hljs-selector-pseudo\">:after</span> {\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">\"\"</span>;\n    <span class=\"hljs-attribute\">background-image</span>: url(<span class=\"hljs-string\">\"logo.png\"</span>);\n}\n\n<span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-attr\">[data-type=\"single\"]</span> {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-27\">7)<code>命名</code></h4>\n<ul>\n<li>类名使用<code>小写字母</code>，以<code>中划线</code>分隔</li>\n<li>id采用<code>驼峰式</code>命名</li>\n<li><code>less</code>中的变量、函数以<code>中划线</code>分隔命名</li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* class */</span>\n<span class=\"hljs-selector-class\">.element-content</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* id */</span>\n<span class=\"hljs-selector-id\">#myDialog</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* 变量 */</span>\n<span class=\"hljs-variable\">@color-black:</span> <span class=\"hljs-number\">#000</span>;\n\n<span class=\"hljs-comment\">/* mixins */</span>\n<span class=\"hljs-selector-class\">.my-mixin</span>() {\n  <span class=\"hljs-attribute\">color</span>: black;\n}\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-28\">8)<code>属性声明顺序</code></h4>\n<p>相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.declaration-order</span> {\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">float</span>: right;\n\n    <span class=\"hljs-attribute\">position</span>: absolute;\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">right</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">bottom</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">100</span>;\n\n    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#e5e5e5</span>;\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n\n    <span class=\"hljs-attribute\">font</span>: normal <span class=\"hljs-number\">13px</span> <span class=\"hljs-string\">\"Helvetica Neue\"</span>, sans-serif;\n    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">1.5</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f5f5f5</span>;\n\n    <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">1</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>书写顺序前后</code>为：</p>\n<p>（1）<code>定位属性</code>：position  display  float  left  top  right  bottom   overflow  clear   z-index</p>\n<p>（2）<code>自身属性</code>：width  height  padding  border  margin   background</p>\n<p>（3）<code>文字样式</code>：font-family   font-size   font-style   font-weight   font-varient   color</p>\n<p>（4）<code>文本属性</code>text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow</p>\n<p><strong>目的</strong>：减少浏览器reflow（回流），提升浏览器渲染dom的性能</p>\n<p><code>原理：浏览器的渲染流程为：</code></p>\n<p>1、解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构</p>\n<p>2、构建render树：DOM树和CSS树合并之后形成的render树。</p>\n<p>3、布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。</p>\n<p>4、绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。</p>\n<p>css样式解析到显示至浏览器屏幕上就发生在234步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第2步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。在解析过程中，一旦浏览器发现某个元素的定位变化影响DOM，则需要重新渲染。</p>\n<p>正确的书写顺序：</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.demo</span>{\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n\t<span class=\"hljs-attribute\">background-color</span>: red ;\n    \n\t<span class=\"hljs-attribute\">position</span>: absolute;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到它回流的影响而重新排位。最终导致③步骤花费的时间太久而影响到④步骤的显示，影响了用户体验。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">// 下面是推荐的属性的顺序</span>\n<span class=\"hljs-selector-attr\">[\n    [\n        \"display\",\n        \"visibility\",\n        \"float\",\n        \"clear\",\n        \"overflow\",\n        \"overflow-x\",\n        \"overflow-y\",\n        \"clip\",\n        \"zoom\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"table-layout\",\n        \"empty-cells\",\n        \"caption-side\",\n        \"border-spacing\",\n        \"border-collapse\",\n        \"list-style\",\n        \"list-style-position\",\n        \"list-style-type\",\n        \"list-style-image\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"-webkit-box-orient\",\n        \"-webkit-box-direction\",\n        \"-webkit-box-decoration-break\",\n        \"-webkit-box-pack\",\n        \"-webkit-box-align\",\n        \"-webkit-box-flex\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"position\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"z-index\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"margin\",\n        \"margin-top\",\n        \"margin-right\",\n        \"margin-bottom\",\n        \"margin-left\",\n        \"-webkit-box-sizing\",\n        \"-moz-box-sizing\",\n        \"box-sizing\",\n        \"border\",\n        \"border-width\",\n        \"border-style\",\n        \"border-color\",\n        \"border-top\",\n        \"border-top-width\",\n        \"border-top-style\",\n        \"border-top-color\",\n        \"border-right\",\n        \"border-right-width\",\n        \"border-right-style\",\n        \"border-right-color\",\n        \"border-bottom\",\n        \"border-bottom-width\",\n        \"border-bottom-style\",\n        \"border-bottom-color\",\n        \"border-left\",\n        \"border-left-width\",\n        \"border-left-style\",\n        \"border-left-color\",\n        \"-webkit-border-radius\",\n        \"-moz-border-radius\",\n        \"border-radius\",\n        \"-webkit-border-top-left-radius\",\n        \"-moz-border-radius-topleft\",\n        \"border-top-left-radius\",\n        \"-webkit-border-top-right-radius\",\n        \"-moz-border-radius-topright\",\n        \"border-top-right-radius\",\n        \"-webkit-border-bottom-right-radius\",\n        \"-moz-border-radius-bottomright\",\n        \"border-bottom-right-radius\",\n        \"-webkit-border-bottom-left-radius\",\n        \"-moz-border-radius-bottomleft\",\n        \"border-bottom-left-radius\",\n        \"-webkit-border-image\",\n        \"-moz-border-image\",\n        \"-o-border-image\",\n        \"border-image\",\n        \"-webkit-border-image-source\",\n        \"-moz-border-image-source\",\n        \"-o-border-image-source\",\n        \"border-image-source\",\n        \"-webkit-border-image-slice\",\n        \"-moz-border-image-slice\",\n        \"-o-border-image-slice\",\n        \"border-image-slice\",\n        \"-webkit-border-image-width\",\n        \"-moz-border-image-width\",\n        \"-o-border-image-width\",\n        \"border-image-width\",\n        \"-webkit-border-image-outset\",\n        \"-moz-border-image-outset\",\n        \"-o-border-image-outset\",\n        \"border-image-outset\",\n        \"-webkit-border-image-repeat\",\n        \"-moz-border-image-repeat\",\n        \"-o-border-image-repeat\",\n        \"border-image-repeat\",\n        \"padding\",\n        \"padding-top\",\n        \"padding-right\",\n        \"padding-bottom\",\n        \"padding-left\",\n        \"width\",\n        \"min-width\",\n        \"max-width\",\n        \"height\",\n        \"min-height\",\n        \"max-height\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"font\",\n        \"font-family\",\n        \"font-size\",\n        \"font-weight\",\n        \"font-style\",\n        \"font-variant\",\n        \"font-size-adjust\",\n        \"font-stretch\",\n        \"font-effect\",\n        \"font-emphasize\",\n        \"font-emphasize-position\",\n        \"font-emphasize-style\",\n        \"font-smooth\",\n        \"line-height\",\n        \"text-align\",\n        \"-webkit-text-align-last\",\n        \"-moz-text-align-last\",\n        \"-ms-text-align-last\",\n        \"text-align-last\",\n        \"vertical-align\",\n        \"white-space\",\n        \"text-decoration\",\n        \"text-emphasis\",\n        \"text-emphasis-color\",\n        \"text-emphasis-style\",\n        \"text-emphasis-position\",\n        \"text-indent\",\n        \"-ms-text-justify\",\n        \"text-justify\",\n        \"letter-spacing\",\n        \"word-spacing\",\n        \"-ms-writing-mode\",\n        \"text-outline\",\n        \"text-transform\",\n        \"text-wrap\",\n        \"-ms-text-overflow\",\n        \"text-overflow\",\n        \"text-overflow-ellipsis\",\n        \"text-overflow-mode\",\n        \"-ms-word-wrap\",\n        \"word-wrap\",\n        \"-ms-word-break\",\n        \"word-break\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"color\",\n        \"background\",\n        \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader\",\n        \"background-color\",\n        \"background-image\",\n        \"background-repeat\",\n        \"background-attachment\",\n        \"background-position\",\n        \"-ms-background-position-x\",\n        \"background-position-x\",\n        \"-ms-background-position-y\",\n        \"background-position-y\",\n        \"-webkit-background-clip\",\n        \"-moz-background-clip\",\n        \"background-clip\",\n        \"background-origin\",\n        \"-webkit-background-size\",\n        \"-moz-background-size\",\n        \"-o-background-size\",\n        \"background-size\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"outline\",\n        \"outline-width\",\n        \"outline-style\",\n        \"outline-color\",\n        \"outline-offset\",\n        \"opacity\",\n        \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity\",\n        \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.Alpha\",\n        \"-ms-interpolation-mode\",\n        \"-webkit-box-shadow\",\n        \"-moz-box-shadow\",\n        \"box-shadow\",\n        \"filter:progid:DXImageTransform.Microsoft.gradient\",\n        \"-ms-filter:\\\\'progid:DXImageTransform.Microsoft.gradient\",\n        \"text-shadow\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"-webkit-transition\",\n        \"-moz-transition\",\n        \"-ms-transition\",\n        \"-o-transition\",\n        \"transition\",\n        \"-webkit-transition-delay\",\n        \"-moz-transition-delay\",\n        \"-ms-transition-delay\",\n        \"-o-transition-delay\",\n        \"transition-delay\",\n        \"-webkit-transition-timing-function\",\n        \"-moz-transition-timing-function\",\n        \"-ms-transition-timing-function\",\n        \"-o-transition-timing-function\",\n        \"transition-timing-function\",\n        \"-webkit-transition-duration\",\n        \"-moz-transition-duration\",\n        \"-ms-transition-duration\",\n        \"-o-transition-duration\",\n        \"transition-duration\",\n        \"-webkit-transition-property\",\n        \"-moz-transition-property\",\n        \"-ms-transition-property\",\n        \"-o-transition-property\",\n        \"transition-property\",\n        \"-webkit-transform\",\n        \"-moz-transform\",\n        \"-ms-transform\",\n        \"-o-transform\",\n        \"transform\",\n        \"-webkit-transform-origin\",\n        \"-moz-transform-origin\",\n        \"-ms-transform-origin\",\n        \"-o-transform-origin\",\n        \"transform-origin\",\n        \"-webkit-animation\",\n        \"-moz-animation\",\n        \"-ms-animation\",\n        \"-o-animation\",\n        \"animation\",\n        \"-webkit-animation-name\",\n        \"-moz-animation-name\",\n        \"-ms-animation-name\",\n        \"-o-animation-name\",\n        \"animation-name\",\n        \"-webkit-animation-duration\",\n        \"-moz-animation-duration\",\n        \"-ms-animation-duration\",\n        \"-o-animation-duration\",\n        \"animation-duration\",\n        \"-webkit-animation-play-state\",\n        \"-moz-animation-play-state\",\n        \"-ms-animation-play-state\",\n        \"-o-animation-play-state\",\n        \"animation-play-state\",\n        \"-webkit-animation-timing-function\",\n        \"-moz-animation-timing-function\",\n        \"-ms-animation-timing-function\",\n        \"-o-animation-timing-function\",\n        \"animation-timing-function\",\n        \"-webkit-animation-delay\",\n        \"-moz-animation-delay\",\n        \"-ms-animation-delay\",\n        \"-o-animation-delay\",\n        \"animation-delay\",\n        \"-webkit-animation-iteration-count\",\n        \"-moz-animation-iteration-count\",\n        \"-ms-animation-iteration-count\",\n        \"-o-animation-iteration-count\",\n        \"animation-iteration-count\",\n        \"-webkit-animation-direction\",\n        \"-moz-animation-direction\",\n        \"-ms-animation-direction\",\n        \"-o-animation-direction\",\n        \"animation-direction\"\n    ]</span>,\n    <span class=\"hljs-selector-attr\">[\n        \"content\",\n        \"quotes\",\n        \"counter-reset\",\n        \"counter-increment\",\n        \"resize\",\n        \"cursor\",\n        \"-webkit-user-select\",\n        \"-moz-user-select\",\n        \"-ms-user-select\",\n        \"user-select\",\n        \"nav-index\",\n        \"nav-up\",\n        \"nav-right\",\n        \"nav-down\",\n        \"nav-left\",\n        \"-moz-tab-size\",\n        \"-o-tab-size\",\n        \"tab-size\",\n        \"-webkit-hyphens\",\n        \"-moz-hyphens\",\n        \"hyphens\",\n        \"pointer-events\"\n    ]</span>\n]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-29\">9)颜色</h4>\n<p>颜色16进制用小写字母；</p>\n<p>颜色16进制尽量用简写。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ABCDEF</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#001122</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#abcdef</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#012</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-30\">10)属性简写</h4>\n<p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p>\n<p><code>margin</code> 和 <code>padding</code> 相反，需要使用简写；</p>\n<p>常见的属性简写包括：</p>\n<ul>\n<li><code>font</code></li>\n<li><code>background</code></li>\n<li><code>transition</code></li>\n<li><code>animation</code></li>\n</ul>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">transition</span>: opacity <span class=\"hljs-number\">1s</span> linear <span class=\"hljs-number\">2s</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">transition-delay</span>: <span class=\"hljs-number\">2s</span>;\n    <span class=\"hljs-attribute\">transition-timing-function</span>: linear;\n    <span class=\"hljs-attribute\">transition-duration</span>: <span class=\"hljs-number\">1s</span>;\n    <span class=\"hljs-attribute\">transition-property</span>: opacity;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-31\">11)<code>媒体查询</code></h4>\n<p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-selector-class\">.element</span> {\n    ...\n}\n\n<span class=\"hljs-selector-class\">.element-avatar</span>{\n    ...\n}\n\n<span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) {\n    <span class=\"hljs-selector-class\">.element</span> {\n        ...\n    }\n\n    <span class=\"hljs-selector-class\">.element-avatar</span> {\n        ...\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-32\">12)<code>Less相关</code></h4>\n<p>每个模块应该有一个单独的less, 然后每个最外层的父类 className 应该写在第一位，所有子Node的样式都写在里面，这样是为了避免命名冲突。比如</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">//out: false</span>\n<span class=\"hljs-selector-class\">.parent-name</span>{\n    \n    <span class=\"hljs-selector-class\">.child-name</span>{\n        ...\n    }\n    \n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>@import</code> 引入的文件不需要结尾的'.less'</p>\n<p><code>LESS嵌套最多不能超过5层</code>；</p>\n<p>不允许有空的规则；</p>\n<p>元素选择器用小写字母；</p>\n<p>去掉小数点前面的0；</p>\n<p>去掉数字中不必要的小数点和末尾的0；</p>\n<p>属性值'0'后面不要加单位；</p>\n<p>同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法；</p>\n<p>无前缀的标准属性应该写在有前缀的属性后面；</p>\n<p>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</p>\n<p>不要在一个文件里出现两个相同的规则；</p>\n<p>用 <code>border: 0;</code> 代替 <code>border: none;</code>；</p>\n<p><code>CSS选择器不要超过3层</code>；</p>\n<p>尽量少用<code>'*'</code>选择器。</p>\n<pre><code class=\"hljs less copyable\" lang=\"less\"><span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-tag\">LI</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-tag\">li</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50.0px</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0px</span>;\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">-webkit-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n    <span class=\"hljs-attribute\">-moz-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n\n    <span class=\"hljs-attribute\">background</span>: linear-gradient(to bottom, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>: -webkit-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>: -moz-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">-webkit-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n       <span class=\"hljs-attribute\">-moz-border-radius</span>: <span class=\"hljs-number\">3px</span>;\n            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n\n    <span class=\"hljs-attribute\">background</span>: -webkit-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>:    -moz-linear-gradient(top, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n    <span class=\"hljs-attribute\">background</span>:         linear-gradient(to bottom, <span class=\"hljs-number\">#fff</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">#eee</span> <span class=\"hljs-number\">100%</span>);\n}\n\n<span class=\"hljs-comment\">/* not good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50px</span>;\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-comment\">/* good */</span>\n<span class=\"hljs-selector-class\">.element</span> {\n    <span class=\"hljs-attribute\">color</span>: rgb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-attribute\">color</span>: rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, .<span class=\"hljs-number\">5</span>);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-33\">5 JavaScript</h3>\n<h4 class=\"heading\" data-id=\"heading-34\">1)缩进</h4>\n<p>使用soft tab（4个空格）。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>,\n    y = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">if</span> (x < y) {\n    x += <span class=\"hljs-number\">10</span>;\n} <span class=\"hljs-keyword\">else</span> {\n    x += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-35\">2)分号</h4>\n<p>以下几种情况后需加分号：</p>\n<ul>\n<li>变量声明</li>\n<li>表达式</li>\n<li>return</li>\n<li>throw</li>\n<li>break</li>\n<li>continue</li>\n<li>do-while</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">/* var declaration */</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">/* expression statement */</span>\nx++;\n\n<span class=\"hljs-comment\">/* do-while */</span>\n<span class=\"hljs-keyword\">do</span> {\n    x++;\n} <span class=\"hljs-keyword\">while</span> (x < <span class=\"hljs-number\">10</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-36\">3)空格</h4>\n<p>以下几种情况不需要空格：</p>\n<ul>\n<li>对象的属性名后</li>\n<li>前缀一元运算符后</li>\n<li>后缀一元运算符前</li>\n<li>函数调用括号前</li>\n<li>无论是函数声明还是函数表达式，'('前不要空格</li>\n<li>数组的'['后和']'前</li>\n<li>对象的'{'后和'}'前</li>\n<li>运算符'('后和')'前</li>\n</ul>\n<p>以下几种情况需要空格：</p>\n<ul>\n<li>二元运算符前后</li>\n<li>三元运算符'?:'前后</li>\n<li>代码块'{'前</li>\n<li>下列关键字前：<code>else</code>, <code>while</code>, <code>catch</code>, <code>finally</code></li>\n<li>下列关键字后：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>case</code>, <code>try</code>,<code>catch</code>, <code>finally</code>, <code>with</code>, <code>return</code>, <code>typeof</code></li>\n<li>单行注释'//'后（若单行注释和代码同行，则'//'前也需要），多行注释'*'后</li>\n<li>对象的属性值前</li>\n<li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格</li>\n<li>无论是函数声明还是函数表达式，'{'前一定要有空格</li>\n<li>函数的参数之间</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span> :<span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-comment\">// not good</span>\n++ x;\ny ++;\nz = x?<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// good</span>\n++x;\ny++;\nz = x ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ];\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = ( <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span> )*<span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = (<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-comment\">// no space before '(', one space before '{', one space between function parameters</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n\n<span class=\"hljs-comment\">// no space before '('</span>\ndoSomething(item);\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i<<span class=\"hljs-number\">6</span>;i++){\n    x++;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">6</span>; i++) {\n    x++;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-37\">4)空行</h4>\n<p>以下几种情况需要空行：</p>\n<ul>\n<li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）</li>\n<li>注释前（当注释在代码块的第一行时，则无需空行）</li>\n<li>代码块后（在函数调用、数组、对象中则无需空行）</li>\n<li>文件最后保留一个空行</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// need blank line after variable declaration</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// not need blank line when variable declaration is last expression in the current block</span>\n<span class=\"hljs-keyword\">if</span> (x >= <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">var</span> y = x + <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// need blank line before line comment</span>\na++;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">b</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// not need blank line when comment is first line of block</span>\n    <span class=\"hljs-keyword\">return</span> a;\n}\n\n<span class=\"hljs-comment\">// need blank line after blocks</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">2</span>; i++) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-keyword\">continue</span>;\n}\n\n<span class=\"hljs-keyword\">var</span> obj = {\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    },\n\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;\n    }\n};\n\n<span class=\"hljs-comment\">// not need blank line when in argument list, array, object</span>\nfunc(\n    <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-number\">3</span>\n);\n\n<span class=\"hljs-keyword\">var</span> foo = [\n    <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-number\">3</span>\n];\n\n<span class=\"hljs-keyword\">var</span> foo = {\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        a++;\n    },\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-38\">5)换行</h4>\n<p>换行的地方，行末必须有','或者运算符；</p>\n<p>以下几种情况不需要换行：</p>\n<ul>\n<li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li>\n<li>代码块'{'前</li>\n</ul>\n<p>以下几种情况需要换行：</p>\n<ul>\n<li>代码块'{'后和'}'前</li>\n<li>变量赋值后</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>\n    , <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n\nx = y\n    ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n\nx = y ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\nx = y ?\n    <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// no need line break with 'else', 'catch', 'finally'</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n    ...\n} <span class=\"hljs-keyword\">else</span> {\n    ...\n}\n\n<span class=\"hljs-keyword\">try</span> {\n    ...\n} <span class=\"hljs-keyword\">catch</span> (e) {\n    ...\n} <span class=\"hljs-keyword\">finally</span> {\n    ...\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>)\n</span>{\n    ...\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a, foo = <span class=\"hljs-number\">7</span>, b,\n    c, bar = <span class=\"hljs-number\">8</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a,\n    foo = <span class=\"hljs-number\">7</span>,\n    b, c, bar = <span class=\"hljs-number\">8</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-39\">6)单行注释</h4>\n<p>双斜线后，必须跟一个空格；</p>\n<p>缩进与下一行代码保持一致；</p>\n<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">if</span> (condition) {\n    <span class=\"hljs-comment\">// if you made it here, then all security checks passed</span>\n    allowed();\n}\n\n<span class=\"hljs-keyword\">var</span> zhangsan = <span class=\"hljs-string\">'zhangsan'</span>; <span class=\"hljs-comment\">// one space after code</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-40\">7)多行注释</h4>\n<p>最少三行, '*'后跟一个空格，具体参照右边的写法；</p>\n<p>建议在以下情况下使用：</p>\n<ul>\n<li>难于理解的代码段</li>\n<li>可能存在错误的代码段</li>\n<li>浏览器特殊的HACK代码</li>\n<li>业务逻辑强相关的代码</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">/*\n * one space after '*'\n */</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-41\">8)<code>文档注释</code></h4>\n<p>各类标签@param, @method等请参考<a target=\"_blank\" href=\"http://usejsdoc.org/\" rel=\"nofollow noopener noreferrer\">usejsdoc</a>和<a target=\"_blank\" href=\"http://yuri4ever.github.io/jsdoc/\" rel=\"nofollow noopener noreferrer\">JSDoc Guide</a>；</p>\n<p>建议在以下情况下使用：</p>\n<ul>\n<li>所有常量</li>\n<li>所有函数</li>\n<li>所有类</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * @func\n * @desc 一个带参数的函数\n * @param {string} a - 参数a\n * @param {number} b=1 - 参数b默认值为1\n * @param {string} c=1 - 参数c有两种支持的取值</br>1—表示x</br>2—表示xx\n * @param {object} d - 参数d为一个对象\n * @param {string} d.e - 参数d的e属性\n * @param {string} d.f - 参数d的f属性\n * @param {object[]} g - 参数g为一个对象数组\n * @param {string} g.h - 参数g数组中一项的h属性\n * @param {string} g.i - 参数g数组中一项的i属性\n * @param {string} [j] - 参数j是一个可选参数\n */\n<span class=\"hljs-keyword\">function</span> foo(a, b, c, d, g, j) {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-42\">9)引号</h4>\n<p>最外层统一使用单引号。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-string\">\"test\"</span>;\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-string\">'foo'</span>,\n    z = <span class=\"hljs-string\">'<div id=\"test\"></div>'</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-43\">10)变量命名</h4>\n<ul>\n<li>标准变量采用驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据）</li>\n<li>'ID'在变量名中全大写</li>\n<li>'URL'在变量名中全大写</li>\n<li>'Android'在变量名中大写第一个字母</li>\n<li>'iOS'在变量名中小写第一个，大写后两个字母</li>\n<li>常量全大写，用下划线连接</li>\n<li>构造函数，大写第一个字母</li>\n<li>jquery对象必须以'$'开头命名</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> thisIsMyName;\n\n<span class=\"hljs-keyword\">var</span> goodID;\n\n<span class=\"hljs-keyword\">var</span> reportURL;\n\n<span class=\"hljs-keyword\">var</span> AndroidVersion;\n\n<span class=\"hljs-keyword\">var</span> iOSVersion;\n\n<span class=\"hljs-keyword\">var</span> MAX_COUNT = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = name;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> body = $(<span class=\"hljs-string\">'body'</span>);\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> $body = $(<span class=\"hljs-string\">'body'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-44\">11)变量声明</h4>\n<p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var 声明，不允许出现两个连续的var声明。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomethingWithItems</span>(<span class=\"hljs-params\">items</span>) </span>{\n    <span class=\"hljs-comment\">// use one var</span>\n    <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-number\">10</span>,\n        result = value + <span class=\"hljs-number\">10</span>,\n        i,\n        len;\n\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>, len = items.length; i < len; i++) {\n        result += <span class=\"hljs-number\">10</span>;\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-45\">12)函数</h4>\n<p>无论是函数声明还是函数表达式，'('前不要空格，但'{'前一定要有空格；</p>\n<p>函数调用括号前不需要空格；</p>\n<p>立即执行函数外必须包一层括号；</p>\n<p>不要给inline function命名；</p>\n<p>参数之间用', '分隔，注意逗号后有一个空格。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// no space before '(', but one space before'{'</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomething</span>(<span class=\"hljs-params\">item</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n}\n\n<span class=\"hljs-comment\">// not good</span>\ndoSomething (item);\n\n<span class=\"hljs-comment\">// good</span>\ndoSomething(item);\n\n<span class=\"hljs-comment\">// requires parentheses around immediately invoked function expressions</span>\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n})();\n\n<span class=\"hljs-comment\">// not good</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">x</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n});\n\n<span class=\"hljs-comment\">// good</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n});\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}];\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n}];\n\n<span class=\"hljs-comment\">// use ', ' between function parameters</span>\n<span class=\"hljs-keyword\">var</span> doSomething = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c</span>) </span>{\n    <span class=\"hljs-comment\">// do something</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-46\">13)数组、对象</h4>\n<p>对象属性名不需要加引号；</p>\n<p>对象以缩进的形式书写，不要写在一行；</p>\n<p>数组、对象最后不要有逗号。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-string\">'b'</span>: <span class=\"hljs-number\">1</span>\n};\n\n<span class=\"hljs-keyword\">var</span> a = {<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>};\n\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>,\n};\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-47\">14)括号</h4>\n<p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>,<code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (condition)\n    doSomething();\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n    doSomething();\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-48\">15)null</h4>\n<p>适用场景：</p>\n<ul>\n<li>初始化一个将来可能被赋值为对象的变量</li>\n<li>与已经初始化的变量做比较</li>\n<li>作为一个参数为对象的函数的调用传参</li>\n<li>作为一个返回对象的函数的返回值</li>\n</ul>\n<p>不适用场景：</p>\n<ul>\n<li>不要用null来判断函数调用时有无传参</li>\n<li>不要与未初始化的变量做比较</li>\n</ul>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (b <span class=\"hljs-string\">`= null) {\n        // not mean b is not supply\n        ...\n    }\n}\n\nvar a;\n\nif (a `</span>= <span class=\"hljs-literal\">null</span>) {\n    ...\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-string\">`= null) {\n    ...\n}\n</span><span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-49\">16)undefined</h4>\n<p>永远不要直接使用undefined进行变量判断；</p>\n<p>使用typeof和字符串'undefined'对变量进行判断。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (person <span class=\"hljs-string\">`= undefined) {\n    ...\n}\n\n// good\nif (typeof person `</span>= <span class=\"hljs-string\">'undefined'</span>) {\n    ...\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-50\">17)jshint</h4>\n<p>用'<code>=', '!</code>'代替'`', '!='；</p>\n<p>for-in里一定要有hasOwnProperty的判断；</p>\n<p>不要在内置对象的原型上添加方法，如Array, Date；</p>\n<p>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</p>\n<p>变量不要先使用后声明；</p>\n<p>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</p>\n<p>不要在同个作用域下声明同名变量；</p>\n<p>不要在一些不需要的地方加括号，例：delete(a.b)；</p>\n<p>不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）；</p>\n<p>不要声明了变量却不使用；</p>\n<p>不要在应该做比较的地方做赋值；</p>\n<p>debugger不要出现在提交的代码里；</p>\n<p>数组中不要存在空元素；</p>\n<p>不要在循环内部声明函数；</p>\n<p>不要像这样使用构造函数，例：<code>new function () { ... }</code>, <code>new Object</code>；</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-string\">` 1) {\n    a++;\n}\n\n// good\nif (a `</span>= <span class=\"hljs-number\">1</span>) {\n    a++;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">for</span> (key <span class=\"hljs-keyword\">in</span> obj) {\n    <span class=\"hljs-keyword\">if</span> (obj.hasOwnProperty(key)) {\n        <span class=\"hljs-comment\">// be sure that obj[key] belongs to the object and was not inherited</span>\n        <span class=\"hljs-built_in\">console</span>.log(obj[key]);\n    }\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-built_in\">Array</span>.prototype.count = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;\n};\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">0</span>;\n    }\n\n    x += <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n\n    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">new</span> Person();\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> Person();\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">delete</span>(obj.attr);\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">delete</span> obj.attr;\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">if</span> (a = <span class=\"hljs-number\">10</span>) {\n    a++;\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, , , <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> nums = [];\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i < <span class=\"hljs-number\">10</span>; i++) {\n    (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{\n        nums[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) </span>{\n            <span class=\"hljs-keyword\">return</span> i + j;\n        };\n    }(i));\n}\n\n<span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> singleton = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> privateVar;\n\n    <span class=\"hljs-keyword\">this</span>.publicMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        privateVar = <span class=\"hljs-number\">1</span>;\n    };\n\n    <span class=\"hljs-keyword\">this</span>.publicMethod2 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        privateVar = <span class=\"hljs-number\">2</span>;\n    };\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-51\">18)杂项</h4>\n<p>不要混用tab和space；</p>\n<p>不要在一处使用多个tab或space；</p>\n<p>换行符统一用'LF'；</p>\n<p>对上下文this的引用只能使用'_this', 'that', 'self'其中一个来命名；</p>\n<p>行尾不要有空白字符；</p>\n<p>switch的falling through和no default的情况一定要有注释特别说明；</p>\n<p>不允许有空的代码块。</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-comment\">// not good</span>\n<span class=\"hljs-keyword\">var</span> a   = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// not good</span>\n    <span class=\"hljs-keyword\">var</span> me = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// good</span>\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n}\n\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">switch</span> (condition) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n        ...\n        break;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n        ...\n    <span class=\"hljs-comment\">// why fall through</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>\n        ...\n        break;\n    <span class=\"hljs-comment\">// why no default</span>\n}\n\n<span class=\"hljs-comment\">// not good with empty block</span>\n<span class=\"hljs-keyword\">if</span> (condition) {\n\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>插件推荐：\n<code>EditorConfig for VS Code 生成.editorconfig文件</code></p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">root = <span class=\"hljs-literal\">true</span>\n\n[*]\nindent_style = space\nindent_size = 4\ncharset = utf-8\ntrim_trailing_whitespace = <span class=\"hljs-literal\">true</span>\ninsert_final_newline = <span class=\"hljs-literal\">true</span>\n\n[*.md]\ntrim_trailing_whitespace = <span class=\"hljs-literal\">false</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>未完待续</p>\n",
      "id": "7cemnhisr380",
      "author": "前端劝退师",
      "title": "大前端团队代码规范",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>前段时间在研究前端异常监控/埋点平台的实现。</p>\n<p>在思考方案时，想到了浏览器自带的观察者以及页面生命周期API 。</p>\n<p>于是在翻查资料时意外发现，原来现代浏览器支持多达四种不同类型的观察者：</p>\n<ul>\n<li><code>Intersection Observer</code>，交叉观察者。</li>\n<li><code>Mutation Observer</code>，变动观察者。</li>\n<li><code>Resize Observer</code>，视图观察者。</li>\n<li><code>Performance Observer</code>，性能观察者\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16df977e0b2680a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"300\" data-height=\"300\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"300\" height=\"300\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IntersectionObserver</th>\n<th>MutationObserver</th>\n<th>ResizeObserver</th>\n<th>PerformanceObserver</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>观察一个元素是否在视窗可见</td>\n<td>观察DOM中的变化</td>\n<td>观察视口大小的变化</td>\n<td>监测性能度量事件</td>\n</tr>\n<tr>\n<td>方法</td>\n<td>observe() <br>disconnect() <br> takeRecords()</td>\n<td>observe() <br>disconnect() <br>takeRecords() <br>unobserve()</td>\n<td>observe() <br>disconnect() <br>unobserve()</td>\n<td>observe() <br>disconnect() <br>takeRecords()</td>\n</tr>\n<tr>\n<td>取代</td>\n<td>Dom Mutation events</td>\n<td>getBoundingClientRect() 返回元素的大小及其相对于可视窗口的位置  <br> <br> Scroll 和 Resize 事件</td>\n<td>Resize 事件</td>\n<td>Performance 接口</td>\n</tr>\n<tr>\n<td>用途</td>\n<td>1. 无限滚动 <br>2. 图片懒加载<br> 3. 兴趣埋点 <br> 4. 控制动画/视频执行（性能优化）</td>\n<td>1. 更高性能的数据绑定及响应<br> 2. 实现视觉差滚动  <br> 3. 图片预加载 <br> 4. 实现富文本编辑器</td>\n<td>1. 更智能的响应式布局（取代@media） <br>2. 响应式组件</td>\n<td>1. 更细颗粒的性能监控 <br>2. 分析性能对业务的影响（交互快/慢是否会影响销量）</td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-1\">1. <code>IntersectionObserver</code>：交叉观察者</h2>\n<blockquote>\n<p><code>IntersectionObserver</code>接口，提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态的方法，祖先元素与视窗(<code>viewport)</code>被称为根(<code>root</code>)</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 出现的意义</h3>\n<p>想要计算Web页面的元素的位置，非常依赖于<code>DOM</code>状态的显式查询。但这些查询是同步的，会导致昂贵的样式计算开销（重绘和回流），且不停轮询会导致大量的性能浪费。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df34ffa206ff4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"710\" data-height=\"379\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"710\" height=\"379\"></svg>\"><figcaption></figcaption></figure>\n于是便发展了以下的几种方案：<p></p>\n<ul>\n<li>构建DOM和数据的自定义预加载和延迟加载。</li>\n<li>实现了数据绑定的高性能滚动列表，该列表加载和呈现数据集的子集。</li>\n<li>通过<code>scroll</code>等事件或通过插件的形式，计算真实元素可见性。</li>\n</ul>\n<p>而它们都有几项共同特点：</p>\n<ol>\n<li>基本实现形式都是查询各个元素相对与某些元素（全局视口）的“被动查询”。</li>\n<li>信息可以异步传递（例如从另一个线程传递），且没有统一捕获错误的处理。</li>\n<li><code>web</code>平台支持匮乏，各有各家的处理。需要开发人员消耗大量精力兼容。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-3\">2. <code>IntersectionObserver</code>的优势</h3>\n<p><code>Intersection Observer API</code>通过为开发人员提供一种新方法来异步查询元素相对于其他元素或全局视口的位置，从而解决了上述问题:</p>\n<ul>\n<li><strong>异步处理</strong>消除了昂贵的<code>DOM</code>和样式查询，连续轮询以及使用自定义插件的需求。</li>\n<li>通过消除对这些方法的需求，可以使应用程序显着降低<code>CPU</code>，<code>GPU</code>和资源成本。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-4\">3. <code>IntersectionObserver</code>基本使用</h3>\n<p>使用<code>IntersectionObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调事件</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-5\">1.<strong>创建观察者</strong></h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const options = {\n    root: document.querySelector(<span class=\"hljs-string\">'.scrollContainer'</span>),\n    rootMargin: <span class=\"hljs-string\">'0px'</span>,\n    threshold: [0.3, 0.5, 0.8, 1] }\n    \nconst observer = new IntersectionObserver(handler, options)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这几个参数用大白话解释就是：</p>\n<ol>\n<li><code>root</code>：指定一个根元素</li>\n<li><code>rootMargin</code>：使用类似于设置CSS边距的语法来指定根边距（根元素的观察影响范围）\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df3610c9bf7742?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"710\" data-height=\"556\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"710\" height=\"556\"></svg>\"><figcaption></figcaption></figure></li>\n<li><code>threshold</code>：阈值，可以为数组。<code>[0.3]</code>意味着，当目标元素在根元素指定的元素内可见30%时，调用处理函数。</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-6\">2. <strong>定义回调事件</strong></h4>\n<p>当目标元素与根元素通过阈值相交时，就会触发回调函数。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> handler (entries, observer) { \n    entries.forEach(entry => { \n    // 每个成员都是一个IntersectionObserverEntry对象。\n    // 举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。\n    // entry.boundingClientRect \n    // entry.intersectionRatio \n    // entry.intersectionRect \n    // entry.isIntersecting \n    // entry.rootBounds \n    // entry.target \n    // entry.time \n    }); \n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>time 时间戳</li>\n<li>rootBounds 根元素的位置</li>\n<li>boundingClientRect 目标元素的位置信息</li>\n<li>intersectionRect 交叉部分的位置信息</li>\n<li>intersectionRatio 目标元素的可见比例，看下图示</li>\n<li>target。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/22/16df3f6a6b04daeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"886\" data-height=\"876\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"886\" height=\"876\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-7\">3. <strong>定义要观察的目标对象</strong></h4>\n<p>任何目标元素都可以通过调用<code>.observer(target)</code>方法来观察。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const target = document.querySelector(“.targetBox”); \nobserver.observe(target);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>此外，还有两个方法：</p>\n<p>停止对某目标的监听</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.unobserve(target)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>终止对所有目标的监听</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.disconnect()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">4. 例子1：图片懒加载</h3>\n<p><code>HTML</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-1.jpg\"</span>>\n<img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-2.jpg\"</span>>\n<img src=<span class=\"hljs-string\">\"placeholder.png\"</span> data-src=<span class=\"hljs-string\">\"img-3.jpg\"</span>>\n<!-- more images -->\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>脚本：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new IntersectionObserver(\n(entries, observer) => { \nentries.forEach(entry => {\n    /* 替换属性 */\n    entry.target.src = entry.target.dataset.src;\n    observer.unobserve(entry.target);\n  });\n}, \n{rootMargin: <span class=\"hljs-string\">\"0px 0px -200px 0px\"</span>});\n\ndocument.querySelectorAll(<span class=\"hljs-string\">'img'</span>).forEach(img => { observer.observe(img) });\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>上述例子表示 仅在到达视口距离底部200px视加载图片。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">5. 例子2：兴趣埋点</h3>\n<p>关于兴趣埋点，一个比较通用的方案是：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d11ced1f265da1b7004b6f7#heading-8\" rel>来自：《超好用的API之IntersectionObserver》</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const boxList = [...document.querySelectorAll(<span class=\"hljs-string\">'.box'</span>)]\n\nvar io = new IntersectionObserver((entries) =>{\n  entries.forEach(item => {\n    // intersectionRatio === 1说明该元素完全暴露出来，符合业务需求\n    <span class=\"hljs-keyword\">if</span> (item.intersectionRatio === 1) {\n      // 。。。 埋点曝光代码\n      io.unobserve(item.target)\n    }\n  })\n}, {\n  root: null,\n  threshold: 1, // 阀值设为1，当只有比例达到1时才触发回调函数\n})\n\n// observe遍历监听所有box节点\nboxList.forEach(box => io.observe(box))\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>至于怎样评断用户是否感兴趣，记录方式就见仁见智了：</p>\n<ul>\n<li>位于屏幕中间，并停留时长大于2秒，计数一次。</li>\n<li>区域悬停，触发定时器记录时间。</li>\n<li><code>PC</code>端记录鼠标点击次数/悬停时间，移动端记录<code>touch</code>事件</li>\n</ul>\n<p>这里就不展开写了（我懒）。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">6. 控制动画/视频 执行</h3>\n<p>这里提供控制视频的版本</p>\n<p><code>HTML</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><video src=<span class=\"hljs-string\">\"OSRO-animation.mp4\"</span> controls=<span class=\"hljs-string\">\"\"</span>></video>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>js</code>:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> video = document.querySelector(<span class=\"hljs-string\">'video'</span>);\n<span class=\"hljs-built_in\">let</span> isPaused = <span class=\"hljs-literal\">false</span>; /* Flag <span class=\"hljs-keyword\">for</span> auto-paused video */\n<span class=\"hljs-built_in\">let</span> observer = new IntersectionObserver((entries, observer) => { \n  entries.forEach(entry => {\n    <span class=\"hljs-keyword\">if</span>(entry.intersectionRatio!=1  && !video.paused){\n      video.pause(); isPaused = <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(isPaused) {video.play(); isPaused=<span class=\"hljs-literal\">false</span>}\n  });\n}, {threshold: 1});\nobserver.observe(video);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>效果：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df6bce3adeb937?imageslim\" data-width=\"504\" data-height=\"721\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"504\" height=\"721\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">2. <code>Mutation Observer</code>：变动观察者</h2>\n<blockquote>\n<p>接口提供了监视对<code>DOM</code>树所做更改的能力。它被设计为旧的<code>MutationEvents</code>功能的替代品，该功能是<code>DOM3 Events</code>规范的一部分。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 出现的意义</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df775ba854199d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"239\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"239\"></svg>\"><figcaption></figcaption></figure>\n归根究底，是<code>MutationEvents</code>的功能不尽人意：<p></p>\n<ol>\n<li>在<code>MDN</code>中也写到了，是被<code>DOM Event</code>承认在API上有缺陷，反对使用。</li>\n<li>核心缺陷是：性能问题和跨浏览器支持。</li>\n<li>为<code>DOM</code>添加 <code>mutation</code> 监听器极度降低进一步修改<code>DOM</code>文档的性能（慢1.5 - 7倍），此外, 移除监听器不会逆转的损害。</li>\n</ol>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6dd5f3f265da03c23eeff9\" rel>来自：《监听DOM加载完成及改变——MutationObserver应用》</a></p>\n</blockquote>\n<p><code>MutationEvents</code>的原理：通过绑定事件监听<code>DOM</code></p>\n<p>乍一看到感觉很正常，那列一下相关监听的事件：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">DOMAttributeNameChanged\nDOMCharacterDataModified\nDOMElementNameChanged\nDOMNodeInserted\nDOMNodeInsertedIntoDocument\nDOMNodeRemoved\nDOMNodeRemovedFromDocument\nDOMSubtreeModified\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>甭记，这么多事件，各内核各版本浏览器想兼容怕是要天荒地老。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. <code>MutationObserver</code>的优势</h3>\n<p>而<code>Mutation Observer</code>的优势在于：</p>\n<ul>\n<li><code>MutationEvents</code>事件是同步触发，也就是说，<code>DOM</code> 的变动立刻会触发相应的事件；</li>\n<li><code>Mutation Observer</code> 则是异步触发，<code>DOM</code> 的变动并不会马上触发，而是要等到当前所有 <code>DOM</code> 操作都结束才触发。</li>\n<li>可以通过配置项，监听目标<code>DOM</code>下子元素的变更记录</li>\n</ul>\n<p>简单讲：<code>异步万岁</code>!</p>\n<h3 class=\"heading\" data-id=\"heading-14\">3. <code>MutationObserver</code>基本使用</h3>\n<p>使用<code>MutationObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-15\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new MutationObserver(callback);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-16\">2. 定义回调函数</h4>\n<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> callback (mutations, observer) {\n  mutations.forEach(<span class=\"hljs-keyword\">function</span>(mutation) {\n    console.log(mutation);\n  });\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>其中每个<code>mutation</code>都对应一个<code>MutationRecord</code>对象，记录着<code>DOM</code>每次发生变化的变动记录</p>\n<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type</code></td>\n<td>观察的变动类型（<code>attribute</code>、<code>characterData</code>或者<code>childList</code>）</td>\n</tr>\n<tr>\n<td><code>target</code></td>\n<td>发生变动的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>addedNodes</code></td>\n<td>新增的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>removedNodes</code></td>\n<td>删除的<code>DOM</code>节点</td>\n</tr>\n<tr>\n<td><code>previousSibling</code></td>\n<td>前一个同级节点，如果没有则返回<code>null</code></td>\n</tr>\n<tr>\n<td><code>nextSibling</code></td>\n<td>下一个同级节点，如果没有则返回<code>null</code></td>\n</tr>\n<tr>\n<td><code>attributeName</code></td>\n<td>发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性</td>\n</tr>\n<tr>\n<td><code>oldValue</code></td>\n<td>变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code></td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-17\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.observe(dom, options)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>启动监听，接收两个参数。</p>\n<ul>\n<li>第一参数：被观察的<code>DOM</code>节点。</li>\n<li>第二参数：配置需要观察的变动项<code>options</code>。</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">mutationObserver.observe(content, {\n    attributes: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标属性的改变\n    characterData: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标数据的改变(改变前的数据/值)\n    childList: <span class=\"hljs-literal\">true</span>, // Boolean - 观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化\n    subtree: <span class=\"hljs-literal\">true</span>, // Boolean - 目标以及目标的后代改变都会观察\n    attributeOldValue: <span class=\"hljs-literal\">true</span>, // Boolean - 表示需要记录改变前的目标属性值\n    characterDataOldValue: <span class=\"hljs-literal\">true</span>, // Boolean - 设置了characterDataOldValue可以省略characterData设置\n    // attributeFilter: [<span class=\"hljs-string\">'src'</span>, <span class=\"hljs-string\">'class'</span>] // Array - 观察指定属性\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>优先级 ：</p>\n<ol>\n<li><code>attributeFilter/attributeOldValue</code> > <code>attributes</code></li>\n<li><code>characterDataOldValue</code> > <code>characterData</code></li>\n<li><code>attributes/characterData/childList</code>（或更高级特定项）至少有一项为true；</li>\n<li>特定项存在, 对应选项可以忽略或必须为<code>true</code></li>\n</ol>\n<p>此外，还有两个方法：</p>\n<p>停止观察。调用后不再触发观察器，解除订阅</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.disconnect()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>清除变动记录。即不再处理未处理的变动。该方法返回变动记录的数组，注意，该方法立即生效。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">MutationObserver.takeRecords()\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-18\">4. 例子1：<code>MutationObserver</code>监听文本变化</h3>\n<p>基本使用是：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const target = document.getElementById(<span class=\"hljs-string\">'target-id'</span>)\n\nconst observer = new MutationObserver(records => {\n  // 输入变更记录\n})\n\n// 开始观察\nobserver.observe(target, {\n  characterData: <span class=\"hljs-literal\">true</span>\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里可以有几种处理。</p>\n<ul>\n<li>聊天的气泡框彩蛋，检测文本中的指定字符串/表情包，触发类似微信聊天的表情落下动画。</li>\n<li>输入框的热点话题搜索，当输入“<code>#</code>”号时，启动搜索框预检文本或高亮话题。</li>\n</ul>\n<p>有个<code>Vue</code>的小型插件就是这么实现的：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/mitsuyacider/vue-hashtag-textarea\" rel=\"nofollow noopener noreferrer\">来自：《vue-hashtag-textarea》</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7e875c46f836?imageslim\" data-width=\"1280\" data-height=\"716\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"716\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-19\">5. 例子2: 色块小游戏脚本</h3>\n<p>这个实现也是秀得飞起：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://benhuang.info/2019/02/20/hacking-the-color-picker-game-mutationobserver/\" rel=\"nofollow noopener noreferrer\">Hacking the color picker game — MutationObserver</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f27f7224655?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"508\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"508\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>游戏的逻辑很简单，当中间的色块颜色改变时，在时间限制内于底下的选项选择跟它颜色一样的选项就得分。难的点在于越后面的关卡选项越多，而且选项颜色也越相近，例如：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f323c1b016c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"504\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"504\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其实原理非常简单，就是观察色块的<code>backgroundColor</code>（属性变化<code>attributes</code>)，然后触发点击事件<code>e.click()</code>。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var targetNode = document.querySelector(<span class=\"hljs-string\">'#kolor-kolor'</span>);\nvar config = { attributes: <span class=\"hljs-literal\">true</span> };\nvar callback = <span class=\"hljs-keyword\">function</span>(mutationsList, observer) {\n    <span class=\"hljs-keyword\">if</span> (mutationsList[0].type == <span class=\"hljs-string\">'attributes'</span>) {\n        console.log(<span class=\"hljs-string\">'attribute change!'</span>);\n        <span class=\"hljs-built_in\">let</span> ans = document.querySelector(<span class=\"hljs-string\">'#kolor-kolor'</span>).style.backgroundColor;\n        document.querySelectorAll(<span class=\"hljs-string\">'#kolor-options a'</span>).forEach( (e) => {\n            <span class=\"hljs-keyword\">if</span> (e.style.backgroundColor == ans) {\n                e.text = <span class=\"hljs-string\">'Ans!'</span>;\n                e.click()\n            }\n        })\n    }\n};\n\nvar observer = new MutationObserver(callback);\nobserver.observe(targetNode, config);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7f942b6c5432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"769\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"769\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-20\">3. <code>ResizeObserver</code>，视图观察者</h2>\n<p><code>ResizeObserver API</code>是一个新的<code>JavaScript API</code>，与<code>IntersectionObserver API</code>非常相似，它们都允许我们去监听某个元素的变化。</p>\n<h3 class=\"heading\" data-id=\"heading-21\">1. 出现的意义</h3>\n<ul>\n<li>\n<p>开发过程当中经常遇到的一个问题就是如何监听一个 <code>div</code> 的尺寸变化。</p>\n</li>\n<li>\n<p>但众所周知，为了监听 <code>div</code> 的尺寸变化，都将侦听器附加到 <code>window</code> 中的 <code>resize</code> 事件。</p>\n</li>\n<li>\n<p>但这很容易导致性能问题，因为大量的触发事件。</p>\n</li>\n<li>\n<p>换句话说，使用\n<code>window.resize</code> 通常是浪费的，因为它告诉我们每个视窗大小的变化，而不仅仅是当一个元素的大小发生变化。</p>\n</li>\n<li>\n<p><strong>而且<code>resize</code>事件会在一秒内触发将近60次，很容易在改变窗口大小时导致性能问题</strong></p>\n</li>\n</ul>\n<p>比如说，你要调整一个元素的大小，那就需要在 <code>resize</code> 的回调函数 <code>callback()</code> 中调用 <code>getBoundingClientRect</code> 或 <code>getComputerStyle</code>。不过你要是不小心处理所有的读和写操作，就会导致布局混乱。比如下面这个小示例：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df805c03bd6059?imageslim\" data-width=\"960\" data-height=\"540\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"960\" height=\"540\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-22\">2. <code>ResizeObserver</code>的优势</h3>\n<p><code>ResizeObserver API</code> 的核心优势有两点：</p>\n<ul>\n<li>细颗粒度的<code>DOM</code>元素观察，而不是<code>window</code></li>\n<li>没有额外的性能开销，只会在绘制前或布局后触发调用</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-23\">3. <code>ResizeObserver</code>基本使用</h3>\n<p>使用<code>ResizeObserver API</code>同样也是三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-24\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new ResizeObserver(callback);\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-25\">2. 定义回调函数</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const callback = entries => {\n    entries.forEach(entry => {\n        \n    })\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>每一个<code>entry</code>都是一个对象，包含两个属性<code>contentRect</code>和<code>target</code>\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8340db8bb93f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"334\" data-height=\"228\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"334\" height=\"228\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>contentRect</code>都是一些位置信息：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bottom</code></td>\n<td><code>top + height</code>的值</td>\n</tr>\n<tr>\n<td><code>height</code></td>\n<td>元素本身的高度，不包含<code>padding</code>，<code>border</code>值</td>\n</tr>\n<tr>\n<td><code>left</code></td>\n<td><code>padding-left</code>的值</td>\n</tr>\n<tr>\n<td><code>right</code></td>\n<td><code>left + width</code>的值</td>\n</tr>\n<tr>\n<td><code>top</code></td>\n<td><code>padidng-top</code>的值</td>\n</tr>\n<tr>\n<td><code>width</code></td>\n<td>元素本身的宽度，不包含<code>padding</code>，<code>border</code>值</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>大小与<code>top</code>相同</td>\n</tr>\n<tr>\n<td><code>y</code></td>\n<td>大小与<code>left</code>相同</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-26\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.observe(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df84167c1a9737?imageslim\" data-width=\"858\" data-height=\"323\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"858\" height=\"323\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>unobserve</code>方法：取消单节点观察</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.unobserve(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>disconnect</code>方法：取消所有节点观察</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.disconnect(document.body)\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-27\">4. 例子1：缩放渐变背景</h3>\n<p><code>html</code>：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><div class=<span class=\"hljs-string\">\"box\"</span>>\n    <h3 class=<span class=\"hljs-string\">\"info\"</span>></h3>\n</div>\n<div class=<span class=\"hljs-string\">\"box small\"</span>>\n    <h3 class=<span class=\"hljs-string\">\"info\"</span>></h3>\n</div>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>添加点样式：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">body {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    padding: 2vw;\n    box-sizing: border-box;\n}\n.box {\n    text-align: center;\n    height: 20vh;\n    border-radius: 8px;\n    box-shadow: 0 0 4px rgba(0,0,0,.25);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 1vw\n}\n.box h3 {\n    color: <span class=\"hljs-comment\">#fff;</span>\n    margin: 0;\n    font-size: 5vmin;\n    text-shadow: 0 0 10px rgba(0,0,0,0.4);\n}\n.box.small {\n    max-width: 550px;\n    margin: 1rem auto;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>JavaScript</code>代码：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const boxes = document.querySelectorAll(<span class=\"hljs-string\">'.box'</span>);\n<span class=\"hljs-built_in\">let</span> callbackFired = 0;\nconst myObserver = new ResizeObserver(entries => {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> entry of entries) {\n        callbackFired++\n        const infoEl = entry.target.querySelector(<span class=\"hljs-string\">'.info'</span>);\n        const width = Math.floor(entry.contentRect.width);\n        const height = Math.floor(entry.contentRect.height);\n        const angle = Math.floor(width / 360 * 100);\n        const gradient = `linear-gradient(<span class=\"hljs-variable\">${ angle }</span>deg, rgba(0,143,104,1) 50%, rgba(250,224,66,1) 50%)`;\n        entry.target.style.background = gradient;\n        infoEl.innerText = `\n        I<span class=\"hljs-string\">'m ${ width }px and ${ height }px tall\n        Callback fired: ${callbackFired}\n        `;\n    }\n});\nboxes.forEach(box => {\n    myObserver.observe(box);\n});\n</span><span class=\"copy-code-btn\">复制代码</span></code></pre><p>当你拖动浏览器窗口，改变其大小时，看到的效果如下：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df844ce8f85e45?imageslim\" data-width=\"738\" data-height=\"417\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"738\" height=\"417\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-28\">5. 例子2：响应式<code>Vue</code>组件</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df85acd889db3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"474\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"474\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>假设你要创建一个postItem组件，在大屏上是这样的显示效果</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8639cc511681?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"512\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"512\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>在手机上需要这样的效果：\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8640f1cc6ade?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"861\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"861\" height=\"1280\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p>简单的<code>@media</code>就可以实现:</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">@media only screen and (max-width: 576px) {\n  .post__item {\n    flex-direction: column;\n  }\n  \n  .post__image {\n    flex: 0 auto;\n    height: auto;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>但这就很容易出现 当你在超过预期的屏幕（过大）查看页面时，会出现以下的布局：</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df85d633a4da85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"809\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"809\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong><code>@media</code>查询的最大问题是：</strong></p>\n<ul>\n<li>组件响应度取决于屏幕尺寸，而不是响应自身的尺寸。</li>\n</ul>\n<p>以下是指令版实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df87b077e12408?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"762\" data-height=\"624\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"762\" height=\"624\"></svg>\"><figcaption></figcaption></figure>\n使用：<p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df8785890f52e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"762\" data-height=\"437\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"762\" height=\"437\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>效果：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df86e5671e9e59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"814\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"814\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>这是<code>vue-responsive-components</code>库的具体实现代码，还有组件形式的实现，感兴趣的可以去看看。</p>\n<h2 class=\"heading\" data-id=\"heading-29\">4. <code>PerformanceObserver</code>：性能观察者</h2>\n<p><strong>这是一个浏览器和<code>Node.js</code> 里都存在的API，采用相同<code>W3C</code>的<code>Performance Timeline</code>规范</strong></p>\n<ul>\n<li>在浏览器中，我们可以使用 window 对象取得<code>window.performance</code>和 <code>window.PerformanceObserver</code> 。</li>\n<li>而在 <code>Node.js</code> 程序中需要<code>perf_hooks</code> 取得性能对象，如下：<pre><code class=\"hljs bash copyable\" lang=\"bash\">const { PerformanceObserver, performance } = require(<span class=\"hljs-string\">'perf_hooks'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-30\">1. 出现的意义</h3>\n<p>首先来看<code>Performance</code> 接口：</p>\n<ul>\n<li>\n<p>可以获取到当前页面中与性能相关的信息。它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing AP</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code>。</p>\n</li>\n<li>\n<p><code>Performance API</code> 是大家熟悉的一个接口，他记录着几种性能指数的庞大对象集合。</p>\n</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df910b6d854744?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1146\" data-height=\"438\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1146\" height=\"438\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol>\n<li>若想获得某项页面加载性能记录，就需要调用<code>performance.getEntries</code>或者<code>performance.getEntriesByName</code>来获得。</li>\n<li>而获得执行效率，也只能通过<code>performance.now</code>来计算。</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df918d6a33e2b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"912\" data-height=\"555\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"912\" height=\"555\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>为了解决上述的问题，在<code>Performance Timeline Level 2</code>中，除了扩展了<code>Performance</code>的基本定义以外，还增加了<code>PerformanceObserver</code>接口。</p>\n<h3 class=\"heading\" data-id=\"heading-31\">2. <code>PerformanceObserver</code>的优势</h3>\n<p><code>PerformanceObserver</code>是浏览器内部对<code>Performance</code>实现的观察者模式，也是现代浏览器支持的几个 <code>Observer</code> 之一。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5cb19aece51d456e4037727e#heading-3\" rel>来自：《你了解 Performance Timeline Level 2 吗？》</a></p>\n</blockquote>\n<p>它解决了以下3点问题：</p>\n<ul>\n<li>避免不知道性能事件啥时候会发生，需要重复轮训<code>timeline</code>获取记录。</li>\n<li>避免产生重复的逻辑去获取不同的性能数据指标</li>\n<li>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系。</li>\n</ul>\n<p><code>W3C</code>官网文档鼓励开发人员尽可能使用<code>PerformanceObserver</code>，而不是通过<code>Performance</code>获取性能参数及指标。</p>\n<h3 class=\"heading\" data-id=\"heading-32\">3. <code>PerformanceObserver</code>的使用</h3>\n<p>使用<code>PerformanceObserver API</code>主要需要三个步骤：</p>\n<ol>\n<li>创建观察者</li>\n<li>定义回调函数事件</li>\n<li>定义要观察的目标对象</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-33\">1. 创建观察者</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> observer = new PerformanceObserver(callback); \n<span class=\"copy-code-btn\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-34\">2. 定义回调函数事件</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const callback = (list, observer) => {\n   const entries = list.getEntries();\n   entries.forEach((entry) => {\n    console.log(“Name: “ + entry.name + “, Type: “ + entry.entryType + “, Start: “ + entry.startTime + “, Duration: “ + entry.duration + “\\n”); });\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>其中每一个<code>list</code>都是一个完整的<code>PerformanceObserverEntryList</code>对象：\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df9412061956d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1130\" data-height=\"310\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1130\" height=\"310\"></svg>\"><figcaption></figcaption></figure>\n包含三个方法<code>getEntries</code>、<code>getEntriesByType</code>、<code>getEntriesByName</code>：<p></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getEntries()</td>\n<td>返回一个列表，该列表包含一些用于承载各种性能数据的对象，不做任何过滤</td>\n</tr>\n<tr>\n<td>getEntriesByType()</td>\n<td>返回一个列表，该列表包含一些用于承载各种性能数据的对象，按类型过滤</td>\n</tr>\n<tr>\n<td>getEntriesByName()</td>\n<td>返回一个列表，，该列表包含一些用于承载各种性能数据的对象，按名称过滤</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-35\">3. 定义要观察的目标对象</h4>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">observer.observe({entryTypes: [<span class=\"hljs-string\">\"entryTypes\"</span>]});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>observer.observe(...)</code>方法接受可以观察到的有效的入口类型。这些输入类型可能属于各种性能API，比如<code>User tming</code>或<code>Navigation Timing API</code>。有效的<code>entryType</code>值：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>别名</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>frame， navigation</td>\n<td>PerformanceFrameTiming， PerformanceNavigationTiming</td>\n<td>URL</td>\n<td>文件的地址。</td>\n</tr>\n<tr>\n<td>resource</td>\n<td>PerformanceResourceTiming</td>\n<td>URL</td>\n<td>所请求资源的解析URL。</td>\n</tr>\n<tr>\n<td>mark</td>\n<td>PerformanceMark</td>\n<td>DOMString</td>\n<td>通过调用创建标记时使用的名称performance.mark()。</td>\n</tr>\n<tr>\n<td>measure</td>\n<td>PerformanceMeasure</td>\n<td>DOMString</td>\n<td>通过调用创建度量时使用的名称performance.measure()。</td>\n</tr>\n<tr>\n<td>paint</td>\n<td>PerformancePaintTiming</td>\n<td>DOMString</td>\n<td>无论是'first-paint'或'first-contentful-paint'。</td>\n</tr>\n<tr>\n<td>longtask</td>\n<td>PerformanceLongTaskTiming</td>\n<td>DOMString</td>\n<td>报告长任务的实例</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-36\">4. 例子1：静态资源监控</h3>\n<blockquote>\n<p><a target=\"_blank\" href=\"http://www.zhanglongdream.com/2018/12/27/js/JavaScript/%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/\" rel=\"nofollow noopener noreferrer\">来自：《资源监控》</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> filterTime(a, b) {\n  <span class=\"hljs-built_in\">return</span> (a > 0 && b > 0 && (a - b) >= 0) ? (a - b) : undefined;\n}\n\n<span class=\"hljs-built_in\">let</span> resolvePerformanceTiming = (timing) => {\n  <span class=\"hljs-built_in\">let</span> o = {\n    initiatorType: timing.initiatorType,\n    name: timing.name,\n    duration: parseInt(timing.duration),\n    redirect: filterTime(timing.redirectEnd, timing.redirectStart), // 重定向\n    dns: filterTime(timing.domainLookupEnd, timing.domainLookupStart), // DNS解析\n    connect: filterTime(timing.connectEnd, timing.connectStart), // TCP建连\n    network: filterTime(timing.connectEnd, timing.startTime), // 网络总耗时\n\n    send: filterTime(timing.responseStart, timing.requestStart), // 发送开始到接受第一个返回\n    receive: filterTime(timing.responseEnd, timing.responseStart), // 接收总时间\n    request: filterTime(timing.responseEnd, timing.requestStart), // 总时间\n\n    ttfb: filterTime(timing.responseStart, timing.requestStart), // 首字节时间\n  };\n\n  <span class=\"hljs-built_in\">return</span> o;\n};\n\n<span class=\"hljs-built_in\">let</span> resolveEntries = (entries) => entries.map(item => resolvePerformanceTiming(item));\n\n<span class=\"hljs-built_in\">let</span> resources = {\n  init: (cb) => {\n    <span class=\"hljs-built_in\">let</span> performance = window.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance;\n    <span class=\"hljs-keyword\">if</span> (!performance || !performance.getEntries) {\n      <span class=\"hljs-built_in\">return</span> void 0;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (window.PerformanceObserver) {\n      <span class=\"hljs-built_in\">let</span> observer = new window.PerformanceObserver((list) => {\n        try {\n          <span class=\"hljs-built_in\">let</span> entries = list.getEntries();\n          cb(resolveEntries(entries));\n        } catch (e) {\n          console.error(e);\n        }\n      });\n      observer.observe({\n        entryTypes: [<span class=\"hljs-string\">'resource'</span>]\n      })\n    } <span class=\"hljs-keyword\">else</span> {\n        window.addEventListener(<span class=\"hljs-string\">'load'</span>, () => {\n        <span class=\"hljs-built_in\">let</span> entries = performance.getEntriesByType(<span class=\"hljs-string\">'resource'</span>);\n        cb(resolveEntries(entries));\n      });\n    }\n  },\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-37\">参考文章&总结</h2>\n<p>参考文章有点多：</p>\n<blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.zhanglongdream.com/2018/12/27/js/JavaScript/%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/\" rel=\"nofollow noopener noreferrer\">资源监控</a></li>\n<li><a target=\"_blank\" href=\"https://codeburst.io/media-queries-based-on-element-width-with-mutationobserver-cf2eff172787\" rel=\"nofollow noopener noreferrer\">Media Queries Based on Element Width with MutationObserver</a></li>\n<li><a target=\"_blank\" href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics?hl=zh-cn\" rel=\"nofollow noopener noreferrer\">以用户为中心的性能指标</a></li>\n<li><a target=\"_blank\" href=\"https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/\" rel=\"nofollow noopener noreferrer\">A Few Functional Uses for Intersection Observer to Know When an Element is in View</a></li>\n<li><a target=\"_blank\" href=\"https://css-tricks.com/getting-to-know-the-mutationobserver-api/\" rel=\"nofollow noopener noreferrer\">Getting To Know The MutationObserver API</a></li>\n<li><a target=\"_blank\" href=\"https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers\" rel=\"nofollow noopener noreferrer\">Different Types Of Observers Supported By Modern Browsers</a></li>\n<li><a target=\"_blank\" href=\"https://pawelgrzybek.com/the-resize-observer-explained/\" rel=\"nofollow noopener noreferrer\">THE RESIZE OBSERVER EXPLAINED</a></li>\n<li><a target=\"_blank\" href=\"https://alligator.io/js/resize-observer/\" rel=\"nofollow noopener noreferrer\">A Look at the Resize Observer JavaScript API</a>\n这四个观察者，都非常适合集成到监控系统。</li>\n</ul>\n</blockquote>\n<p>且都有对应的<code>Polyfills</code>版实现。</p>\n<p>网上的总结和文档都深浅不一，如果哪里有错误，欢迎指正。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16df9766165811f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"198\" data-height=\"189\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"198\" height=\"189\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-38\">❤️ 看完三件事</h2>\n<p>如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：</p>\n<ol>\n<li>点赞，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）</li>\n<li>关注公众号「前端劝退师」，不定期分享原创知识。</li>\n<li>也看看其它文章</li>\n</ol>\n<ul>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d9eea84e51d4577eb5d8510\" rel>Chrome Devtools 高级调试指南（新）</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d7f80796fb9a06b24434d4e\" rel>90行代码，15个元素实现无限滚动</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d674313e51d4561c94b1000\" rel>「React Hooks」120行代码实现一个交互完整的拖拽上传组件</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5d565015f265da03eb13c575\" rel>「React Hooks」160行代码实现动态炫酷的可视化图表 - 排行榜</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5faffbefaea2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"647\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"647\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p>也可以来我的<code>GitHub</code>博客里拿所有文章的源文件：</p>\n<p><strong>前端劝退指南</strong>：<a target=\"_blank\" href=\"https://github.com/roger-hiro/BlogFN\" rel=\"nofollow noopener noreferrer\">github.com/roger-hiro/…</a></p>\n",
      "id": "j3zela7ct0g",
      "author": "voanit",
      "title": "现代浏览器观察者 Observer API  指南（新）",
      "baseClassName": "article-content"
    },
    {
      "content": "<h1 data-id=\"heading-0\">程序员节起源</h1><p>程序员的工作我们都知道，编程嘛。但为什么程序员节要在1024呢？1024最早火起来是因为一个“不可描述”的论坛，那里的回帖机制是：新用户发过贴之后，过1024秒才能发一贴，如果没到1024秒就又发了一条，则帖子里只会显示1024。</p><p><br></p><p>久而久之，1024成为了在这个论坛中灌水的最常用词，再加上在计算机数学中，1024M=1GB，谐音为“一级棒”，引申为对帖子的肯定。<br></p><p>再后来，1024越来越火，而1024在程序员中被应用的最广泛的，慢慢的1024成了程序员的象征，而10月24日也就成了程序员日。</p><p><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd1ffbae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"372\" data-height=\"262\" src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd1ffbae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"></p><h1 data-id=\"heading-1\">程序员改变世界</h1><p>有人笑称：程序员们每天的工作就是写代码，他们堪称是世界上最苦逼的人群，刚刚毕业的时候还是浓密的黑头发，五年之后就成了秃顶。</p><p>但是，不少技术出身的大佬早已占据创业半边天：李彦宏、马化腾、周鸿祎、雷军……不管对他们怎么看，有一点不可否认——他们确确实实在用技术改变生活。</p><p>程序改变世界，至今已经有几十年了，但真正进入普罗大众的生活，应该是从2007年移动智能手机的应用开始，越来越多的人开始关注程序和程序员。</p><p>有调查显示，程序员是“十大猝死职业”之一。</p><p>昨天程序员圈子迅速扩散一个IT哥们猝死消息，多么的突然与惋惜！<br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fd84170b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"523\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"523\" height=\"800\"></svg>\"></p><p><br></p><p>猝死的原因大多在于过度疲劳或者压力过大，程序员工作强度大，经常加班，心脏会经常出现心律不齐等症状，如果不重视这些症状，任其发展，就有可能出现猝死的状况。</p><p>所以程序员小哥哥小姐姐们，工作压力再大也要注意作息健康，身体是革命的本钱，工作这么多年，感觉颈椎已经落下病根了，直立久了就会酸痛难受，看来以后没事得多多抬头仰望天花板画“粪”字了...</p><h4 data-id=\"heading-2\">程序员的日常作息是规律的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb8008151d02d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"450\" data-height=\"216\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"450\" height=\"216\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb80081633e46?imageslim\" data-width=\"346\" data-height=\"194\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"346\" height=\"194\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800817fb7d2?imageslim\" data-width=\"400\" data-height=\"278\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"400\" height=\"278\"></svg>\"></p><p><br></p><h4 data-id=\"heading-3\">工作状态是淡定自若的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fdded8ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"504\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"504\" height=\"1280\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fe720952?imageslim\" data-width=\"380\" data-height=\"220\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"380\" height=\"220\"></svg>\"></p><p><b><br></b></p><p><br></p><p><br></p><h4 data-id=\"heading-4\">底线是非常明确的</h4><p><br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fed9806f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"535\" data-height=\"603\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"535\" height=\"603\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e2fee66a29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"600\" data-height=\"1250\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"600\" height=\"1250\"></svg>\"></p><h4 data-id=\"heading-5\">处理 Bug是信手拈来的</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e315b1695c?imageslim\" data-width=\"256\" data-height=\"144\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"256\" height=\"144\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e316deee02?imageslim\" data-width=\"350\" data-height=\"204\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"350\" height=\"204\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb8008755ec43?imageslim\" data-width=\"248\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"248\" height=\"200\"></svg>\"></p><p><br></p><h4 data-id=\"heading-6\">电脑坏了是包修不过夜的</h4><p><br></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb80087ac3dfb?imageslim\" data-width=\"240\" data-height=\"180\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"240\" height=\"180\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800a35e0614?imageslim\" data-width=\"320\" data-height=\"176\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"176\"></svg>\"></p><h4 data-id=\"heading-7\">地位是至高无上的</h4><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><h4 data-id=\"heading-8\">会「深度学习」</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e31f5b587d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"1280\"></svg>\"></p><h4 data-id=\"heading-9\">有巨大发展空间</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e320db4566?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"652\" data-height=\"197\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"652\" height=\"197\"></svg>\"></p><h4 data-id=\"heading-10\">因为有大把的时间</h4><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800a6d1a3bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"440\" data-height=\"330\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"440\" height=\"330\"></svg>\"></p><h4 data-id=\"heading-11\">所以业余生活很丰富</h4><p><br></p><p><br></p><p><img class=\"lazyload inited\" data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"></p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb800af4fe72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"690\" data-height=\"736\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"690\" height=\"736\"></svg>\"></p><p>段子讲到这里，也要明白，虽然面对屏幕中的数据世界，程序员也有着属于自己的方式默默地表达着他们的浪漫。<br></p><blockquote><p>世界上最遥远的距离，是我在 if 里，你在 else 里，似乎一直相伴又永远分离；世界上最痴心的等待，是我当 case，你是 switch，或许永远都选不上自己；世界上最真情的相依，是你在 try，我在 catch ，无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的 finally。<br></p></blockquote><p>在浮躁的世界里，程序员们固执地坚持自己对于知识、技术与创新追求，值得我们在这样的日子里向程序员们致敬。感谢你们，是你们真正改变了世界。</p><h2 data-id=\"heading-12\">祝福</h2><p>1024程序员节，愿所有程序员，身体健康，永无Bug！</p><h2 data-id=\"heading-13\"><b style>如果你是程序员，用一句话表述程序员生涯的苦逼。</b></h2><h2 data-id=\"heading-14\"><b style>欢迎留言评论。</b></h2><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e324175141?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1080\" data-height=\"536\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1080\" height=\"536\"></svg>\"></p><p><br></p><h2 data-id=\"heading-15\">结尾彩蛋</h2><p>欢迎关注前端之阶公众号，获取更多前端知识，加入前端大群，与知名互联网大佬做朋友，开启共同学习新篇章！</p><p><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/24/16dfb7e3274e1715?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"430\" height=\"430\"></svg>\"></p><p><br></p>",
      "id": "wmziflvzylc",
      "author": "于是乎_",
      "title": "“1024”竟然火于“羞羞”论坛？程序员节敢不敢一起来吐槽",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>yarn 是在工作中离不开的工具，但在工作中，很多人基本只会使用 <code>yarn install</code>，而且会手动删除 <code>node-modules</code>，或删除 <code>yarn.lock</code> 文件等不规范操作。本文将从一些基础的知识点开始介绍，循序渐进的让你对 <code>Yarn</code> 有一个更深入的了解，来保证规范的使用yarn，避免一些隐藏bug的产生。<br>\n本文主要介绍以下知识：</p>\n<blockquote>\n<ol>\n<li>什么是registry</li>\n<li>依赖的版本含义及写法</li>\n<li>依赖类型及区别（<code>devDependences</code>，<code>devDependences</code>，<code>peerDependences</code>， <code>optionalDependencies</code>，<code>bundledDependencies</code>）</li>\n<li>缓存介绍</li>\n<li><code>yarn.lock</code> 文件作用及介绍</li>\n<li><code>yarn install</code> 安装依赖的过程</li>\n<li>依赖关系树的模块扁平化</li>\n<li>常用的 <code>yarn</code> 命令介绍</li>\n</ol>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">什么是registry</h2>\n<p><code>registry</code>是 模块仓库提供了一个查询服务，也就是我们常说的源。以yarn官方镜像源为例，它的查询服务网址是<code>https://registry.yarnpkg.com</code>。</p>\n<p>这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 <code>https://registry.npmjs.org/vue</code>，就会看到 vue 模块所有版本的信息。</p>\n<p>registry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。\n<code>https://registry.yarnpkg.com/vue/2.6.10</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/25/16e02889c4f2a501?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"564\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"564\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>上面返回的 JSON 对象里面，有一个dist.tarball属性，是该版本压缩包的网址。dist.shasum 属性相当于hash值，在lock和缓存时会使用到，下文会提到。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">dist: {\n  <span class=\"hljs-string\">\"shasum\"</span>: <span class=\"hljs-string\">\"a72b1a42a4d82a721ea438d1b6bf55e66195c637\"</span>,\n  <span class=\"hljs-string\">\"tarball\"</span>:<span class=\"hljs-string\">\"https://registry.npmjs.org/vue/-/vue-2.6.10.tgz\"</span>\n},\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>我们在执行 <code>yarn install</code> 时，就是向 <code>registry</code> 查询得到上面的压缩包地址进行下载的。<br>\n工作中，我们可能有需要修改镜像源的场景，比如修改成淘宝源或者自己公司的私有源。<br>\n查看和设置源，可以通过 yarn config 命令来完成<br>\n查看当前使用的镜像源</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config get registry\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>修改镜像源（以修改成淘宝源为例）</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org/\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-1\">依赖版本</h2>\n<p>yarn的包遵守 <code>semver</code>，即语义化版本。\nSemVer 是一套语义化版本控制的约定，定义的格式为</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">X.Y.Z（主版本号.次版本号.修订号）：\nX.主版本号：进行不向下兼容的修改时，递增主版本号\nY.次版本号: 做了向下兼容的新增功能或修改\nZ.修订号：做了向下兼容的问题修复\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p><code>yarn</code> 中依赖版本范围的表示方法有以下几种：</p>\n<ol>\n<li>通过比较器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><2.0.0</td>\n<td style=\"text-align:center\">任何小于 2.0.0 的版本</td>\n</tr>\n<tr>\n<td><=3.1.4</td>\n<td style=\"text-align:center\">任何小于或等于 3.1.4 的版本</td>\n</tr>\n<tr>\n<td>>0.4.2</td>\n<td style=\"text-align:center\">任何大于 0.4.2 的版本</td>\n</tr>\n<tr>\n<td>>=2.7.1</td>\n<td style=\"text-align:center\">任何大于或等于 2.7.1 的版本</td>\n</tr>\n<tr>\n<td>=4.6.6</td>\n<td style=\"text-align:center\">任何等于 4.6.6 的版本</td>\n</tr>\n<tr>\n<td>>=2.0.0 <3.1.4</td>\n<td style=\"text-align:center\">交集，大于或等于 2.0.0 并小于 3.1.4</td>\n</tr>\n<tr>\n<td><2.0.0 || >3.1.4</td>\n<td style=\"text-align:center\">并集 小于 2.0.0 或者大于 3.1.4</td>\n</tr>\n</tbody>\n</table>\n<p>如果没有指定运算符，默认为 =</p>\n<ol start=\"2\">\n<li>通过连字符</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2.0.0 - 3.1.4</td>\n<td style=\"text-align:center\">>=2.0.0 <=3.1.4</td>\n</tr>\n<tr>\n<td>0.4 - 2</td>\n<td style=\"text-align:center\">>=0.4.0 <=2.0.0</td>\n</tr>\n</tbody>\n</table>\n<p>版本号中缺少的那些部分会用数字 0 填充。</p>\n<ol start=\"3\">\n<li>X范围<br>\n字符 X、x 或者 * 都可以作为通配符，用于填充部分或全部版本号。\n被省略的那部分版本号默认为 x 范围。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:center\">>=0.0.0 (任意版本)</td>\n</tr>\n<tr>\n<td>2.x</td>\n<td style=\"text-align:center\">>=2.0.0 <3.0.0（匹配主要版本）</td>\n</tr>\n<tr>\n<td>3.1.x</td>\n<td style=\"text-align:center\">> = 3.1.0 < 3.2.0（匹配主要和次要版本）</td>\n</tr>\n<tr>\n<td>``（空字符串）</td>\n<td style=\"text-align:center\">* 或 > = 0.0.0</td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">2.x.x 或 > = 2.0.0 < 3.0.0</td>\n</tr>\n<tr>\n<td>3.1</td>\n<td style=\"text-align:center\">3.1.x 或 > = 3.1.0 < 3.2.0</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>～ 字符范围<br>\n同时使用字符 ~ 和次版本号，表明允许 <code>修订号</code> 变更。同时使用字符 ~ 和主版本号，表明允许 <code>次版本</code> 号变更。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~3.1.4</td>\n<td style=\"text-align:center\">>=3.1.4 <3.2.0</td>\n</tr>\n<tr>\n<td>~3.1</td>\n<td style=\"text-align:center\">3.1.x 或 > = 3.1.0 < 3.2.0</td>\n</tr>\n<tr>\n<td>~3</td>\n<td style=\"text-align:center\">3.x 或 > = 3.0.0 < 4.0.0</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>^ 字符范围<br>\n字符 ^ 表明不会修改版本号中的第一个非零数字，3.1.4 里的 3 或者 0.4.2 里的 4。版本号中缺少的部分将被 0 填充，且在匹配时这些位置允许改变。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th style=\"text-align:center\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^3.1.4</td>\n<td style=\"text-align:center\">>=3.1.4 <4.0.0</td>\n</tr>\n<tr>\n<td>^0.4.2</td>\n<td style=\"text-align:center\">>=0.4.2 <0.5.0</td>\n</tr>\n<tr>\n<td>^0.0.2</td>\n<td style=\"text-align:center\">>=0.0.2 <0.0.3</td>\n</tr>\n</tbody>\n</table>\n<p>使用 <code>yarn add [package-name]</code> 命令安装依赖，默认使用的是 ^ 范围。<br>\n需要注意的是，如果一个比较器包含有预发布标签的版本，它将只匹配有相同 major.minor.patch 的版本。\n例如 <code>>=3.1.4-beta.2</code>，可以匹配 <code>3.1.4-beta.3</code>，但不会匹配 <code>3.1.5-beta.3</code> 版本。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">依赖类型</h2>\n<p><code>dependences</code> 代码运行时所需要的依赖，比如vue，vue-router。</p>\n<p><code>devDependences</code> 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖，比如babel，webpack。</p>\n<p><code>peerDependences</code> 同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围。<br>\n如果宿主环境没有对应版本的依赖，在安装依赖时会报出警告。<br>\n比如包 <code>eslint-plugin-import</code> 中有依赖：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> <span class=\"hljs-string\">\"peerDependencies\"</span>: {\n    <span class=\"hljs-string\">\"eslint\"</span>: <span class=\"hljs-string\">\"2.x - 5.x\"</span>\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>在install时，如果宿主环境没有 <code>2.x-5.x</code> 版本的 <code>eslint</code>,cli就会抛出警告。但不会自动帮我们安装，仍然需要手动安装。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/18/16ddf773d9a8aeef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"91\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"91\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>optionalDependencies</code> 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。<br>\n可选依赖适用于那些即便没有成功安装可选依赖，也有后备方案的情况。</p>\n<p><code>bundledDependencies</code> 打包依赖，在发布包时，这个数组里的包都会被打包打包到最终的发布包里，需要注意 <code>bundledDependencies</code> 中的包必须是在devDependencies或dependencies声明过的。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">缓存</h2>\n<p><code>yarn</code> 会将安装过的包缓存下来，这样再次安装相同包的时候，就不需要再去下载，而是直接从缓存文件中直接copy进来。</p>\n<p>可以通过命令 <code>yarn cache dir</code> 查看yarn的全局缓存目录。我的缓存目录在 <code>/Library/Caches/Yarn/v1</code> 下。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/19/16de476f6032c3c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1208\" data-height=\"1180\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1208\" height=\"1180\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>可以看出，<code>yarn</code> 会将不通版本解压后的包存放在不同目录下，目录以</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm-[package name]-[version]-[shasum]` \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>来命名。shasum 即上文中 <code>registry</code> 获取的 <code>dist.shasum</code>。</p>\n<p>我们可以通过命令查看已经缓存过的包。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn cache list    列出已缓存的每个包\n\nyarn cache list --pattern <pattern>  列出匹配指定模式的已缓存的包\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>例如执行 <code>yarn cache list --pattern vue</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/19/16de484ef6a6360d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"404\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"404\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">yarn.lock</h2>\n<p><code>yarn.lock</code> 中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的结果。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/27/16e0dc3640b2a68b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"502\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"502\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>下面以@babel/code-frame为例，看看yarn.lock 中会记录哪些信息。</p>\n<ol>\n<li>第一行 <code>\"@babel/code-frame@7.0.0-beta.54\"</code>\n包的name和语义化版本号，这些都来自package.json中的定义。</li>\n<li><code>version</code> 字段，记录的是一个确切的版本。</li>\n<li><code>resolved</code> 字段记录的是包的URL地址。其中hash值，即上文的 <code>dist.shasum</code>。</li>\n<li><code>dependencies</code> 字段记录的是当前包的依赖，即当前包在 <code>package.json</code> 的 <code>dependencies</code> 字段中的所有依赖。</li>\n</ol>\n<p><code>Yarn</code> 在安装期间，只会使用当前项目的 <code>yarn.lock</code> 文件（即 顶级 <code>yarn.lock</code> 文件），会忽略任何依赖里面的 <code>yarn.lock</code> 文件。在顶级 <code>yarn.lock</code> 中包含需要锁定的整个依赖树里全部包版本的所有信息。</p>\n<p><code>yarn.lock</code>文件是在安装期间，由 <code>Yarn</code> 自动生成的，并且由yarn来管理，不应该手动去更改，更不应该删除yarn.lock文件，且要提交到版本控制系统中，以免因为不同机器安装的包版本不一致引发问题。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">Yarn install过程</h2>\n<p>首次执行 <code>yarn install</code> 安装，会按照 <code>package.json</code> 中的语义化版本，去向 <code>registry</code> 进行查询，并获取到符合版本规则的最新的依赖包进行下载，并构建构建依赖关系树。 比如在 <code>package.json</code> 中指定 vue 的版本为 <code>^2.0.0</code>，就会获取符合 <code>2.x.x</code>\n的最高版本的包。然后自动生成 <code>yarn.lock</code> 文件，并生成缓存。</p>\n<p>之后再执行 <code>yarn install</code>，会对比 <code>package.json</code> 中依赖版本范围和 <code>yarn.lock</code> 中版本号是否匹配。</p>\n<ol>\n<li>版本号匹配，会根据 <code>yarn.lock</code> 中的 <code>resolved</code> 字段去查看缓存， 如果有缓存，直接copy，没有缓存则按照 <code>resolved</code> 字段的url去下载包。</li>\n<li>版本号不匹配，根据 <code>package.json</code> 中的版本范围去 <code>registry</code> 查询，下载符合版本规则最新的包，并更新至 <code>yarn.lock</code> 中。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-6\">模块扁平化</h2>\n<p>上面提到，在安装依赖时，会解析依赖构建出依赖关系树。\n比如我项目的首层依赖(即当前项目的dependence和devDependences中的依赖，不包括依赖的依赖)中有A，B，C三个包，A 和 B包同时依赖了相同版本范围的D包。那么这部分的依赖关系树是这样的：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n│ └── D    \n├── B    \t\t\t\t\n│ └── D  \n├── C \n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果按照这样的依赖关系树直接安装的话，D模块会在A包和B包的 <code>node_modules</code>中都安装，这样会导致模块冗余。</p>\n<p>为了保证依赖关系树中没有大量重复模块，yarn在安装时会做dedupe（去重）操作，它会遍历所有节点，逐个将模块放在根节点下面，也就是当前项目的 <code>node-modules</code> 中。当发现有相同的模块时，会判断当前模块指定的 <code>semver</code> 版本范围是否交集，如果有，则只保留兼容版本，如果没有则在当前的包的 <code>node-modules</code> 下安装。<br>\n所以上面的说的情况，最终安装完成是下面这样的，A，B，C，D包都会安装在第一层 <code>node-modules</code> 下。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n├── B    \t\t\t\t\n├── C \n├── D\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>如果A包和B包依赖的是不兼容的版本，假设A包依赖的是D@1版本的包，B包依赖的是D@2版本。则最终安装的结果如下：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">├── A    \t\t\t\t\n├── B    \n│ └── D@2 \n├── C \n├── D@1\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>当代码中 <code>require</code> 或 <code>import</code> 某个模块时，会从当前 <code>package</code> 的 <code>node-modules</code> 里中开始找，找不到就到当前package的上一层 <code>node-modules</code> 里找，这样一直找到全局的node_modules。\n所以上面的安装的树结构，可以保证每个 <code>package</code> 都能获取到所需要版本的包。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">常用的yarn命令</h2>\n<ol>\n<li>yarn install 安装依赖</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn install / yarn  在本地 node_modules 目录安装 package.json 里列出的所有依赖\nyarn install --force 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）\nyarn install --modules-folder <path> 为 node_modules 目录指定另一位置，代替默认的 ./node_modules\nyarn install --no-lockfile 不读取或生成 yarn.lock 文件\nyarn install --production[=<span class=\"hljs-literal\">true</span>|<span class=\"hljs-literal\">false</span>] / --production / --prod 只安装 dependence下的包，不安装 devDependencies 的包\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>yarn add</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn add package-name 会安装 latest 最新版本。\nyarn add <package...>  安装包到dependencies中\nyarn add <package...> [--dev/-D]  用 --dev 或 -D 安装包到 devDependencies\nyarn add <package...> [--peer/-P]  用 --peer 或者 -P 安装包到 peerDependencies\nyarn add <package...> [--optional/-O] 用 --optional 或者 -O 安装包到 optionalDependencies \nyarn add <package...> [--exact/-E] 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版。\nyarn add <package...> [--tilde/-T]  用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0。\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>yarn config 管理配置文件</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn config get <key> 查看配置key的值\nyarn config list 查看当前的配置\nyarn config delete <key> 从配置中删除配置key\nyarn config <span class=\"hljs-built_in\">set</span> <key> <value> [-g|--global] 设置配置项 key 的值为 value\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li>其他常用命令</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn list 查询当前工作文件夹所有的依赖\nyarn info <package> [<field>]  查看包信息，可以查看特定\nyarn remove <package...>  从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件。\nyarn <script> [<args>] 执行用户自定义的脚本\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li>详细日志模式\n运行yarn命令时，增加参数 <code>--verbose</code>，这对排查错误时很有帮助</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">yarn <<span class=\"hljs-built_in\">command</span>> --verbose\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>可以打印出执行的详细信息(创建目录、复制文件或 HTTP 请求等)</p>\n<blockquote>\n<p>欢迎关注我的公众号「前端小苑」，我会定期在上面更新原创文章。</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/23/16d5d5f0591a7d2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"580\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"580\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "6cwrhcl51yc0",
      "author": "ikoala",
      "title": "前端工程师应该知道的yarn知识",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [
    {
      "content": "<div>\n\n\n        \n\n        \n\n        <h2 data-id=\"heading-0\">关于</h2>\n\n        <p>\n            本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-1\">状态</h3>\n\n        <p>\n            你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。\n        </p>\n\n        <p>\n            本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-2\">读者对象</h3>\n\n        <p>\n            本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。\n        </p>\n\n        <p>\n            这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。\n        </p>\n\n        <p>\n            然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-3\">本书结构</h3>\n\n        <p>\n            读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。\n        </p>\n\n        <p>\n            当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。\n        </p>\n\n        <p>\n            本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。\n        </p>\n\n        <p>\n            紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。\n        </p>\n\n        <p>\n            最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。\n        </p>\n\n        <p>\n            可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。\n        </p>\n\n        <p>\n            该应用所有的源代码都可以通过\n            <a href=\"https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">本书Github代码仓库</a>.\n        </p>\n\n        <div>目录</div>\n        <div>\n            <ul>\n\n                <li><a href=\"#about\">关于</a>\n                    <ul>\n                        <li><a href=\"#status\">状态</a></li>\n                        <li><a href=\"#intended-audience\">读者对象</a></li>\n                        <li><a href=\"#structure\">本书结构</a></li>\n                    </ul>\n                </li>\n\n                <li><a href=\"#javascript-and-nodejs\">JavaScript与Node.js</a>\n                    <ul>\n                        <li><a href=\"#javascript-and-you\">JavaScript与你</a></li>\n                        <li><a href=\"#a-word-of-warning\">简短申明</a></li>\n                        <li><a href=\"#server-side-javascript\">服务器端JavaScript</a></li>\n                        <li><a href=\"#hello-world\">“Hello World”</a></li>\n\n                    </ul>\n                </li>\n                <li><a href=\"#a-full-blown-web-application-with-nodejs\">一个完整的基于Node.js的web应用</a>\n                    <ul>\n                        <li><a href=\"#the-use-cases\">用例</a></li>\n                        <li><a href=\"#the-application-stack\">应用不同模块分析</a></li>\n                    </ul>\n\n                </li>\n                <li><a href=\"#building-the-application-stack\">构建应用的模块</a>\n                    <ul>\n                        <li><a href=\"#a-basic-http-server\">一个基础的HTTP服务器</a></li>\n                        <li><a href=\"#analyzing-our-http-server\">分析HTTP服务器</a></li>\n                        <li><a href=\"#passing-functions-around\">进行函数传递</a></li>\n                        <li><a href=\"#how-function-passing-makes-our-http-server-work\">函数传递是如何让HTTP服务器工作的</a></li>\n\n                        <li><a href=\"#event-driven-callbacks\">基于事件驱动的回调</a></li>\n                        <li><a href=\"#how-our-server-handles-requests\">服务器是如何处理请求的</a></li>\n                        <li><a href=\"#finding-a-place-for-our-server-module\">服务端的模块放在哪里</a>\n                        </li>\n                        <li><a href=\"#whats-needed-to-route-requests\">如何来进行请求的“路由”</a></li>\n                        <li><a href=\"#execution-in-the-kongdom-of-verbs\">行为驱动执行</a></li>\n                        <li><a href=\"#routing-to-real-request-handlers\">路由给真正的请求处理程序</a></li>\n\n                        <li><a href=\"#making-the-request-handlers-respond\">让请求处理程序作出响应</a>\n                            <ul>\n                                <li><a href=\"#how-to-not-do-it\">不好的实现方式</a></li>\n                                <li><a href=\"#blocking-and-non-blocking\">阻塞与非阻塞</a></li>\n                                <li><a href=\"#responding-request-handlers-with-non-blocking-operations\">以非阻塞操作进行请求响应</a>\n                                </li>\n                            </ul>\n\n                        </li>\n                        <li><a href=\"#serving-something-useful\">更有用的场景</a>\n                            <ul>\n                                <li><a href=\"#handling-post-requests\">处理POST请求</a></li>\n                                <li><a href=\"#handling-file-uploads\">处理文件上传</a></li>\n                            </ul>\n                        </li>\n\n                        <li><a href=\"#conclusion-and-outlook\">总结与展望</a></li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n\n        <a></a>\n\n        <h2 data-id=\"heading-4\">JavaScript与Node.js</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-5\">JavaScript与你</h3>\n\n        <p>\n            抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。\n        </p>\n\n        <p>\n            如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。\n        </p>\n\n        <p>\n            而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。\n        </p>\n\n        <p>\n            与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是<em>window.open() </em>那么简单。 .\n        </p>\n\n        <p>\n            不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript<em>用户</em>，而非JavaScript<em>开发者</em>。\n        </p>\n\n        <p>\n            然后，出现了Node.js，服务端的JavaScript，这有多酷啊？\n        </p>\n\n        <p>\n            于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。\n        </p>\n\n        <p>\n            问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。\n        </p>\n\n        <p>\n            因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。\n        </p>\n\n        <p>\n            当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。\n        </p>\n\n        <p>\n            本书的目标就是给你提供指导。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-6\">简短申明</h3>\n\n        <p>\n            业界有非常优秀的JavaScript程序员。而我并非其中一员。\n        </p>\n\n        <p>\n            我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。\n        </p>\n\n        <p>\n            因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。\n        </p>\n\n        <p>\n            如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-7\">服务端JavaScript</h3>\n\n        <p>\n            JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\n        </p>\n\n        <p>\n            Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。\n        </p>\n\n        <p>\n            要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。\n        </p>\n\n        <p>\n            除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。\n        </p>\n\n        <p>\n            因此，Node.js事实上既是一个运行时环境，同时又是一个库。\n        </p>\n\n        <p>\n            要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考<a href=\"https://github.com/joyent/node/wiki/Installation\" title=\"Building and Installing Node.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方的安装指南</a>。安装完成后，继续回来阅读本书下面的内容。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-8\">“Hello World”</h3>\n\n        <p>\n            好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。\n        </p>\n\n        <p>\n            打开你最喜欢的编辑器，创建一个<em>helloworld.js</em>文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：\n        </p>\n        <pre>console.log(\"Hello World\");</pre>\n        \n        <p>\n            保存该文件，并通过Node.js来执行：\n        </p>\n\n        <pre>node helloworld.js</pre>\n        <p>\n            正常的话，就会在终端输出<em>Hello World</em> 。\n        </p>\n\n        <p>\n            好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。\n        </p>\n\n\n        <a></a>\n\n        <h2 data-id=\"heading-9\">一个完整的基于Node.js的web应用</h2>\n \n        <a></a> \n \n        <h3 data-id=\"heading-10\">用例</h3> \n \n        <p>我们来把目标设定得简单点，不过也要够实际才行：</p>\n\n        <ul>\n        <li>用户可以通过浏览器使用我们的应用。</li>\n        <li>当用户请求<em>http://domain/start</em>时，可以看到一个欢迎页面，页面上有一个文件上传的表单。</li>\n        <li>用户可以选择一个图片并提交表单，随后文件将被上传到<em>http://domain/upload</em>，该页面完成上传后会把图片显示在页面上。</li>\n        </ul>\n\n        <p>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>\n\n        <p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>\n\n        <h3 data-id=\"heading-11\">应用不同模块分析</h3>\n\n        <p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>\n\n        <ul>\n        <li>我们需要提供Web页面，因此需要一个<em>HTTP服务器</em></li>\n        <li>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个<em>路由</em>，用于把请求对应到请求处理程序（request handler）</li>\n        <li>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的<em>请求处理程序</em></li>\n        <li>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要<em>请求数据处理功能</em></li>\n        <li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>\n        <li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>\n        </ul>\n\n        <p>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>\n\n        <p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n\n        <p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>\n\n        <p>现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。</p>\n\n        <a></a>\n\n        <h2 data-id=\"heading-12\">构建应用的模块</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-13\">一个基础的HTTP服务器</h3>\n\n        <p>\n            当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。\n            <br>\n            我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？\n        </p>\n\n        <p>\n\n            实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。\n        </p>\n\n        <p>\n            这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。  \n        </p>\n\n        <p>\n            那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。\n        </p>\n\n        <p>\n\n            在我的印象里，把主文件叫做<em>index.js</em>或多或少是个标准格式。把服务器模块放进叫<em>server.js</em>的文件里则很好理解。\n        </p>\n\n        <p>\n            让我们先从服务器模块开始。在你的项目的根目录下创建一个叫<em>server.js</em>的文件，并写入以下代码：\n        </p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>\n            搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：\n        </p>\n        <pre>node server.js</pre>\n        <p>\n            接下来，打开浏览器访问<a href=\"http://localhost:8888/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a>，你会看到一个写着“Hello World”的网页。 \n        </p>\n\n        <p>\n            这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-14\">分析HTTP服务器</h3>\n\n        <p>\n            那么接下来，让我们分析一下这个HTTP服务器的构成。\n        </p>\n\n        <p>\n            第一行<em>请求（require）</em>Node.js自带的 <em>http</em> 模块，并且把它赋值给 <em>http</em> 变量。\n        </p>\n\n\n        <p>\n            接下来我们调用http模块提供的函数： <em>createServer</em> 。这个函数会返回一个对象，这个对象有一个叫做 <em>listen</em> 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。\n        </p>\n\n        <p>\n            咱们暂时先不管 <em>http.createServer</em> 的括号里的那个函数定义。\n        </p>\n\n        <p>\n            我们本来可以用这样的代码来启动服务器并侦听8888端口：\n        </p>\n        <pre>var http = require(\"http\");var server = http.createServer();server.listen(8888);</pre>\n\n        <p>\n            这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。\n        </p>\n\n        <p>\n            最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 <em>createSever()</em> 的第一个参数，一个函数定义。\n        </p>\n\n        <p>\n            实际上，这个函数定义是 <em>createServer()</em> 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-15\">进行函数传递</h3>\n\n        <p>\n            举例来说，你可以这样做：\n        </p>\n        <pre>function say(word) {  console.log(word);}function execute(someFunction, value) {  someFunction(value);}execute(say, \"Hello\");</pre>\n\n        <p>\n            请仔细阅读这段代码！在这里，我们把 <em>say</em> 函数作为<em>execute</em>函数的第一个变量进行了传递。这里传递的不是 <em>say</em> 的返回值，而是 <em>say</em> 本身！\n        </p>\n\n        <p>\n            这样一来， <em>say</em> 就变成了<em>execute</em> 中的本地变量 <em>someFunction</em> ，execute可以通过调用 <em>someFunction()</em> （带括号的形式）来使用 <em>say</em> 函数。\n        </p>\n\n        <p>\n            当然，因为 <em>say</em> 有一个变量， <em>execute</em> 在调用 <em>someFunction</em> 时可以传递这样一个变量。\n        </p>\n\n        <p>\n            我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n        </p>\n        <pre>function execute(someFunction, value) {  someFunction(value);}execute(function(word){ console.log(word) }, \"Hello\");</pre>\n\n        <p>\n            我们在 <em>execute</em> 接受第一个参数的地方直接定义了我们准备传递给 <em>execute</em> 的函数。\n        </p>\n\n        <p>\n            用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 <em>匿名函数</em> 。\n        </p>\n\n        <p>\n            这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-16\">函数传递是如何让HTTP服务器工作的</h3>\n\n        <p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>现在它看上去应该清晰了很多：我们向 <em>createServer</em> 函数传递了一个匿名函数。  </p>\n\n        <p>用这样的代码也可以达到同样的目的：  </p>\n        <pre>var http = require(\"http\");function onRequest(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);</pre>\n\n        <p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-17\">基于事件驱动的回调</h3>\n\n        <p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。  </p>\n\n        <p>你也许会想花点时间读一下Felix Geisendörfer的大作<a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding node.js</a>，它介绍了一些背景知识。  </p>\n\n        <p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。  </p>\n\n        <p>当我们使用 <em>http.createServer</em> 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。  </p>\n\n        <p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。  </p>\n\n        <p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。  </p>\n\n        <p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？  </p>\n\n        <p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。  </p>\n\n        <p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。  </p>\n\n        <p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。  </p>\n\n        <p>这个就是传说中的 <em>回调</em> 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 <em>回调</em> 。  </p>\n\n        <p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。  </p>\n\n        <p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：  </p>\n\n        <pre>var http = require(\"http\");function onRequest(request, response) {  console.log(\"Request received.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);console.log(\"Server has started.\");</pre>\n\n        <p>注意：在 <em>onRequest</em> （我们的回调函数）触发的地方，我用 <em>console.log</em> 输出了一段文本。在HTTP服务器开始工作<em>之后</em>，也输出一段文本。  </p>\n\n        <p>\n            当我们与往常一样，运行它<em>node server.js</em>时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href=\"http://localhost:8888/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a> ），“Request received.”这条消息就会在命令行中出现。\n        </p>\n\n        <p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>\n\n        <p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /时尝试读取 http://localhost:8888/favicon.ico )</p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-18\">服务器是如何处理请求的</h3>\n\n        <p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 <em>onRequest()</em> 的主体部分。  </p>\n\n        <p>当回调启动，我们的 <em>onRequest()</em> 函数被触发的时候，有两个参数被传入： <em>request</em> 和 <em>response</em> 。  </p>\n\n        <p>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。  </p>\n\n        <p>所以我们的代码就是：当收到请求时，使用 <em>response.writeHead()</em> 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 <em>response.write()</em> 函数在HTTP相应主体中发送文本“Hello World\"。  </p>\n\n        <p>最后，我们调用 <em>response.end()</em> 完成响应。  </p>\n\n        <p>目前来说，我们对请求的细节并不在意，所以我们没有使用 <em>request</em> 对象。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-19\">服务端的模块放在哪里</h3>\n\n        <p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 <em>server.js</em> 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 <em>index.js</em> 的文件去调用应用的其他模块（比如 <em>server.js</em> 中的HTTP服务器模块）来引导和启动应用。  </p>\n\n        <p>我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 <em>index.js</em> 主文件使用。</p>\n\n        <p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：  </p>\n        <pre>var http = require(\"http\");...http.createServer(...);</pre>\n\n        <p>Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。  </p>\n\n        <p>这把我们的本地变量变成了一个拥有所有 <em>http</em> 模块所提供的公共方法的对象。</p>\n\n        <p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：  </p>\n        <pre>var foo = require(\"http\");...foo.createServer(...);</pre>\n\n        <p>很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？  </p>\n\n        <p>等我们把 <em>server.js</em> 变成一个真正的模块，你就能搞明白了。  </p>\n\n        <p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 <em>导出</em> 到请求这个模块的脚本。  </p>\n\n        <p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。  </p>\n\n        <p>我们把我们的服务器脚本放到一个叫做 <em>start</em> 的函数里，然后我们会导出这个函数。  </p>\n        <pre>var http = require(\"http\");function start() {  function onRequest(request, response) {    console.log(\"Request received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>这样，我们现在就可以创建我们的主文件 <em>index.js</em> 并在其中启动我们的HTTP了，虽然服务器的代码还在 <em>server.js</em> 中。  </p>\n\n        <p>创建 <em>index.js</em> 文件并写入以下内容：  </p>\n        <pre>var server = require(\"./server\");server.start();</pre>\n\n        <p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>\n\n        <p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>\n        <pre>node index.js</pre>\n\n        <p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。  </p>\n\n        <p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。  </p>\n\n        <p>对于一个非常简单的应用来说，你可以直接在回调函数 <em>onRequest()</em> 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。  </p>\n\n        <p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 <em>路由</em> 的模块吧。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-20\">如何来进行请求的“路由”</h3> \n\n         <p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>\n\n        <p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n\n        <p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>\n<pre>                               url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n</pre>\n\n        <p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>\n\n        <p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start() {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>\n\n        <p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n\n        <p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>\n        <pre>function route(pathname) {  console.log(\"About to route a request for \" + pathname);}exports.route = route;</pre>\n\n        <p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n\n        <p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href=\"http://martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>\n\n        <p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(pathname);    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");server.start(router.route);</pre>\n\n        <p>在这里，我们传递的函数依旧什么也没做。</p>\n\n        <p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n\n        <pre>bash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo</pre>\n\n        <p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>\n \n        <a></a> \n \n        <h3 data-id=\"heading-21\">行为驱动执行</h3> \n\n        <p>请允许我再次脱离主题，在这里谈一谈函数式编程。</p>\n\n        <p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将<em>router</em>对象传递进去，服务器随后可以调用这个对象的<em>route</em>函数。</p>\n\n        <p>就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？</p>\n\n        <p>但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要<em>名词</em>，你需要<em>动词</em>。</p>\n\n        <p>理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</p>\n\n        <p>我是在读了Steve Yegge的大作<a href=\"http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">名词王国中的死刑</a>之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。</p>\n\n        <a></a> \n \n        <h3 data-id=\"heading-22\">路由给真正的请求处理程序</h3> \n\n         <p>回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。</p>\n\n        <p>当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理<em>/start</em>的“业务逻辑”就应该和处理<em>/upload</em>的不同。</p>\n\n        <p>在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。</p>\n\n        <p>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>\n\n        <p>应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>\n\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");}function upload() {  console.log(\"Request handler 'upload' was called.\");}exports.start = start;exports.upload = upload;</pre>\n\n        <p>这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</p>\n\n        <p>在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</p>\n\n        <p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>\n\n        <p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<em>if request == x then call handler y</em>也使得系统丑陋不堪。</p>\n\n        <p>仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array）能完美胜任。</p>\n\n        <p>不过结果有点令人失望，JavaScript没提供关联数组 -- 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。</p>\n\n        <p>在这方面，<a href=\"http://msdn.microsoft.com/en-us/magazine/cc163419.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">msdn.microsoft.com/en-us/magaz…</a>有一个不错的介绍，我在此摘录一段：</p>\n\n         <blockquote>\n            <p>在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>\n        </blockquote>\n\n        <p>但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！</p>\n\n        <p>好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到<em>route()</em>函数中。</p>\n\n        <p>我们先将这个对象引入到主文件<em>index.js</em>中：</p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = {}handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;server.start(router.route, handle);</pre>\n\n        <p>虽然<em>handle</em>并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。</p>\n\n        <p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为<em>\"/\"</em>的属性，对应<em>requestHandlers.start</em>即可，这样我们就可以干净简洁地配置<em>/start</em>和<em>/</em>的请求都交由<em>start</em>这一处理程序处理。</p>\n\n        <p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将<em>server.js</em>修改如下：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname);    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>这样我们就在<em>start()</em>函数里添加了<em>handle</em>参数，并且把handle对象作为第一个参数传递给了<em>route()</em>回调函数。</p>\n\n        <p>然后我们相应地在<em>route.js</em>文件中修改<em>route()</em>函数：</p>\n        <pre>function route(handle, pathname) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname]();  } else {    console.log(\"No request handler found for \" + pathname);  }}exports.route = route;</pre>\n\n       <p>通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如<em>handle[pathname]();</em>的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</p>\n\n        <p>有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问<em>http://localhost:8888/start</em>，以下日志可以说明系统调用了正确的请求处理程序：</p>\n\n        <pre>Server has started.\nRequest for /start received.\nAbout to route a request for /start\nRequest handler 'start' was called.</pre>\n\n         <p>并且在浏览器中打开<em>http://localhost:8888/</em>可以看到这个请求同样被<em>start</em>请求处理程序处理了：</p>\n        <pre>Request for / received.\nAbout to route a request for /\nRequest handler 'start' was called.</pre>\n\n        <a></a>\n\n        <h3 data-id=\"heading-23\">让请求处理程序作出响应</h3>\n\n        <p>\n            很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。\n        </p>\n\n        <p>\n            这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们<em>server.js</em>文件中的<em>onRequest</em>函数。\n        </p>\n\n        <p>\n            其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像<em>onRequest</em>函数那样可以和浏览器进行“对话”。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-24\">不好的实现方式</h4>\n\n        <p>\n            对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。\n        </p>\n\n        <p>\n            这里我指的“直截了当的实现方式”意思是：让请求处理程序通过<em>onRequest</em>函数直接返回（<em>return()</em>）他们要展示给用户的信息。\n        </p>\n\n        <p>\n            我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。\n        </p>\n\n        <p>\n            让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将<em>requestHandler.js</em>修改为如下形式：\n        </p>\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");  return \"Hello Start\";}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将<em>router.js</em>修改为如下形式：\n        </p>\n        <pre>function route(handle, pathname) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    return handle[pathname]();  } else {    console.log(\"No request handler found for \" + pathname);    return \"404 Not found\";  }}exports.route = route;</pre>\n        <p>\n            正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。\n        </p>\n\n        <p>\n            最后，我们需要对我们的<em>server.js</em>进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    var content = route(handle, pathname)    response.write(content);    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n        <p>\n            如果我们运行重构后的应用，一切都会工作的很好：请求<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>,浏览器会输出“Hello Start”，请求<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>会输出“Hello Upload”,而请求<a href=\"http://localhost:8888/foo\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/foo</a> 会输出“404 Not found”。\n        </p>\n\n        <p>\n            好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。\n        </p>\n\n        <p>\n            没理解？没关系，下面就来详细解释下。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-25\">阻塞与非阻塞</h4>\n\n        <p>\n            正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。\n        </p>\n\n        <p>\n            我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。\n        </p>\n\n        <p>\n            这里，我们来修改下<em>start</em>请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似<em>sleep()</em>这样的操作，所以这里只能够来点小Hack来模拟实现。\n        </p>\n\n        <p>\n            让我们将<em>requestHandlers.js</em>修改成如下形式：\n        </p>\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");  function sleep(milliSeconds) {    var startTime = new Date().getTime();    while (new Date().getTime() < startTime + milliSeconds);  }  sleep(10000);  return \"Hello Start\";}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            上述代码中，当函数<em>start()</em>被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用<em>upload()</em>的时候，会和此前一样立即返回。\n        </p>\n\n        <p>\n            （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）\n        </p>\n\n        <p>\n            接下来就让我们来看看，我们的改动带来了哪些变化。\n        </p>\n\n        <p>\n            如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>， 但是先不要打开它！\n        </p>\n\n        <p>\n            在第二个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>， 同样的，先不要打开它！\n        </p>\n\n        <p>\n           接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。\n        </p>\n\n        <p>\n            注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然<em>也</em>花了10秒，而它在对应的请求处理程序中并没有类似于<em>sleep()</em>这样的操作！\n        </p>\n\n        <p>\n            这到底是为什么呢？原因就是<em>start()</em>包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。\n        </p>\n\n        <p>\n            这显然是个问题，因为Node一向是这样来标榜自己的：<em>“在node中除了代码，所有一切都是并行执行的”</em>。\n        </p>\n\n        <p>\n            这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。\n        </p>\n\n        <p>\n            然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。\n        </p>\n\n        <p>\n            对于Node.js来说，它是这样处理的：<em>“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</em>\n        </p>\n\n        <p>\n            （如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">理解node.js的事件轮询</a>。）\n        </p>\n\n        <p>\n            接下来，我们会介绍一种错误的使用非阻塞操作的方式。\n        </p>\n\n        <p>\n            和上次一样，我们通过修改我们的应用来暴露问题。\n        </p>\n\n        <p>\n            这次我们还是拿<em>start</em>请求处理程序来“开刀”。将其修改成如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start() {  console.log(\"Request handler 'start' was called.\");  var content = \"empty\";  exec(\"ls -lah\", function (error, stdout, stderr) {    content = stdout;  });  return content;}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            上述代码中，我们引入了一个新的Node.js模块，<em>child_process</em>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<em>exec()</em>。\n        </p>\n\n        <p>\n            <em>exec()</em>做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当<em>/start</em>URL请求的时候将文件信息输出到浏览器中。\n        </p>\n\n        <p>\n            上述代码是非常直观的： 创建了一个新的变量<em>content</em>（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。\n        </p>\n\n        <p>\n            和往常一样，我们启动服务器，然后访问“<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>” 。\n        </p>\n\n        <p>\n            之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？\n        </p>\n\n        <p>\n            这个时候，你可能大致已经猜到了，<em>exec()</em>在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。\n        </p>\n\n        <p>\n            （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。\n        </p>\n\n        <p>\n            然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？\n        </p>\n\n        <p>\n            好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。\n        </p>\n\n        <p>\n            问题就在于，为了进行非阻塞工作，<em>exec()</em>使用了回调函数。\n        </p>\n\n        <p>\n            在我们的例子中，该回调函数就是作为第二个参数传递给<em>exec()</em>的匿名函数：\n        </p>\n        <pre>function (error, stdout, stderr) {  content = stdout;}</pre>\n\n        <p>\n            现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用<em>exec()</em>之后，Node.js会立即执行 <em>return content</em> ；在这个时候，<em>content</em>仍然是“empty”，因为传递给<em>exec()</em>的回调函数还未执行到——因为<em>exec()</em>的操作是异步的。\n        </p>\n\n        <p>\n            我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。\n        </p>\n\n        <p>\n            为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当<em>exec()</em>在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给<em>exec()</em>的回调函数，只会在“find /”命令执行完成之后才会被调用。\n        </p>\n\n        <p>\n            那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？\n        </p>\n\n        <p>\n            好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-26\">以非阻塞操作进行请求响应</h4>\n\n        <p>\n            我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。\n        </p>\n\n        <p>\n            不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。\n        </p>\n\n        <p>\n            到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -> 请求路由 -> 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。\n        </p>\n\n        <p>\n            现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将<em>response</em>对象（从服务器的回调函数<em>onRequest()</em>获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。\n        </p>\n\n        <p>\n            原理就是如此，接下来让我们来一步步实现这种方案。\n        </p>\n\n        <p>\n            先从<em>server.js</em>开始：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname, response);  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            相对此前从<em>route()</em>函数获取返回值的做法，这次我们将response对象作为第三个参数传递给<em>route()</em>函数，并且，我们将<em>onRequest()</em>处理程序中所有有关<em>response</em>的函数调都移除，因为我们希望这部分工作让<em>route()</em>函数来完成。\n        </p>\n\n        <p>\n            下面就来看看我们的<em>router.js</em>:\n        </p>\n        <pre>function route(handle, pathname, response) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/plain\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递<em>response</em>对象。\n        </p>\n\n        <p>\n            如果没有对应的请求处理器处理，我们就直接返回“404”错误。\n        </p>\n\n        <p>\n            最后，我们将<em>requestHandler.js</em>修改为如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start(response) {  console.log(\"Request handler 'start' was called.\");  exec(\"ls -lah\", function (error, stdout, stderr) {    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(stdout);    response.end();  });}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。\n        </p>\n\n        <p>\n            <em>start</em>处理程序在<em>exec()</em>的匿名回调函数中做请求响应的操作，而<em>upload</em>处理程序仍然是简单的回复“Hello World”，只是这次是使用<em>response</em>对象而已。\n        </p>\n\n        <p>\n            这时再次我们启动应用（<em>node index.js</em>），一切都会工作的很好。\n        </p>\n\n        <p>\n            如果想要证明<em>/start</em>处理程序中耗时的操作不会阻塞对<em>/upload</em>请求作出立即响应的话，可以将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start(response) {  console.log(\"Request handler 'start' was called.\");  exec(\"find /\",    { timeout: 10000, maxBuffer: 20000*1024 },    function (error, stdout, stderr) {      response.writeHead(200, {\"Content-Type\": \"text/plain\"});      response.write(stdout);      response.end();    });}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            这样一来，当请求<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>的时候，会花10秒钟的时间才载入，而当请求<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>的时候，会立即响应，纵然这个时候/start响应还在处理中。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-27\">更有用的场景</h3>\n\n        <p>\n            到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。\n        </p>\n\n        <p>\n            服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。\n        </p>\n\n        <p>\n            好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。\n        </p>\n\n        <p>\n            要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。\n        </p>\n\n        <p>\n            第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。\n            <br>\n            第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它<em>不</em>在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-28\">处理POST请求</h4>\n\n        <p>\n            考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。\n        </p>\n        \n        <p>\n            <em>/start</em>请求处理程序用于生成带文本区的表单，因此，我们将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n        <pre>function start(response) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>就可以看到简单的表单了，要记得重启服务器哦！\n        </p>\n\n        <p>\n            你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。\n        </p>\n\n        <p>\n            余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发<em>/upload</em>请求处理程序处理POST请求的问题。\n        </p>\n\n        <p>\n            现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。\n        </p>\n\n        <p>\n            这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。\n        </p>\n\n        <p>\n            为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有<em>data</em>事件（表示新的小数据块到达了）以及<em>end</em>事件（表示所有的数据都已经接收完毕）。\n        </p>\n\n        <p>\n            我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在<em>request</em>对象上注册<em>监听器</em>（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给<em>onRequest</em>回调函数。\n        </p>\n\n        <p>\n            如下所示：\n        </p>\n        <pre>request.addListener(\"data\", function(chunk) {  // called when a new chunk of data was received});request.addListener(\"end\", function() {  // called when all chunks of data have been received});</pre>\n\n        <p>\n            问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了<em>request</em>对象 —— 我们并没有像之前<em>response</em>对象那样，把 request 对象传递给请求路由和请求处理程序。\n        </p>\n\n        <p>\n            在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。\n        </p>\n\n        <p>\n            因此，实现思路就是： 将<em>data</em>和<em>end</em>事件的回调函数直接放在服务器中，在<em>data</em>事件回调中收集所有的POST数据，当接收到所有数据，触发<em>end</em>事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。\n        </p>\n\n        <p>\n            还等什么，马上来实现。先从<em>server.js</em>开始：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var postData = \"\";    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    request.setEncoding(\"utf8\");    request.addListener(\"data\", function(postDataChunk) {      postData += postDataChunk;      console.log(\"Received POST data chunk '\"+      postDataChunk + \"'.\");    });    request.addListener(\"end\", function() {      route(handle, pathname, response, postData);    });  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给<em>postData</em> 变量，最后，我们将请求路由的调用移到<em>end</em>事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。\n        </p>\n\n        <p>\n            上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。\n        </p>\n\n        <p>\n            我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现<em>data</em>事件会触发多次。\n        </p>\n\n        <p>\n            再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将<em>postData</em>传递给请求处理程序，修改<em>router.js</em>为如下形式：\n        </p>\n\n        <pre>function route(handle, pathname, response, postData) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response, postData);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/plain\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            然后，在<em>requestHandlers.js</em>中，我们将数据包含在对<em>upload</em>请求的响应中：\n        </p>\n        <pre>function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent: \" + postData);  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。\n        </p>\n\n        <p>\n            我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是<em>text</em>字段。\n        </p>\n\n        <p>\n            我们可以使用此前介绍过的<em>querystring</em>模块来实现：\n        </p>\n        <pre>var querystring = require(\"querystring\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，以上就是关于处理POST数据的全部内容。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-29\">处理文件上传</h4>\n\n        <p>\n            最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。\n        </p>\n\n        <p>\n            回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。\n        </p>\n\n        <p>\n            这里我们要用到的外部模块是Felix Geisendörfer开发的<em>node-formidable</em>模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传<em>“就是”</em>处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。\n        </p>\n\n        <p>\n            使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫<em>NPM</em>。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：\n        </p>\n        <pre>npm install formidable</pre>\n\n        <p>\n            如果终端输出如下内容：\n        </p>\n        <pre>npm info build Success: formidable@1.0.9npm ok</pre>\n\n        <p>\n            就说明模块已经安装成功了。\n        </p>\n\n        <p>\n            现在我们就可以用<em>formidable</em>模块了——使用外部模块与内部模块类似，用require语句将其引入即可：\n        </p>\n        <pre>var formidable = require(\"formidable\");</pre>\n\n        <p>\n            这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的<em>IncomingForm</em>，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。\n        </p>\n\n        <p>\n            node-formidable官方的例子展示了这两部分是如何融合在一起工作的：\n        </p>\n        <pre>var formidable = require('formidable'),    http = require('http'),    util = require('util');http.createServer(function(req, res) {  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {    // parse a file upload    var form = new formidable.IncomingForm();    form.parse(req, function(err, fields, files) {      res.writeHead(200, {'content-type': 'text/plain'});      res.write('received upload:\\n\\n');      res.end(util.inspect({fields: fields, files: files}));    });    return;  }  // show a file upload form  res.writeHead(200, {'content-type': 'text/html'});  res.end(    '+    'method=\"post\">'+    '<input type=\"text\" name=\"title\"><br>'+    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+    '<input type=\"submit\" value=\"Upload\">'+    ''  );}).listen(8888);</pre>\n\n        <p>\n            如果我们将上述代码，保存到一个文件中，并通过<em>node</em>来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用<em>form.parse</em>传递给回调函数的<em>files</em>对象的内容，如下所示：\n        </p>\n        <pre>received upload:\n\n{ fields: { title: 'Hello World' },\n  files:\n   { upload:\n      { size: 1558,\n        path: '/tmp/1c747974a27a6292743669e91f29350b',\n        name: 'us-flag.png',\n        type: 'image/png',\n        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,\n        _writeStream: [Object],\n        length: [Getter],\n        filename: [Getter],\n        mime: [Getter] } } }</pre>\n\n        <p>\n            为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在<em>/tmp</em>目录中）显示到浏览器中。\n        </p>\n\n        <p>\n            我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？\n        </p>\n\n        <p>\n            显然，我们需要将该文件读取到我们的服务器中，使用一个叫<em>fs</em>的模块。\n        </p>\n\n        <p>\n            我们来添加<em>/show</em>URL的请求处理程序，该处理程序直接硬编码将文件<em>/tmp/test.png</em>内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。\n        </p>\n\n        <p>\n            将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'content=\"text/html; charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}function show(response, postData) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            我们还需要将这新的请求处理程序，添加到<em>index.js</em>中的路由映射表中：\n        </p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = {}handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.route, handle);</pre>\n\n        <p>\n            重启服务器之后，通过访问<a href=\"http://localhost:8888/show\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/show</a>，就可以看到保存在<em>/tmp/test.png</em>的图片了。\n        </p>\n\n        <p>\n            好，最后我们要的就是：\n        </p>\n        \n        <p>\n            </p><ul>\n                <li>\n                    在<em>/start</em>表单中添加一个文件上传元素\n                </li>\n                <li>\n                    将node-formidable整合到我们的<em>upload</em>请求处理程序中，用于将上传的图片保存到<em>/tmp/test.png</em>\n                </li>\n        \n                <li>\n                    将上传的图片内嵌到<em>/upload</em>URL输出的HTML中\n                </li>\n            </ul>\n        <p></p>\n\n        <p>\n            第一项很简单。只需要在HTML表单中，添加一个<em>multipart/form-data</em>的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下<em>requestHandler.js</em>所示：\n        </p>\n\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'content=\"text/html; charset=UTF-8\" />'+    ''+    ''+    '+    'method=\"post\">'+    '<input type=\"file\" name=\"upload\">'+    '<input type=\"submit\" value=\"Upload file\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}function show(response, postData) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在<em>upload</em>处理程序中对上传的文件进行处理，这样的话，我们就需要将<em>request</em>对象传递给node-formidable的<em>form.parse</em>函数。\n        </p>\n\n        <p>\n            但是，我们有的只是<em>response</em>对象和<em>postData</em>数组。看样子，我们只能不得不将<em>request</em>对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。\n        </p>\n\n        <p>\n            到这里，我们可以将<em>postData</em>从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了<em>request</em>对象中的数据，这意味着，对于<em>form.parse</em>来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）\n        </p>\n\n        <p>\n            我们从<em>server.js</em>开始 —— 移除对postData的处理以及<em>request.setEncoding</em>\n            （这部分node-formidable自身会处理），转而采用将<em>request</em>对象传递给请求路由的方式：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname, response, request);  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            接下来是 router.js —— 我们不再需要传递<em>postData</em>了，这次要传递<em>request</em>对象：\n        </p>\n        <pre>function route(handle, pathname, response, request) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response, request);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/html\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            现在，<em>request</em>对象就可以在我们的<em>upload</em>请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地<em>/tmp</em>目录中，而我们需要做的是确保该文件保存成<em>/tmp/test.png</em>。 没错，我们保持简单，并假设只允许上传PNG图片。\n        </p>\n\n        <p>\n            这里采用<em>fs.renameSync(path1,path2)</em>来实现。要注意的是，正如其名，该方法是同步执行的，\n            也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。\n        </p>\n\n        <p>\n            接下来，我们把处理文件上传以及重命名的操作放到一起，如下<em>requestHandlers.js</em>所示：\n        </p>\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\"),    formidable = require(\"formidable\");function start(response) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '+    'method=\"post\">'+    '<input type=\"file\" name=\"upload\" multiple=\"multiple\">'+    '<input type=\"submit\" value=\"Upload file\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, request) {  console.log(\"Request handler 'upload' was called.\");  var form = new formidable.IncomingForm();  console.log(\"about to parse\");  form.parse(request, function(error, fields, files) {    console.log(\"parsing done\");    fs.renameSync(files.upload.path, \"/tmp/test.png\");    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(\"received image:<br>\");    response.write(\"<img style class=\"lazyload inited\" data-src=\"/show\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\">\");    response.end();  });}function show(response) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。\n        </p>\n\n        <a></a>\n\n        <h2 data-id=\"heading-30\">总结与展望</h2>\n\n        <p>\n            恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。\n        </p>\n\n        <p>\n            当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。\n        </p>\n\n        <p>\n            但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。\n        </p>\n\n        <p>\n            幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？），\n            这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。\n            其中<a href=\"https://github.com/joyent/node/wiki\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js社区的wiki</a>以及\n            <a href=\"http://www.nodecloud.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NodeCloud</a>就是最好的资源。\n        </p>\n        </div>",
      "id": "5g2zxxr5ods0",
      "author": "sing1ee",
      "title": "Node入门 » 一本全面的Node.js教程",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">一、概述</h2>\n<blockquote>\n<p>4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在 Node 这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">二、Node 基础框架的迭代与演进</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 从 Koa 到 阿童木（Astroboy）</h3>\n<h4 class=\"heading\" data-id=\"heading-3\">（1）Koa + 中间件</h4>\n<p>有赞最早的一个比较完整的 Node 项目是公司内部的一个管理系统，这个系统是用 Node 全栈开发的，主要包括一个给 HR 用的员工管理系统和给小伙伴用的 APP。就像大多数公司一样，我们第一个 Node 项目也是直接用 Koa，然后整合一些开源的中间件，这样就快速的把项目搭建起来了。</p>\n<p>这个项目做了半年之后，我们把 Node 该踩的坑基本也都踩了一遍，所以我们就开始尝试在对外产品上使用 Node了，我们第一个尝试改造的项目是公司的官网，这是最简单的一个项目，基本没什么大的风险。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">（2）脚手架项目模板</h4>\n<p>第二个项目我们不可能再按照之前的方式，简单用 Koa 加上一堆中间件的方式来搭建项目了，因为已经有了之前的经验，所以我们就整理了下这一套方案，抽离出了一个项目模板，每个新项目只要把这个模板克隆下来，然后改一下配置，就可以快速搭建出一个新的项目来。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">（3）阿童木 1.0</h4>\n<p>项目多了之后，这种方式弊端很快就显现出来了，因为模板代码和业务代码是耦合在一起，如果要改模板生成的代码，只能每个项目手动更新，而随着时间的推移，越来越难保持同步了，每个项目的目录结构和代码风格可能也会变得非常不一样，所以，<strong>解耦框架代码和业务代码就非常重要了</strong>。所以我们就在脚手架模板的基础上抽离出了一个框架叫 Astroboy（阿童木），这个框架是在  Koa 的基础上封装的，这样，每个项目都基于这个框架开发，如果框架更新了，项目也只需要更改下框架的版本号。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cc9555a2b18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1164\" data-height=\"666\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1164\" height=\"666\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">（4）阿童木 2.0</h4>\n<p>很多项目都开始用 Node 了，新的问题又出现了，因为每个产品的业务场景都不一样，对框架的需求也都不一样。例如某个中间件，产品 A 可能需要，而产品 B 可能根本不需要这个中间件，而这个时候的框架又不支持定制改造。所以对框架来说，又提出了新的挑战，所以在今年年初，对框架做了一次大的重构。</p>\n<p>这次重构在阿童木 1.0 的基础上，加入了很多新特性，主要有以下几点：</p>\n<ul>\n<li>基于 Koa2 开发，性能表现优异</li>\n<li>提供基于 Astroboy 定制上层框架的能力</li>\n<li>高度可扩展的插件机制</li>\n<li>渐进式开发</li>\n</ul>\n<p>首先提供基于 Astroboy 定制上层框架的能力，如下图所示，Youzan Base Framework 是在阿童木的基础上定制的一个有赞最基础的 Node Web 框架，这一层主要集成了一些有赞最基础的服务，像：</p>\n<ul>\n<li>天网系统接入，这是有赞内部的一个日志及业务监控系统</li>\n<li>健康检查，运维监控系统每隔5秒钟，都会检查系统服务可用性</li>\n<li>全链路监控，对于一次 HTTP 请求，一般都会调用多个后端接口，相应的后端接口也会再去调用其他接口，所以整个调用过程实际上是一棵树状的结构，如果碰到性能问题，找出其中性能瓶颈问题就非常重要了，全链路监控就是为了解决这个问题。</li>\n<li>Dubbo 服务调用接入，关于这一点，查看下面关于服务化的介绍。</li>\n</ul>\n<p>有了 Youzan Base Framework 后，我们就需要在上面开发业务了，这个分两种业务场景：对于一些简单单一的业务，直接继承 Youzan Base Framework 开发就可以了；而如果是一些复杂的业务，就可以先在 Youzan Base Framework 的基础上，定制出一个业务框架，像我们有赞原先有一个超大的 PHP 项目（我们叫 Iron），那么服务化拆分后，Node 就承担了原先 PHP 的部分，所以我们新先定制了一个业务级的框架叫 Iron Base Framework，然后再按照业务模块（交易、店铺、用户、营销）拆分成多个子项目。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cd133687115?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"694\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"694\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其次是支持插件化，关于这一点，可查看下面关于插件的说明。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">2. 框架的几个核心概念</h3>\n<p>以上介绍了有赞 Node 基础框架迭代和演变的过程，下面主要介绍下阿童木2.0 框架的几个核心概念</p>\n<h4 class=\"heading\" data-id=\"heading-8\">（1）应用 Application</h4>\n<p>应用 Application 的概念很好理解，在这里应用就可以理解成一个项目，它是从框架继承下来，并且实例化之后的一个实例，应用也是由一个一个插件构成的。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">（2）框架 Framework</h4>\n<p>Astroboy 框架是在 Koa2 的基础上封装的，关于框架的概念，这里就不再做过多的介绍了。</p>\n<h4 class=\"heading\" data-id=\"heading-10\">（3）插件 Plugin</h4>\n<p>插件化是软件设计中一个很重要的思想，很多软件像 Eclipse 都支持这样的特性，插件化可以让我们的系统解耦，每个模块做到独立开发，而模块之间又不会相互影响，这样的特性对于大型项目来说是非常重要的。</p>\n<p>插件化是 Astroboy 框架中最核心的一个实现，它是服务（Service）、中间件（Middleware）和工具函数库（Lib）等的载体，它本质上还是 NPM 包，只不过是在 NPM 包的基础上，做了更深层次的抽象。基于 Astroboy 的应用，就是由一个一个的 Plugin 组成的，Plugin 就是我们手中的积木，通过 Astroboy 的框架引擎把这些积木组织在一起，就形成了系统。</p>\n<p><strong>那么插件跟普通的 NPM 包有什么区别呢？</strong></p>\n<p>插件约定了目录结构，这样每个插件看起来都是类似的，这对于团队的协作是非常重要，如果每个模块看起来都不一样，那么团队的协作成本就会很高。\n应用启动后，插件的代码是自动注入到整个应用的，只需要在插件的配置文件里面开启这个插件即可。</p>\n<p><strong>一个插件可以包含哪些信息？</strong></p>\n<ul>\n<li>插件元数据，包括插件名称、版本、描述等；</li>\n<li>服务（Service）、中间件（Middleware）以及工具函数库（Lib）等；</li>\n<li>Koa 内置对象的扩展，包括 Context、Application、Request 以及 Response 等；</li>\n</ul>\n<p><strong>插件的管理</strong></p>\n<ul>\n<li>安装插件，通过npm install 命令即可，例如：npm install [<@scope>/]@</li>\n<li>启用插件，安装插件后还需要启用插件，插件才会真正生效。启用插件也很简单，只需要配置 plugin.default.js 即可，如果不同环境插件配置不一样，也只需修改相应* 环境的配置（plugin.${env}.js）即可，这里 env 表示 Node 运行时的环境变量，例如：development、test、production 等。如下代码所示：</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    path: path.resolve(__dirname, <span class=\"hljs-string\">'../plugins/astroboy-cookie'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>enable 设置成 true 就可以开启这个插件，path 表示插件的绝对路径，这种一般适合于还在快速迭代中的插件，如果插件已经很稳定了，你就可以把这个插件打包发布成一个 NPM 包，然后通过 package 声明你的插件即可，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    package: <span class=\"hljs-string\">'astroboy-cookie'</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>禁用插件，禁用插件就更加简单了，只需将 enable 设置成 false 即可。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-11\">三、Node 接入有赞服务化体系的历程</h2>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 为什么要做服务化？</h3>\n<p>随着公司业务的发展，网站应用的规模不断扩大，垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键，所以在这个时候，分布式服务架构就势在必行了。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. 技术栈的选择</h3>\n<p>在介绍技术栈选择之前，先讲一下公司的一些技术背景。</p>\n<blockquote>\n<p>在公司成立初期，为了能够快速开发，把产品快速做出来推出市场，所以我们选择用 PHP 语言，我想这也是大多数创业公司的选择。而随着业务的发展，PHP 越来越难处理复杂的业务。</p>\n</blockquote>\n<p>所以等到了一定时候，我们开始做服务化拆分，那么首先考虑的就是底层技术的选择，我们从下面几点考虑：</p>\n<ul>\n<li>第一个是这门技术的生态是否足够完善，也就是相关的开源软件、工具是否成熟；</li>\n<li>第二个是否能够快速招到你需要的人才。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-14\">3. 服务化拆分之后，每一层职责分别是什么？</h3>\n<p>对于 Node 层，我们的定位是一层很薄的中间层，Node 这一层不会过多地处理业务逻辑，业务逻辑全部都交给 Java 来处理，它只负责下面三件事情：</p>\n<ul>\n<li>模板渲染：模板渲染说的就是 HTML 模板的渲染；</li>\n<li>业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node 就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。</li>\n<li>接口转发：Java 的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node 需要承担接口转发的角色。</li>\n</ul>\n<p>而对于 Java 这一层，就需要承担业务逻辑以及缓存等复杂的操作，这里就不做过多的介绍了。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">4. Node 如何调用 Java 接口？</h3>\n<p>那么服务化拆分之后，首先要解决的一个问题是：Node 如何调用 Java 提供的接口。首先，我们想到的就是 HTTP 的方式，这里说明一下，我们公司采用的分布式服务化框架是阿里开源的 Dubbo 框架，而 Dubbo 框架本身是支持通过添加注解的方式生成 Restful API 的，所以在初期，我们就是采用这个现成的方案。</p>\n<p>而随着应用数目的增加，这种方式的弊端也逐渐显现出来，主要有下面几点：</p>\n<ul>\n<li>如果某个接口需要暴露给 Node 使用，就需要手动再去添加额外的注解。</li>\n<li>每增加一个应用，运维都需要针对每个应用配置域名，不同的环境又需要配置不同的域名，所以随着应用数的增加，应用域名的管理越来越难维护。</li>\n<li>相应的，node 也需要维护一份很长的域名配置文件。</li>\n<li>由于 Java 是直接提供 HTTP 接口，所以性能上相对 RPC 的方式会低一点。</li>\n</ul>\n<p>所以，我们就调研了下，看其他公司在使用 Dubbo 框架时，Node 是如何调用 Java 的？如下图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce4fa59a7c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1216\" data-height=\"489\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1216\" height=\"489\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>首先，Java 应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是 ETCD 或者 Zookeeper，然后，Node 应用在启动的时候，会先从服务注册中心拉取服务列表，接着 Node 会跟 Java 服务建立一条TCP长链接，除此之外，Node 还需要负责 Hession 协议解析以及负载均衡等。</p>\n<p>不难发现，这种方式 Node 的职责就比较重，而且对 Node 开发的要求会很高。所以，我们对这种方式做了改进，如下图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce94f18acfa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1029\" data-height=\"481\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1029\" height=\"481\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>我们在 Node 和 Java 之间添加了一层中间代理层 Tether，Tether 是用 Go 语言写的一个本地代理，Tether 会对外暴露一个 HTTP 的服务，对 Node 来说，只需要通过 HTTP 方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由 Tether 来处理。这样，Node 这一层就非常轻量了，那么，最终实现出来，Node 是怎么调用 Java 服务的呢？如下代码所示：</p>\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> Service = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../base/BaseService'</span>);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoodsService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span> </span>{\n  <span class=\"hljs-comment\">/**\n   * 根据商品 alias 获取商品详情\n   * @param  {String} alias 商品 alias\n   */</span>\n  <span class=\"hljs-keyword\">async</span> getGoodsDetailByAlias(alias) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">this</span>.invoke(\n      <span class=\"hljs-string\">'com.youzan.ic.service.GoodsService'</span>,\n      <span class=\"hljs-string\">'getGoodsDetailByAlias'</span>,\n      [alias]\n    );\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n}\n<span class=\"hljs-built_in\">module</span>.exports = GoodsService;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>对 Node 来说，调用 Java 服务它只需要关注三个点：</p>\n<ul>\n<li>服务名：服务名是由 Java 的包名 + 类名组成，例如上面的 com.youzan.ic.service.GoodsService</li>\n<li>方法名：Java 类对外暴露的方法，例如上面代码所示的根据商品 alias 查询商品详情的一个方法 getGoodsDetailByAlias</li>\n<li>参数：参数就是传递给 Java 的参数列表</li>\n</ul>\n<p>最后，总结下这种方式都有哪些优点：</p>\n<ul>\n<li>第一个是使用简单，对前端开发非常友好，只需要通过 HTTP 方式调用本地的 Tether 服务即可；</li>\n<li>第二个是多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像 Node 一样，它们都只需要调用本地 Tether 暴露的 HTTP 服务即可，没有额外的开发成本了。</li>\n<li>第三个是后期更方便做协议层的优化，因为这种方式 Tether 其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化 Tether 的性能就可以了。</li>\n</ul>\n<p>那么，看到这里，有人可能又会想，这里 Node 也是通过 HTTP 方式调用 Java 的，性能上是不是也存在问题呢？所以这里我们就做了一些优化，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">const Agent = require(<span class=\"hljs-string\">'agentkeepalive'</span>);\n\nmodule.exports = new Agent({\n  maxSockets: 100,\n  maxFreeSockets: 10,\n  timeout: 60000,\n  freeSocketKeepAliveTimeout: 30000,\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>这里，我们引用了一个 agentkeepalive 包，在 HTTP 早期，每个 HTTP 请求都要求打开一个 TCP Socket 连接，并且使用一次之后就断开这个 TCP 连接，使用 keep-alive 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。所以通过使用 keep-alive 机制，就可以减少 TCP 连接建立次数。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">四、参考资料</h2>\n<p>https://github.com/apache/incubator-dubbo\nhttps://github.com/QianmiOpen/dubbo2.js\nhttps://github.com/QianmiOpen/dubbo-node-client\nhttps://github.com/p412726700/node-zookeeper-dubbo\nhttps://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cf039b468ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4q42z5xe10u0",
      "author": "有赞技术",
      "title": "Node 在有赞的实践",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>Create by <strong>jsliang</strong> on <strong>2018-11-8 13:42:42</strong><br>\nRecently revised in <strong>2018-12-23 21:59:20</strong></p>\n</blockquote>\n<p>Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<br>\n<p> <span style=\"color:red\">【2019-08-16】Hello 小伙伴们，由于 <strong>jsliang</strong> 对文档库进行了重构，这篇文章的一些链接可能失效，而 <strong>jsliang</strong> 没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的 GitHub 地址，去文档库查看调整后的文章。</span></p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-0\">本文重点内容</h3>\n<ul>\n<li>Node 基础 - 通过对 Node 基础的了解学习，打下 Node 基础</li>\n<li>Node API - 开启服务提供 API 给前端调用</li>\n<li>Node 连接 MySQL - 通过 npm 安装 mysql，从而实现数据库的链接</li>\n<li>Node 实战 - 企业官网从 0 开始，打造能注册、登录以及留言的企业官网</li>\n<li>Node 部署 - 如何通过部署云服务器，让小伙伴们可以查看到你的网站</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">本文延伸链接</h3>\n<ul>\n<li>Node 部署项目、云服务器以及域名的使用：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 基础代码下载地址：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 成品代码下载地址：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">本文成品演示</h3>\n<ul>\n<li>Node 项目演示：<a target=\"_blank\" href=\"http://company.jsliang.top/\" rel=\"nofollow noopener noreferrer\">jsliang 前端有限公司</a></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47764ad7e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"726\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"726\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\"><a id=\"chapter-one\" name=\"chapter-one\">一 目录</a></h2>\n<p> <strong>不折腾的前端，和咸鱼有什么区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#chapter-one\">一 目录</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-two\" name=\"catalog-chapter-two\"></a><a href=\"#chapter-two\">二 前言</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-three\" name=\"catalog-chapter-three\"></a><a href=\"#chapter-three\">三 基础学习</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-one\" name=\"catalog-chapter-three-one\"></a><a href=\"#chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-two\" name=\"catalog-chapter-three-two\"></a><a href=\"#chapter-three-two\">3.2 URL 模块</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-three\" name=\"catalog-chapter-three-three\"></a><a href=\"#chapter-three-three\">3.3 CommonJS</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-four\" name=\"catalog-chapter-three-four\"></a><a href=\"#chapter-three-four\">3.4 包与 npm</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-five\" name=\"catalog-chapter-three-five\"></a><a href=\"#chapter-three-five\">3.5 fs 文件管理</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-six\" name=\"catalog-chapter-three-six\"></a><a href=\"#chapter-three-six\">3.6 fs 案例</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-seven\" name=\"catalog-chapter-three-seven\"></a><a href=\"#chapter-three-seven\">3.7 fs 流</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eight\" name=\"catalog-chapter-three-eight\"></a><a href=\"#chapter-three-eight\">3.8 创建 Web 服务器</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-night\" name=\"catalog-chapter-three-night\"></a><a href=\"#chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-ten\" name=\"catalog-chapter-three-ten\"></a><a href=\"#chapter-three-ten\">3.10 get 与 post</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eleven\" name=\"catalog-chapter-three-eleven\"></a><a href=\"#chapter-three-eleven\">3.11 Node 连接 MySQL</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-four\" name=\"catalog-chapter-four\"></a><a href=\"#chapter-four\">四 Web 实战 —— 企业官网</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-one\" name=\"catalog-chapter-four-one\"></a><a href=\"#chapter-four-one\">4.1 编程环境</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-two\" name=\"catalog-chapter-four-two\"></a><a href=\"#chapter-four-two\">4.2 后端接口</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-three\" name=\"catalog-chapter-four-three\"></a><a href=\"#chapter-four-three\">4.3 注册功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-four\" name=\"catalog-chapter-four-four\"></a><a href=\"#chapter-four-four\">4.4 登录功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-five\" name=\"catalog-chapter-four-five\"></a><a href=\"#chapter-four-five\">4.5 留言功能</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-five\" name=\"catalog-chapter-five\"></a><a href=\"#chapter-five\">五 工具整合</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-one\" name=\"catalog-chapter-five-one\"></a><a href=\"#chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-two\" name=\"catalog-chapter-five-two\"></a><a href=\"#chapter-five-two\">5.2 PM2 - Node 进程管理</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-six\" name=\"catalog-chapter-six\"></a><a href=\"#chapter-six\">六 参考资料</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-seven\" name=\"catalog-chapter-seven\"></a><a href=\"#chapter-seven\">七 线上部署</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-eight\" name=\"catalog-chapter-eight\"></a><a href=\"#chapter-eight\">八 归纳总结</a></td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-4\"><a id=\"chapter-two\" name=\"chapter-two\">二 前言</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-two\">返回目录</a></p>\n</blockquote>\n<p> 本文主要目的：</p>\n<ol>\n<li>整合 Node 基础，加深 <strong>jsliang</strong> 对 Node 的学习了解，并且方便日后复习。</li>\n<li>整合 Node 工具，方便查找在 Node 开发中，有哪些工具比较有利于开发。</li>\n<li>给初学 Node 的小伙伴做一个参考，如有疑问还请在 QQ 群：<code>798961601</code> 中咨询。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-5\"><a id=\"chapter-three\" name=\"chapter-three\">三 基础</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-three\">返回目录</a></p>\n</blockquote>\n<p> <strong>万丈高楼平地起，地基还得自己起。</strong></p>\n<h3 class=\"heading\" data-id=\"heading-6\"><a id=\"chapter-three-one\" name=\"chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-one\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>01_http.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 2. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面代码，我们要怎么用呢？</p>\n<p> <strong>首先</strong>，将上面的代码复制粘贴到 <code>01_http.js</code> 中。<br>\n <strong>然后</strong>，启动 VS Code 终端：<code>Ctrl + ~</code>。<br>\n <strong>接着</strong>，输入 <code>node 01_http.js</code> 并回车。<br>\n <strong>最后</strong>，打开 <code>localhost:3000</code>：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47a578759c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"660\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"660\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> OK，搞定完事，现在我们一一讲解上面代码：</p>\n<ol>\n<li><strong>首先</strong>，我们需要先开启仙人模式。哦，不是，是 HTTP 模式。我们都知道，像 PHP 这类老牌子的后端语言，需要 Apache 或者 Nginx 开启 HTTP 服务。然而我们的 Node 不需要：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li><strong>然后</strong>，开启 HTTP 服务，并设置开启的端口：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 步骤 3 代码\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li><strong>接着</strong>，我们设置 HTTP 头部，并往页面打印值，最后结束响应：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\nres.writeHead(200, {\n  <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n});\n\n// 往页面打印值\nres.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n// 结束响应 \nres.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><strong>最后</strong>，我们往浏览器输入 <code>http://localhost:3000/</code>，将访问到我们开启的 Node 服务，从而往页面渲染页面。</li>\n</ol>\n<p> 至此，小伙伴们是不是也开启了自己的 Node 之旅？</p>\n<h3 class=\"heading\" data-id=\"heading-7\"><a id=\"chapter-three-two\" name=\"chapter-three-two\">3.2 URL 模块</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-two\">返回目录</a></p>\n</blockquote>\n<p> URL 模块是什么呢？<br>\n 我们在控制台（终端）开启 Node 模式，并打印出 <code>url</code> 来看一下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db481725e04bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"509\" data-height=\"230\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"509\" height=\"230\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，它有 <code>Url</code>、<code>parse</code>、<code>resolve</code>、<code>resolveObject</code>、<code>format</code>、<code>URL</code>、<code>URLSearchParams</code>、<code>domainToASCII</code>、<code>domainToUnicode</code> 这么多模块。<br>\n 那么，这些模块都有什么用呢？</p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>02_url.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 4. 获取服务器请求\n  /**\n   * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n   * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n   * /  ?userName=jsliang&userAge=23\n   * /  /favicon.ico\n   * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n   */\n  <span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    \n    // 5. 使用 url 的 parse 方法\n    /**\n     * parse 方法需要两个参数：\n     * 第一个参数是地址\n     * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n     */ \n    var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n    console.log(result);\n    /**\n     * Url {\n     *   protocol: null,\n     *   slashes: null,\n     *   auth: null,\n     *   host: null,\n     *   port: null,\n     *   hostname: null,\n     *   <span class=\"hljs-built_in\">hash</span>: null,\n     *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n     *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n     *   pathname: <span class=\"hljs-string\">'/'</span>,\n     *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n     *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n     */\n\n    console.log(result.query.userName); // jsliang\n\n    console.log(result.query.userAge); // 23\n  }\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的代码中：</p>\n<p> <strong>首先</strong>，我们引入该章节的主角 <code>url</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>然后</strong>，我们引入 <code>http</code> 模块：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>接着</strong>，我们创建 <code>http</code> 模块，因为 <code>url</code> 的监听，需要 <code>http</code> 模块的开启：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 第 4 步、第 5 步代码\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们访问我们给出的地址：<code>http://localhost:3000/?userName=jsliang&userAge=23</code>，并通过它查看 <code>url</code> 的 <code>parse</code> 模块怎么用，输出啥：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 4. 获取服务器请求\n/**\n  * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n  * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n  * /  ?userName=jsliang&userAge=23\n  * /  /favicon.ico\n  * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n  */\n<span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n  \n  // 5. 使用 url 的 parse 方法\n  /**\n    * parse 方法需要两个参数：\n    * 第一个参数是地址\n    * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n    */ \n  var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n  console.log(result);\n  /**\n    * Url {\n    *   protocol: null,\n    *   slashes: null,\n    *   auth: null,\n    *   host: null,\n    *   port: null,\n    *   hostname: null,\n    *   <span class=\"hljs-built_in\">hash</span>: null,\n    *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n    *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n    *   pathname: <span class=\"hljs-string\">'/'</span>,\n    *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n    *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n    */\n\n  console.log(result.query.userName); // jsliang\n\n  console.log(result.query.userAge); // 23\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 从中，我们可以看出，我们可以通过 <code>query</code>，获取到我们想要的路径字段。</p>\n<p> 当然，上面只讲解了 <code>parse</code> 的用法，我们可以将上面代码中 <code>if</code> 语句里面的代码全部清空。然后，输入下面的内容，去学习 <code>url</code> 模块更多的内容：</p>\n<ol>\n<li>url 模块所有内容：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url);\n\n/**\n * Console：\n { \n   Url: [Function: Url],\n    parse: [Function: urlParse], // 获取地址信息\n    resolve: [Function: urlResolve], // 追加或者替换地址\n    resolveObject: [Function: urlResolveObject],\n    format: [Function: urlFormat], // 逆向 parse，根据地址信息获取原 url 信息\n    URL: [Function: URL],\n    URLSearchParams: [Function: URLSearchParams],\n    domainToASCII: [Function: domainToASCII],\n    domainToUnicode: [Function: domainToUnicode] \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"2\">\n<li>parse 如何使用</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com\"</span>));\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: null,\n    query: null,\n    pathname: <span class=\"hljs-string\">'/'</span>,\n    path: <span class=\"hljs-string\">'/'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"3\">\n<li>parse 带参数：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com/new?name=zhangsan\"</span>));\n\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n    query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n    pathname: <span class=\"hljs-string\">'/new'</span>,\n    path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n  }\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"4\">\n<li><code>format</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.format({\n  protocol: <span class=\"hljs-string\">'http:'</span>,\n  slashes: <span class=\"hljs-literal\">true</span>,\n  auth: null,\n  host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  port: null,\n  hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  <span class=\"hljs-built_in\">hash</span>: null,\n  search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n  query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n  pathname: <span class=\"hljs-string\">'/new'</span>,\n  path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n  href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n}))\n\n// Console：\n// http://www.baidu.com/new?name=zhangsan\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ol start=\"5\">\n<li><code>resolve</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(url.resolve(<span class=\"hljs-string\">\"http://www.baidu.com/jsliang\"</span>, <span class=\"hljs-string\">\"梁峻荣\"</span>));\n\n// Console：\n// http://www.baidu.com/梁峻荣\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，<code>url</code> 这里我们只讲解了个入门，更多的还请看官网 API：<a target=\"_blank\" href=\"http://nodejs.cn/api/url.html#url_class_url\" rel=\"nofollow noopener noreferrer\">url | Node.js v10.14.1 文档</a></p>\n<h3 class=\"heading\" data-id=\"heading-8\"><a id=\"chapter-three-three\" name=\"chapter-three-three\">3.3 CommonJS</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-three\">返回目录</a></p>\n</blockquote>\n<ul>\n<li>什么是 CommonJS？</li>\n</ul>\n<p> CommonJS 就是为 JS 的表现来制定规范，因为 JS 没有模块系统、标准库较少、缺乏包管理工具，所以 CommonJS 应运而生，它希望 JS 可以在任何地方运行，而不只是在浏览器中，从而达到 Java、C#、PHP 这些后端语言具备开发大型应用的能力。</p>\n<ul>\n<li>CommonJS 的应用？</li>\n</ul>\n<ol>\n<li>服务器端 JavaScript 应用程序。（Node.js）</li>\n<li>命令行工具</li>\n<li>桌面图形界面应用程序。</li>\n</ol>\n<ul>\n<li>CommonJS 与 Node.js 的关系？</li>\n</ul>\n<p> CommonJS 就是模块化的标准，Node.js 就是 CommonJS（模块化）的实现。</p>\n<ul>\n<li>Node.js 中的模块化？</li>\n</ul>\n<ol>\n<li>在 Node 中，模块分为两类：一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP 模块、URL 模块、FS 模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。</li>\n<li>我们可以将公共的功能抽离出一个单独的 JS 文件存放，然后在需要的情况下，通过 exports 或者 module.exports 将模块导出，并通过 require 引入这些模块。</li>\n</ol>\n<p> 现在，我们通过三种使用方式，来讲解下 Node 中的模块化及 exports/require 的使用。</p>\n<p> 我们先查看下目录：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4838b82f804?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"227\" data-height=\"381\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"227\" height=\"381\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> <strong>方法一</strong>：</p>\n<p> 首先，我们新建 <code>03_CommonJS.js</code>、<code>03_tool-add.js</code>、<code>node_modules/03_tool-multiply.js</code>、<code>node_modules/jsliang-module/tools.js</code> 这 4 个文件/文件夹。<br>\n 其中 <code>package.json</code> 我们暂且不理会，稍后会讲解它如何自动生成。</p>\n<p> 在 <code>03_tool-add.js</code> 中：</p>\n<blockquote>\n<p>03_tool-add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 1. 假设我们文件其中有个工具模块\nvar tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\n/**\n * 2. 暴露模块\n * exports.str = str;\n * module.exports = str;\n * 区别：\n * module.exports 是真正的接口\n * exports 是一个辅助工具\n * 如果 module.exports 为空，那么所有的 exports 收集到的属性和方法，都赋值给了 module.exports\n * 如果 module.exports 具有任何属性和方法，则 exports 会被忽略\n */\n\n// exports 使用方法\n// var str = <span class=\"hljs-string\">\"jsliang is very good!\"</span>;\n// exports.str = str; // { str: <span class=\"hljs-string\">'jsliang is very good!'</span> }\n\n// module.exports 使用方法\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 那么，上面的代码有啥含义呢？<br>\n 第一步，我们定义了个工具库 <code>tools</code>。<br>\n 第二步，我们通过 <code>modules.exports</code> 将 <code>tools</code> 进行了导出。<br>\n 所以，我们在 <code>03_CommonJS.js</code> 可以通过 <code>require</code> 导入使用：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  /**\n   * Console：\n   * 6\n   * 6\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就完成了 <code>exports</code> 与 <code>require</code> 的初次使用。</p>\n<p> <strong>方法二</strong>：</p>\n<p> 当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node 就很靠谱，它规范我们可以将这些文件都放在 <code>node_modules</code> 目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。</p>\n<p> 所以，我们在 <code>node_modules</code> 中新建一个 <code>03_tool-multiply.js</code> 文件，其内容如下：</p>\n<blockquote>\n<p>03_tool-multiply.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在引用方面，我们只需要通过：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\nconsole.log(tools2.multiply(1, 2, 3, 4));\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，就可以成功导入 <code>03_tool-multiply.js</code> 文件了。</p>\n<p> <strong>方法三</strong>：</p>\n<p> 如果全部单个文件丢在 <code>node_modules</code> 上，它会显得杂乱无章，所以我们应该定义个自己的模块：<code>jsliang-module</code>，然后将我们的 <code>tools.js</code> 存放在该目录中：</p>\n<blockquote>\n<p>jsliang-module/tools.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  },\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就定义好了自己的工具库。<br>\n 但是，如果我们通过 <code>var tools3 = require('jsliang-module');</code> 去导入，会发现它报 <code>error</code> 了，所以，我们应该在 <code>jsliang-module</code> 目录下，通过下面命令行生成一个 <code>package.json</code></p>\n<blockquote>\n<p>PS E:\\MyWeb\\node_modules\\jsliang-module> npm init --yes</p>\n</blockquote>\n<p> 这样，在 <code>jsliang-module</code> 中就有了 <code>package.json</code>。<br>\n 而我们在 <code>03_CommonJS.js</code> 就可以引用它了：</p>\n<blockquote>\n<p>03_CommonJS.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\n// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\n/**\n * 通过 package.json 来引用文件\n * 1. 通过在 jsliang-module 中 npm init --yes 来生成 package.json 文件\n * 2. package.json 文件中告诉了程序入口文件为 ：<span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"tools.js\"</span>,\n * 3. Node 通过 require 查找 jsliang-module，发现它有个 package.json\n * 4. Node 执行 tools.js 文件\n */\nvar tools3 = require(<span class=\"hljs-string\">'jsliang-module'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  console.log(tools2.multiply(1, 2, 3, 4));\n  console.log(tools3.add(4, 5, 6));\n  /**\n   * Console：\n   * 6\n   * 24\n   * 15\n   * 6\n   * 24\n   * 15\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 到此，我们就通过三种方法，了解了各种 <code>exports</code> 和 <code>require</code> 的姿势以及 Node 模块化的概念啦~</p>\n<p> 参考文献：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/littlebirdlbw/p/5670633.html\" rel=\"nofollow noopener noreferrer\">CommonJS 规范 | 博客园 - Little Bird</a></li>\n<li><a target=\"_blank\" href=\"http://www.cnblogs.com/chenguangliang/p/5856701.html\" rel=\"nofollow noopener noreferrer\">js模块化编程之彻底弄懂CommonJS和AMD/CMD！ | 博客园 - 方便以后复习</a></li>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/ghostwu/p/7298462.html\" rel=\"nofollow noopener noreferrer\">[js高手之路] es6系列教程 - 不定参数与展开运算符(...) | 博客园 - ghostwu</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-9\"><a id=\"chapter-three-four\" name=\"chapter-three-four\">3.4 包与 npm</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-four\">返回目录</a></p>\n</blockquote>\n<p> Node 中除了它自己提供的核心模块之外，还可以自定义模块，以及使用 <strong>第三方模块</strong>。<br>\n Node 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4863f64fe3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"822\" data-height=\"468\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"822\" height=\"468\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 那么，假如我们需要使用一些第三方模块，应该去哪找呢？</p>\n<ol>\n<li><a target=\"_blank\" href=\"https://www.baidu.com\" rel=\"nofollow noopener noreferrer\">百度</a>。百度查找你需要安装的第三方模块的对应内容。</li>\n<li><a target=\"_blank\" href=\"https://www.npmjs.com/\" rel=\"nofollow noopener noreferrer\">npm 官网</a>。如果你已经知道包的名字或者包的作用。那么，直接在 npm 官网上搜索，想必会更快找到想要安装的包。</li>\n</ol>\n<p> 那么，npm 是啥？<br>\n npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。<br>\n 在我们安装 Node 的时候，它默认会顺带给你安装 npm。</p>\n<ul>\n<li><code>npm -v</code>：查看 npm 版本。</li>\n<li><code>npm list</code>：查看当前目录下都安装了哪些 npm 包。</li>\n<li><code>npm info 模块</code>：查看该模块的版本及内容。</li>\n<li><code>npm i 模块@版本号</code>：安装该模块的指定版本。</li>\n</ul>\n<p> 在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识：</p>\n<ul>\n<li><code>i</code>/<code>install</code>：安装。使用 <code>install</code> 或者它的简写 <code>i</code>，都表明你想要下载这个包。</li>\n<li><code>uninstall</code>：卸载。如果你发现这个模块你已经不使用了，那么可以通过 <code>uninstall</code> 卸载它。</li>\n<li><code>g</code>：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。</li>\n<li><code>--save</code>/<code>-S</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>dependencies</code> 中。<code>dependencies</code> 是需要发布在生成环境的。例如：<code>ElementUI</code> 是部署后还需要的，所以通过 <code>-S</code> 形式来安装。</li>\n<li><code>--save-dev</code>/<code>-D</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>devDependencies</code> 中。<code>devDependencies</code> 只在开发环境使用。例如：<code>gulp</code> 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 <code>-D</code> 形式来安装。</li>\n</ul>\n<p> 例子：</p>\n<ul>\n<li><code>cnpm i webpack-cli -D</code></li>\n<li><code>npm install element-ui -S</code></li>\n</ul>\n<p> 那么，这么多的 npm 包，我们通过什么管理呢？<br>\n 答案是 <code>package.json</code>。<br>\n 如果我们需要创建 <code>package.json</code>，那么我们只需要在指定的包管理目录（例如 <code>node_modules</code>）中通过以下命名进行生成：</p>\n<ul>\n<li><code>npm init</code>：按步骤创建 <code>package.json</code>。</li>\n<li><code>npm init --yes</code>：快速创建 <code>package.json</code></li>\n</ul>\n<p> 当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm</p>\n<ul>\n<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-10\"><a id=\"chapter-three-five\" name=\"chapter-three-five\">3.5 fs 文件管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-five\">返回目录</a></p>\n</blockquote>\n<p> 本章节我们讲解下 fs 文件管理：</p>\n<blockquote>\n<p>如需快速找到下面某个内容，请使用 <code>Ctrl + F</code></p>\n</blockquote>\n<ol>\n<li><code>fs.stat</code> 检测是文件还是目录</li>\n<li><code>fs.mkdir</code> 创建目录</li>\n<li><code>fs.writeFile</code> 创建写入文件</li>\n<li><code>fs.appendFile</code> 追加文件</li>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n<li><code>fs.rename</code> 重命名</li>\n<li><code>fs.rmdir</code> 删除目录</li>\n<li><code>fs.unlink</code> 删除文件</li>\n</ol>\n<blockquote>\n<p>此章节文件目录：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4943495aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"228\" data-height=\"373\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"228\" height=\"373\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> <strong>首先</strong>，我们通过 <code>fs.stat</code> 检查一个读取的是文件还是目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  1. fs.stat\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\nfs.stat(<span class=\"hljs-string\">'index.js'</span>, (error, stats) => {\n  <span class=\"hljs-keyword\">if</span>(error) {\n    console.log(error);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(stats);\n    /**\n     * Console：\n     * Stats {\n     *  dev: 886875,\n     *  mode: 33206,\n     *  nlink: 1,\n     *  uid: 0,\n     *  gid: 0,\n     *  rdev: 0,\n     *  blksize: undefined,\n     *  ino: 844424931461390,\n     *  size: 284,\n     *  blocks: undefined,\n     *  atimeMs: 1542847157494,\n     *  mtimeMs: 1543887546361.2158,\n     *  ctimeMs: 1543887546361.2158,\n     *  birthtimeMs: 1542847157493.663,\n     *  atime: 2018-11-22T00:39:17.494Z,\n     *  mtime: 2018-12-04T01:39:06.361Z,\n     *  ctime: 2018-12-04T01:39:06.361Z,\n     *  birthtime: 2018-11-22T00:39:17.494Z }\n     */\n\n    console.log(`文件：<span class=\"hljs-variable\">${stats.isFile()}</span>`); \n    // Console：文件：<span class=\"hljs-literal\">true</span>\n    \n    console.log(`目录：<span class=\"hljs-variable\">${stats.isDirectory()}</span>`); \n    // Console：目录：<span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>Console</code> 打印出来的信息，我们基础掌握了 <code>fs.stat</code> 的作用。</p>\n<p> <strong>然后</strong>，我们尝试通过 <code>fs.mkdir</code> 创建目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  2. fs.mkdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.mkdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中多了一个 <code>css</code> 文件夹。</p>\n<p> <strong>那么</strong>，有创建就有删除，创建的目录如何删除呢？这里讲解下 <code>fs.rmdir</code>：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  8. fs.rmdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.rmdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中的 <code>css</code> 文件夹被删除了。</p>\n<p> <strong>接着</strong>，我们通过 <code>fs.writeFile</code> 来创建写入文件：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  3. fs.writeFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * filename (String) 文件名称\n * data (String | Buffer) 将要写入的内容，可以是字符串或者 buffer 数据。\n * · encoding (String) 可选。默认 <span class=\"hljs-string\">'utf-8'</span>，当 data 是 buffer 时，该值应该为 ignored。\n * · mode (Number) 文件读写权限，默认 438。\n * · flag (String) 默认值 <span class=\"hljs-string\">'w'</span>。\n * callback { Function } 回调，传递一个异常参数 err。\n */\nfs.writeFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'Hello jsliang'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">'写入成功！'</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加 <code>Hello jsliang</code> 这句话。即：存在即覆盖，不存在即创建。</p>\n<p> 有创建就有删除，感兴趣的可以使用 <code>fs.unlink</code> 进行文件的删除，再次不做过多讲解。</p>\n<p> <strong>既然</strong>，上面的是覆盖文件，那么有没有追加文件呢？有的，使用 <code>fs.appendFile</code> 吧：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">//  4. fs.appendFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\nfs.appendFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'这段文本是要追加的内容'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"追加成功\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们就成功往里面追加了一段话，从而使 <code>index.js</code> 变成了：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">Hello jsliang这段文本是要追加的内容\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>在上面</strong>，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了：</p>\n<ul>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n</ul>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 5. fs.readFile\nfs.readFile(<span class=\"hljs-string\">'index.js'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取文件成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取文件成功！\n    // <Buffer 48 65 6c 6c 6f 20 6a 73 6c 69 61 6e 67 e8 bf 99 e6 ae b5 e6 96 87 e6 9c ac e6 98 af e8 a6 81 e8 bf bd e5 8a a0 e7 9a 84 e5 86 85 e5 ae b9>\n  }\n})\n\n// 6. fs.readdir 读取目录\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取目录成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取目录成功！\n    // [ <span class=\"hljs-string\">'03_tool-multiply.js'</span>, <span class=\"hljs-string\">'jsliang-module'</span> ]\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如上，我们成功做到了读取文件和读取目录。</p>\n<p> <strong>最后</strong>，我们再回顾一开始的目标：</p>\n<p><s>1. <code>fs.stat</code> 检测是文件还是目录</s><br>\n<s>2. <code>fs.mkdir</code> 创建目录</s><br>\n<s>3. <code>fs.writeFile</code> 创建写入文件</s><br>\n<s>4. <code>fs.appendFile</code> 追加文件</s><br>\n<s>5. <code>fs.readFile</code> 读取文件</s><br>\n<s>6. <code>fs.readdir</code> 读取目录</s><br>\n7. <code>fs.rename</code> 重命名<br>\n<s>8. <code>fs.rmdir</code> 删除目录</s><br>\n<s>9. <code>fs.unlink</code> 删除文件</s></p>\n<p> 很好，我们就剩下重命名了：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"重命名成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 当然，如果 <code>fs.rename</code> 还有更劲爆的功能：剪切</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'jsliang.js'</span>, <span class=\"hljs-string\">'node_modules/jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"剪切成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> OK，通通搞定，现在目录变成了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4968b350f54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"231\" data-height=\"329\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"231\" height=\"329\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\"><a id=\"chapter-three-six\" name=\"chapter-three-six\">3.6 fs 案例</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-six\">返回目录</a></p>\n</blockquote>\n<p> 在上一章节中，我们了解了 <code>fs</code> 的文件管理。<br>\n 那么，在这里，我们尝试使用 <code>fs</code> 做点小事情：</p>\n<blockquote>\n<p>06_fsDemo.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">/**\n * 1. fs.stat 检测是文件还是目录\n * 2. fs.mkdir 创建目录\n * 3. fs.writeFile 创建写入文件\n * 4. fs.appendFile 追加文件\n * 5. fs.readFile 读取文件\n * 6. fs.readdir 读取目录\n * 7. fs.rename 重命名\n * 8. fs.rmdir 删除目录\n * 9. fs.unlink 删除文件\n */\n\n// 1. 判断服务器上面有没有 upload 目录，没有就创建这个目录\n// 2. 找出 html 目录下面的所有的目录，然后打印出来\n\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 图片上传\nfs.stat(<span class=\"hljs-string\">'upload'</span>, (err, stats) => {\n  // 判断有没有 upload 目录\n  <span class=\"hljs-keyword\">if</span>(err) {\n    // 如果没有\n    fs.mkdir(<span class=\"hljs-string\">'upload'</span>, (error) => {\n      <span class=\"hljs-keyword\">if</span>(error) {\n        console.log(error);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"创建 upload 目录成功！\"</span>);\n      }\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    // 如果有\n    console.log(stats.isDirectory());\n    console.log(<span class=\"hljs-string\">\"有 upload 目录，你可以做更多操作！\"</span>);\n  }\n})\n\n// 读取目录全部文件\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, files) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    // 判断是目录还是文件夹\n    console.log(files);\n\n    <span class=\"hljs-built_in\">let</span> filesArr = [];\n\n    (<span class=\"hljs-keyword\">function</span> getFile(i) {\n      \n      // 循环结束\n      <span class=\"hljs-keyword\">if</span>(i == files.length) {\n        // 打印出所有目录\n        console.log(<span class=\"hljs-string\">\"目录：\"</span>);\n        console.log(filesArr);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      // 判断目录是文件还是文件夹\n      fs.stat(<span class=\"hljs-string\">'node_modules/'</span> + files[i], (error, stats) => {\n\n        <span class=\"hljs-keyword\">if</span>(stats.isDirectory()) {\n          filesArr.push(files[i]);\n        }\n\n        // 递归调用\n        getFile(i+1);\n        \n      })\n    })(0)\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-12\"><a id=\"chapter-three-seven\" name=\"chapter-three-seven\">3.7 fs 流</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-seven\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，我们了解下 <code>fs</code> 流及其读取：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 新建 fs\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\n// 流的方式读取文件\n<span class=\"hljs-built_in\">let</span> fileReadStream = fs.createReadStream(<span class=\"hljs-string\">'index.js'</span>);\n// 读取次数\n<span class=\"hljs-built_in\">let</span> count = 0;\n// 保存数据\n<span class=\"hljs-built_in\">let</span> str = <span class=\"hljs-string\">''</span>;\n// 开始读取\nfileReadStream.on(<span class=\"hljs-string\">'data'</span>, (chunk) => {\n  console.log(`<span class=\"hljs-variable\">${++count}</span> 接收到：<span class=\"hljs-variable\">${chunk.length}</span>`);\n  // Console：1 接收到：30\n  str += chunk;\n})\n// 读取完成\nfileReadStream.on(<span class=\"hljs-string\">'end'</span>, () => {\n  console.log(<span class=\"hljs-string\">\"——结束——\"</span>);\n  console.log(count);\n  console.log(str);\n\n  // Console：——结束——\n  // 1\n  // console.log(<span class=\"hljs-string\">\"Hello World！\"</span>);\n})\n// 读取失败\nfileReadStream.on(<span class=\"hljs-string\">'error'</span>, (error) => {\n  console.log(error);\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，我们通过 <code>fs</code> 模块的 <code>createReadStream</code> 创建了读取流，然后读取文件 <code>index.js</code>，从而最后在控制台输出了：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">1 接收到：259\n——结束——\n1\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 其中 <code>console.log()</code> 那三行就是 <code>index.js</code> 的文本内容。</p>\n<p> 然后，我们试下流的存入：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-built_in\">let</span> data = <span class=\"hljs-string\">'console.log(\"Hello World! 我要存入数据！\")'</span>;\n\n// 创建一个可以写入的流，写入到文件 index.js 中\n<span class=\"hljs-built_in\">let</span> writeStream = fs.createWriteStream(<span class=\"hljs-string\">'index.js'</span>);\n// 开始写入\nwriteStream.write(data, <span class=\"hljs-string\">'utf8'</span>);\n// 写入完成\nwriteStream.end();\nwriteStream.on(<span class=\"hljs-string\">'finish'</span>, () => {\n  console.log(<span class=\"hljs-string\">'写入完成！'</span>);\n  // Console：写入完成\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们打开 <code>index.js</code>，会发现里面的内容变成了 <code>console.log(\"Hello World! 我要存入数据！\")</code>，依次，我们通过流的形式进行了读取和写入的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-13\"><a id=\"chapter-three-eight\" name=\"chapter-three-eight\">3.8 创建 Web 服务器</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eight\">返回目录</a></p>\n</blockquote>\n<p> 在这里，我们利用 http 模块、url 模块、path 模块、fs 模块创建一个 Web 服务器。</p>\n<p> 什么是 Web 服务器？<br>\n Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。</p>\n<p> 下面，我们使用 Node 来创建一个 Web 服务：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db499027a9b6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"240\" data-height=\"580\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"240\" height=\"580\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\nhttp.createServer((req, res) => {\n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        \n        // 如果不存在这个文件\n        \n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(<span class=\"hljs-string\">'./08_WebService/404.html'</span>, (errorNotFound, dataNotFound) => {\n          <span class=\"hljs-keyword\">if</span>(errorNotFound) {\n            console.log(errorNotFound);\n          } <span class=\"hljs-keyword\">else</span> {\n            res.writeHead(200, {\n              <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n            });\n            // 读取写入文件\n            res.write(dataNotFound);\n            // 结束响应\n            res.end();\n          }\n        })\n        <span class=\"hljs-built_in\">return</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n\n        // 返回这个文件\n        \n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，我们在浏览器输入 <code>localhost:8080</code> 即可以看到：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db49cdf6207cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1220\" data-height=\"1080\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1220\" height=\"1080\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，感情它就加载了整个 <code>index.html</code> 文件，连 CSS 这些没引入么？<br>\n 所以，下一步，我们要动态加载 <code>html</code>、<code>css</code> 以及 <code>js</code>：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  switch(extName) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.html'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.css'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/css'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.js'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/js'</span>;\n    default: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 这样，当我们再次请求的时候，浏览器就变成了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4a2ba76f9ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"720\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"720\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 当然，在上面，我们仅仅模拟了 <code>html</code>、<code>css</code>、<code>js</code> 这三种文件类型而已，我们需要模拟更多的文件类型：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/blob/master/NodeBase/08_ext.json\" rel=\"nofollow noopener noreferrer\"> 08_ext.json</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"> 代码详情请点击上面的链接\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面的 <code>json</code> 文件中，我们定义了各种的文件类型，此刻文件目录如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4ab7f829e99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"236\" data-height=\"422\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"236\" height=\"422\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 这时候，我们需要修改下我们的 <code>js</code> 文件，让它适应多种请求响应了：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n        console.log(ext);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  // <span class=\"hljs-built_in\">read</span>File 是异步操作，所以需要使用 <span class=\"hljs-built_in\">read</span>FileSync\n  <span class=\"hljs-built_in\">let</span> data = fs.readFileSync(<span class=\"hljs-string\">'./08_ext.json'</span>);\n  <span class=\"hljs-built_in\">let</span> ext = JSON.parse(data.toString());\n  <span class=\"hljs-built_in\">return</span> ext[extName];\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们做了个简单的 Web 服务器。</p>\n<h3 class=\"heading\" data-id=\"heading-14\"><a id=\"chapter-three-night\" name=\"chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-night\">返回目录</a></p>\n</blockquote>\n<p> Java、PHP 或者 .NET 等服务端语言，会为每一个客户端的连接创建一个新的线程。<br>\n Node 不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。<br>\n 当有用户连接了，就会触发一个内部事件，通过非租塞 I/O、事件驱动机制，让 Node 程序宏观上也是并行的。<br>\n 使用 Node，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。</p>\n<p> 在这一章节中，主要解决：</p>\n<ol>\n<li>Node 的非阻塞 I/O 是什么？</li>\n<li>Node events 模块是什么？</li>\n</ol>\n<p> 首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"2\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 2\n * 3\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 但是，事与愿违。<br>\n 我们有时候，会执行一些异步方法（函数）：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\n// console.log(<span class=\"hljs-string\">\"2\"</span>);\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    console.log(<span class=\"hljs-string\">\"2\"</span>);\n  })\n}\ngetExt();\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 3\n * 2\n */\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在上面代码中，由于 <code>fs.readFile</code> 是 Node 的异步函数。所以，程序先执行了 1 和 3，最后才执行 <code>fs.readFile</code> 的 2 部分。</p>\n<blockquote>\n<p>在这里，可以看出 Node 不会因为一段代码的逻辑错误，从而导致其他代码无法运行。</p>\n</blockquote>\n<p> 这样子，就导致了一个问题：步骤 3 可能拿不到步骤 2 的执行结果了！这就是 Node 的非租塞性 I/O 驱动。<br>\n 那么，我们有没有办法解决这个问题呢？<br>\n 有的！</p>\n<ol>\n<li>通过回调函数</li>\n<li>通过 Node 的 <code>events</code> 模块</li>\n</ol>\n<p> 首先，我们通过回调函数来解决这个异步问题：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\ngetExt = (callback) => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    callback(data);\n  })  \n}\n\ngetExt( (result) => {\n  console.log(result.toString());\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过回调，我们可以将 <code>getExt</code> 的数据提取出来。</p>\n<p> 然后，我们通过 Node 的 <code>events</code> 模块来解决这个异步问题：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n/**\n * Node 事件循环：\n * 1. Node 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。\n * 2. Node 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。\n * 3. Node 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。\n */\n\n// 引入 events 模块\n<span class=\"hljs-built_in\">let</span> events = require(<span class=\"hljs-string\">\"events\"</span>);\n// 实例化事件对象\n<span class=\"hljs-built_in\">let</span> EventEmitter = new events.EventEmitter();\n\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    // 将 data 广播出去\n    EventEmitter.emit(<span class=\"hljs-string\">'data'</span>, data.toString());\n  })  \n};\n\ngetExt();\n\n// 监听 data\nEventEmitter.on(<span class=\"hljs-string\">'data'</span>, (ext) => {\n  console.log(ext);\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 在这里，<code>EventEmitter.on</code> 通过监听 <code>data</code> 的形式，获取了 <code>getExt</code> 内部的执行结果。<br>\n 如此，我们就了解了 Node 的 I/O 事件及 <code>events</code> 模块</p>\n<h3 class=\"heading\" data-id=\"heading-15\"><a id=\"chapter-three-ten\" name=\"chapter-three-ten\">3.10 get 与 post</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-ten\">返回目录</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4adefcf3363?imageslim\" data-width=\"970\" data-height=\"618\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"970\" height=\"618\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 加载 http 模块\nvar http = require(<span class=\"hljs-string\">'http'</span>);\n\n// 虚拟 SQL 读取出来的数据\nvar items = [];\n\n// 创建 http 服务\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  \n  // 设置跨域的域名，* 代表允许任意域名跨域\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  // 判断请求\n  switch (req.method) {\n    \n    // post 请求时，浏览器会先发一次 options 请求，如果请求通过，则继续发送正式的 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'OPTIONS'</span>:\n      res.statusCode = 200;\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n    \n      // 如果是 get 请求，则直接返回 items 数组\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'GET'</span>:\n      <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n      res.write(data);\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n      \n    // 如果是 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'POST'</span>:\n      <span class=\"hljs-built_in\">let</span> item = <span class=\"hljs-string\">''</span>;\n      // 读取每次发送的数据\n      req.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n        item += chunk;\n      });\n      // 数据发送完成\n      req.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 存入\n        item = JSON.parse(item);\n        items.push(item.item);\n        // 将数据返回到客户端\n        <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n        res.write(data);\n        res.end();\n      });\n      <span class=\"hljs-built_in\">break</span>;\n  }\n}).listen(3000)\n\nconsole.log(<span class=\"hljs-string\">'http server is start...'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们加载了 <code>http</code> 模块，并创建了服务。<br>\n <strong>然后</strong>，我们设置了跨域的处理方式，允许进行跨域。<br>\n <strong>接着</strong>，我们进行了请求的判断处理，由于只做简单演练，故只判断是 <code>get</code> 请求还是 <code>post</code> 请求。<br>\n <strong>最后</strong>，我们将请求的结果返回给客户端。</p>\n<p> 在上面，我们进行了后端 Node 的部署，那么前端页面要怎么做呢？</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-⌃-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>Node Web</title>\n\n</head>\n\n<body>\n\n  <div id=<span class=\"hljs-string\">\"app\"</span>>\n    <h1>Todo List</h1>\n    <ul>\n      <li v-for=<span class=\"hljs-string\">\"(item, index) in items\"</span> :key=<span class=\"hljs-string\">\"index\"</span>>{{ item }}</li>\n    </ul>\n    <input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> v-model=<span class=\"hljs-string\">\"item\"</span>>\n    <button @click=<span class=\"hljs-string\">\"postApi\"</span>>添加</button>\n  </div>\n\n  <!-- cdn 引用：Vue 和 Node -->\n  <script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"https://unpkg.com/axios/dist/axios.min.js\"</span>></script>\n  \n  <script>\n    new Vue({\n      el: document.getElementById(<span class=\"hljs-string\">'app'</span>),\n      data: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        <span class=\"hljs-built_in\">return</span> {\n          items: [],\n          item: <span class=\"hljs-string\">''</span>,\n        }\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-title\">created</span></span>() {\n        // 进入页面请求数据\n        axios.get(<span class=\"hljs-string\">'http://localhost:3000/'</span>).then(res => {\n          console.log(<span class=\"hljs-string\">\"\\n【API - get 数据】\"</span>);\n          console.log(res);\n          this.items = res.data;\n        }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err)\n        })\n      },\n      methods: {\n        // 点击按钮提交数据\n        <span class=\"hljs-function\"><span class=\"hljs-title\">postApi</span></span>() {\n          axios.post(<span class=\"hljs-string\">'http://localhost:3000/'</span>, {\n            item: this.item\n          }).then(res => {\n            console.log(<span class=\"hljs-string\">\"\\n【API - post 数据】\"</span>)\n            console.log(res);\n            this.items = res.data;\n          }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err)\n          })\n        }\n      }\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们通过 Vue 进行了布局，通过 Axios 进行了接口的请求。从而完成了对数据的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-16\"><a id=\"chapter-three-eleven\" name=\"chapter-three-eleven\">3.11 Node 连接 MySQL</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eleven\">返回目录</a></p>\n</blockquote>\n<blockquote>\n<p>关于 MySQL 的安装，可以查看 <strong>jsliang</strong> 写的：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">MySQL 安装及图形化工具</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们通过可视化工具进行表的设计：</p>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>age</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>然后</strong>，我们进行表的填充：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>jslliang</td>\n<td>23</td>\n</tr>\n<tr>\n<td>2</td>\n<td>梁峻荣</td>\n<td>23</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>接着</strong>，我们安装 Node 连接 MySQL 的包：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">npm i mysql -D\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>再来</strong>，我们编写 Node 的 <code>index.js</code>：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\nconnection.query(<span class=\"hljs-string\">'SELECT * FROM user'</span>, <span class=\"hljs-keyword\">function</span> (error, results, fields) {\n  <span class=\"hljs-keyword\">if</span> (error) throw error;\n  console.log(results);\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，打开该服务：</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">[ RowDataPacket { id: 1, name: <span class=\"hljs-string\">'jsliang'</span>, age: <span class=\"hljs-string\">'23'</span> },\n  RowDataPacket { id: 2, name: <span class=\"hljs-string\">'梁峻荣'</span>, age: <span class=\"hljs-string\">'23'</span> } ]\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们便完成了 Node 连接 MySQL。</p>\n<p> ———————华丽分割线———————</p>\n<p> 当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。</p>\n<p> 先看目录：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b034ab5dc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"178\" data-height=\"261\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"178\" height=\"261\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>新增表字段</strong></li>\n</ul>\n<blockquote>\n<p>add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\n<span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(id,name,age) VALUES(0,?,?)\"</span>;\n<span class=\"hljs-built_in\">let</span> addSqlParams = [<span class=\"hljs-string\">\"jsliang\"</span>, <span class=\"hljs-string\">\"23\"</span>];\n\nconnection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"新增成功：\"</span>);\n    console.log(res);\n  }\n});\n\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 我们只需要直接 <code>node add.js</code>，就能往数据库中新增数据了。</p>\n<ul>\n<li><strong>删除表字段</strong></li>\n</ul>\n<blockquote>\n<p>delete.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\nvar delSql = <span class=\"hljs-string\">'DELETE FROM user where id = 2'</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(delSql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"删除错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"删除成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>修改表字段</strong></li>\n</ul>\n<blockquote>\n<p>update.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> updateSql = <span class=\"hljs-string\">\"UPDATE user SET name = ?,age = ? WHERE Id = ?\"</span>;\n<span class=\"hljs-built_in\">let</span> updateSqlParams = [<span class=\"hljs-string\">\"LiangJunrong\"</span>, <span class=\"hljs-string\">\"23\"</span>, 1];\n\n// 连接 SQL 并实施语句\nconnection.query(updateSql, updateSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"修改错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"修改成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li><strong>查询表字段</strong></li>\n</ul>\n<blockquote>\n<p>read.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) throw err;\n  console.log(res);\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 以上，我们打通了 Node 与 MySQL 的壁垒，实现了数据的增删改查。</p>\n<h2 class=\"heading\" data-id=\"heading-17\"><a id=\"chapter-four\" name=\"chapter-four\">四 Web 实战 —— 企业官网</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-four\">返回目录</a></p>\n</blockquote>\n<p> 在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo 制作、ico 制作、icon 挑选等……</p>\n<p> 下面这些都是 <strong>jsliang</strong> 平时碰到的，小伙伴有需要的可以 mark 啦~</p>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.uugai.com/logoa/wenzi.php\" rel=\"nofollow noopener noreferrer\">logo 制作</a></li>\n<li><a target=\"_blank\" href=\"http://www.bitbug.net/\" rel=\"nofollow noopener noreferrer\">ico 制作</a></li>\n<li><a target=\"_blank\" href=\"https://www.iconfont.cn/home/index\" rel=\"nofollow noopener noreferrer\">icon 挑选</a></li>\n</ul>\n<p> 另外，由于 HTML 与 CSS 没什么好讲的，所以本章节的前提静态页面 <strong>jsliang</strong> 已经写好了，小伙伴们在学习前可以预先下载：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">本文静态页面代码地址</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-18\"><a id=\"chapter-four-one\" name=\"chapter-four-one\">4.1 编程环境</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-one\">返回目录</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们查看下我们的前端基本代码：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">地址</a></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b22a71f82d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1010\" data-height=\"340\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1010\" height=\"340\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 如上，我们仅需要了解 FrontEndCode 目录以及 NodeWeb 目录即可，其他目录为上面章节练习参考。</p>\n<p> <strong>然后</strong>，我们进行后端功能分析：</p>\n<ol>\n<li>留言板。用户点击 <strong>留言板</strong> 的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到 <strong>登录页</strong>；如果用户登录了，则显示 <strong>留言板页面</strong>。</li>\n</ol>\n<p> 在 <strong>留言板页面</strong> 中，存在两个接口：</p>\n<ul>\n<li><strong>获取留言内容</strong>：调取 <code>getMessage</code> 接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。</li>\n<li><strong>提交留言内容</strong>：调取 <code>sendMessage</code> 接口，将用户名、用户 id、留言内容发送给后端。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b629555859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1219\" data-height=\"828\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1219\" height=\"828\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol start=\"2\">\n<li>在 <strong>登录页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>登录</strong>：调取 <code>login</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4eac593083f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1180\" data-height=\"810\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1180\" height=\"810\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol start=\"3\">\n<li>在 <strong>注册页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>注册</strong>：调取 <code>register</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db50d7d913be2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1200\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1200\" height=\"800\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 由此，我们可以设计下前后端的接口结合：</p>\n<blockquote>\n<p>接口文档</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>类型</th>\n<th>参数</th>\n<th>返回信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getMessage</code>：获取留言信息</td>\n<td>get</td>\n<td>无参</td>\n<td>n 条记录：id(用户 id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间)</td>\n</tr>\n<tr>\n<td><code>sendMessage</code>：提交留言信息</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_message(用户留言内容)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>login</code>：登录</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>register</code>：注册</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>最后</strong>，我们进行 MySQL 数据库的表设计：</p>\n<blockquote>\n<p>user 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_password</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>message 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_message</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>varchar</td>\n<td>255</td>\n<td>外键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-19\"><a id=\"chapter-four-two\" name=\"chapter-four-two\">4.2 后端接口</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-two\">返回目录</a></p>\n</blockquote>\n<p> 在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个 <code>test</code> 文件夹，里面放一个 <code>index.html</code> 以及一个 <code>index.js</code> 来测试一下。</p>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">- text\n - index.html\n - index.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>首先</strong>，我们就 4.1 提到的接口，提前进行后端接口的设置：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// 连接 MySQL：先安装 npm i mysql -D\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'nodebase'</span>\n});\n// 开始连接\nconnection.connect();\n\n// 引入 http 模块：http 是提供 Web 服务的基础\nconst http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 url 模块：url 是对用户提交的路径进行解析\nconst url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 qs 模块：qs 是对路径进行 json 化或者将 json 转换为 string 路径\nconst qs = require(<span class=\"hljs-string\">\"querystring\"</span>);\n\n// 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 设置 cors 跨域\n  res.setHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"hljs-string\">\"*\"</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"POST\"</span>) { // 接口 POST 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【POST 形式】\"</span>);\n\n    // 获取前端发来的路由地址\n    <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    // 接收发送过来的参数\n    <span class=\"hljs-built_in\">let</span> tempResult = <span class=\"hljs-string\">\"\"</span>;\n\n    // 数据接入中\n    req.addListener(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n      tempResult += chunk;\n    });\n\n    // 数据接收完成\n    req.addListener(<span class=\"hljs-string\">\"end\"</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n      var result = JSON.stringify(qs.parse(tempResult));\n      console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n      console.log(result);\n\n      <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n      }\n      // 接口信息处理完毕\n    })\n    // 数据接收完毕\n\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"GET\"</span>) { // 接口 GET 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【GET 形式】\"</span>);\n\n    // 解析 url 接口\n    <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n      console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n      res.writeHead(200, {\n        <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n      });\n\n      res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n      res.end();\n    }\n\n  }\n\n}).listen(8888); // 监听的端口\n\n// 获取当前时间\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getNowFormatDate</span></span>() {\n  var date = new Date();\n  var year = date.getFullYear(); // 年\n  var month = date.getMonth() + 1; // 月\n  var strDate = date.getDate(); // 日\n  var hour = date.getHours(); // 时\n  var minute = date.getMinutes(); // 分\n  var second = date.getMinutes(); // 秒\n  <span class=\"hljs-keyword\">if</span> (month >= 1 && month <= 9) {\n    month = <span class=\"hljs-string\">\"0\"</span> + month;\n  }\n  <span class=\"hljs-keyword\">if</span> (strDate >= 0 && strDate <= 9) {\n    strDate = <span class=\"hljs-string\">\"0\"</span> + strDate;\n  }\n  // 返回 yyyy-mm-dd hh:mm:ss 形式\n  var currentdate = year + <span class=\"hljs-string\">\"-\"</span> + month + <span class=\"hljs-string\">\"-\"</span> + strDate + <span class=\"hljs-string\">\" \"</span> + hour + <span class=\"hljs-string\">\":\"</span> + minute + <span class=\"hljs-string\">\":\"</span> + second;\n  <span class=\"hljs-built_in\">return</span> currentdate;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 通过判断 <code>req.method</code> 属于 <code>GET</code> 还是 <code>POST</code> 形式，从而确定加载的接口：</p>\n<ul>\n<li>在 <code>POST</code> 中，判断是属于 <strong>提交留言信息</strong>、<strong>登录</strong> 还是 <strong>注册</strong>；</li>\n<li>在 <code>GET</code> 中，判断是不是 <strong>获取留言信息</strong>。</li>\n</ul>\n<p> <strong>同时</strong>，我们在其中定义了 MySQL 的连接以及一个 <code>getNowFormatDate</code> 用来获取当前时间，格式为：<code>2018-12-21 10:03:59</code></p>\n<p> <strong>然后</strong>，我们通过一个前端页面来演示我们的接口是否能使用：</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>演示代码</title>\n</head>\n\n<body>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"user\"</span>>用户名</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> id=<span class=\"hljs-string\">\"user\"</span>>\n  </div>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"password\"</span>>密&nbsp;&nbsp;&nbsp;码</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"password\"</span> id=<span class=\"hljs-string\">\"password\"</span>>\n  </div>\n  <div>\n    <button id=<span class=\"hljs-string\">\"register\"</span>>注册</button>\n  </div>\n\n  <script src=<span class=\"hljs-string\">\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      // 测试 get 接口\n      $.ajax({\n        url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n        <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n        data: {\n          username: <span class=\"hljs-string\">\"jsliang\"</span>\n        },\n        success: <span class=\"hljs-keyword\">function</span> (res) {\n          console.log(res);\n        },\n        error: <span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err);\n        }\n      })\n\n      $(<span class=\"hljs-string\">\"#register\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 测试 post 接口\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n          data: {\n            username: $(<span class=\"hljs-string\">\"#user\"</span>).val(),\n            password: $(<span class=\"hljs-string\">\"#password\"</span>).val()\n          },\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      })\n    });\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，并打开 <code>index.html</code>，通过 <code>F12</code> 控制台查看我们的接口是否正常：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db510727a4435?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"684\" data-height=\"662\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"684\" height=\"662\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这 4 个接口的设计了。</p>\n<blockquote>\n<p>如果小伙伴们觉得每次更新 Node 代码后，又要重启一遍 <code>node index.js</code> 觉得麻烦，可以通过 <code>supervisor</code> 来监听 Node 代码的改动，<code>supervisor</code> 的安装使用：<a href=\"#chapter-five-one\">supervisor</a></p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-20\"><a id=\"chapter-four-three\" name=\"chapter-four-three\">4.3 注册功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-three\">返回目录</a></p>\n</blockquote>\n<p> 很好，我们回到仿企业网站的页面上，准备编写接口以及丰富 Node 的接口。</p>\n<p> <strong>首先</strong>，我们开启前端和 Node 服务：</p>\n<ol>\n<li>\n<p>打开命令行/终端</p>\n</li>\n<li>\n<p>开启前端</p>\n</li>\n</ol>\n<ul>\n<li><code>cd FrontEndCode</code></li>\n<li><code>live-server</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>live-server</code>：<code>npm i live-server -g</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>开启后端</li>\n</ol>\n<ul>\n<li><code>cd NodeWeb</code></li>\n<li><code>supervisor index.js</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>supervisor</code>：<code>npm i supervisor -g</code></p>\n</blockquote>\n<p> <strong>然后</strong>，我们在注册页面通过点击事件来触发调接口：</p>\n<blockquote>\n<p>register.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>注册-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  <!-- 省略 body 中代码，有需要的请前往第四章开头下载查看全部代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#register-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val();\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val();\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          // 如果用户输入的没毛病，那就加载接口\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/register\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册成功，前往登录！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./login.html\"</span>;\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>) {\n                alert(<span class=\"hljs-string\">\"用户名已被注册！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，名额已满！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 如此，我们在用户点击 <strong>注册</strong> 按钮的时候，进行接口的调用，发送数据到了后端，如果成功了，那就弹窗，并跳转到登录页；如果没成功，就弹窗提示。</p>\n<p> <strong>接着</strong>，我们编写 Node，前端调用接口后，Node 判断这两个参数是否为空，如果不为空，则将数据存储到数据库。</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"注册失败，用户名为空。\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) { // 姓名过长\n    res.end(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) { // 密码过长\n    res.end(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 查询 user 表\n    // 使用 Promise 的原因是因为中间调用了两次数据库，而数据库查询是异步的，所以需要用 Promise。\n    new Promise( (resolve, reject) => {\n\n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n      \n      // 连接 SQL 并实施语句\n      connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n        \n        <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n          throw error1;\n        } <span class=\"hljs-keyword\">else</span> {\n          \n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n\n          // 将结果先去掉 RowDataPacket，再转换为 json 对象\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          // 判断姓名重复与否\n          <span class=\"hljs-built_in\">let</span> userNameRepeat = <span class=\"hljs-literal\">false</span>;\n          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> newRes) {\n            <span class=\"hljs-keyword\">if</span>(newRes[item].user_name == username) {\n              userNameRepeat = <span class=\"hljs-literal\">true</span>;\n            }\n          }\n\n          // 如果姓名重复\n          <span class=\"hljs-keyword\">if</span>(userNameRepeat) {\n            res.end(<span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(newRes.length > 300) { // 如果注册名额已满\n            res.end(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> { // 可以注册\n            resolve();\n          }\n          \n        }\n      });\n\n    }).then( () => {\n      \n      console.log(<span class=\"hljs-string\">\"\\n第二步：\"</span>);\n      \n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(user_name,user_password, time) VALUES(?,?,?)\"</span>;\n      <span class=\"hljs-built_in\">let</span> addSqlParams = [result.username, result.password, time];\n\n      // 连接 SQL 并实施语句\n      connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error2, response2) {\n        <span class=\"hljs-keyword\">if</span> (error2) { // 如果 SQL 语句错误\n          console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n          console.log(error2);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n          console.log(response2);\n\n          console.log(<span class=\"hljs-string\">\"\\n注册成功！\"</span>);\n\n          // 返回数据\n          res.write(JSON.stringify({\n            code: <span class=\"hljs-string\">\"0\"</span>,\n            message: <span class=\"hljs-string\">\"注册成功！\"</span>\n          }));\n\n          // 结束响应\n          res.end();\n        }\n      });\n\n    })\n    // Promise 结束\n  }\n  // 注册流程结束\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> <strong>最后</strong>，我们在查看下该功能是否成功：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5157604487c?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-21\"><a id=\"chapter-four-four\" name=\"chapter-four-four\">4.4 登录功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-four\">返回目录</a></p>\n</blockquote>\n<p> 在上面，我们完成了注册功能，那么相对来说，登录功能就容易通了，因为查询部分我们已经试过了一次。</p>\n<blockquote>\n<p>login.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>登录-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，有需要的小伙伴请在第四章前言部分下载代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#login-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val(); // 用户名\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val(); // 密码\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                sessionStorage.setItem(<span class=\"hljs-string\">\"id\"</span>, res.data.id);\n                sessionStorage.setItem(<span class=\"hljs-string\">\"userName\"</span>, res.data.userName);\n                alert(<span class=\"hljs-string\">\"登录成功！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./messageBoard.html\"</span>;\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"1\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码错误！\"</span>);\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"不存在该用户！\"</span>) {\n                alert(<span class=\"hljs-string\">\"不存在该用户！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 编写完前端的代码后，我们进行 Node 代码的编辑：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) {\n    res.end(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) {\n    res.end(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> { \n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user WHERE user_name  = '\"</span> + username + <span class=\"hljs-string\">\"'\"</span>;\n\n    // 连接 SQL 并实施语句\n    connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) {\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">if</span>(response1 == undefined || response1.length == 0) { // 不存在用户\n          res.end(<span class=\"hljs-string\">\"\\n不存在该用户！\"</span>);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> { // 存在用户\n          console.log(<span class=\"hljs-string\">\"\\n存在该用户！\"</span>);\n\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          <span class=\"hljs-keyword\">if</span>(newRes[0].user_password == password) { // 密码正确\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"0\"</span>,\n              message: <span class=\"hljs-string\">\"登录成功！\"</span>,\n              data: {\n                id: newRes[0].id,\n                userName: newRes[0].user_name\n              }\n            }));\n\n            res.end();\n          } <span class=\"hljs-keyword\">else</span> { // 密码错误\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"1\"</span>,\n              message: <span class=\"hljs-string\">\"登录失败，密码错误！\"</span>\n            }));\n\n            res.end();\n          }\n          // 判断密码正确与否完毕\n        }\n        // 存在用户处理结束\n      }\n    });\n  }\n  // 登录步骤结束\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 很好，前端和后端都编写完毕，是时候查验下功能是否实现了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db52440fdaf7f?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-22\"><a id=\"chapter-four-five\" name=\"chapter-four-five\">4.5 留言功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-five\">返回目录</a></p>\n</blockquote>\n<p> 现在，我们就剩下留言功能了，一鼓作气做好它吧！</p>\n<blockquote>\n<p>messageBoard.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\"><!-- 留言板 -->\n<!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>留言板-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，基础代码请前往本章节前言下载 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      \n      <span class=\"hljs-built_in\">let</span> userName = sessionStorage.getItem(<span class=\"hljs-string\">\"userName\"</span>);\n      <span class=\"hljs-built_in\">let</span> userId = sessionStorage.getItem(<span class=\"hljs-string\">\"id\"</span>);\n      \n      // 查询留言板\n      <span class=\"hljs-keyword\">if</span>(userName && userId) { // 如果有存储\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'get'</span>,\n          dataType: <span class=\"hljs-string\">'json'</span>,\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n            <span class=\"hljs-built_in\">let</span> li = ``;\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> res.data) {\n              li = li + `\n                <li>\n                  <span class=<span class=\"hljs-string\">\"text-warning font-bold\"</span>>☆ </span>\n                  <span class=<span class=\"hljs-string\">\"user-message\"</span>><span class=\"hljs-variable\">${res.data[item].user_message}</span></span>\n                  <span>—— </span>\n                  <span class=<span class=\"hljs-string\">\"user-name\"</span>><span class=\"hljs-variable\">${res.data[item].user_name}</span> [<span class=\"hljs-variable\">${res.data[item].user_id}</span>]</span>\n                  <span class=<span class=\"hljs-string\">\"message-time\"</span>><span class=\"hljs-variable\">${res.data[item].time}</span></span>\n                </li>\n              `;\n            }\n            $(<span class=\"hljs-string\">\"#message-board-ul\"</span>).append(li);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      } <span class=\"hljs-keyword\">else</span> { // 如果没有存储\n        window.location.href = <span class=\"hljs-string\">\"../login.html\"</span>;\n      }\n\n      // 提交留言\n      $(<span class=\"hljs-string\">\"#message-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-built_in\">let</span> messageText = $(<span class=\"hljs-string\">\"#message\"</span>).val()\n        <span class=\"hljs-keyword\">if</span>(!messageText) {\n          alert(<span class=\"hljs-string\">\"留言内容不能为空\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n          alert(<span class=\"hljs-string\">\"留言长度不能超过 140 位！\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/sendMessage\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              userid: userId,\n              username: userName,\n              message: messageText\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span>(res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"新增成功！\"</span>);\n                window.location.reload();\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err);\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n      })\n\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 接着编写下 Node 后端：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> id = result.userid; // id\n  <span class=\"hljs-built_in\">let</span> userName = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> messageText = result.message; // 留言内容\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span>(!messageText) {\n    res.end(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n    res.end(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO message(user_message, user_id, user_name, time) VALUES(?, ?, ?, ?)\"</span>;\n    <span class=\"hljs-built_in\">let</span> addSqlParams = [messageText, id, userName, time];\n\n    // 连接 SQL 并实施语句\n    connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"\\n新增成功！\"</span>);\n\n        // 返回数据\n        res.write(JSON.stringify({\n          code: <span class=\"hljs-string\">\"0\"</span>,\n          message: <span class=\"hljs-string\">\"新增成功！\"</span>\n        }));\n\n        // 结束响应\n        res.end();\n      }\n    })\n  }\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n\n\n\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n  // 解析 url 参数部分\n  <span class=\"hljs-built_in\">let</span> params = url.parse(req.url, <span class=\"hljs-literal\">true</span>).query;\n\n  console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n  console.log(params);\n\n  // 新增的 SQL 语句及新增的字段信息\n  <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM message\"</span>;\n\n  // 连接 SQL 并实施语句\n  connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n    <span class=\"hljs-keyword\">if</span> (error1) {\n      throw error1; \n    } <span class=\"hljs-keyword\">else</span> {\n      \n      <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n      console.log(newRes);\n\n      // 返回数据\n      res.write(JSON.stringify({\n        code: <span class=\"hljs-string\">\"1\"</span>,\n        message: <span class=\"hljs-string\">\"查询成功！\"</span>,\n        data: newRes\n      }));\n\n      // 结束响应\n      res.end();\n    }\n  });\n  // 查询完毕\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n  res.end();\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p> 敲完代码再看下功能是否实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5280acce0c8?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 综上，我们完成了所有的功能模块：注册、登录以及留言。</p>\n<h2 class=\"heading\" data-id=\"heading-23\"><a id=\"chapter-five\" name=\"chapter-five\">五 工具整合</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-five\">返回目录</a></p>\n</blockquote>\n<p> <strong>工欲善其事，必先利其器。</strong><br>\n 掌控好了工具，可以方便你更快地进行开发。</p>\n<h3 class=\"heading\" data-id=\"heading-24\"><a id=\"chapter-five-one\" name=\"chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-one\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.supervisord.org/\" rel=\"nofollow noopener noreferrer\">supervisor 官网</a></li>\n</ul>\n<p> 正如其官网所说，它是一个进行控制系统：</p>\n<ol>\n<li>安装插件：<code>npm i supervisor -g</code></li>\n<li>运行文件：<code>supervisor app.js</code></li>\n<li>查看运行：<code>localhost:3000</code></li>\n</ol>\n<p> 平时，我们 <code>node app.js</code> 后，当我们修改了 <code>app.js</code> 的内容，就需要关闭 node 命令行再执行 <code>node app.js</code>。<br>\n 而我们使用 <code>supervisor</code> 后，我们修改了 <code>app.js</code> 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。</p>\n<p> 关于这个工具，网上更详细的攻略有：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.jianshu.com/p/6d84e5efe99d\" rel=\"nofollow noopener noreferrer\">详细版：用Supervisor守护你的Node.js进程 | 简书 - Mike的读书季</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-25\"><a id=\"chapter-five-two\" name=\"chapter-five-two\">5.2 PM2 - Node 进程管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-two\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.npmjs.com/package/pm2\" rel=\"nofollow noopener noreferrer\">PM2 - npm</a></li>\n</ul>\n<p> PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>\n<p> 下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置：</p>\n<ol>\n<li>全局安装 PM2：<code>npm i pm2 -g</code></li>\n<li>监听应用：<code>pm2 start index.js</code></li>\n<li>查看所有进程：<code>pm2 list</code></li>\n<li>查看某个进程：<code>pm2 describe App name/id</code></li>\n<li>停止某个进程：<code>pm2 stop App name/id</code>。例如：</li>\n</ol>\n<blockquote>\n<p>先通过 <code>pm2 list</code> 查看：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>App name</th>\n<th>id</th>\n<th>status</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>0</td>\n<td>online</td>\n</tr>\n</tbody>\n</table>\n<p> 只需要执行 <code>pm2 stop index</code> 或者 <code>pm2 stop 0</code> 即可。</p>\n<ol start=\"6\">\n<li>停止所有进程：<code>pm2 stop all</code></li>\n<li>重启某个进程：<code>pm2 restart App name/id</code></li>\n<li>删除某个进程：<code>pm2 delete App name/id</code></li>\n</ol>\n<p> 如上，如果说我们的 <code>supervisor</code> 是监听单个进程的话，那么 <code>PM2</code> 就是监听多个进程。</p>\n<p> 更多攻略：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://pm2.io/doc/en/runtime/quick-start/?utm_source=pm2&utm_medium=website&utm_campaign=rebranding\" rel=\"nofollow noopener noreferrer\">PM2 官网</a></li>\n<li><a target=\"_blank\" href=\"https://www.jianshu.com/p/f640450bd120\" rel=\"nofollow noopener noreferrer\">PM2 用法简介 | 简书 - LeavesLife</a></li>\n<li><a target=\"_blank\" href=\"http://www.cnblogs.com/chyingp/p/pm2-documentation.html\" rel=\"nofollow noopener noreferrer\">PM2实用入门指南 | 博客园 - 程序猿小卡</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-26\"><a id=\"chapter-six\" name=\"chapter-six\">六 参考资料</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-six\">返回目录</a></p>\n</blockquote>\n<p> 在编写这篇文章的过程中，有一些参考资料是值得保留阅读的：</p>\n<ol>\n<li><strong>经典：该类值得我们研读</strong></li>\n</ol>\n<blockquote>\n<p>经典，就是随着时间流逝，它还是那么有参考价值。</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://nodejs.cn/api/\" rel=\"nofollow noopener noreferrer\">API 文档 | Node.js 中文网</a></li>\n<li><a target=\"_blank\" href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\" rel=\"nofollow noopener noreferrer\">Node.js 教程 | 菜鸟教程</a></li>\n<li><a target=\"_blank\" href=\"http://www.expressjs.com.cn/\" rel=\"nofollow noopener noreferrer\">Express 文档 | Express 中文网</a></li>\n</ul>\n<ol start=\"2\">\n<li><strong>尝试：该类值得我们参考借鉴</strong></li>\n</ol>\n<blockquote>\n<p>Node 基础模块</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/whiteMu/p/5986297.html\" rel=\"nofollow noopener noreferrer\">nodejs之querystring模块 | 博客园 - whiteMu</a></li>\n</ul>\n<blockquote>\n<p>Node 编写接口</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.php.cn/js-tutorial-406242.html\" rel=\"nofollow noopener noreferrer\">用Node编写RESTful API接口 | php 中文网 - 不言</a></li>\n</ul>\n<blockquote>\n<p>MySQL 学习</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.runoob.com/mysql/mysql-tutorial.html\" rel=\"nofollow noopener noreferrer\">MySQL 教程 | 菜鸟教程</a></li>\n</ul>\n<blockquote>\n<p>Node 连接数据库</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/by-dxm/p/6723039.html\" rel=\"nofollow noopener noreferrer\">node.js前后台交互示例 -- 使用node.js实现用户注册功能 | 博客园 - 返回主页 党兴明</a></li>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/bestjarvan/archive/2017/04/08/6680857.html\" rel=\"nofollow noopener noreferrer\">node.js实现简单的登录注册页面 - 博客园 - 返回主页 bestjarvan</a></li>\n</ul>\n<blockquote>\n<p>Node 仿 Express</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/tiantangyouzui/article/details/70184959\" rel=\"nofollow noopener noreferrer\">nodejs模块：简单http请求路由，仿express | CSDN - TTUZ</a></li>\n<li><a target=\"_blank\" href=\"http://www.html-js.com/article/1603\" rel=\"nofollow noopener noreferrer\">初学nodejs一：别被Express的API搞晕了 | 前端乱炖 - 飞天小黑神猪</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf227a751882516be2ec124\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（一） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf4e46a6fb9a049f153d2ae\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（二） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/wallaceyuan/yuan-express\" rel=\"nofollow noopener noreferrer\">仿 Express | Github - wallaceyuan</a></li>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/cckevincyh/article/details/78695177\" rel=\"nofollow noopener noreferrer\">Node.js 封装仿照 express 的路由 | CSDN - c.</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/BadWaka/node-express-middleware-study\" rel=\"nofollow noopener noreferrer\">学习node中express框架中间件的相关知识及实践 | Github - BadWaka</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-27\"><a id=\"chapter-seven\" name=\"chapter-seven\">七 线上部署</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-seven\">返回目录</a></p>\n</blockquote>\n<p> 关于线上部署及域名、服务器相关的配置，<strong>jsliang</strong> 在另外一篇文章有所交代：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">云服务器建站</a>。</p>\n<p> 如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 <strong>jsliang</strong> QQ：<code>1741020489</code> 咨询，下面是一些优惠推广：</p>\n<p> <strong>腾讯云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://cloud.tencent.com/redirect.php?redirect=1025&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console\" rel=\"nofollow noopener noreferrer\">新客户无门槛 2775 元代金券</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c70d0376e68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://cloud.tencent.com/redirect.php?redirect=1014&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console\" rel=\"nofollow noopener noreferrer\">12 月优惠低至 168 元/年</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c7d4e1ea4f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<br>\n<p> <strong>阿里云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">新用户云产品 1888 通用代金券</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c84a3c2cde4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"720\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"720\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">高性能云服务器 - 低至 293元/年</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c8c17693c71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1200\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1200\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买企业级云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/act/enterprise-discount.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">企业级高性能云服务器</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c934dada38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"90\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"90\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-28\"><a id=\"chapter-eight\" name=\"chapter-eight\">八 归纳总结</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-eight\">返回目录</a></p>\n</blockquote>\n<p> 综上，搞定一切！<br>\n 兴许在前面代码的摧残下，能看到这里的小伙伴已经寥寥无几了，但我坚信我该交代的基本都交代了，不该交代的也交代了~<br>\n 所以，如果小伙伴看完真觉得不错，那就点个赞或者给个 star 吧！你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<p> 如果小伙伴看完这里要评论的话，可以加个暗语：<code>Node 基础，***</code>，这样 <strong>jsliang</strong> 看到必回，哈哈~</p>\n<ul>\n<li>Node 基础，我完成了！</li>\n<li>Node 基础，我想说 jsliang 肯定还偷懒了，没写成最完美的，我不管我打赏了你赶紧给我完善下！</li>\n<li>……</li>\n</ul>\n<p> <strong>so, that's all, thanks~</strong></p>\n<p><em>-----------------------</em></p>\n<h2 class=\"heading\" data-id=\"heading-29\">后记</h2>\n<p><strong>撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5346ad6c037?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db537a115c675?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p><a href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\"><img style=\"border-width:0\" alt=\"知识共享许可协议\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167d9537f3e29c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"88\" data-height=\"31\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"88\" height=\"31\"></svg>\"></a><br><a><strong>jsliang</strong> 的文档库</a> 由 <a href=\"https://github.com/LiangJunrong/document-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">梁峻荣</a> 采用 <a href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br>基于<a href=\"https://github.com/LiangJunrong/document-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.om/LiangJunron…</a>上的作品创作。<br>本许可协议授权之外的使用权限可以从 <a href=\"https://creativecommons.org/licenses/by-nc-sa/2.5/cn/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">creativecommons.org/licenses/by…</a> 处获得。</p>\n</blockquote>\n",
      "id": "5i9rpf0nsqk0",
      "author": "jsliang",
      "title": "Node - 从0基础到实战企业官网",
      "baseClassName": "article-content"
    },
    {
      "content": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 383px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 38.690000000000005%;\"></div>\n<div class=\"image-view\" data-width=\"990\" data-height=\"383\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-dc3e11b3f475fa2e.png\" data-original-width=\"990\" data-original-height=\"383\" data-original-format=\"image/png\" data-original-filesize=\"19894\" class data-image-index=\"0\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/4479768-dc3e11b3f475fa2e.png?imageMogr2/auto-orient/strip|imageView2/2/w/990/format/webp\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。</p>\n<p>作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-db7a7390efe30040.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"5563\" class data-image-index=\"1\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/4479768-db7a7390efe30040.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><br>\n<p>Node.js 是名副其实的版本帝，版本更新确实很频繁，时间线如下。</p>\n\n<ul>\n<li>2013年，发布了0.10版本。</li>\n<li>2015年1月，发布了1.0.0版本（io.js）。</li>\n<li>2015年5月，发布了2.x版本（io.js）。</li>\n<li>2015年8月，发布了3.x版本（io.js）。</li>\n<li>2015年9月，Node.js基金会发布了5.0版本与io.js合并后的第一个版本。</li>\n<li>2015年10月，Node.js 5.2.0版本成为首个LTS（长期支持）版本。</li>\n<li>2015年年底，发布了5.2.4和5.5.0版本。</li>\n<li>2016年3月，发布了5.5.0 LTS版本和5.9.0 Stable稳定版本。</li>\n<li>2016年年底，6.0版本支持95%以上的ES6特性，7.0版本通过flag支持async函数，全面支持99%的ES6特性。</li>\n<li>2017年2月，发布了7.6版本，可以不通过flag使用async函数。</li>\n<li>2017年5月，发布了8.0版本，支持async Hooks，N-API等特性。</li>\n<li>2018年4月，发布了10.0版本，新增http2模块，将npm从v5.7更新到了v6，并且增强了对ESMModules的支持。</li>\n<li>2018年10月，发布了11.0版本，增加了多线程Worker Threads。</li>\n</ul>\n<p>整体上来说，Node.js的发展趋于稳定。成立Node.js基金会能够让Node.js在未来获得更好的开源社区支持；发布LTS版本意味着Node.js SDK API趋于稳定；频繁发布版本虽然被很多人诟病，但换个角度来看，这也是社区活跃的一个体现，如果大家真的看了Changelog，便会发现，新版本相比于旧版本只增加了一些小的改进，而且是边边角角的改进，也就是说，Node.js的核心代码已经非常稳定了，可以大规模使用。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-8d3ffb1d67e440e8.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9370\" class=\"image-loading\" data-image-index=\"2\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>Node.js在2009年横空出世，可以说靠异步特性获得了很大的性能优势。所有语言几乎没有能和它相比的。但是福祸相依，因为性能太出众，所以促使很多语言、编程模型都纷纷进行改进，比如产生了Go语言，比如PHP里的SWoole框架可以支持异步协程了，再比如鸟哥（惠新宸）对PHP的VM进行了改进，大家似乎都以不支持异步为耻。后来的故事大家都知道了，各种语言的性能都得到了提高。</p>\n<p><strong>那么在这种情况下，Node.js还有优势吗？</strong></p>\n<p><strong>在实现难易度上</strong>，Node.js除了异步流程控制稍复杂外，其他的都非常简单。比如在写法上，你可以选择编写面向过程、面向对象、函数式的程序。不要因为Node.js变化快，就觉得自己跟不上潮流。一般后端程序员转为Node.js开发人员时，几乎两周就能精通，这一点相比其他语言还是很有优势的。</p>\n<p><strong>在调优成本上，</strong>Node.js即使不进行优化，性能也非常好，另外，对Node.js进行优化也比其他语言更简单。</p>\n<p><strong>在学习成本上，</strong>Node.js是有优势的。学习其他语言，前后端至少要学两种以上，如果学习Node.js，你只需要学会JavaScript即可，可以少学一种语言。我想问，大前端离得开JavaScript吗？今日的前端还不够复杂吗？你真的有那么多精力学习更多语言吗？</p>\n<p>其实大家可以关注一下基于npm的开源生态，截至2019年3月，npm上已有超过94.7万个模块，“秒杀”无数竞品。npm是所有开源包管理中最强大的，我们说“更了不起的Node.js”，其实npm居功甚伟。</p>\n<p>下图展示了来自Module Counts的各个包管理模块的差异。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 388px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 55.36%;\"></div>\n<div class=\"image-view\" data-width=\"1716\" data-height=\"950\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-fff0fa3498d73e7a.png\" data-original-width=\"1716\" data-original-height=\"950\" data-original-format=\"image/png\" data-original-filesize=\"351318\" class=\"image-loading\" data-image-index=\"3\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">来自Module Counts的各个包管理模块的差异</div>\n</div><br>\n<p>npm生态是Node.js的优势，可是说“Node.js没有性能优势”真的对吗？这其实是对Node.js的误解。Node.js的性能依然很好，不断迭代的版本其实就是在提升性能。而且Node.js具有npm极其完善的生态，可谓性能与生态双剑合璧，这是无与伦比的。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-875fdcaacac12c28.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9307\" class=\"image-loading\" data-image-index=\"4\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>正因为异步特性，Node.jsAPI设计只能采用错误优先（Error-First）风格的回调约定，于是大家硬生生地把多层回调写成了回调地狱（callback hell），这时就有各种“黑粉”冒出来对Node.js进行攻击。</p>\n<p>但正是因为回调地狱是最差的实践，所以大家才不得不求变，于是Thunk函数、Promise/A+规范等相继出现。虽然Promise/A+规范不是那么完美，但对于解决回调地狱问题来说已经足够。而且Generator特性和Generator的执行环境co模块也被逐渐引入新的异步解决方案，使得异步在写法上越来越接近于同步。当async函数落地的时候，Node.js 已经站在了同C#、Python一样的高度上，大家还有什么理由攻击它呢？</p>\n<p>下面列举了Node.js支持的所有异步解决方案，并给出了推荐建议（5星为最高级别）。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 401px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 41.77%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"401\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-6064714bc727e611.png\" data-original-width=\"960\" data-original-height=\"401\" data-original-format=\"image/png\" data-original-filesize=\"95519\" class=\"image-loading\" data-image-index=\"5\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>从推荐指数可以看出，我们应首选async函数，但要注意版本问题，要使用最新的版本。其次就是Promise，它都能非常好地驾驭callback和async函数，尤其是在异常捕获、扩展上，具有明显的优势。</p>\n<p>有时，将一件事做到极致，也许能收获另一片天地。异步流程控制是Node.js编程的核心，掌握异步流程控制之后，Node.js中就只剩API需要学习了，后面会详细讲解。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-d20456ac536b3570.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9072\" class=\"image-loading\" data-image-index=\"6\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>自从ES6规范在Node.js中落地之后，整个Node.js开发领域都发生了翻天覆地的变化。从v0.10开始，Node.js中就逐渐加入了ES6特性，比如Node.js v0.12可以使用Generator，这也促使寻求异步流程控制的TJ Holowaychuk写出了co这个著名的模块，进而产生了Koa框架。但是在v5.0之前，必须通过flag才能开启Generator支持，因此Koa v1.0迟迟未发布，在Node.js v5.0发布后，Koa v1.0才发布。</p>\n<p>2015年，传统写法终结；2016年，变革写法开始兴起。其中核心变更是支持使用ES6语法编写Node.js代码。</p>\n<ul>\n<li>可以使用Node.js v5.x+里的ES6特性，如果想实现更高级的功能，可以使用Babel编译支持ES7特性，或者使用TypeScript。</li>\n<li>合理使用Standard或者xo模块代码风格约定。</li>\n<li>适当引入ES6语法，只要Node.js SDK内置支持的，都可以使用。</li>\n<li>大家要重视面向对象写法的使用，虽然ES6的面向对象机制不健全，但以后定会不断完善。面向对象对于大型软件开发更适合，这其实也是我推荐使用TypeScript的原因之一。</li>\n</ul>\n<p>下面对比了变革前后的技术栈选型，希望读者能够从中感受到其中的变化。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 571px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 47.78%;\"></div>\n<div class=\"image-view\" data-width=\"1195\" data-height=\"571\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-24815333363f00fa.png\" data-original-width=\"1195\" data-original-height=\"571\" data-original-format=\"image/png\" data-original-filesize=\"131982\" class=\"image-loading\" data-image-index=\"7\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<hr>\n<p><strong>本文选自《狼书（卷1）：更了不起的Node.js》一书。</strong><br>\n</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-e6b46ef89f933c7f.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"13945\" class=\"image-loading\" data-image-index=\"8\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p></p>\n<p>对于Node.js来说，在简化并发编程方面，用“了不起”来形容并不过分。Node.js在2009年横空出世时，确实是独一无二的。但在今天，已经10岁的Node.js有了更多、更广泛的应用场景，它的意义已经远远大于设计时的初衷了，用“更了不起”来形容并不过分。</p>\n<p><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\"></a></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 591px; max-height: 903px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 128.92999999999998%;\"></div>\n<div class=\"image-view\" data-width=\"591\" data-height=\"762\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-7b9f6a2dd12deb1a.jpg\" data-original-width=\"591\" data-original-height=\"762\" data-original-format=\"image/jpeg\" data-original-filesize=\"93434\" class=\"image-loading\" data-image-index=\"9\" style=\"cursor: zoom-in;\"></div>\n</div>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\"><div class=\"image-caption\">点击封面了解详情</div></a>\n</div><p></p>\n<p>本书以Node.js为主，讲解了Node.js的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过最新的Node.js和npm编写出更具前端特色、更具工程化优势的代码。本书还讲解了Node.js中最核心、最复杂的异步流程控制，展望了未来异步流程的发展方向，非常适合大前端领域及后端领域的测试、运维及软件开发从业者阅读、学习。</p>\n<p>愿本书够带你打开Node.js世界的大门，领略大前端领域璀璨的星光。</p>\n<p><strong>作 者 简 介</strong></p>\n<hr>\n<p>狼叔（网名i5ting），Node.js 技术布道者，“Node全栈”公众号作者，全栈技术实践者。曾就职于多家知名IT企业，从事前端开发、后端开发、数据分析等工作，目前负责公司内的Node.js开发和基础框架开发工作。</p>\n<p><strong>本 书 内 容</strong></p>\n<hr>\n<p>本书共分7章，每章的内容简介如下。</p>\n<p><strong>第1章 Node.js初识</strong></p>\n<p>本章介绍了Node.js的一些基础知识，包括什么是Node.js、Node.js和JavaScript的关系、Node.js的特点和应用场景等。</p>\n<p><strong>第2章 Node.js安装与入门</strong></p>\n<p>本章介绍了Node.js安装与使用的基本方法，包括3m（即nvm、nrm、npm）安装法、Node.js基础示例，以及编辑器和调试等内容。</p>\n<p><strong>第3章 更了不起的Node.js</strong></p>\n<p>本章更加详细地介绍了Node.js的各类应用场景，对Node.js的核心作用进行了概括与总结，还对如何成为全栈工程师提供了宝贵建议。</p>\n<p><strong>第4章 更好的Node.js</strong></p>\n<p>本章介绍了Node.js的各种写法，包括单线程与集群，以及各种优秀实践，包括ES语法、多模块管理器Lerna、npm的替代品Yarn等。</p>\n<p><strong>第5章 Node.js是如何执行的</strong></p>\n<p>本章介绍了Node.js的源码构建和调试过程，阐述了Node.js是如何执行的，还介绍了API的调用过程，以及事件循环机制。</p>\n<p><strong>第6章 模块与核心</strong></p>\n<p>本章介绍了Node.js中的CommonJS规范、SDK模块与核心技术，还对未来的ES6模块功能进行了预测与展望。</p>\n<p><strong>第7章 异步写法与流程控制</strong></p>\n<p>本章介绍了异步流程控制的演进过程、Node.js的核心异步写法，以及更好的异步流程控制机制，如Thunk、Promise、async函数等。</p>\n<p>本书中的各章在内容上基本是相互独立的，因此各位读者可以挑选自己感兴趣的章节阅读。这本书是“狼书”系列的第1卷，还有第2卷和第3卷稍后会和各位读者见面，内容涉及Web应用和性能优化等，搭配阅读，效果更好。</p>\n<p>即将出版：</p>\n<p>《狼书（卷2）：Node.js Web应用开发》<br>\n《狼书（卷3）：Node.js高级技术》</p>\n<p><strong>了解本书详情：<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\">京东</a>、<a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fproduct.dangdang.com%2F27880000.html\" target=\"_blank\">当当</a></strong></p>\n",
      "id": "1w0tcl55n2w0",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "baseClassName": "_2rhmJa"
    },
    {
      "content": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 350px; max-height: 350px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 100.0%;\"></div>\n<div class=\"image-view\" data-width=\"350\" data-height=\"350\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5720-96c4c01c641f597e.png\" data-original-width=\"350\" data-original-height=\"350\" data-original-format=\"image/png\" data-original-filesize=\"54806\" class data-image-index=\"0\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/5720-96c4c01c641f597e.png?imageMogr2/auto-orient/strip|imageView2/2/w/350/format/webp\"></div>\n</div>\n<div class=\"image-caption\">封面</div>\n</div>\n<blockquote>\n<p>千呼万唤始出来，犹抱琵琶生哪吒。</p>\n<p>真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。</p>\n</blockquote>\n<p>Node.js 作为近几年新兴的一种编程运行时，托 V8 引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++ 开发 Node.js 原生扩展的口子，让开发者进行项目开发时有了更多的选择。</p>\n<p>《Node.js：来一打 C++ 扩展》以 Chrome V8 的知识作为基础，配合 GYP 的一些内容，将教会大家如何使用 Node.js提供的一些 API 来编写其 C++ 的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN 以及与异步相关的 libuv 知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的 Node.js 以及 C++ 基础。</p>\n<p>阅读《Node.js：来一打 C++ 扩展》，相当于同时学习Chrome V8 开发、libuv 开发以及 Node.js 的原生 C++ 扩展开发知识，非常值得！</p>\n<p><strong>最后十分感谢包括 Node.js TSC 之一的 Anna、几位 Collaborator 以及各位业界的大佬帮忙写推荐语，感谢 @yorkie 大佬和 @justjavac 大佬帮忙作序。</strong></p>\n<h2>编辑推荐</h2>\n<p>《Node.js：来一打 C++ 扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍 Node.js 的包和模块规范开始，深入解析（包括但不限于剖析 Node.js 自身的源码） Node.js 的模块是如何在运行时被引入的，尤其是如何引入 C++ 模块的；接下来详细讲解了在什么时候、为何要编写 C++ 模块；借此契机，深入介绍了 Node.js 的基石 Chrome V8 和 libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以 Node.js 的 C++ 扩展为中心，衍生出对 Node.js 底层风光的层层剖析，最后再回归到如何编写 Node.js 的 C++ 扩展，一气呵成。读来酣畅淋漓，痛快不已！</p>\n<p>买这一本书相当于买了“Node.js 的底层风光、C++ 扩展编写”、“Chrome V8”和“libuv”三本书！</p>\n<p>读完本书后，你甚至能为 Node.js 自身的添砖加瓦做出非凡贡献。</p>\n<h2>购书链接</h2>\n<p><strong>目前在预售阶段，顺便蹭 618 活动。</strong></p>\n<ul>\n<li><a href=\"https://item.jd.com/12380404.html\" target=\"_blank\" rel=\"nofollow\">京东</a></li>\n<li><a href=\"https://detail.tmall.com/item.htm?id=571628730908&cat_id=2\" target=\"_blank\" rel=\"nofollow\">天猫</a></li>\n<li><a href=\"http://product.dangdang.com/25291814.html\" target=\"_blank\" rel=\"nofollow\">当当</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07DL8GHQC/ie=UTF8&qid=1528969734\" target=\"_blank\" rel=\"nofollow\">亚马逊</a></li>\n<li>\n<a href=\"https://book.douban.com/subject/30247892/\" target=\"_blank\" rel=\"nofollow\">豆瓣</a>（不算购书链接）</li>\n</ul>\n<h2>目录</h2>\n<pre class=\"line-numbers  language-jsx\"><code class=\"  language-jsx\"><span class=\"token number\">1</span> Node<span class=\"token punctuation\">.</span>js 的 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展前驱知识储备 <span class=\"token number\">1</span>\n<span class=\"token number\">1.1</span> Node<span class=\"token punctuation\">.</span>js 的模块机制 <span class=\"token number\">2</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.1</span> CommonJS 的模块规范 <span class=\"token number\">2</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js 的模块 <span class=\"token number\">4</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">9</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span> Node<span class=\"token punctuation\">.</span>js 的包机制 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.1</span> CommonJS 的包规范 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js <span class=\"token operator\">/</span> <span class=\"token constant\">NPM</span> 下的包 <span class=\"token number\">13</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.3</span> <span class=\"token constant\">NPM</span> 与 <span class=\"token constant\">CNPM</span> <span class=\"token number\">16</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">19</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">19</span>\n<span class=\"token number\">1.3</span> Node<span class=\"token punctuation\">.</span>js 依赖简介 <span class=\"token number\">20</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.1</span> Chrome <span class=\"token constant\">V8</span> <span class=\"token number\">20</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.2</span> libuv <span class=\"token number\">25</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.3</span> 其他依赖 <span class=\"token number\">28</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">30</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">30</span>\n<span class=\"token number\">1.4</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展开发的准备工作 <span class=\"token number\">31</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.1</span> 编辑器 <span class=\"token operator\">/</span> <span class=\"token constant\">IDE</span> <span class=\"token number\">31</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.2</span> node<span class=\"token operator\">-</span>gyp <span class=\"token number\">36</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.3</span> 其他构建工具 <span class=\"token number\">54</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">56</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">56</span>\n<span class=\"token number\">2</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块原理简析 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span> 为什么要写 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 比 JavaScript 解释器高效 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.2</span> 已有的 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 轮子 <span class=\"token number\">72</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">77</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">77</span>\n<span class=\"token number\">2.2</span> 什么是 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展 <span class=\"token number\">78</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块本质 <span class=\"token number\">78</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js 模块加载原理 <span class=\"token number\">80</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">102</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">103</span>\n<span class=\"token number\">3</span> Chrome <span class=\"token constant\">V8</span> 基础 <span class=\"token number\">104</span>\n<span class=\"token number\">3.1</span> Node<span class=\"token punctuation\">.</span>js 与 Chrome <span class=\"token constant\">V8</span> <span class=\"token number\">104</span>\n<span class=\"token number\">3.2</span> 基本概念 <span class=\"token number\">105</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.1</span> 内存机制 <span class=\"token number\">105</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.2</span> 隔离实例（Isolate） <span class=\"token number\">108</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.3</span> 上下文（Context） <span class=\"token number\">109</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.4</span> 脚本（Script） <span class=\"token number\">110</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">110</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">111</span>\n<span class=\"token number\">3.3</span> 句柄（Handle） <span class=\"token number\">111</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.1</span> 本地句柄（Local） <span class=\"token number\">112</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.2</span> 持久句柄（Persistent） <span class=\"token number\">115</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.3</span> 永生句柄（Eternal） <span class=\"token number\">119</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.4</span> 待实本地句柄（Maybe Local） <span class=\"token number\">119</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">121</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">121</span>\n<span class=\"token number\">3.4</span> 句柄作用域 <span class=\"token number\">121</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.1</span> 一般句柄作用域（Handle Scope） <span class=\"token number\">122</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.2</span> 可逃句柄作用域（Escapable Handle Scope） <span class=\"token number\">125</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">129</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">129</span>\n<span class=\"token number\">3.5</span> 上下文（Context） <span class=\"token number\">129</span>\n<span class=\"token number\">3.6</span> 模板（Template） <span class=\"token number\">133</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.1</span> 函数模板（Function Template） <span class=\"token number\">133</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.2</span> 对象模板（Object Template） <span class=\"token number\">138</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.3</span> 对象模板的访问器（Accessor）与拦截器（Interceptor） <span class=\"token number\">144</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.4</span> 对象模板的内置字段（Internal Field） <span class=\"token number\">175</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.5</span> 函数模板的继承（Inherit） <span class=\"token number\">183</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">188</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span> 常用数据类型 <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.1</span> 基值（Value） <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.2</span> 字符串（String） <span class=\"token number\">194</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.3</span> 数值类型 <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.4</span> 布尔类型（Boolean） <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.5</span> 对象（Object） <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.6</span> 函数（Function） <span class=\"token number\">200</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.7</span> 数组（Array） <span class=\"token number\">202</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.8</span> <span class=\"token constant\">JSON</span> 解析器 <span class=\"token number\">203</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.9</span> 函数回调信息（Function Callback Info） <span class=\"token number\">203</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.10</span> 函数返回值（Return Value） <span class=\"token number\">204</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.11</span> 隔离实例（Isolate） <span class=\"token number\">204</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.12</span> 小结 <span class=\"token number\">205</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.13</span> 参考资料 <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span> 异常机制 <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.1</span> <span class=\"token keyword\">try</span><span class=\"token operator\">-</span>catch <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.2</span> 抛出异常 <span class=\"token number\">209</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.3</span> 异常生成类（Exception） <span class=\"token number\">211</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">211</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">211</span>\n<span class=\"token number\">4</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展实战初探 <span class=\"token number\">212</span>\n<span class=\"token number\">4.1</span> binding<span class=\"token punctuation\">.</span>gyp <span class=\"token number\">212</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.1</span> 惊鸿一瞥 <span class=\"token number\">213</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.2</span> binding<span class=\"token punctuation\">.</span>gyp 基础结构 <span class=\"token number\">213</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.3</span> <span class=\"token constant\">GYP</span> 文件 <span class=\"token number\">214</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.4</span> 常用字段 <span class=\"token number\">221</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">228</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">228</span>\n<span class=\"token number\">4.2</span> 牛刀小试 <span class=\"token number\">229</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.1</span> 又是 Hello World <span class=\"token number\">229</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.2</span> 函数参数 <span class=\"token number\">232</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.3</span> 回调函数 <span class=\"token number\">234</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.4</span> 函数返回 <span class=\"token number\">238</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">239</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span> 循序渐进 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 与 JavaScript 类封装 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.2</span> 实例化 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 类封装对象的函数 <span class=\"token number\">250</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.3</span> 将 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 类封装对象传来传去 <span class=\"token number\">253</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.4</span> 进程退出钩子 <span class=\"token number\">255</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">259</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">259</span>\n<span class=\"token number\">5</span> Node<span class=\"token punctuation\">.</span>js 原生抽象——<span class=\"token constant\">NAN</span> <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span> Node<span class=\"token punctuation\">.</span>js 原生模块开发方式的变迁 <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.1</span> 以不变应万变 <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.2</span> 时代在召唤 <span class=\"token number\">261</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">267</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span> 基础开发 <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.1</span> 什么是 <span class=\"token constant\">NAN</span> <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.2</span> 安装和配置 <span class=\"token number\">269</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.3</span> 先睹为快——搭上<span class=\"token constant\">NAN</span> 的快车 <span class=\"token number\">270</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.4</span> 基础帮助函数和宏 <span class=\"token number\">276</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.5</span> 忽略 node_modules <span class=\"token number\">279</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">279</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span> JavaScript 函数 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.1</span> 函数参数类型 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.2</span> 函数声明 <span class=\"token number\">282</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.3</span> 函数设置 <span class=\"token number\">288</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">296</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span> 常用帮助类与函数 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.1</span> 句柄相关 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.2</span> 创建数据对象 <span class=\"token number\">298</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.3</span> 与数据对象“玩耍” <span class=\"token number\">300</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.4</span> 封装一个类 <span class=\"token number\">314</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.5</span> 异常处理 <span class=\"token number\">315</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">315</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span> <span class=\"token constant\">NAN</span> 中的异步机制 <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.1</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncQueueWorker <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.2</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Callback <span class=\"token number\">317</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.3</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncWorker <span class=\"token number\">317</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.4</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncProgressWorker <span class=\"token number\">323</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">327</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">327</span>\n<span class=\"token number\">6</span> 异步之旅——libuv <span class=\"token number\">328</span>\n<span class=\"token number\">6.1</span> 基础概念 <span class=\"token number\">329</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.1</span> 事件循环 <span class=\"token number\">330</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.2</span> 句柄（Handle）与请求（Request） <span class=\"token number\">333</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.3</span> 尝尝甜头 <span class=\"token number\">335</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">340</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">340</span>\n<span class=\"token number\">6.2</span> libuv 的跨线程编程基础 <span class=\"token number\">341</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.1</span> libuv 的线程 <span class=\"token number\">342</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.2</span> 同步原语（Synchronization Primitive） <span class=\"token number\">347</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.3</span> 工作队列 <span class=\"token number\">355</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">356</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span> 跨线程通信 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.1</span> uv_async_t 句柄 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.2</span> Watchdog 半成品实战解析 <span class=\"token number\">358</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.3</span> Watchdog 试运行 <span class=\"token number\">367</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">368</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">369</span>\n<span class=\"token number\">7</span> 实战——文件监视器 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span> 准备工作 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.1</span> 功能规划 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.2</span> 文件系统监听库——efsw <span class=\"token number\">373</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">376</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">376</span>\n<span class=\"token number\">7.2</span> 核心设计 <span class=\"token number\">376</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.1</span> <span class=\"token constant\">API</span> 设计 <span class=\"token number\">377</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.2</span> EFSWCore 的血肉之躯 <span class=\"token number\">377</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.3</span> EFSWCore 的灵魂 <span class=\"token number\">381</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">385</span>\n<span class=\"token number\">7.3</span> 编写JavaScript 类 <span class=\"token number\">386</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.1</span> 类的设计 <span class=\"token number\">386</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.2</span> 核心逻辑 <span class=\"token number\">388</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.3</span> 简单容错 <span class=\"token number\">391</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span> 进一步完善 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 代码的完善 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.2</span> JavaScript 代码的完善 <span class=\"token number\">398</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">400</span>\n<span class=\"token number\">8</span> 实战——现有包剖析 <span class=\"token number\">401</span>\n<span class=\"token number\">8.1</span> 字符串哈希模块——Bling Hashes <span class=\"token number\">401</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.1</span> 文件设定 <span class=\"token number\">402</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.2</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 源码剖析 <span class=\"token number\">403</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.3</span> JavaScript 源码剖析 <span class=\"token number\">408</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">409</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span> 类 Proxy 包——Auto Object <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.1</span> Proxy <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.2</span> Auto Object 使用范例 <span class=\"token number\">412</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.3</span> 代码剖析 <span class=\"token number\">415</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">424</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">424</span>\n<span class=\"token number\">9</span> <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span>——下一代 Node<span class=\"token punctuation\">.</span>js <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展开发方式 <span class=\"token number\">425</span>\n<span class=\"token number\">9.1</span> 浅尝辄止 <span class=\"token number\">426</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.1</span> 实现一个 Echo 函数 <span class=\"token number\">426</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.2</span> 尝试运行 <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span> 扩展 <span class=\"token number\">430</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.3</span> 向下兼容 <span class=\"token number\">431</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.4</span> <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span> Package——<span class=\"token constant\">C</span><span class=\"token operator\">++</span> 封装 <span class=\"token number\">433</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">433</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span> 基本数据类型与错误处理 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.1</span> 基本数据类型 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.2</span> 与作用域及生命周期相关的数据类型 <span class=\"token number\">435</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.3</span> 回调数据类型 <span class=\"token number\">438</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.4</span> 错误处理 <span class=\"token number\">439</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.5</span> 模块注册 <span class=\"token number\">441</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">442</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span> 对象与函数 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.1</span> 对象 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.2</span> 函数 <span class=\"token number\">448</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.3</span> 类的封装 <span class=\"token number\">453</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">455</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">455</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code><button class=\"VJbwyy\" type=\"button\" aria-label=\"复制代码\"><i aria-label=\"icon: copy\" class=\"anticon anticon-copy\"><svg viewBox=\"64 64 896 896\" focusable=\"false\" class=\"\" data-icon=\"copy\" width=\"1em\" height=\"1em\" fill=\"currentColor\" aria-hidden=\"true\"><path d=\"M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z\"/></svg></i></button></pre>\n<h2>推荐语</h2>\n<blockquote>\n<p>This book contains absolutely everything you need to know about how all the pieces of Node.js' C++ code work and interact, explaining the necessary concepts without needing prior knowledge about the internals of V8, libuv or other pieces of Node.js. It shows well how Node.js' own built-in modules are constructed using the APIs provided by V8, so that they are usable from JavaScript, and how you can create the same kind of modules from scratch.</p>\n<p>After having read this book, you will be able to write a production-quality, future-proof C++ extension for Node.js if you need to do that, or maybe even make changes Node.js itself if you're interested in that!</p>\n<p>这本书包含了所有你需要了解的有关于 Node.js C++ 代码是如何运行和交互的知识，解释了一些你不需要知道 V8 的内部机制就能理解的必要概念，另外该书还介绍了 libuv 以及其他一些内容的方方面面。这本书还展示了 Node.js 的内置模块是如何使用 V8 的 API 进行构建并在 JavaScript 层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。</p>\n<p>读完这本书，你将学到如何写出产品级质量的、面向未来的 Node.js C++ 扩展。感兴趣的话，你甚至可以对 Node.js 自身进行修改！</p>\n<p>——安娜·亨宁森（Anna Henningsen, addaleax），Node.js 技术指导委员会成员（Node.js TSC）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Node.js 不是第一个将 JavaScript 带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于 Node.js 适逢后端高并发潮流，巧妙结合 Reactor 模型和 JavaScript 所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合 JavaScript 和前端工程师的一套生态和工具链，Node.js 刚好成为前端 JavaScript 最易上手掌握的命令行环境。在 Node.js 发展这么火热之后，Node.js 的开发体验在不断提升，上手门槛也在不断降低。</p>\n<p>然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解 Node.js 的底层机制，去学习写一些 Node.js 的扩展。从 Node.js 的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。</p>\n<p>死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用 C++ 写一个扩展很有意思也很简单。作为 Node.js 工程师/爱好者的你，值得拥有本书。</p>\n<p>——曹力（ShiningRay），酷链科技 CEO，前暴走漫画 CTO，前糗事百科联合创始人，高级 Node.js 技术专家，《JavaScript 高级程序设计》译者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Native module is one of the most underappreciated features of Node.js. But even in the age of asm.js and WebAssembly, it is an irreplaceable part of the Node.js ecosystem due to its versatility and performance. XadillaX's book provides a refreshing introduction (or reintroduction), and is a must-read for all low-level Node.js engineers.</p>\n<p>原生模块是 Node.js 中最被低估的功能之一。因为它的性能和多样性，使其即使是在 asm.js 和 WebAssembly 时代，仍旧能作为 Node.js 生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js 工程师必读之物。</p>\n<p>——顾天骋（Timothy Gu），pug、ejs 前 Maintainer，Node.js Core Collaborator 之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>本书全面讲解了 V8、libuv 的原理并且手把手教你编写一打 Node.js 的 C++ 扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解 Node.js 的实现原理，除了熟读内置 API 文档之外，阅读这本书会是一个很好的选择。</p>\n<p>——雷宗民（老雷），《Node.js 实战》作者之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>这是一本角度刁钻的 Node.js 相关书籍，与市面上大多数的 Node.js 书籍定位不同。它借为 Node.js 开发 C++ 扩展为基石，顺带介绍了 Chrome V8 和 libuv 的内容，填补了市场上这一类书籍的空白，值得一读。</p>\n<p>——李启雷博士，趣链科技 CTO</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月一直把实战贯穿在整本书之内，无论是基础部分的 V8 练习，还是使用 Node.js 经典的 Addon 开发、用 NAN 来改写，或是 libuv 里的 WatchDog 案例、EFSW 的封装，甚至在第八章里还特意剖析了两个 C++ 模块，把之前讲解的基础知识部分综合起来，可以边学边练。</p>\n<p>这本《Node.js：来一打 C++ 扩展》，在如今追求大而全的时代，单纯的讲 Node.js 的某一个方面，而且讲的特别棒的书，真的难得。</p>\n<p>——刘琥（响马），西祠胡同创始人，fibjs 作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当你掌握了 Node.js 的上层使用，下一步进阶的方向就是研究 Node.js 的底层原理。本书为学习 Node.js 的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（Handle Scope）等概念直接来自于源码，对于阅读 Node.js 及 V8 的源码具有极高的参考价值。</p>\n<p>——潘旻琦（pmq20），Node.js 技术专家，Node.js Collaborator 之一，RubyConf 讲师之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>国内 Node.js 偏向于原理的书目前只有朴灵的《深入浅出 Node.js》一本，至今 4 年过去了，Node.js 已经从 v0.10 发展到 v9 版本，中间再没有这样的系统的有深度的书籍。</p>\n<p>很高兴死月的新书弥补了这一遗憾。本书以 C++ 为主线，涵盖 Node.js 最核心的 libuv 和 V8，对理解 Node.js 原理有极大的好处。当然最大的好处在于使用 C++ 编写 Node.js Addon 可以让 Node.js 有更广阔的应用空间。我们都知道 Node.js 擅长的是 I/O 密集型任务，对于 CPU 密集型运算这是极好的弥补。</p>\n<p>特别推荐大家阅读此书，Node.js 应用极其广泛的今天，使用 C++ 编写 Node.js Addon 是更出彩的部分，你值得拥有。</p>\n<p>——桑世龙（狼叔），StuQ 明星讲师，Node.js 技术布道者，《更了不起的 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月对 Node.js 底层机制有非常深入的了解。阅读本书，除了学习 C++ 扩展开发，还会跟随死月了解 V8、libuv，相信读后大家对于 Node.js 的理解会更上一层楼。</p>\n<p>——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>C++ 扩展其实是从外在，用 C++ 的角度去观察 Node.js 内在的形式。因为 Node.js 整个系统自身几乎就是构建在 C/C++ 之上的，只是内部称之为 built-in，在 user-land 则称之 Addon，它们本质上其实没有区别。死月凭借他在 C/C++ 的深厚积累，选择从 C++ 扩展作为突破口，带大家领略 Node.js 底层的风光，在书里，你能看到真正发挥巨大价值的 V8、libuv 亦是精彩纷呈。</p>\n<p>死月将 C++ 扩展写得这么透，我是服的。</p>\n<p>——田永强（朴灵），高级 Node.js 技术专家，《深入浅出 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>开发 C++ 扩展，可以扩充 Node.js 平台的本地 API，扩充 Node.js 应用的能力。这本书详细介绍了包括 libuv、V8 在内的各种必要知识，是该领域不可多得的好书。对 C++ 开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。</p>\n<p>——王文睿博士（Roger Wang），node-webkit 和 NW.js 项目创始人和维护者，因特尔软件架构师</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>清晰记得手写的第一个 Node.js C++ 扩展模块，在 Node.js 0.6.9 跑通的那种愉悦感。随着应用升级到 Node.js 0.8，依赖的 C++ 扩展模块无法安装编译成功，最后发现是 V8 的 API 变化导致不兼容，从此对 C++ 扩展模块产生抗拒。后来看到《Node.js：来一打 C++ 扩展》，从实现原理，到 V8 基础概念的一系列介绍，让我重新对 C++ 扩展模块产生兴趣。参考书里的实战例子，以及 NAN 的辅助下，现在编写一个跨 Node.js 版本的 C++ 扩展已经不是什么困难的事情。通过最后一章节，可以了解到 Node.js 官方的 N-API 计划，让 C++ 扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。</p>\n<p>——袁锋（fengmk2），Node.js 技术专家</p>\n</blockquote>\n",
      "id": "2tka21f8v9u0",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "baseClassName": "_2rhmJa"
    }
  ],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dafb263f265da5b9b80244d",
      "k": "juejin",
      "id": "42ou4p218z40",
      "author": "第一名的小蝌蚪",
      "title": "web前端面试总结(自认为还算全面哈哈哈哈哈！！！）",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h1 class=\"heading\" data-id=\"heading-0\">一、CSS问题</h1>\n<h4 class=\"heading\" data-id=\"heading-1\">1.flex布局</h4>\n<blockquote>\n<p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩\nflex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容..."
    },
    {
      "url": "https://juejin.im/post/5db5cf2e6fb9a02074738b25",
      "k": "juejin",
      "id": "5dagssi80f80",
      "author": "云中桥",
      "title": "小蝌蚪传记：200行代码实现前端无痕埋点",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>灰色的天</p>\n<p>妳的脸</p>\n<p>说分手的语气斩钉截铁</p>\n<p>小蝌蚪：“能不走吗”</p>\n<p>女神：“不能”</p>\n<p>小蝌蚪：“那个男人有什么好”</p>\n<p>女神：“他说话好听，长得帅，还有钱”</p>\n<p>小蝌蚪：“我没房没车没存款，但我有一颗爱妳的心”</p>\n<p>高富帅出现：“我有房有车有存款，我也有一颗爱她的心”</p>\n<p>小蝌蚪：“我能跑十公里去为她买宵夜”</p>\n<p>高富帅：“我开兰博基尼去为她买宵夜”</p>\n<p>小蝌蚪：“我一..."
    },
    {
      "url": "https://juejin.im/post/5db684ddf265da4d495c40e5",
      "k": "juejin",
      "id": "2zxb1dwpeok0",
      "author": "Void_0",
      "title": "「前端进阶」高性能渲染十万条数据(虚拟列表)",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做<code>长列表</code>。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>\n<p>在<a target=\"_blank\" href=\"https://juejin.im/post/5d76f469f265da03..."
    },
    {
      "url": "https://juejin.im/post/5db52dedf265da4d495c3fb8",
      "k": "juejin",
      "id": "3l7uk66lz100",
      "author": "voanit",
      "title": "基于vue+vant搭建H5通用架子",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h3 class=\"heading\" data-id=\"heading-0\">项目初衷</h3>\n<p>开发一个H5的通用架子，让前端同学开箱即用，迅速投入战斗。</p>\n<blockquote>\n<p>截止到2019-10-29 10:25，已经被fork了34次，如果您在使用过程中还希望能给我提<a target=\"_blank\" href=\"https://github.com/Ljhhhhhh/h5vue/issues\" rel=\"nofollow noopener noreferre..."
    },
    {
      "url": "https://juejin.im/post/5db66672f265da4d0e009aad",
      "k": "juejin",
      "id": "4bymoe296qi0",
      "author": "前端小智",
      "title": "VSCode前端必备插件，有可能你装了却不知道如何使用？",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>Visual Studio Code 是由微软开发的一款免费、跨平台的文本编辑器。由于其卓越的性能和丰富的功能，它很快就受到了大家的喜爱。</p>\n<p>就像大多数 IDE 一样，VSCode 也有一个扩展和主题市场，包含了数以千计质量不同的插件。下面我列出一些VSCode前端必备插件，并配有图文介绍，快来看看你是否都会使用呢？</p>\n<h2 class=\"heading\" data-id=\"heading-0\">VS Code 安装和汉化</h2>\n<p>下载地址：VS Code官网链..."
    },
    {
      "url": "https://juejin.im/post/5db62f1bf265da4d560906ab",
      "k": "juejin",
      "id": "4jxr194oaqk0",
      "author": "极客James",
      "title": "13 个 JS 数组精简技巧，一起来看看",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>作者：Duomly</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong>阿里云服务器很便宜火爆，今年比去年便宜，10.24~11.11购买是1年86元，3年229元，可以点击 下面链接进行参与：</strong>\n<a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBE..."
    },
    {
      "url": "https://juejin.im/post/5dafc91a6fb9a04e4047a713",
      "k": "juejin",
      "id": "58mvpog3e0g0",
      "author": "非著名程序猿",
      "title": "Vue登录注册-掘金可爱萌猫",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p><code>阅读时间预计5分钟,干货满满,记得点赞加收藏哦😄</code></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/23/16df7b4e851e3c18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"..."
    },
    {
      "url": "https://juejin.im/post/5db919816fb9a020333c362f",
      "k": "juejin",
      "id": "7cemnhisr380",
      "author": "前端劝退师",
      "title": "大前端团队代码规范",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h3 class=\"heading\" data-id=\"heading-0\">1 前言</h3>\n<p>随着团队人数的增加，每个人的代码编写喜好不同，代码风格也迥然不同。如果有一个大家的统一的愿意遵守的代码规范，肯定事半功倍，提高效率，避免代码<code>Review</code>和<code>重构</code>。</p>\n<p>其中一部分规则参考了 腾讯<code>alloyteam</code>团队的代码规范，如有错误，请指出，将会非常感谢。</p>\n<p>坚持好的代码风格规范，从你我做起..."
    },
    {
      "url": "https://juejin.im/post/5db10695e51d452a091fde90",
      "k": "juejin",
      "id": "j3zela7ct0g",
      "author": "voanit",
      "title": "现代浏览器观察者 Observer API  指南（新）",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>前段时间在研究前端异常监控/埋点平台的实现。</p>\n<p>在思考方案时，想到了浏览器自带的观察者以及页面生命周期API 。</p>\n<p>于是在翻查资料时意外发现，原来现代浏览器支持多达四种不同类型的观察者：</p>\n<ul>\n<li><code>Intersection Observer</code>，交叉观察者。</li>\n<li><code>Mutation Observer</code..."
    },
    {
      "url": "https://juejin.im/post/5db105a1f265da4d082b7d27",
      "k": "juejin",
      "id": "wmziflvzylc",
      "author": "于是乎_",
      "title": "“1024”竟然火于“羞羞”论坛？程序员节敢不敢一起来吐槽",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h1 data-id=\"heading-0\">程序员节起源</h1><p>程序员的工作我们都知道，编程嘛。但为什么程序员节要在1024呢？1024最早火起来是因为一个“不可描述”的论坛，那里的回帖机制是：新用户发过贴之后，过1024秒才能发一贴，如果没到1024秒就又发了一条，则帖子里只会显示1024。</p><p><br></p><p>久而久之，1024成为了在这个论坛中灌水的最常用词，再加上在计算机数学中，1024M=1GB，谐音为“一级棒”，引申为对帖子的肯定。<br></p><p>再后..."
    },
    {
      "url": "https://juejin.im/post/5da9c6b0e51d4524d67486e2",
      "k": "juejin",
      "id": "6cwrhcl51yc0",
      "author": "ikoala",
      "title": "前端工程师应该知道的yarn知识",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>yarn 是在工作中离不开的工具，但在工作中，很多人基本只会使用 <code>yarn install</code>，而且会手动删除 <code>node-modules</code>，或删除 <code>yarn.lock</code> 文件等不规范操作。本文将从一些基础的知识点开始介绍，循序渐进的让你对 <code>Yarn</code> 有一个更深入的了解，来保证规范的使用yarn，避免一些隐藏bug的产生。<br>\n本文主要介绍以下知识：</p>\n<blockquote>\n<ol>..."
    }
  ]
}