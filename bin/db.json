{
  "searchResList": [
    {
      "id": "7k4zj2zx9cc0",
      "author": "博文视点",
      "time": "\n            3 个月前\n          ",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "url": "https://www.jianshu.com/p/f3e10a011381",
      "detail": "Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。Node.js是名副其实的版本帝，版本更新确实很频繁，时间线如下。2013年，发布了0.10版本。2015年1月，发布了1.0.0版本（io..."
    },
    {
      "id": "1bucirtj0bxc",
      "author": "機巧死月不會碼代碼",
      "time": "\n            1 年前\n          ",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "url": "https://www.jianshu.com/p/f8b105bb2b13",
      "detail": "封面千呼万唤始出来，犹抱琵琶生哪吒。真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。Node.js作为近几年新兴的一种编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++开发Node.js原生扩展的口子，让开发者进行项目开发时有了更多的选择。《Node.js：来一打C++扩展》以ChromeV8的知识作为基础，配合GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写..."
    },
    {
      "id": "j8bdd9963cg",
      "author": "越努力越幸运_952c",
      "time": "\n            2 年前\n          ",
      "title": "Node.js的线程和进程",
      "url": "https://www.jianshu.com/p/e8a7657b83b8",
      "detail": "很多Node.js初学者都会有这样的疑惑，Node.js到底是单线程的还是多线程的？通过本章的学习，能够让读者较为清晰的理解Node.js对于单/多线程的关系和支持情况。同时本章还将列举一些让Node.js的web服务器线程阻塞的例子，最后会提供Node.js碰到这类cpu密集型问题的解决方案。在学习本章之前，读者需要对Node.js有一个初步的认识，熟悉Node.js基本语法、cluster模块、child_process模块和express框架；接触过apache的http压力测试工具ab；..."
    },
    {
      "id": "4r7keh9d4bc0",
      "author": "全栈大前端",
      "time": "\n            4 个月前\n          ",
      "title": "为什么使用Node.js？逐个案例教程",
      "url": "https://www.jianshu.com/p/b5c58e0d9865",
      "detail": "专注全栈大前端，爱前端整理了一批2019年最新WEB前端教学视频，不论是零基础想要学习前端还是学完在工作想要提升自己，这些资料都会给你带来帮助，从HTML到各种框架，帮助所有想要学好前端的同学，学习规划、学习路线、学习资料、问题解答。只要加入全栈大前端学习交流Q群：137503198，即可免费获取。介绍JavaScript的日益普及带来了很多变化，而今天的Web开发面貌却截然不同。我们现在可以在服务器上运行JavaScript以及在浏览器中执行的操作几年前很难想象，或者封装在沙盒环境中，如Fla..."
    },
    {
      "source": "掘金",
      "id": "3ioysphfseo0",
      "author": "",
      "time": "3年前",
      "title": "Node入门 » 一本全面的Node.js教程",
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "detail": "关于本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“HelloWorld”的教程。状态你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。本书中的代码案例都在Node.js0.6.11版本中测试过，可以正确工作。读者对象本书最适合与我有相似技术背景的读者：至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaS..."
    },
    {
      "source": "掘金",
      "id": "33jyuyiifte0",
      "author": "sing1ee",
      "time": "1年前",
      "title": "Node 在有赞的实践",
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "detail": "一、概述4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在Node这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。二、Node基础框架的迭代与演进1.从Koa到阿童木（Astroboy）（1）Koa+中间件有赞最早的一个比较完整的Node项目是公司内部的一个管理系统，这个系统是用Node全栈开发的，主要包括一个给H..."
    },
    {
      "source": "掘金",
      "id": "3lj2nlpubna0",
      "author": "",
      "time": "9月前",
      "title": "Node - 从0基础到实战企业官网",
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "detail": "Createbyjsliangon2018-11-813:42:42Recentlyrevisedin2018-12-2321:59:20Hello小伙伴们，如果觉得本文还不错，记得点个赞或者给个star，你们的赞和star是我编写更多更精彩文章的动力！GitHub地址【2019-08-16】Hello小伙伴们，由于jsliang对文档库进行了重构，这篇文章的一些链接可能失效，而jsliang没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的GitHub地址，去文..."
    },
    {
      "source": "掘金",
      "id": "2r32jxn9cuw0",
      "author": "有赞技术",
      "time": "2年前",
      "title": "Node 爬虫入门",
      "url": "https://juejin.im/post/592ed10a2f301e00571966b2",
      "detail": "边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章为了验证“简书上，经验总结、资料归集类技术文章更容易上热榜”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的..."
    }
  ],
  "articleDetail": [
    {
      "id": "7k4zj2zx9cc0",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "content": "Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。Node.js是名副其实的版本帝，版本更新确实很频繁，时间线如下。2013年，发布了0.10版本。2015年1月，发布了1.0.0版本（io.js）。2015年5月，发布了2.x版本（io.js）。2015年8月，发布了3.x版本（io.js）。2015年9月，Node.js基金会发布了5.0版本与io.js合并后的第一个版本。2015年10月，Node.js5.2.0版本成为首个LTS（长期支持）版本。2015年年底，发布了5.2.4和5.5.0版本。2016年3月，发布了5.5.0LTS版本和5.9.0Stable稳定版本。2016年年底，6.0版本支持95%以上的ES6特性，7.0版本通过flag支持async函数，全面支持99%的ES6特性。2017年2月，发布了7.6版本，可以不通过flag使用async函数。2017年5月，发布了8.0版本，支持asyncHooks，N-API等特性。2018年4月，发布了10.0版本，新增http2模块，将npm从v5.7更新到了v6，并且增强了对ESMModules的支持。2018年10月，发布了11.0版本，增加了多线程WorkerThreads。整体上来说，Node.js的发展趋于稳定。成立Node.js基金会能够让Node.js在未来获得更好的开源社区支持；发布LTS版本意味着Node.jsSDKAPI趋于稳定；频繁发布版本虽然被很多人诟病，但换个角度来看，这也是社区活跃的一个体现，如果大家真的看了Changelog，便会发现，新版本相比于旧版本只增加了一些小的改进，而且是边边角角的改进，也就是说，Node.js的核心代码已经非常稳定了，可以大规模使用。Node.js在2009年横空出世，可以说靠异步特性获得了很大的性能优势。所有语言几乎没有能和它相比的。但是福祸相依，因为性能太出众，所以促使很多语言、编程模型都纷纷进行改进，比如产生了Go语言，比如PHP里的SWoole框架可以支持异步协程了，再比如鸟哥（惠新宸）对PHP的VM进行了改进，大家似乎都以不支持异步为耻。后来的故事大家都知道了，各种语言的性能都得到了提高。那么在这种情况下，Node.js还有优势吗？在实现难易度上，Node.js除了异步流程控制稍复杂外，其他的都非常简单。比如在写法上，你可以选择编写面向过程、面向对象、函数式的程序。不要因为Node.js变化快，就觉得自己跟不上潮流。一般后端程序员转为Node.js开发人员时，几乎两周就能精通，这一点相比其他语言还是很有优势的。在调优成本上，Node.js即使不进行优化，性能也非常好，另外，对Node.js进行优化也比其他语言更简单。在学习成本上，Node.js是有优势的。学习其他语言，前后端至少要学两种以上，如果学习Node.js，你只需要学会JavaScript即可，可以少学一种语言。我想问，大前端离得开JavaScript吗？今日的前端还不够复杂吗？你真的有那么多精力学习更多语言吗？其实大家可以关注一下基于npm的开源生态，截至2019年3月，npm上已有超过94.7万个模块，“秒杀”无数竞品。npm是所有开源包管理中最强大的，我们说“更了不起的Node.js”，其实npm居功甚伟。下图展示了来自ModuleCounts的各个包管理模块的差异。来自ModuleCounts的各个包管理模块的差异npm生态是Node.js的优势，可是说“Node.js没有性能优势”真的对吗？这其实是对Node.js的误解。Node.js的性能依然很好，不断迭代的版本其实就是在提升性能。而且Node.js具有npm极其完善的生态，可谓性能与生态双剑合璧，这是无与伦比的。正因为异步特性，Node.jsAPI设计只能采用错误优先（Error-First）风格的回调约定，于是大家硬生生地把多层回调写成了回调地狱（callbackhell），这时就有各种“黑粉”冒出来对Node.js进行攻击。但正是因为回调地狱是最差的实践，所以大家才不得不求变，于是Thunk函数、Promise/A+规范等相继出现。虽然Promise/A+规范不是那么完美，但对于解决回调地狱问题来说已经足够。而且Generator特性和Generator的执行环境co模块也被逐渐引入新的异步解决方案，使得异步在写法上越来越接近于同步。当async函数落地的时候，Node.js已经站在了同C#、Python一样的高度上，大家还有什么理由攻击它呢？下面列举了Node.js支持的所有异步解决方案，并给出了推荐建议（5星为最高级别）。从推荐指数可以看出，我们应首选async函数，但要注意版本问题，要使用最新的版本。其次就是Promise，它都能非常好地驾驭callback和async函数，尤其是在异常捕获、扩展上，具有明显的优势。有时，将一件事做到极致，也许能收获另一片天地。异步流程控制是Node.js编程的核心，掌握异步流程控制之后，Node.js中就只剩API需要学习了，后面会详细讲解。自从ES6规范在Node.js中落地之后，整个Node.js开发领域都发生了翻天覆地的变化。从v0.10开始，Node.js中就逐渐加入了ES6特性，比如Node.jsv0.12可以使用Generator，这也促使寻求异步流程控制的TJHolowaychuk写出了co这个著名的模块，进而产生了Koa框架。但是在v5.0之前，必须通过flag才能开启Generator支持，因此Koav1.0迟迟未发布，在Node.jsv5.0发布后，Koav1.0才发布。2015年，传统写法终结；2016年，变革写法开始兴起。其中核心变更是支持使用ES6语法编写Node.js代码。可以使用Node.jsv5.x+里的ES6特性，如果想实现更高级的功能，可以使用Babel编译支持ES7特性，或者使用TypeScript。合理使用Standard或者xo模块代码风格约定。适当引入ES6语法，只要Node.jsSDK内置支持的，都可以使用。大家要重视面向对象写法的使用，虽然ES6的面向对象机制不健全，但以后定会不断完善。面向对象对于大型软件开发更适合，这其实也是我推荐使用TypeScript的原因之一。下面对比了变革前后的技术栈选型，希望读者能够从中感受到其中的变化。本文选自《狼书（卷1）：更了不起的Node.js》一书。对于Node.js来说，在简化并发编程方面，用“了不起”来形容并不过分。Node.js在2009年横空出世时，确实是独一无二的。但在今天，已经10岁的Node.js有了更多、更广泛的应用场景，它的意义已经远远大于设计时的初衷了，用“更了不起”来形容并不过分。点击封面了解详情本书以Node.js为主，讲解了Node.js的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过最新的Node.js和npm编写出更具前端特色、更具工程化优势的代码。本书还讲解了Node.js中最核心、最复杂的异步流程控制，展望了未来异步流程的发展方向，非常适合大前端领域及后端领域的测试、运维及软件开发从业者阅读、学习。愿本书够带你打开Node.js世界的大门，领略大前端领域璀璨的星光。作者简介狼叔（网名i5ting），Node.js技术布道者，“Node全栈”公众号作者，全栈技术实践者。曾就职于多家知名IT企业，从事前端开发、后端开发、数据分析等工作，目前负责公司内的Node.js开发和基础框架开发工作。本书内容本书共分7章，每章的内容简介如下。第1章Node.js初识本章介绍了Node.js的一些基础知识，包括什么是Node.js、Node.js和JavaScript的关系、Node.js的特点和应用场景等。第2章Node.js安装与入门本章介绍了Node.js安装与使用的基本方法，包括3m（即nvm、nrm、npm）安装法、Node.js基础示例，以及编辑器和调试等内容。第3章更了不起的Node.js本章更加详细地介绍了Node.js的各类应用场景，对Node.js的核心作用进行了概括与总结，还对如何成为全栈工程师提供了宝贵建议。第4章更好的Node.js本章介绍了Node.js的各种写法，包括单线程与集群，以及各种优秀实践，包括ES语法、多模块管理器Lerna、npm的替代品Yarn等。第5章Node.js是如何执行的本章介绍了Node.js的源码构建和调试过程，阐述了Node.js是如何执行的，还介绍了API的调用过程，以及事件循环机制。第6章模块与核心本章介绍了Node.js中的CommonJS规范、SDK模块与核心技术，还对未来的ES6模块功能进行了预测与展望。第7章异步写法与流程控制本章介绍了异步流程控制的演进过程、Node.js的核心异步写法，以及更好的异步流程控制机制，如Thunk、Promise、async函数等。本书中的各章在内容上基本是相互独立的，因此各位读者可以挑选自己感兴趣的章节阅读。这本书是“狼书”系列的第1卷，还有第2卷和第3卷稍后会和各位读者见面，内容涉及Web应用和性能优化等，搭配阅读，效果更好。即将出版：《狼书（卷2）：Node.jsWeb应用开发》《狼书（卷3）：Node.js高级技术》了解本书详情：京东、当当",
      "time": "2019.06.2514:39:13"
    },
    {
      "id": "1bucirtj0bxc",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "content": "封面千呼万唤始出来，犹抱琵琶生哪吒。真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。Node.js作为近几年新兴的一种编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++开发Node.js原生扩展的口子，让开发者进行项目开发时有了更多的选择。《Node.js：来一打C++扩展》以ChromeV8的知识作为基础，配合GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写其C++的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN以及与异步相关的libuv知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的Node.js以及C++基础。阅读《Node.js：来一打C++扩展》，相当于同时学习ChromeV8开发、libuv开发以及Node.js的原生C++扩展开发知识，非常值得！最后十分感谢包括Node.jsTSC之一的Anna、几位Collaborator以及各位业界的大佬帮忙写推荐语，感谢@yorkie大佬和@justjavac大佬帮忙作序。编辑推荐《Node.js：来一打C++扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍Node.js的包和模块规范开始，深入解析（包括但不限于剖析Node.js自身的源码）Node.js的模块是如何在运行时被引入的，尤其是如何引入C++模块的；接下来详细讲解了在什么时候、为何要编写C++模块；借此契机，深入介绍了Node.js的基石ChromeV8和libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以Node.js的C++扩展为中心，衍生出对Node.js底层风光的层层剖析，最后再回归到如何编写Node.js的C++扩展，一气呵成。读来酣畅淋漓，痛快不已！买这一本书相当于买了“Node.js的底层风光、C++扩展编写”、“ChromeV8”和“libuv”三本书！读完本书后，你甚至能为Node.js自身的添砖加瓦做出非凡贡献。购书链接目前在预售阶段，顺便蹭618活动。京东天猫当当亚马逊豆瓣（不算购书链接）目录1Node.js的C++扩展前驱知识储备11.1Node.js的模块机制21.1.1CommonJS的模块规范21.1.2Node.js的模块41.1.3小结91.1.4参考资料91.2Node.js的包机制91.2.1CommonJS的包规范91.2.2Node.js/NPM下的包131.2.3NPM与CNPM161.2.4小结191.2.5参考资料191.3Node.js依赖简介201.3.1ChromeV8201.3.2libuv251.3.3其他依赖281.3.4小结301.3.5参考资料301.4C++扩展开发的准备工作311.4.1编辑器/IDE311.4.2node-gyp361.4.3其他构建工具541.4.4小结561.4.5参考资料562C++模块原理简析572.1为什么要写C++模块572.1.1C++比JavaScript解释器高效572.1.2已有的C++轮子722.1.3小结772.1.4参考资料772.2什么是C++扩展782.2.1C++模块本质782.2.2Node.js模块加载原理802.2.3小结1022.2.4参考资料1033ChromeV8基础1043.1Node.js与ChromeV81043.2基本概念1053.2.1内存机制1053.2.2隔离实例（Isolate）1083.2.3上下文（Context）1093.2.4脚本（Script）1103.2.5小结1103.2.6参考资料1113.3句柄（Handle）1113.3.1本地句柄（Local）1123.3.2持久句柄（Persistent）1153.3.3永生句柄（Eternal）1193.3.4待实本地句柄（MaybeLocal）1193.3.5小结1213.3.6参考资料1213.4句柄作用域1213.4.1一般句柄作用域（HandleScope）1223.4.2可逃句柄作用域（EscapableHandleScope）1253.4.3小结1293.4.4参考资料1293.5上下文（Context）1293.6模板（Template）1333.6.1函数模板（FunctionTemplate）1333.6.2对象模板（ObjectTemplate）1383.6.3对象模板的访问器（Accessor）与拦截器（Interceptor）1443.6.4对象模板的内置字段（InternalField）1753.6.5函数模板的继承（Inherit）1833.6.6小结1883.6.7参考资料1893.7常用数据类型1893.7.1基值（Value）1893.7.2字符串（String）1943.7.3数值类型1963.7.4布尔类型（Boolean）1963.7.5对象（Object）1963.7.6函数（Function）2003.7.7数组（Array）2023.7.8JSON解析器2033.7.9函数回调信息（FunctionCallbackInfo）2033.7.10函数返回值（ReturnValue）2043.7.11隔离实例（Isolate）2043.7.12小结2053.7.13参考资料2063.8异常机制2063.8.1try-catch2063.8.2抛出异常2093.8.3异常生成类（Exception）2113.8.4小结2113.8.5参考资料2114C++扩展实战初探2124.1binding.gyp2124.1.1惊鸿一瞥2134.1.2binding.gyp基础结构2134.1.3GYP文件2144.1.4常用字段2214.1.5小结2284.1.6参考资料2284.2牛刀小试2294.2.1又是HelloWorld2294.2.2函数参数2324.2.3回调函数2344.2.4函数返回2384.2.5小结2394.2.6参考资料2404.3循序渐进2404.3.1C++与JavaScript类封装2404.3.2实例化C++类封装对象的函数2504.3.3将C++类封装对象传来传去2534.3.4进程退出钩子2554.3.5小结2594.3.6参考资料2595Node.js原生抽象——NAN2605.1Node.js原生模块开发方式的变迁2605.1.1以不变应万变2605.1.2时代在召唤2615.1.3小结2675.1.4参考资料2675.2基础开发2675.2.1什么是NAN2675.2.2安装和配置2695.2.3先睹为快——搭上NAN的快车2705.2.4基础帮助函数和宏2765.2.5忽略node_modules2795.2.6小结2795.2.7参考资料2805.3JavaScript函数2805.3.1函数参数类型2805.3.2函数声明2825.3.3函数设置2885.3.4小结2965.3.5参考资料2965.4常用帮助类与函数2965.4.1句柄相关2965.4.2创建数据对象2985.4.3与数据对象“玩耍”3005.4.4封装一个类3145.4.5异常处理3155.4.6小结3155.4.7参考资料3165.5NAN中的异步机制3165.5.1Nan::AsyncQueueWorker3165.5.2Nan::Callback3175.5.3Nan::AsyncWorker3175.5.4Nan::AsyncProgressWorker3235.5.5小结3275.5.6参考资料3276异步之旅——libuv3286.1基础概念3296.1.1事件循环3306.1.2句柄（Handle）与请求（Request）3336.1.3尝尝甜头3356.1.4小结3406.1.5参考资料3406.2libuv的跨线程编程基础3416.2.1libuv的线程3426.2.2同步原语（SynchronizationPrimitive）3476.2.3工作队列3556.2.4小结3566.2.5参考资料3576.3跨线程通信3576.3.1uv_async_t句柄3576.3.2Watchdog半成品实战解析3586.3.3Watchdog试运行3676.3.4小结3686.3.5参考资料3697实战——文件监视器3707.1准备工作3707.1.1功能规划3707.1.2文件系统监听库——efsw3737.1.3小结3767.1.4参考资料3767.2核心设计3767.2.1API设计3777.2.2EFSWCore的血肉之躯3777.2.3EFSWCore的灵魂3817.2.4小结3857.3编写JavaScript类3867.3.1类的设计3867.3.2核心逻辑3887.3.3简单容错3917.3.4小结3937.4进一步完善3937.4.1C++代码的完善3937.4.2JavaScript代码的完善3987.4.3小结4008实战——现有包剖析4018.1字符串哈希模块——BlingHashes4018.1.1文件设定4028.1.2C++源码剖析4038.1.3JavaScript源码剖析4088.1.4小结4098.1.5参考资料4108.2类Proxy包——AutoObject4108.2.1Proxy4108.2.2AutoObject使用范例4128.2.3代码剖析4158.2.4小结4248.2.5参考资料4249N-API——下一代Node.jsC++扩展开发方式4259.1浅尝辄止4269.1.1实现一个Echo函数4269.1.2尝试运行N-API扩展4309.1.3向下兼容4319.1.4N-APIPackage——C++封装4339.1.5小结4339.1.6参考资料4339.2基本数据类型与错误处理4339.2.1基本数据类型4339.2.2与作用域及生命周期相关的数据类型4359.2.3回调数据类型4389.2.4错误处理4399.2.5模块注册4419.2.6小结4429.2.7参考资料4429.3对象与函数4429.3.1对象4429.3.2函数4489.3.3类的封装4539.3.4小结4559.3.5参考资料455推荐语ThisbookcontainsabsolutelyeverythingyouneedtoknowabouthowallthepiecesofNode.js'C++codeworkandinteract,explainingthenecessaryconceptswithoutneedingpriorknowledgeabouttheinternalsofV8,libuvorotherpiecesofNode.js.ItshowswellhowNode.js'ownbuilt-inmodulesareconstructedusingtheAPIsprovidedbyV8,sothattheyareusablefromJavaScript,andhowyoucancreatethesamekindofmodulesfromscratch.Afterhavingreadthisbook,youwillbeabletowriteaproduction-quality,future-proofC++extensionforNode.jsifyouneedtodothat,ormaybeevenmakechangesNode.jsitselfifyou'reinterestedinthat!这本书包含了所有你需要了解的有关于Node.jsC++代码是如何运行和交互的知识，解释了一些你不需要知道V8的内部机制就能理解的必要概念，另外该书还介绍了libuv以及其他一些内容的方方面面。这本书还展示了Node.js的内置模块是如何使用V8的API进行构建并在JavaScript层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。读完这本书，你将学到如何写出产品级质量的、面向未来的Node.jsC++扩展。感兴趣的话，你甚至可以对Node.js自身进行修改！——安娜·亨宁森（AnnaHenningsen,addaleax），Node.js技术指导委员会成员（Node.jsTSC）Node.js不是第一个将JavaScript带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于Node.js适逢后端高并发潮流，巧妙结合Reactor模型和JavaScript所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合JavaScript和前端工程师的一套生态和工具链，Node.js刚好成为前端JavaScript最易上手掌握的命令行环境。在Node.js发展这么火热之后，Node.js的开发体验在不断提升，上手门槛也在不断降低。然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解Node.js的底层机制，去学习写一些Node.js的扩展。从Node.js的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用C++写一个扩展很有意思也很简单。作为Node.js工程师/爱好者的你，值得拥有本书。——曹力（ShiningRay），酷链科技CEO，前暴走漫画CTO，前糗事百科联合创始人，高级Node.js技术专家，《JavaScript高级程序设计》译者NativemoduleisoneofthemostunderappreciatedfeaturesofNode.js.Butevenintheageofasm.jsandWebAssembly,itisanirreplaceablepartoftheNode.jsecosystemduetoitsversatilityandperformance.XadillaX'sbookprovidesarefreshingintroduction(orreintroduction),andisamust-readforalllow-levelNode.jsengineers.原生模块是Node.js中最被低估的功能之一。因为它的性能和多样性，使其即使是在asm.js和WebAssembly时代，仍旧能作为Node.js生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js工程师必读之物。——顾天骋（TimothyGu），pug、ejs前Maintainer，Node.jsCoreCollaborator之一本书全面讲解了V8、libuv的原理并且手把手教你编写一打Node.js的C++扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解Node.js的实现原理，除了熟读内置API文档之外，阅读这本书会是一个很好的选择。——雷宗民（老雷），《Node.js实战》作者之一这是一本角度刁钻的Node.js相关书籍，与市面上大多数的Node.js书籍定位不同。它借为Node.js开发C++扩展为基石，顺带介绍了ChromeV8和libuv的内容，填补了市场上这一类书籍的空白，值得一读。——李启雷博士，趣链科技CTO死月一直把实战贯穿在整本书之内，无论是基础部分的V8练习，还是使用Node.js经典的Addon开发、用NAN来改写，或是libuv里的WatchDog案例、EFSW的封装，甚至在第八章里还特意剖析了两个C++模块，把之前讲解的基础知识部分综合起来，可以边学边练。这本《Node.js：来一打C++扩展》，在如今追求大而全的时代，单纯的讲Node.js的某一个方面，而且讲的特别棒的书，真的难得。——刘琥（响马），西祠胡同创始人，fibjs作者当你掌握了Node.js的上层使用，下一步进阶的方向就是研究Node.js的底层原理。本书为学习Node.js的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（HandleScope）等概念直接来自于源码，对于阅读Node.js及V8的源码具有极高的参考价值。——潘旻琦（pmq20），Node.js技术专家，Node.jsCollaborator之一，RubyConf讲师之一国内Node.js偏向于原理的书目前只有朴灵的《深入浅出Node.js》一本，至今4年过去了，Node.js已经从v0.10发展到v9版本，中间再没有这样的系统的有深度的书籍。很高兴死月的新书弥补了这一遗憾。本书以C++为主线，涵盖Node.js最核心的libuv和V8，对理解Node.js原理有极大的好处。当然最大的好处在于使用C++编写Node.jsAddon可以让Node.js有更广阔的应用空间。我们都知道Node.js擅长的是I/O密集型任务，对于CPU密集型运算这是极好的弥补。特别推荐大家阅读此书，Node.js应用极其广泛的今天，使用C++编写Node.jsAddon是更出彩的部分，你值得拥有。——桑世龙（狼叔），StuQ明星讲师，Node.js技术布道者，《更了不起的Node.js》作者死月对Node.js底层机制有非常深入的了解。阅读本书，除了学习C++扩展开发，还会跟随死月了解V8、libuv，相信读后大家对于Node.js的理解会更上一层楼。——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长C++扩展其实是从外在，用C++的角度去观察Node.js内在的形式。因为Node.js整个系统自身几乎就是构建在C/C++之上的，只是内部称之为built-in，在user-land则称之Addon，它们本质上其实没有区别。死月凭借他在C/C++的深厚积累，选择从C++扩展作为突破口，带大家领略Node.js底层的风光，在书里，你能看到真正发挥巨大价值的V8、libuv亦是精彩纷呈。死月将C++扩展写得这么透，我是服的。——田永强（朴灵），高级Node.js技术专家，《深入浅出Node.js》作者开发C++扩展，可以扩充Node.js平台的本地API，扩充Node.js应用的能力。这本书详细介绍了包括libuv、V8在内的各种必要知识，是该领域不可多得的好书。对C++开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。——王文睿博士（RogerWang），node-webkit和NW.js项目创始人和维护者，因特尔软件架构师清晰记得手写的第一个Node.jsC++扩展模块，在Node.js0.6.9跑通的那种愉悦感。随着应用升级到Node.js0.8，依赖的C++扩展模块无法安装编译成功，最后发现是V8的API变化导致不兼容，从此对C++扩展模块产生抗拒。后来看到《Node.js：来一打C++扩展》，从实现原理，到V8基础概念的一系列介绍，让我重新对C++扩展模块产生兴趣。参考书里的实战例子，以及NAN的辅助下，现在编写一个跨Node.js版本的C++扩展已经不是什么困难的事情。通过最后一章节，可以了解到Node.js官方的N-API计划，让C++扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。——袁锋（fengmk2），Node.js技术专家",
      "time": "2018.06.1418:27:17"
    },
    {
      "id": "j8bdd9963cg",
      "author": "越努力越幸运_952c",
      "title": "Node.js的线程和进程",
      "content": "很多Node.js初学者都会有这样的疑惑，Node.js到底是单线程的还是多线程的？通过本章的学习，能够让读者较为清晰的理解Node.js对于单/多线程的关系和支持情况。同时本章还将列举一些让Node.js的web服务器线程阻塞的例子，最后会提供Node.js碰到这类cpu密集型问题的解决方案。在学习本章之前，读者需要对Node.js有一个初步的认识，熟悉Node.js基本语法、cluster模块、child_process模块和express框架；接触过apache的http压力测试工具ab；了解一般web服务器对于静态文件的处理流程。Node.js和PHP早期有很多关于Node.js争论的焦点都在它的单线程模型方面，在由JaniHartikainen写的一篇著名的文章《PHP优于Node.js的五大理由》中，更有一条矛头直接指向Node.js单线程脆弱的问题。如果PHP代码损坏，不会拖垮整个服务器。PHP代码只运行在自己的进程范围中，当某个请求显示错误时，它只对特定的请求产生影响。而在Node.js环境中，所有的请求均在单一的进程服务中，当某个请求导致未知错误时，整个服务器都会受到影响。Node.js和Apache+PHP还有一个非常不同的地方就是进程的运行时间长短，当然这一点也被此文作为一个PHP优于Node.js的理由来写了。PHP进程短暂。在PHP中，每个进程对请求持续的时间很短暂，这就意味着你不必为资源配置和内存而担忧。而Node.js的进程需要运行很长一段时间，你需要小心并妥善管理好内存。比如，如果你忘记从全局数据中删除条目，这会轻易的导致内存泄露。在这里我们并不想引起一次关于PHP和Node.js孰优孰劣的口水仗，PHP和Node.js各代表着一个互联网时代的开发语言，就如同我们讨论跑车和越野车谁更好一样，它们都有自己所擅长和适用的场景。我们可以通过下面这两张图深入理解一下PHP和Node.js对处理Http请求时的区别。PHP的模型：Node.js的模型：所以你在编写Node.js代码时，要保持清醒的头脑，任何一个隐藏着的异常被触发后，都会将整个Node.js进程击溃。但是这样的特性也为我们编写代码带来便利，比如同样要实现一个简单的网站访问次数统计，Node.js只需要在内存里定义一个变量varcount=0;，每次有用户请求过来执行count++;即可。varhttp=require('http');varcount=0;http.createServer(function(request,response){response.writeHead(200,{'Content-Type':'text/plain'});response.end((++count).toString())}).listen(8124);console.log('Serverrunningathttp://127.0.0.1:8124/');但是对于PHP来说就需要使用第三方媒介来存储这个count值了，比如创建一个count.txt文件来保存网站的访问次数。$counter_file=(\"count.txt\");$visits=file($counter_file);$visits[0]++;$fp=fopen($counter_file,\"w\");fputs($fp,\"$visits[0]\");fclose($fp);echo\"$visits[0]\";?>单线程的jsGoogle的V8Javascript引擎已经在Chrome浏览器里证明了它的性能，所以Node.js的作者RyanDahl选择了v8作为Node.js的执行引擎，v8赋予Node.js高效性能的同时也注定了Node.js和大名鼎鼎的Nginx一样，都是以单线程为基础的，当然这也正是作者RyanDahl设计Node.js的初衷。单线程的优缺点Node.js的单线程具有它的优势，但也并非十全十美，在保持单线程模型的同时，它是如何保证非阻塞的呢？高性能首先，单线程避免了传统PHP那样频繁创建、切换线程的开销，使执行速度更加迅速。第二，资源占用小，如果有对Node.js的web服务器做过压力测试的朋友可能发现，Node.js在大负荷下对内存占用仍然很低，同样的负载PHP因为一个请求一个线程的模型，将会占用大量的物理内存，很可能会导致服务器因物理内存耗尽而频繁交换，失去响应。线程安全单线程的js还保证了绝对的线程安全，不用担心同一变量同时被多个线程进行读写而造成的程序崩溃。比如我们之前做的web访问统计，因为单线程的绝对线程安全，所以不可能存在同时对count变量进行读写的情况，我们的统计代码就算是成百的并发用户请求都不会出现问题，相较PHP的那种存文件记录访问，就会面临并发同时写文件的问题。线程安全的同时也解放了开发人员，免去了多线程编程中忘记对变量加锁或者解锁造成的悲剧。单线程的异步和非阻塞Node.js是单线程的，但是它如何做到I/O的异步和非阻塞的呢？其实Node.js在底层访问I/O还是多线程的，有兴趣的朋友可以翻看Node.js的fs模块的源码，里面会用到libuv来处理I/O，所以在我们看来Node.js的代码就是非阻塞和异步形式的。阻塞/非阻塞与异步/同步是两个不同的概念，同步不代表阻塞，但是阻塞肯定就是同步了。举个现实生活中的例子，我去食堂打饭，我选择了A套餐，然后工作人员帮我去配餐，如果我就站在旁边，等待工作人员给我配餐，这种情况就称之为同步；若工作人员帮我配餐的同时，排在我后面的人就开始点餐，这样整个食堂的点餐服务并没有因为我在等待A套餐而停止，这种情况就称之为非阻塞。这个例子就简单说明了同步但非阻塞的情况。再如果我在等待配餐的时候去买饮料，等听到叫号再回去拿套餐，此时我的饮料也已经买好，这样我在等待配餐的同时还执行了买饮料的任务，叫号就等于执行了回调，就是异步非阻塞了。阻塞的单线程既然Node.js是单线程异步非阻塞的，是不是我们就可以高枕无忧了呢？还是拿上面那个买套餐的例子，如果我在买饮料的时候，已经叫我的号让我去拿套餐，可是我等了好久才拿到饮料，所以我可能在大厅叫我的餐号之后很久才拿到A套餐，这也就是单线程的阻塞情况。在浏览器中，js都是以单线程的方式运行的，所以我们不用担心js同时执行带来的冲突问题，这对于我们编码带来很多的便利。但是对于在服务端执行的Node.js，它可能每秒有上百个请求需要处理，对于在浏览器端工作良好的单线程js是否也能同样在服务端表现良好呢？我们看如下代码：varstart=Date.now();//获取当前时间戳setTimeout(function(){console.log(Date.now()-start);for(vari=0;i<1000000000;i++){//执行长循环}},1000);setTimeout(function(){console.log(Date.now()-start);},2000);最终我们的打印结果是：（结果可能因为你的机器而不同）10003738对于我们期望2秒后执行的setTimeout函数其实经过了3738毫秒之后才执行，换而言之，因为执行了一个很长的for循环，所以我们整个Node.js主线程被阻塞了，如果在我们处理100个用户请求中，其中第一个有需要这样大量的计算，那么其余99个就都会被延迟执行。其实虽然Node.js可以处理数以千记的并发，但是一个Node.js进程在某一时刻其实只是在处理一个请求。单线程和多核线程是cpu调度的一个基本单位，一个cpu同时只能执行一个线程的任务，同样一个线程任务也只能在一个cpu上执行，所以如果你运行Node.js的机器是像i5，i7这样多核cpu，那么将无法充分利用多核cpu的性能来为Node.js服务。多线程在C++、C#、python等其他语言都有与之对应的多线程编程，有些时候这很有趣，带给我们灵活的编程方式；但是也可能带给我们一堆麻烦，需要学习更多的Api知识，在编写更多代码的同时也存在着更多的风险，线程的切换和锁也会造成系统资源的开销。就像上面的那个例子，如果我们的Node.js有创建子线程的能力，那问题就迎刃而解了：varstart=Date.now();createThread(function(){//创建一个子线程执行这10亿次循环console.log(Date.now()-start);for(vari=0;i<1000000000;i++){}});setTimeout(function(){//因为10亿次循环是在子线程中执行的，所以主线程不受影响console.log(Date.now()-start);},2000);可惜也可以说可喜的是，Node.js的核心模块并没有提供这样的api给我们，我们真的不想多线程又回归回来。不过或许多线程真的能够解决我们某方面的问题。tagg2模块JorgeChamorroBieling是tagg(ThreadsagogoforNode.js)包的作者，他硬是利用phread库和C语言让Node.js支持了多线程的开发，我们看一下tagg模块的简单示例：varThreads=require('threads_a_gogo');//加载tagg包functionfibo(n){//定义斐波那契数组计算函数returnn>1?fibo(n-1)+fibo(n-2):1;}vart=Threads.create().eval(fibo);t.eval('fibo(35)',function(err,result){//将fibo(35)丢入子线程运行if(err)throwerr;//线程创建失败console.log('fibo(35)='+result);//打印fibo执行35次的结果});console.log('notblock');//打印信息了，表示没有阻塞上面这段代码利用tagg包将fibo(35)这个计算丢入了子线程中进行，保证了Node.js主线程的舒畅，当子线程任务执行完毕将会执行主线程的回调函数，把结果打印到屏幕上，执行结果如下：notblockfibo(35)=14930352斐波那契数列，又称黄金分割数列，这个数列从第三项开始，每一项都等于前两项之和：0、1、1、2、3、5、8、13、21、……。注意我们上面代码的斐波那契数组算法并不是最优算法，只是为了模拟cpu密集型计算任务。由于tagg包目前只能在linux下安装运行，所以我fork了一个分支，修改了部分tagg包的代码，发布了tagg2包。tagg2包同样具有tagg包的多线程功能，采用新的node-gyp命令进行编译，同时它跨平台支持，mac，linux，windows下都可以使用，对开发人员的api也更加友好。安装方法很简单，直接npminstalltagg2。一个利用tagg2计算斐波那契数组的http服务器代码：varexpress=require('express');vartagg2=require(\"tagg2\");varapp=express();varth_func=function(){//线程执行函数，以下内容会在线程中执行varfibo=functionfibo(n){//在子线程中定义fibo函数returnn>1?fibo(n-1)+fibo(n-2):1;}varn=fibo(~~thread.buffer);//执行fibo递归thread.end(n);//当线程执行完毕，执行thread.end带上计算结果回调主线程};app.get('/',function(req,res){varn=~~req.query.n||1;//获取用户请求参数varbuf=newBuffer(n.toString());tagg2.create(th_func,{buffer:buf},function(err,result){//创建一个js线程,传入工作函数,buffer参数以及回调函数if(err)returnres.end(err);//如果线程创建失败res.end(result.toString());//响应线程执行计算的结果})});app.listen(8124);console.log('listenon8124');其中~~req.query.n表示将用户传递的参数n取整，功能类似Math.floor函数。我们用express框架搭建了一个web服务器，根据用户发送的参数n的值来创建子线程计算斐波那契数组，当子线程计算完毕之后将结果响应给客户端。由于计算是丢入子线程中运行的，所以整个主线程不会被阻塞，还是能够继续处理新请求的。我们利用apache的http压力测试工具ab来进行一次简单的压力测试，看看执行斐波那契数组35次，100客户端并发100个请求，我们的QPS(QueryPerSecond)每秒查询率在多少。ab的全称是ApacheBench，是Apache附带的一个小工具，用于进行HTTP服务器的性能测试，可以同时模拟多个并发请求。我们的测试硬件：linux2.6.44cpu8G64bit，网络环境则是内网。ab压力测试命令：ab-c100-n100http://192.168.28.5:8124/?n=35压力测试结果：ServerSoftware:ServerHostname:192.168.28.5ServerPort:8124DocumentPath:/?n=35DocumentLength:8bytesConcurrencyLevel:100Timetakenfortests:5.606secondsCompleterequests:100Failedrequests:0Writeerrors:0Totaltransferred:10600bytesHTMLtransferred:800bytesRequestspersecond:17.84[#/sec](mean)Timeperrequest:5605.769[ms](mean)Timeperrequest:56.058[ms](mean,acrossallconcurrentrequests)Transferrate:1.85[Kbytes/sec]receivedConnectionTimes(ms)minmean[+/-sd]medianmaxConnect:340.846Processing:4555367599.755265598Waiting:4545367599.755265598Total:4615372599.355315602Percentageoftherequestsservedwithinacertaintime(ms)50%553166%556575%557780%558190%559295%559798%560099%5602100%5602(longestrequest)我们看到Requestspersecond表示每秒我们服务器处理的任务数量，这里是17.84。第二个我们比较关心的是两个Timeperrequest结果，上面一行Timeperrequest:5605.769[ms](mean)表示当前这个并发量下处理每组请求的时间，而下面这个Timeperrequest:56.058[ms](mean,acrossallconcurrentrequests)表示每个用户平均处理时间，因为我们本次测试并发是100，所以结果正好是上一行的100分之1。得出本次测试平均每个用户请求的平均等待时间为56.058[ms]。另外我们看下最后带有百分比的列表，可以看到50%的用户是在5531ms以内返回的，最慢的也不过5602ms，响应延迟非常的平均。我们如果用cluster来启动4个进程，是否可以充分利用cpu达到tagg2那样的QPS呢？我们在同样的网络环境和测试机上运行如下代码：varcluster=require('cluster');//加载clustr模块varnumCPUs=require('os').cpus().length;//设定启动进程数为cpu个数if(cluster.isMaster){for(vari=0;i<numCPUs;i++){cluster.fork();//启动子进程}}else{varexpress=require('express');varapp=express();varfibo=functionfibo(n){//定义斐波那契数组算法returnn>1?fibo(n-1)+fibo(n-2):1;}app.get('/',function(req,res){varn=fibo(~~req.query.n||1);//接收参数res.send(n.toString());});app.listen(8124);console.log('listenon8124');}在终端屏幕上打印了4行信息：listenon8124listenon8124listenon8124listenon8124我们成功启动了4个cluster之后，用同样的ab压力测试命令对8124端口进行测试，结果如下：ServerSoftware:ServerHostname:192.168.28.5ServerPort:8124DocumentPath:/?n=35DocumentLength:8bytesConcurrencyLevel:100Timetakenfortests:10.509secondsCompleterequests:100Failedrequests:0Writeerrors:0Totaltransferred:16500bytesHTMLtransferred:800bytesRequestspersecond:9.52[#/sec](mean)Timeperrequest:10508.755[ms](mean)Timeperrequest:105.088[ms](mean,acrossallconcurrentrequests)Transferrate:1.53[Kbytes/sec]receivedConnectionTimes(ms)minmean[+/-sd]medianmaxConnect:450.456Processing:33635392639.8292910499Waiting:33535392639.9292910499Total:34035442640.0293410504Percentageoftherequestsservedwithinacertaintime(ms)50%293466%376375%452780%515390%826195%971998%1030899%10504100%10504(longestrequest)通过和上面tagg2包的测试结果对比，我们发现区别很大。首先每秒处理的任务数从17.84[#/sec]下降到了9.52[#/sec]，这说明我们web服务器整体的吞吐率下降了；然后每个用户请求的平均等待时间也从56.058[ms]提高到了105.088[ms]，用户等待的时间也更长了。最后我们发现用户请求处理的时长非常的不均匀，50%的用户在2934ms内返回了，最慢的等待达到了10504ms。虽然我们使用了cluster启动了4个Node.js进程处理用户请求，但是对于每个Node.js进程来说还是单线程的，所以当有4个用户跑满了4个Node.js的cluster进程之后，新来的用户请求就只能等待了，最后造成了先到的用户处理时间短，后到的用户请求处理时间比较长，就造成了用户等待时间非常的不平均。v8引擎大家看到这里是不是开始心潮澎湃，感觉js一统江湖的时代来临了，单线程异步非阻塞的模型可以胜任大并发，同时开发也非常高效，多线程下的js可以承担cpu密集型任务，不会有主线程阻塞而引起的性能问题。但是，不论tagg还是tagg2包都是利用phtread库和v8的v8::IsolateClass类来实现js多线程功能的。Isolate代表着一个独立的v8引擎实例，v8的Isolate拥有完全分开的状态，在一个Isolate实例中的对象不能够在另外一个Isolate实例中使用。嵌入式开发者可以在其他线程创建一些额外的Isolate实例并行运行。在任何时刻，一个Isolate实例只能够被一个线程进行访问，可以利用加锁/解锁进行同步操作。换而言之，我们在进行v8的嵌入式开发时，无法在多线程中访问js变量，这条规则将直接导致我们之前的tagg2里面线程执行的函数无法使用Node.js的核心api，比如fs，crypto等模块。如此看来，tagg2包还是有它使用的局限性，针对一些可以使用js原生的大量计算或循环可以使用tagg2，Node.js核心api因为无法从主线程共享对象的关系，也就不能跨线程使用了。libuv最后，如果我们非要让Node.js支持多线程，还是提倡使用官方的做法，利用libuv库来实现。libuv是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被Mozilla'sRustlanguage,Luvit,Julia,pyuv等使用。它主要包括了Eventloops事件循环，Filesystem文件系统，Networking网络支持，Threads线程，Processes进程，Utilities其他工具。在Node.js核心api中的异步多线程大多是使用libuv来实现的，下一章将带领大家开发一个让Node.js支持多线程并基于libuv的Node.js包。多进程在支持html5的浏览器里，我们可以使用webworker来将一些耗时的计算丢入worker进程中执行，这样主进程就不会阻塞，用户也就不会有卡顿的感觉了。在Node.js中是否也可以使用这类技术，保证主线程的通畅呢？clustercluster可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的cluster示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。webworker想要像在浏览器端那样启动worker进程，我们需要利用Node.js核心api里的child_process模块。child_process模块提供了fork的方法，可以启动一个Node.js文件，将它作为worker进程，当worker进程工作完毕，把结果通过send方法传递给主进程，然后自动退出，这样我们就利用了多进程来解决主线程阻塞的问题。我们先启动一个web服务，还是接收参数计算斐波那契数组：varexpress=require('express');varfork=require('child_process').fork;varapp=express();app.get('/',function(req,res){varworker=fork('./work_fibo.js')//创建一个工作进程worker.on('message',function(m){//接收工作进程计算结果if('object'===typeofm&&m.type==='fibo'){worker.kill();//发送杀死进程的信号res.send(m.result.toString());//将结果返回客户端}});worker.send({type:'fibo',num:~~req.query.n||1});//发送给工作进程计算fibo的数量});app.listen(8124);我们通过express监听8124端口，对每个用户的请求都会去fork一个子进程，通过调用worker.send方法将参数n传递给子进程，同时监听子进程发送消息的message事件，将结果响应给客户端。下面是被fork的work_fibo.js文件内容：varfibo=functionfibo(n){//定义算法returnn>1?fibo(n-1)+fibo(n-2):1;}process.on('message',function(m){//接收主进程发送过来的消息if(typeofm==='object'&&m.type==='fibo'){varnum=fibo(~~m.num);//计算jiboprocess.send({type:'fibo',result:num})//计算完毕返回结果}});process.on('SIGHUP',function(){process.exit();//收到kill信息，进程退出});我们先定义函数fibo用来计算斐波那契数组，然后监听了主线程发来的消息，计算完毕之后将结果send到主线程。同时还监听process的SIGHUP事件，触发此事件就进程退出。这里我们有一点需要注意，主线程的kill方法并不是真的使子进程退出，而是会触发子进程的SIGHUP事件，真正的退出还是依靠process.exit();。下面我们用ab命令测试一下多进程方案的处理性能和用户请求延迟，测试环境不变，还是100个并发100次请求，计算斐波那切数组第35位:ServerSoftware:ServerHostname:192.168.28.5ServerPort:8124DocumentPath:/?n=35DocumentLength:8bytesConcurrencyLevel:100Timetakenfortests:7.036secondsCompleterequests:100Failedrequests:0Writeerrors:0Totaltransferred:16500bytesHTMLtransferred:800bytesRequestspersecond:14.21[#/sec](mean)Timeperrequest:7035.775[ms](mean)Timeperrequest:70.358[ms](mean,acrossallconcurrentrequests)Transferrate:2.29[Kbytes/sec]receivedConnectionTimes(ms)minmean[+/-sd]medianmaxConnect:440.245Processing:42695855970.361327027Waiting:42695855970.361327027Total:42735860970.361367032Percentageoftherequestsservedwithinacertaintime(ms)50%613666%656175%678180%685790%696895%700398%701799%7032100%7032(longestrequest)压力测试结果QPS约为14.21,相比cluster来说，还是快了很多，每个用户请求的延迟都很平均，因为进程的创建和销毁的开销要大于线程，所以在性能方面略低于tagg2，不过相对于cluster方案，这样的提升还是令我们满意的。换一种思路使用child_process模块的fork方法确实可以让我们很好的解决单线程对cpu密集型任务的阻塞问题，同时又没有tagg2包那样无法使用Node.js核心api的限制。但是如果我的worker具有多样性，每次在利用child_process模块解决问题时都需要去创建一个worker.js的工作函数文件，有点麻烦。我们是不是可以更加简单一些呢？在我们启动Node.js程序时，node命令可以带上-e这个参数，它将直接执行-e后面的字符串，如下代码就将打印出helloworld。node-e\"console.log('helloworld')\"合理的利用这个特性，我们就可以免去每次都创建一个文件的麻烦。varexpress=require('express');varspawn=require('child_process').spawn;varapp=express();varspawn_worker=function(n,end){//定义工作函数varfibo=functionfibo(n){returnn>1?fibo(n-1)+fibo(n-2):1;}end(fibo(n));}varspawn_end=function(result){//定义工作函数结束的回调函数参数console.log(result);process.exit();}app.get('/',function(req,res){varn=~~req.query.n||1;//拼接-e后面的参数varspawn_cmd='('+spawn_worker.toString()+'('+n+','+spawn_end.toString()+'));'console.log(spawn_cmd);//注意这个打印结果varworker=spawn('node',['-e',spawn_cmd]);//执行node-e\"xxx\"命令varfibo_res='';worker.stdout.on('data',function(data){//接收工作函数的返回fibo_res+=data.toString();});worker.on('close',function(code){//将结果响应给客户端res.send(fibo_res);});});app.listen(8124);代码很简单，我们主要关注3个地方。第一、我们定义了spawn_worker函数，他其实就是将会在-e后面执行的工作函数，所以我们把计算斐波那契数组的算法定义在内，spawn_worker函数接收2个参数，第一个参数n表示客户请求要计算的斐波那契数组的位数，第二个end参数是一个函数，如果计算完毕则执行end，将结果传回主线程；第二、真正当Node.js脚步执行的字符串其实就是spawn_cmd里的内容，它的内容我们通过运行之后的打印信息，很容易就能明白；第三、我们利用child_process的spawn方法，类似在命令行里执行了node-e\"jscode\"，启动Node.js工作进程，同时监听子进程的标准输出，将数据保存起来，当子进程退出之后把结果响应给用户。现在主要的焦点就是变量spawn_cmd到底保存了什么，我们打开浏览器在地址栏里输入：http://127.0.0.1:8124/?n=35下面就是程序运行之后的打印信息，(function(n,end){varfibo=functionfibo(n){returnn>1?fibo(n-1)+fibo(n-2):1;}end(fibo(n));}(35,function(result){console.log(result);process.exit();}));对于在子进程执行的工作函数的两个参数n和end现在一目了然，n代表着用户请求的参数，期望获得的斐波那契数组的位数，而end参数则是一个匿名函数，在标准输出中打印计算结果然后退出进程。node-e命令虽然可以减少创建文件的麻烦，但同时它也有命令行长度的限制，这个值各个系统都不相同，我们通过命令getconfARG_MAX来获得最大命令长度，例如：MACOSX下是262,144byte，而我的linux虚拟机则是131072byte。多进程和多线程大部分多线程解决cpu密集型任务的方案都可以用我们之前讨论的多进程方案来替代，但是有一些比较特殊的场景多线程的优势就发挥出来了，下面就拿我们最常见的httpweb服务器响应一个小的静态文件作为例子。以express处理小型静态文件为例，大致的处理流程如下：1、首先获取文件状态，判断文件的修改时间或者判断etag来确定是否响应304给客户端，让客户端继续使用本地缓存。2、如果缓存已经失效或者客户端没有缓存，就需要获取文件的内容到buffer中，为响应作准备。3、然后判断文件的MIME类型，如果是类似html，js，css等静态资源，还需要gzip压缩之后传输给客户端4、最后将gzip压缩完成的静态文件响应给客户端。下面是一个正常成功的Node.js处理静态资源无缓存流程图：这个流程中的(2)，(3)，(4)步都经历了从js到C++，打开和释放文件，还有调用了zlib库的gzip算法，其中每个异步的算法都会有创建和销毁线程的开销，所以这样也是大家诟病Node.js处理静态文件不给力的原因之一。为了改善这个问题，我之前有利用libuv库开发了一个改善Node.js的http/https处理静态文件的包，名为ifile，ifile包，之所以可以加速Node.js的静态文件处理性能，主要是减少了js和C++的互相调用，以及频繁的创建和销毁线程的开销，下图是ifile包处理一个静态无缓存资源的流程图：由于全部工作都是在libuv的子线程中执行的，所以Node.js主线程不会阻塞，当然性能也会大幅提升了，使用ifile包非常简单，它能够和express无缝的对接。varexpress=require('express');varifile=require(\"ifile\");varapp=express();app.use(ifile.connect());//默认值是[['/static',__dirname]];app.listen(8124);上面这4行代码就可以让express把静态资源交给ifile包来处理了，我们在这里对它进行了一个简单的压力测试，测试用例为响应一个大小为92kb的jquery.1.7.1.min.js文件，测试命令：ab-c500-n5000-H\"Accept-Encoding:gzip\"http://192.168.28.5:8124/static/jquery.1.7.1.min.js由于在ab命令中我们加入了-H\"Accept-Encoding:gzip\"，表示响应的静态文件希望是gzip压缩之后的，所以ifile将会把压缩之后的jquery.1.7.1.min.js文件响应给客户端。结果如下：ServerSoftware:ServerHostname:192.168.28.5ServerPort:8124DocumentPath:/static/jquery.1.7.1.min.jsDocumentLength:33016bytesConcurrencyLevel:500Timetakenfortests:9.222secondsCompleterequests:5000Failedrequests:0Writeerrors:0Totaltransferred:166495000bytesHTMLtransferred:165080000bytesRequestspersecond:542.16[#/sec](mean)Timeperrequest:922.232[ms](mean)Timeperrequest:1.844[ms](mean,acrossallconcurrentrequests)Transferrate:17630.35[Kbytes/sec]receivedConnectionTimes(ms)minmean[+/-sd]medianmaxConnect:049210.211003Processing:191829128.68701367Waiting:150824128.58691091Total:221878230.78731921Percentageoftherequestsservedwithinacertaintime(ms)50%87366%87875%88180%88590%91895%110998%181599%1875100%1921(longestrequest)我们首先看到DocumentLength一项结果为33016bytes说明我们的jquery文件已经被成功的gzip压缩，因为源文件大小是92kb；其次，我们最关心的Requestspersecond:542.16[#/sec](mean)，说明我们每秒能处理542个任务；最后，我们看到，在这样的压力情况下，平均每个用户的延迟在1.844[ms]。我们看下使用express框架处理这样的压力会是什么样的结果，express测试代码如下：varexpress=require('express');varapp=express();app.use(express.compress());//支持gzipapp.use('/static',express.static(__dirname+'/static'));app.listen(8124);代码同样非常简单，注意这里我们使用：app.use('/static',express.static(__dirname+'/static'));而不是：app.use(express.static(__dirname));后者每个请求都会去匹配一次文件是否存在，而前者只有请求url是/static开头的才会去匹配静态资源，所以前者效率更高一些。然后我们执行相同的ab压力测试命令看下结果：ServerSoftware:ServerHostname:192.168.28.5ServerPort:8124DocumentPath:/static/jquery.1.7.1.min.jsDocumentLength:33064bytesConcurrencyLevel:500Timetakenfortests:16.665secondsCompleterequests:5000Failedrequests:0Writeerrors:0Totaltransferred:166890000bytesHTMLtransferred:165320000bytesRequestspersecond:300.03[#/sec](mean)Timeperrequest:1666.517[ms](mean)Timeperrequest:3.333[ms](mean,acrossallconcurrentrequests)Transferrate:9779.59[Kbytes/sec]receivedConnectionTimes(ms)minmean[+/-sd]medianmaxConnect:0173539.817003Processing:509886350.58099366Waiting:238476277.94269361Total:5101059632.98259367Percentageoftherequestsservedwithinacertaintime(ms)50%82566%90875%120180%144690%182095%195298%256099%3737100%9367(longestrequest)同样分析一下结果，DocumentLength:33064bytes表示文档大小为33064bytes，说明我们的gzip起作用了，每秒处理任务数从ifile包的542下降到了300，最长用户等待时间也延长到了9367ms，可见我们的努力起到了立竿见影的作用，js和C++互相调用以及线程的创建和释放并不是没有损耗的。但是当我在express的谷歌论坛里贴上这些测试结果，并宣传ifile包的时候，express的作者TJ，给出了不一样的评价，他在回复中说道：请牢记你可能不需要这么高等级吞吐率的系统，就算是每月百万级别下载量的npm网站，也仅仅每秒处理17个请求而已，这样的压力甚至于PHP也可以处理掉（又黑了一把php）。确实如TJ所说，性能只是我们项目的指标之一而非全部，一味的去追求高性能并不是很理智。ifile包开源项目地址：https://github.com/DoubleSpout/ifile总结单线程的Node.js给我们编码带来了太多的便利和乐趣，我们应该时刻保持清醒的头脑，在写Node.js代码中切不可与PHP混淆，任何一个隐藏的问题都可能击溃整个线上正在运行的Node.js程序。单线程异步的Node.js不代表不会阻塞，在主线程做过多的任务可能会导致主线程的卡死，影响整个程序的性能，所以我们要非常小心的处理大量的循环，字符串拼接和浮点运算等cpu密集型任务，合理的利用各种技术把任务丢给子线程或子进程去完成，保持Node.js主线程的畅通。线程/进程的使用并不是没有开销的，尽可能减少创建和销毁线程/进程的次数，可以提升我们系统整体的性能和出错的概率。最后请不要一味的追求高性能和高并发，因为我们可能不需要系统具有那么大的吞吐率。高效，敏捷，低成本的开发才是项目所需要的，这也是为什么Node.js能够在众多开发语言中脱颖而出的关键。参考文献：http://smashingnode.comSmashingNode.JSByGuillermoRauchhttp://bjouhier.wordpress.com/2012/03/11/fibers-and-threads-in-node-js-what-forFibersandThreadsinnode.js–whatfor?ByBruno'sRamblingshttps://github.com/xk/node-threads-a-gogoTAGG:ThreadsàgogoforNode.jsByJorgeChamorroBielinghttps://code.google.com/p/v8/Googlev8https://github.com/joyent/libuvlibuvbyjoyent本文转自：https://www.cnblogs.com/chris-oil/p/5339305.html",
      "time": "2018.01.2916:47:49"
    },
    {
      "id": "4r7keh9d4bc0",
      "author": "全栈大前端",
      "title": "为什么使用Node.js？逐个案例教程",
      "content": "专注全栈大前端，爱前端整理了一批2019年最新WEB前端教学视频，不论是零基础想要学习前端还是学完在工作想要提升自己，这些资料都会给你带来帮助，从HTML到各种框架，帮助所有想要学好前端的同学，学习规划、学习路线、学习资料、问题解答。只要加入全栈大前端学习交流Q群：137503198，即可免费获取。介绍JavaScript的日益普及带来了很多变化，而今天的Web开发面貌却截然不同。我们现在可以在服务器上运行JavaScript以及在浏览器中执行的操作几年前很难想象，或者封装在沙盒环境中，如Flash或JavaApplet。在深入研究Node.js之前，您可能希望了解在堆栈中使用JavaScript的好处，它统一了语言和数据格式（JSON），允许您以最佳方式重用开发人员资源。由于这比JavaScript特别是Node.js更有益，我们在此不再讨论它。但是将Node合并到堆栈中是一个关键优势。正如维基百科所说：“Node.js是Google的V8JavaScript引擎，libuv平台抽象层和核心库的打包汇编，它本身主要用JavaScript编写。”除此之外，值得注意的是RyanDahl，创作者Node.js的目标是创建具有推送功能的实时网站，“受Gmail等应用程序的启发”。在Node.js中，他为开发人员提供了一个工具，用于处理非阻塞，事件驱动的I/O范例。在基于无状态请求-响应范例的20多年无状态网络之后，我们终于拥有了具有实时双向连接的Web应用程序。用一句话来说：Node.js在基于websockets的推送技术的实时Web应用程序中大放异彩。那是什么革命性的？好吧，在基于无状态请求-响应范例的20多年无状态网络之后，我们终于拥有了具有实时双向连接的Web应用程序，其中客户端和服务器都可以启动通信，允许它们自由地交换数据。这与典型的Web响应范例形成鲜明对比，客户端总是发起通信。此外，它都基于在标准端口80上运行的开放Web堆栈（HTML，CSS和JS）。有人可能会争辩说，我们多年来一直以Flash和JavaApplet的形式拥有这一点-但实际上，这些只是使用Web作为传输协议传递给客户端的沙盒环境。此外，它们是隔离运行的，通常在非标准端口上运行，这可能需要额外的权限等。凭借其所有优势，Node.js现在在依赖其独特优势的众多知名公司的技术堆栈中发挥着关键作用。Node.js基金会已经整合了所有关于为什么企业应该在Node.js基金会的案例研究页面上找到的简短演示中考虑Node.js的最佳思考。在这个Node.js指南中，我将不仅讨论如何实现这些优势，而且还讨论为什么你可能想要使用Node.js-以及为什么不-使用一些经典的Web应用程序模型作为示例。它是如何工作的？Node.js的主要思想是：在面向跨分布式设备运行的数据密集型实时应用程序时，使用非阻塞，事件驱动的I/O保持轻量级和高效。那是满口的。它的真正含义是Node.js不是一个将在Web开发领域占主导地位的银弹新平台。相反，它是一个满足特定需求的平台。它的真正含义是Node.js不是一个将在Web开发领域占主导地位的银弹新平台。相反，它是一个满足特定需求的平台。了解这一点绝对必要。您绝对不希望将Node.js用于CPU密集型操作;实际上，将它用于繁重的计算将几乎消除其所有优点。Node真正发挥作用的地方在于构建快速，可扩展的网络应用程序，因为它能够以高吞吐量处理大量同时连接，这相当于高可扩展性。如何在引擎盖下工作非常有趣。与传统的Web服务技术相比，每个连接（请求）产生一个新线程，占用系统RAM并最终以可用的RAM量最大化，Node.js在单线程上运行，使用非阻塞I/O调用，允许它支持事件循环中保存的数万个并发连接。快速计算：假设每个线程可能随附2MB内存，在具有8GBRAM的系统上运行使我们理论上最多可以有4,000个并发连接（计算来自MichaelAbernethy的文章“JustwhatisNode”.js？“，2011年在IBMdeveloperWorks上发布;遗憾的是，这篇文章不再可用了），加上线程之间的上下文切换成本。这就是您通常在传统的网络服务技术中处理的场景。通过避免这一切，Node.js实现了超过1M并发连接的可伸缩性级别，以及超过600k并发的websockets连接。当然，存在在所有客户端请求之间共享单个线程的问题，这是编写Node.js应用程序的潜在缺陷。首先，繁重的计算可能会阻塞Node的单个线程并导致所有客户端出现问题（稍后会详细说明），因为传入的请求将被阻塞，直到所述计算完成为止。其次，开发人员需要非常小心，不要让异常冒泡到核心（最顶层）Node.js事件循环，这将导致Node.js实例终止（有效地崩溃程序）。用于避免冒泡到表面的异常的技术是将错误作为回调参数传递回调用者（而不是像在其他环境中那样抛出它们）。即使一些未处理的异常设法冒泡，也开发了一些工具来监视Node.js进程并执行崩溃实例的必要恢复（尽管您可能无法恢复用户会话的当前状态），最常见的是Forever模块，或者使用不同的方法与外部系统工具upstart和monit，甚至只是暴发户。NPM：节点包管理器在讨论Node.js时，有一点绝对不应该被忽略的是内置支持使用NPM进行包管理，NPM是默认情况下每个Node.js安装的工具。NPM模块的概念与RubyGems非常相似：一组公开可用的可重用组件，可通过在线存储库轻松安装，具有版本和依赖关系管理。可以在npm网站上找到已打包模块的完整列表，也可以使用自动与Node.js一起安装的npmCLI工具进行访问。模块生态系统对所有人开放，任何人都可以发布自己的模块，该模块将列在npm存储库中。今天一些最有用的npm模块是：表达-Express.js-或简单表达-一个受Sinatra启发的Node.jsWeb开发框架，以及当今大多数Node.js应用程序的事实标准。hapi-一个非常模块化且易于使用的以配置为中心的框架，用于构建Web和服务应用程序connect-Connect是Node.js的可扩展HTTP服务器框架，提供了一系列称为中间件的高性能“插件”;作为Express的基础。socket.io和sockjs-今天两个最常见的websockets组件的服务器端组件。帕格（以前称为Jade）-受HAML启发的流行模板引擎之一，Express.js中的默认值。mongodb和mongojs-MongoDB包装器，为Node.js中的MongoDB对象数据库提供API。redis-Redis客户端库。lodash（下划线，lazy.js）-JavaScript实用程序带。Underscore发起了游戏，但被其两个对手之一推翻，主要是因为更好的性能和模块化实施。永远-可能是确保给定节点脚本连续运行的最常用实用程序。在遇到任何意外故障时，将Node.js进程保持在生产状态。bluebird-功能齐全的Promises/A+实现，性能非常出色moment-用于解析，验证，操作和格式化日期的JavaScript日期库。名单还在继续。那里有很多真正有用的包，可供所有人使用（对于我在这里省略的那些没有冒犯）。应该使用Node.js的示例CHAT聊天是最典型的实时多用户应用程序。从IRC（在当天），通过在非标准端口上运行的许多专有和开放协议，到今天在Node.js中实现一切的能力，其中websockets在标准端口80上运行。聊天应用程序实际上是Node.js的最佳示例：它是一个轻量级，高流量，数据密集型（但低处理/计算）的应用程序，可跨分布式设备运行。它也是一个很好的学习用例，因为它很简单，但它涵盖了你在典型的Node.js应用程序中使用的大部分范例。让我们试着描绘它是如何工作的。在最简单的例子中，我们在我们的网站上有一个聊天室，人们可以通过一对多（实际上所有）方式交换消息。例如，假设网站上有三个人都连接到我们的留言板。在服务器端，我们有一个简单的Express.js应用程序，它实现了两件事：一个GET/请求处理程序，它为包含消息板和“发送”按钮的网页提供服务，以初始化新的消息输入，以及一个websockets服务器，用于侦听websocket客户端发出的新消息。在客户端，我们有一个HTML页面，其中设置了几个处理程序，一个用于“发送”按钮单击事件，它接收输入消息并将其发送到websocket，另一个用于侦听新的传入消息在websockets客户端上（即，由服务器现在希望客户端显示的其他用户发送的消息）。当其中一个客户发布消息时，会发生以下情况：浏览器通过JavaScript处理程序捕获“发送”按钮，从输入字段（即消息文本）中获取值，并使用连接到我们服务器的websocket客户端（在网页初始化时初始化）发出websocket消息。websocket连接的服务器端组件接收消息，并使用广播方法将其转发到所有其他连接的客户端。所有客户端都通过在网页中运行的websockets客户端组件将新消息作为推送消息接收。然后，他们通过将新消息附加到电路板来获取消息内容并就地更新网页。这是最简单的例子。对于更强大的解决方案，您可以使用基于Redis存储的简单缓存。或者在更高级的解决方案中，消息队列用于处理到客户端的消息路由以及更强大的传递机制，其可以覆盖临时连接丢失或在注册客户端脱机时存储消息。但无论您做出哪些改进，Node.js仍将按照相同的基本原则运行：对事件做出反应，处理许多并发连接，并保持用户体验的流畅性。对象数据库顶部的API虽然Node.js真的很适合实时应用程序，但它非常适合从对象DB（例如MongoDB）公开数据。JSON存储的数据允许Node.js在没有阻抗不匹配和数据转换的情况下运行。例如，如果您正在使用Rails，那么您将从JSON转换为二进制模型，然后在Backbone.js，Angular.js等使用数据时将它们作为JSON通过HTTP公开，甚至是简单的jQueryAJAX调用。使用Node.js，您可以使用RESTAPI公开您的JSON对象，供客户端使用。此外，在从数据库读取或写入时（如果您使用的是MongoDB），您无需担心在JSON和其他任何内容之间进行转换。总之，通过在客户端，服务器和数据库中使用统一的数据序列化格式，可以避免需要多次转换。排队输入如果您收到大量并发数据，您的数据库可能会成为瓶颈。如上所述，Node.js可以轻松地自己处理并发连接。但是因为数据库访问是一种阻塞操作（在这种情况下），我们遇到了麻烦。解决方案是在数据真正写入数据库之前确认客户端的行为。通过这种方法，系统可以在高负载下保持其响应性，这在客户端不需要确认成功数据写入时尤其有用。典型的例子包括：记录或写入用户跟踪数据，分批处理，直到以后才使用;以及不需要立即反映的操作（例如更新Facebook上的“喜欢”计数），其中最终的一致性（在NoSQL世界中经常使用）是可以接受的。数据通过某种缓存或消息排队基础结构（如RabbitMQ或ZeroMQ）排队，并通过单独的数据库批处理写入过程或计算密集型处理后端服务进行消化，这些服务是在更好的平台中编写的，用于执行此类任务。类似的行为可以用其他语言/框架实现，但不能在相同的硬件上实现，具有相同的高维护吞吐量。简而言之：使用Node，您可以将数据库写入到一边并稍后处理它们，就像它们成功一样。数据流在更传统的Web平台中，HTTP请求和响应被视为孤立事件;事实上，他们实际上是溪流。可以在Node.js中使用此观察来构建一些很酷的功能。例如，可以在文件仍在上传时处理文件，因为数据通过流进入，我们可以以在线方式处理它。这可以用于实时音频或视频编码，以及不同数据源之间的代理（参见下一节）。代理Node.js很容易用作服务器端代理，它可以以非阻塞方式处理大量的同时连接。它对于使用不同响应时间代理不同服务或从多个源点收集数据特别有用。例如：考虑服务器端应用程序与第三方资源进行通信，从不同来源提取数据，或将图像和视频等资产存储到第三方云服务。尽管存在专用代理服务器，但如果您的代理基础架构不存在或者您需要本地开发解决方案，则使用Node可能会有所帮助。通过这个，我的意思是你可以构建一个客户端应用程序与Node.js开发服务器的资产和代理/存根API请求，而在生产中你可以处理这种与专用代理服务（nginx，HAProxy等）的交互）。BROKERAGE-股票交易者的仪表板让我们回到应用程序级别。桌面软件占主导地位，但可以很容易地用实时网络解决方案取代的另一个例子是经纪人的交易软件，用于跟踪股票价格，执行计算/技术分析，以及创建图表/图表。切换到基于Web的实时解决方案将允许经纪人轻松切换工作站或工作场所。很快，我们可能会开始在佛罗里达州的海滩上看到它们......或者伊维萨岛或巴厘岛。应用监控仪表板另一个常见的用例，其中Node-with-web-socket完全适合：跟踪网站访问者并实时可视化他们的交互。您可以从用户那里收集实时统计信息，甚至可以通过在访问渠道中的特定点打开通信渠道时与访问者进行有针对性的互动，将其移至更高级别。（如果你有兴趣，这个想法已经被CANDDi产品化了。）想象一下，如果您能够实时了解访问者的行为，那么如何改善您的业务-如果您能够想象他们的互动。使用Node.js的实时双向套接字，现在就可以了。系统监控仪表板现在，让我们访问基础设施方面的事情。例如，想象一下，SaaS提供商希望为其用户提供服务监控页面，如GitHub的状态页面。通过Node.js事件循环，我们可以创建一个功能强大的基于Web的仪表板，以异步方式检查服务的状态，并使用websockets将数据推送到客户端。内部（公司内部）和公共服务的状态都可以使用该技术实时和实时报告。进一步推动这一想法并尝试设想电信运营商，云/网络/托管提供商或某些金融机构中的网络运营中心（NOC）监控应用程序，所有这些应用程序都运行在由Node.js和websockets支持的开放Web堆栈上而不是Java和/或JavaApplet。注意：不要尝试在Node中构建硬实时系统（即需要一致响应时间的系统）。Erlang可能是该类应用程序的更好选择。可以使用Node.js的位置服务器端Web应用程序带有Express.js的Node.js也可用于在服务器端创建经典Web应用程序。但是，虽然可能，Node.js将携带呈现HTML的请求-响应范例不是最典型的用例。有人支持和反对这种方法。以下是一些需要考虑的事实：优点：如果您的应用程序没有任何CPU密集型计算，那么您可以使用Javascript存储对象数据库（如MongoDB）从上到下构建它，甚至可以在数据库级别构建它。这显着简化了发展（包括招聘）。Crawlers收到一个完全呈现的HTML响应，这比单个页面应用程序或在Node.js上运行的websockets应用程序更具SEO。缺点：任何CPU密集型计算都会阻止Node.js的响应，因此线程平台是一种更好的方法。或者，您可以尝试扩展计算[*]。将Node.js与关系数据库一起使用仍然非常痛苦（更多细节见下文）。如果您正在尝试执行关系操作，请帮自己一个忙，并选择Rails，Django或ASP.NetMVC等任何其他环境。[*]这些CPU密集型计算的替代方案是创建一个高度可扩展的MQ支持环境，该环境具有后端处理功能，以使Node成为一个面向前端的“职员”，以异步方式处理客户端请求。不应该使用Node.js的地方服务器端WEB应用程序W/A关系数据库的背后例如，将Node.js与Express.js与RubyonRails进行比较时，在访问PostgreSQL，MySQL和MicrosoftSQLServer等关系数据库时，曾经有过一个干净的决策支持后者。Node.js的关系数据库工具仍处于早期阶段。另一方面，Rails自动提供开箱即用的数据访问设置以及数据库架构迁移支持工具和其他Gems（双关语）。Rails及其对等框架具有成熟且经过验证的ActiveRecord或DataMapper数据访问层实现。[*]但事情发生了变化。Sequelize，TypeORM和Bookshelf在成为成熟的ORM解决方案方面走了很长的路。如果您希望从GraphQL查询生成SQL，那么可能还需要查看JoinMonster。[*]使用Node作为前端，同时保持Rails后端并轻松访问关系数据库是可能的，而且并不罕见。相关：后端：使用Gatsby.js和Node.js进行静态站点更新重型服务器端计算/处理当涉及到繁重的计算时，Node.js并不是最好的平台。不，你绝对不想在Node.js中构建一个Fibonacci计算服务器。通常，任何CPU密集型操作都会消除Node提供的所有吞吐量优势及其事件驱动的非阻塞I/O模型，因为任何传入的请求都会在线程被数字运算占用时被阻止-假设您正在尝试在您响应请求的同一个Node实例中运行计算。如前所述，Node.js是单线程的，只使用一个CPU核心。在多核服务器上添加并发性时，Node核心团队正在以集群模块的形式完成一些工作[ref：http：//nodejs.org/api/cluster.html]。您还可以通过nginx在反向代理后面很容易地运行几个Node.js服务器实例。使用群集，您仍然应该将所有繁重的计算卸载到在更合适的环境中编写的后台进程，并让它们通过像RabbitMQ这样的消息队列服务器进行通信。即使您的后台处理最初可能在同一服务器上运行，这种方法也有可能实现非常高的可伸缩性。这些后台处理服务可以轻松地分发到单独的工作服务器，而无需配置前置Web服务器的负载。当然，您也可以在其他平台上使用相同的方法，但是使用Node.js，您可以获得我们所讨论的高reqs/sec吞吐量，因为每个请求都是一个非常快速有效的小任务。结论我们讨论了Node.js从理论到实践，从它的目标和抱负开始，并以其最佳点和陷阱结束。当人们遇到Node的问题时，它几乎总是归结为阻塞操作是所有邪恶的根源--99％的Node滥用是直接后果。在Node中，阻塞操作是所有邪恶的根源-99％的Node滥用是直接后果。请记住：从未创建过Node.js来解决计算扩展问题。它的创建是为了解决I/O扩展问题，它确实很好。为什么要使用Node.js？如果您的用例不包含CPU密集型操作，也不访问任何阻塞资源，您可以利用Node.js的优势，享受快速，可扩展的网络应用程序。欢迎来到实时网站。专注全栈大前端，爱前端整理了一批2019年最新WEB前端教学视频，不论是零基础想要学习前端还是学完在工作想要提升自己，这些资料都会给你带来帮助，从HTML到各种框架，帮助所有想要学好前端的同学，学习规划、学习路线、学习资料、问题解答。只要加入全栈大前端学习交流Q群：137503198，即可免费获取。",
      "time": "2019.06.0415:01:20"
    },
    {
      "source": "掘金",
      "id": "3ioysphfseo0",
      "author": "",
      "title": "Node入门 » 一本全面的Node.js教程",
      "content": "关于本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“HelloWorld”的教程。状态你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。本书中的代码案例都在Node.js0.6.11版本中测试过，可以正确工作。读者对象本书最适合与我有相似技术背景的读者：至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。本书结构读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。是不是很玄乎？稍后你就明白了。本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。紧接着，会带领大家完成一个最传统的“HelloWorld”应用，这也是最基础的Node.js应用。最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。该应用所有的源代码都可以通过本书Github代码仓库.目录关于状态读者对象本书结构JavaScript与Node.jsJavaScript与你简短申明服务器端JavaScript“HelloWorld”一个完整的基于Node.js的web应用用例应用不同模块分析构建应用的模块一个基础的HTTP服务器分析HTTP服务器进行函数传递函数传递是如何让HTTP服务器工作的基于事件驱动的回调服务器是如何处理请求的服务端的模块放在哪里如何来进行请求的“路由”行为驱动执行路由给真正的请求处理程序让请求处理程序作出响应不好的实现方式阻塞与非阻塞以非阻塞操作进行请求响应更有用的场景处理POST请求处理文件上传总结与展望JavaScript与Node.jsJavaScript与你抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。而你真正想要的是“干货”，你想要知道如何构建复杂的web站点——于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是window.open()那么简单。.不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。然后，出现了Node.js，服务端的JavaScript，这有多酷啊？于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。问题来了：由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。因为这就是关键：你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。本书的目标就是给你提供指导。简短申明业界有非常优秀的JavaScript程序员。而我并非其中一员。我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言：它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。因此，Node.js事实上既是一个运行时环境，同时又是一个库。要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。“HelloWorld”好了，“废话”不多说了，马上开始我们第一个Node.js应用：“HelloWorld”。打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“HelloWorld”，如下是实现该功能的代码：console.log(\"HelloWorld\");保存该文件，并通过Node.js来执行：nodehelloworld.js正常的话，就会在终端输出HelloWorld。好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。一个完整的基于Node.js的web应用用例我们来把目标设定得简单点，不过也要够实际才行：用户可以通过浏览器使用我们的应用。当用户请求http://domain/start时，可以看到一个欢迎页面，页面上有一个文件上传的表单。用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload，该页面完成上传后会把图片显示在页面上。差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。应用不同模块分析我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？我们需要提供Web页面，因此需要一个HTTP服务器对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（requesthandler）当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个ApacheHTTP服务器并配上mod_php5模块。从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。构建应用的模块一个基础的HTTP服务器当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。这种方法允许你拥有一个干净的主文件（mainfile），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：varhttp=require(\"http\");http.createServer(function(request,response){response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}).listen(8888);搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：nodeserver.js接下来，打开浏览器访问http://localhost:8888/，你会看到一个写着“HelloWorld”的网页。这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。分析HTTP服务器那么接下来，让我们分析一下这个HTTP服务器的构成。第一行请求（require）Node.js自带的http模块，并且把它赋值给http变量。接下来我们调用http模块提供的函数：createServer。这个函数会返回一个对象，这个对象有一个叫做listen的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。咱们暂时先不管http.createServer的括号里的那个函数定义。我们本来可以用这样的代码来启动服务器并侦听8888端口：varhttp=require(\"http\");varserver=http.createServer();server.listen(8888);这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是createSever()的第一个参数，一个函数定义。实际上，这个函数定义是createServer()的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。进行函数传递举例来说，你可以这样做：functionsay(word){console.log(word);}functionexecute(someFunction,value){someFunction(value);}execute(say,\"Hello\");请仔细阅读这段代码！在这里，我们把say函数作为execute函数的第一个变量进行了传递。这里传递的不是say的返回值，而是say本身！这样一来，say就变成了execute中的本地变量someFunction，execute可以通过调用someFunction()（带括号的形式）来使用say函数。当然，因为say有一个变量，execute在调用someFunction时可以传递这样一个变量。我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：functionexecute(someFunction,value){someFunction(value);}execute(function(word){console.log(word)},\"Hello\");我们在execute接受第一个参数的地方直接定义了我们准备传递给execute的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数。这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：varhttp=require(\"http\");http.createServer(function(request,response){response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}).listen(8888);现在它看上去应该清晰了很多：我们向createServer函数传递了一个匿名函数。用这样的代码也可以达到同样的目的：varhttp=require(\"http\");functiononRequest(request,response){response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);也许现在我们该问这个问题了：我们为什么要用这种方式呢？基于事件驱动的回调这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。你也许会想花点时间读一下FelixGeisendörfer的大作Understandingnode.js，它介绍了一些背景知识。这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Webbasedapplication）是有意义的。当我们使用http.createServer方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。这个就是传说中的回调。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行回调。至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：varhttp=require(\"http\");functiononRequest(request,response){console.log(\"Requestreceived.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");注意：在onRequest（我们的回调函数）触发的地方，我用console.log输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。当我们与往常一样，运行它nodeserver.js时，它会马上在命令行上输出“Serverhasstarted.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/），“Requestreceived.”这条消息就会在命令行中出现。这就是事件驱动的异步服务器端JavaScript和它的回调啦！（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Requestreceived.”。那是因为大部分服务器都会在你访问http://localhost:8888/时尝试读取http://localhost:8888/favicon.ico)服务器是如何处理请求的好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数onRequest()的主体部分。当回调启动，我们的onRequest()函数被触发的时候，有两个参数被传入：request和response。它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。所以我们的代码就是：当收到请求时，使用response.writeHead()函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用response.write()函数在HTTP相应主体中发送文本“HelloWorld\"。最后，我们调用response.end()完成响应。目前来说，我们对请求的细节并不在意，所以我们没有使用request对象。服务端的模块放在哪里OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在server.js文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫index.js的文件去调用应用的其他模块（比如server.js中的HTTP服务器模块）来引导和启动应用。我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的index.js主文件使用。也许你已经注意到，我们已经在代码中使用了模块了。像这样：varhttp=require(\"http\");...http.createServer(...);Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有http模块所提供的公共方法的对象。给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：varfoo=require(\"http\");...foo.createServer(...);很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？等我们把server.js变成一个真正的模块，你就能搞明白了。事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分导出到请求这个模块的脚本。目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。我们把我们的服务器脚本放到一个叫做start的函数里，然后我们会导出这个函数。varhttp=require(\"http\");functionstart(){functiononRequest(request,response){console.log(\"Requestreceived.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;这样，我们现在就可以创建我们的主文件index.js并在其中启动我们的HTTP了，虽然服务器的代码还在server.js中。创建index.js文件并写入以下内容：varserver=require(\"./server\");server.start();正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：nodeindex.js非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。对于一个非常简单的应用来说，你可以直接在回调函数onRequest()中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做路由的模块吧。如何来进行请求的“路由”我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。url.parse(string).query|url.parse(string).pathname|||||-------------------------http://localhost:8888/start?foo=bar&hello=world--------||||querystring(string)[\"foo\"]||querystring(string)[\"hello\"]当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：varhttp=require(\"http\");varurl=require(\"url\");functionstart(){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：functionroute(pathname){console.log(\"Abouttoroutearequestfor\"+pathname);}exports.route=route;如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读MartinFowlers关于依赖注入的大作来作为背景知识）。首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");route(pathname);response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：varserver=require(\"./server\");varrouter=require(\"./router\");server.start(router.route);在这里，我们传递的函数依旧什么也没做。如果现在启动应用（nodeindex.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：bash$nodeindex.jsRequestfor/fooreceived.Abouttoroutearequestfor/foo（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。行为驱动执行请允许我再次脱离主题，在这里谈一谈函数式编程。将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。我是在读了SteveYegge的大作名词王国中的死刑之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。路由给真正的请求处理程序回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。应用程序需要新的部件，因此加入新的模块--已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：functionstart(){console.log(\"Requesthandler'start'wascalled.\");}functionupload(){console.log(\"Requesthandler'upload'wascalled.\");}exports.start=start;exports.upload=upload;这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆ifrequest==xthencallhandlery也使得系统丑陋不堪。仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associativearray）能完美胜任。不过结果有点令人失望，JavaScript没提供关联数组--也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。在这方面，msdn.microsoft.com/en-us/magaz…有一个不错的介绍，我在此摘录一段：在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合--你可以把JavaScript的对象想象成一个键为字符串类型的字典。但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。我们先将这个对象引入到主文件index.js中：varserver=require(\"./server\");varrouter=require(\"./router\");varrequestHandlers=require(\"./requestHandlers\");varhandle={}handle[\"/\"]=requestHandlers.start;handle[\"/start\"]=requestHandlers.start;handle[\"/upload\"]=requestHandlers.upload;server.start(router.route,handle);虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为\"/\"的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route,handle){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");route(handle,pathname);response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloWorld\");response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。然后我们相应地在route.js文件中修改route()函数：functionroute(handle,pathname){console.log(\"Abouttoroutearequestfor\"+pathname);if(typeofhandle[pathname]==='function'){handle[pathname]();}else{console.log(\"Norequesthandlerfoundfor\"+pathname);}}exports.route=route;通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：Serverhasstarted.Requestfor/startreceived.Abouttoroutearequestfor/startRequesthandler'start'wascalled.并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：Requestfor/received.Abouttoroutearequestfor/Requesthandler'start'wascalled.让请求处理程序作出响应很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“HelloWorld”，那就更好了。这里要记住的是，浏览器发出请求后获得并显示的“HelloWorld”信息仍是来自于我们server.js文件中的onRequest函数。其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。不好的实现方式对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱：看似有效，实则未必如此。这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：functionstart(){console.log(\"Requesthandler'start'wascalled.\");return\"HelloStart\";}functionupload(){console.log(\"Requesthandler'upload'wascalled.\");return\"HelloUpload\";}exports.start=start;exports.upload=upload;好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：functionroute(handle,pathname){console.log(\"Abouttoroutearequestfor\"+pathname);if(typeofhandle[pathname]==='function'){returnhandle[pathname]();}else{console.log(\"Norequesthandlerfoundfor\"+pathname);return\"404Notfound\";}}exports.route=route;正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route,handle){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});varcontent=route(handle,pathname)response.write(content);response.end();}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start,浏览器会输出“HelloStart”，请求http://localhost:8888/upload会输出“HelloUpload”,而请求http://localhost:8888/foo会输出“404Notfound”。好，那么问题在哪里呢？简单的说就是：当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。没理解？没关系，下面就来详细解释下。阻塞与非阻塞正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“HelloStart”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。让我们将requestHandlers.js修改成如下形式：functionstart(){console.log(\"Requesthandler'start'wascalled.\");functionsleep(milliSeconds){varstartTime=newDate().getTime();while(newDate().getTime()<startTime+milliSeconds);}sleep(10000);return\"HelloStart\";}functionupload(){console.log(\"Requesthandler'upload'wascalled.\");return\"HelloUpload\";}exports.start=start;exports.upload=upload;上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“HelloStart”。当调用upload()的时候，会和此前一样立即返回。（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）接下来就让我们来看看，我们的改动带来了哪些变化。如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）：首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start，但是先不要打开它！在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload，同样的，先不要打开它！接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。注意，发生了什么：/startURL加载花了10秒，这和我们预期的一样。但是，/uploadURL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理——Node.js是单线程的。它通过事件轮询（eventloop）来实现并行操作，对此，我们应该要充分利用这一点——尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——理解node.js的事件轮询。）接下来，我们会介绍一种错误的使用非阻塞操作的方式。和上次一样，我们通过修改我们的应用来暴露问题。这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：varexec=require(\"child_process\").exec;functionstart(){console.log(\"Requesthandler'start'wascalled.\");varcontent=\"empty\";exec(\"ls-lah\",function(error,stdout,stderr){content=stdout;});returncontent;}functionupload(){console.log(\"Requesthandler'upload'wascalled.\");return\"HelloUpload\";}exports.start=start;exports.upload=upload;上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls-lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。上述代码是非常直观的：创建了一个新的变量content（初始值为“empty”），执行“ls-lah”命令，将结果赋值给content，最后将content返回。和往常一样，我们启动服务器，然后访问“http://localhost:8888/start”。之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。（如果想要证明这一点，可以将“ls-lah”换成比如“find/”这样更耗时的操作来效果）。然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。问题就在于，为了进行非阻塞工作，exec()使用了回调函数。在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：function(error,stdout,stderr){content=stdout;}现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行returncontent；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。我们这里“ls-lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到——不过，不管怎么说它还是异步的。为了让效果更加明显，我们想象一个更耗时的命令：“find/”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls-lah”换成“find/”，当打开/startURL的时候，依然能够立即获得HTTP响应——很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find/”命令执行完成之后才会被调用。那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。以非阻塞操作进行请求响应我刚刚提到了这样一个短语——“正确的方式”。而事实上通常“正确的方式”一般都不简单。不过，用Node.js就有这样一种实现方案：函数传递。下面就让我们来具体看看如何实现。到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序->请求路由->服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。随后，处理程序就可以采用该对象上的函数来对请求作出响应。原理就是如此，接下来让我们来一步步实现这种方案。先从server.js开始：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route,handle){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");route(handle,pathname,response);}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。下面就来看看我们的router.js:functionroute(handle,pathname,response){console.log(\"Abouttoroutearequestfor\"+pathname);if(typeofhandle[pathname]==='function'){handle[pathname](response);}else{console.log(\"Norequesthandlerfoundfor\"+pathname);response.writeHead(404,{\"Content-Type\":\"text/plain\"});response.write(\"404Notfound\");response.end();}}exports.route=route;同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。如果没有对应的请求处理器处理，我们就直接返回“404”错误。最后，我们将requestHandler.js修改为如下形式：varexec=require(\"child_process\").exec;functionstart(response){console.log(\"Requesthandler'start'wascalled.\");exec(\"ls-lah\",function(error,stdout,stderr){response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(stdout);response.end();});}functionupload(response){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloUpload\");response.end();}exports.start=start;exports.upload=upload;我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“HelloWorld”，只是这次是使用response对象而已。这时再次我们启动应用（nodeindex.js），一切都会工作的很好。如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：varexec=require(\"child_process\").exec;functionstart(response){console.log(\"Requesthandler'start'wascalled.\");exec(\"find/\",{timeout:10000,maxBuffer:20000*1024},function(error,stdout,stderr){response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(stdout);response.end();});}functionupload(response){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloUpload\");response.end();}exports.start=start;exports.upload=upload;这样一来，当请求http://localhost:8888/start的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。更有用的场景到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。要实现该功能，分为如下两步：首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。第二，用Node.js来处理文件上传（multipartPOST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。处理POST请求考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：functionstart(response){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'charset=UTF-8\"/>'+''+''+''+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"HelloUpload\");response.end();}exports.start=start;exports.upload=upload;好了，现在我们的应用已经很完善了，都可以获得威比奖（WebbyAwards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start就可以看到简单的表单了，要记得重启服务器哦！你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。余下的篇幅，我们来探讨一个更有趣的问题：当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重”——用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？我们通过在request对象上注册监听器（listener）来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。如下所示：request.addListener(\"data\",function(chunk){//calledwhenanewchunkofdatawasreceived});request.addListener(\"end\",function(){//calledwhenallchunksofdatahavebeenreceived});问题来了，这部分逻辑写在哪里呢？我们现在只是在服务器中获取到了request对象——我们并没有像之前response对象那样，把request对象传递给请求路由和请求处理程序。在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。因此，实现思路就是：将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。还等什么，马上来实现。先从server.js开始：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route,handle){functiononRequest(request,response){varpostData=\"\";varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");request.setEncoding(\"utf8\");request.addListener(\"data\",function(postDataChunk){postData+=postDataChunk;console.log(\"ReceivedPOSTdatachunk'\"+postDataChunk+\"'.\");});request.addListener(\"end\",function(){route(handle,pathname,response,postData);});}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;上述代码做了三件事情：首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：functionroute(handle,pathname,response,postData){console.log(\"Abouttoroutearequestfor\"+pathname);if(typeofhandle[pathname]==='function'){handle[pathname](response,postData);}else{console.log(\"Norequesthandlerfoundfor\"+pathname);response.writeHead(404,{\"Content-Type\":\"text/plain\"});response.write(\"404Notfound\");response.end();}}exports.route=route;然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：functionstart(response,postData){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'charset=UTF-8\"/>'+''+''+''+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response,postData){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"You'vesent:\"+postData);response.end();}exports.start=start;exports.upload=upload;好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。我们最后要做的是：当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。我们可以使用此前介绍过的querystring模块来实现：varquerystring=require(\"querystring\");functionstart(response,postData){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'charset=UTF-8\"/>'+''+''+''+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response,postData){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"You'vesentthetext:\"+querystring.parse(postData).text);response.end();}exports.start=start;exports.upload=upload;好了，以上就是关于处理POST数据的全部内容。处理文件上传最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情：如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。这里我们要用到的外部模块是FelixGeisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。其实说白了，处理文件上传“就是”处理POST数据——但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：npminstallformidable如果终端输出如下内容：npminfobuildSuccess:formidable@1.0.9npmok就说明模块已经安装成功了。现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：varformidable=require(\"formidable\");这里该模块做的就是将通过HTTPPOST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。node-formidable官方的例子展示了这两部分是如何融合在一起工作的：varformidable=require('formidable'),http=require('http'),util=require('util');http.createServer(function(req,res){if(req.url=='/upload'&&req.method.toLowerCase()=='post'){//parseafileuploadvarform=newformidable.IncomingForm();form.parse(req,function(err,fields,files){res.writeHead(200,{'content-type':'text/plain'});res.write('receivedupload:');res.end(util.inspect({fields:fields,files:files}));});return;}//showafileuploadformres.writeHead(200,{'content-type':'text/html'});res.end('+'method=\"post\">'+''+''+''+'');}).listen(8888);如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：receivedupload:{fields:{title:'HelloWorld'},files:{upload:{size:1558,path:'/tmp/1c747974a27a6292743669e91f29350b',name:'us-flag.png',type:'image/png',lastModifiedDate:Tue,21Jun201107:02:41GMT,_writeStream:[Object],length:[Getter],filename:[Getter],mime:[Getter]}}}为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。我们先来解决后面那个问题：对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。将requestHandlers.js修改为如下形式：varquerystring=require(\"querystring\"),fs=require(\"fs\");functionstart(response,postData){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'content=\"text/html;charset=UTF-8\"/>'+''+''+''+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response,postData){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"You'vesentthetext:\"+querystring.parse(postData).text);response.end();}functionshow(response,postData){console.log(\"Requesthandler'show'wascalled.\");fs.readFile(\"/tmp/test.png\",\"binary\",function(error,file){if(error){response.writeHead(500,{\"Content-Type\":\"text/plain\"});response.write(error+\"\");response.end();}else{response.writeHead(200,{\"Content-Type\":\"image/png\"});response.write(file,\"binary\");response.end();}});}exports.start=start;exports.upload=upload;exports.show=show;我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：varserver=require(\"./server\");varrouter=require(\"./router\");varrequestHandlers=require(\"./requestHandlers\");varhandle={}handle[\"/\"]=requestHandlers.start;handle[\"/start\"]=requestHandlers.start;handle[\"/upload\"]=requestHandlers.upload;handle[\"/show\"]=requestHandlers.show;server.start(router.route,handle);重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。好，最后我们要的就是：在/start表单中添加一个文件上传元素将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png将上传的图片内嵌到/uploadURL输出的HTML中第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Uploadfile”即可。如下requestHandler.js所示：varquerystring=require(\"querystring\"),fs=require(\"fs\");functionstart(response,postData){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'content=\"text/html;charset=UTF-8\"/>'+''+''+'+'method=\"post\">'+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response,postData){console.log(\"Requesthandler'upload'wascalled.\");response.writeHead(200,{\"Content-Type\":\"text/plain\"});response.write(\"You'vesentthetext:\"+querystring.parse(postData).text);response.end();}functionshow(response,postData){console.log(\"Requesthandler'show'wascalled.\");fs.readFile(\"/tmp/test.png\",\"binary\",function(error,file){if(error){response.writeHead(500,{\"Content-Type\":\"text/plain\"});response.write(error+\"\");response.end();}else{response.writeHead(200,{\"Content-Type\":\"image/png\"});response.write(file,\"binary\");response.end();}});}exports.start=start;exports.upload=upload;exports.show=show;很好。下一步相对比较复杂。这里有这样一个问题：我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。到这里，我们可以将postData从服务器以及请求处理程序中移除了——一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题：我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）我们从server.js开始——移除对postData的处理以及request.setEncoding（这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：varhttp=require(\"http\");varurl=require(\"url\");functionstart(route,handle){functiononRequest(request,response){varpathname=url.parse(request.url).pathname;console.log(\"Requestfor\"+pathname+\"received.\");route(handle,pathname,response,request);}http.createServer(onRequest).listen(8888);console.log(\"Serverhasstarted.\");}exports.start=start;接下来是router.js——我们不再需要传递postData了，这次要传递request对象：functionroute(handle,pathname,response,request){console.log(\"Abouttoroutearequestfor\"+pathname);if(typeofhandle[pathname]==='function'){handle[pathname](response,request);}else{console.log(\"Norequesthandlerfoundfor\"+pathname);response.writeHead(404,{\"Content-Type\":\"text/html\"});response.write(\"404Notfound\");response.end();}}exports.route=route;现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。没错，我们保持简单，并假设只允许上传PNG图片。这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的，也就是说，如果该重命名的操作很耗时的话会阻塞。这块我们先不考虑。接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：varquerystring=require(\"querystring\"),fs=require(\"fs\"),formidable=require(\"formidable\");functionstart(response){console.log(\"Requesthandler'start'wascalled.\");varbody=''+''+'+'charset=UTF-8\"/>'+''+''+'+'method=\"post\">'+''+''+''+''+'';response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(body);response.end();}functionupload(response,request){console.log(\"Requesthandler'upload'wascalled.\");varform=newformidable.IncomingForm();console.log(\"abouttoparse\");form.parse(request,function(error,fields,files){console.log(\"parsingdone\");fs.renameSync(files.upload.path,\"/tmp/test.png\");response.writeHead(200,{\"Content-Type\":\"text/html\"});response.write(\"receivedimage:\");response.write(\"\">\");response.end();});}functionshow(response){console.log(\"Requesthandler'show'wascalled.\");fs.readFile(\"/tmp/test.png\",\"binary\",function(error,file){if(error){response.writeHead(500,{\"Content-Type\":\"text/plain\"});response.write(error+\"\");response.end();}else{response.writeHead(200,{\"Content-Type\":\"image/png\"});response.write(file,\"binary\");response.end();}});}exports.start=start;exports.upload=upload;exports.show=show;好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。总结与展望恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。当然了，还有许多本书没有介绍到的：如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。但本书毕竟只是一本给初学者的教程——不可能覆盖到所有的内容。幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？），这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。其中Node.js社区的wiki以及NodeCloud就是最好的资源。"
    },
    {
      "source": "掘金",
      "id": "33jyuyiifte0",
      "author": "sing1ee",
      "title": "Node 在有赞的实践",
      "content": "一、概述4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在Node这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。二、Node基础框架的迭代与演进1.从Koa到阿童木（Astroboy）（1）Koa+中间件有赞最早的一个比较完整的Node项目是公司内部的一个管理系统，这个系统是用Node全栈开发的，主要包括一个给HR用的员工管理系统和给小伙伴用的APP。就像大多数公司一样，我们第一个Node项目也是直接用Koa，然后整合一些开源的中间件，这样就快速的把项目搭建起来了。这个项目做了半年之后，我们把Node该踩的坑基本也都踩了一遍，所以我们就开始尝试在对外产品上使用Node了，我们第一个尝试改造的项目是公司的官网，这是最简单的一个项目，基本没什么大的风险。（2）脚手架项目模板第二个项目我们不可能再按照之前的方式，简单用Koa加上一堆中间件的方式来搭建项目了，因为已经有了之前的经验，所以我们就整理了下这一套方案，抽离出了一个项目模板，每个新项目只要把这个模板克隆下来，然后改一下配置，就可以快速搭建出一个新的项目来。（3）阿童木1.0项目多了之后，这种方式弊端很快就显现出来了，因为模板代码和业务代码是耦合在一起，如果要改模板生成的代码，只能每个项目手动更新，而随着时间的推移，越来越难保持同步了，每个项目的目录结构和代码风格可能也会变得非常不一样，所以，解耦框架代码和业务代码就非常重要了。所以我们就在脚手架模板的基础上抽离出了一个框架叫Astroboy（阿童木），这个框架是在Koa的基础上封装的，这样，每个项目都基于这个框架开发，如果框架更新了，项目也只需要更改下框架的版本号。\">（4）阿童木2.0很多项目都开始用Node了，新的问题又出现了，因为每个产品的业务场景都不一样，对框架的需求也都不一样。例如某个中间件，产品A可能需要，而产品B可能根本不需要这个中间件，而这个时候的框架又不支持定制改造。所以对框架来说，又提出了新的挑战，所以在今年年初，对框架做了一次大的重构。这次重构在阿童木1.0的基础上，加入了很多新特性，主要有以下几点：基于Koa2开发，性能表现优异提供基于Astroboy定制上层框架的能力高度可扩展的插件机制渐进式开发首先提供基于Astroboy定制上层框架的能力，如下图所示，YouzanBaseFramework是在阿童木的基础上定制的一个有赞最基础的NodeWeb框架，这一层主要集成了一些有赞最基础的服务，像：天网系统接入，这是有赞内部的一个日志及业务监控系统健康检查，运维监控系统每隔5秒钟，都会检查系统服务可用性全链路监控，对于一次HTTP请求，一般都会调用多个后端接口，相应的后端接口也会再去调用其他接口，所以整个调用过程实际上是一棵树状的结构，如果碰到性能问题，找出其中性能瓶颈问题就非常重要了，全链路监控就是为了解决这个问题。Dubbo服务调用接入，关于这一点，查看下面关于服务化的介绍。有了YouzanBaseFramework后，我们就需要在上面开发业务了，这个分两种业务场景：对于一些简单单一的业务，直接继承YouzanBaseFramework开发就可以了；而如果是一些复杂的业务，就可以先在YouzanBaseFramework的基础上，定制出一个业务框架，像我们有赞原先有一个超大的PHP项目（我们叫Iron），那么服务化拆分后，Node就承担了原先PHP的部分，所以我们新先定制了一个业务级的框架叫IronBaseFramework，然后再按照业务模块（交易、店铺、用户、营销）拆分成多个子项目。\">其次是支持插件化，关于这一点，可查看下面关于插件的说明。2.框架的几个核心概念以上介绍了有赞Node基础框架迭代和演变的过程，下面主要介绍下阿童木2.0框架的几个核心概念（1）应用Application应用Application的概念很好理解，在这里应用就可以理解成一个项目，它是从框架继承下来，并且实例化之后的一个实例，应用也是由一个一个插件构成的。（2）框架FrameworkAstroboy框架是在Koa2的基础上封装的，关于框架的概念，这里就不再做过多的介绍了。（3）插件Plugin插件化是软件设计中一个很重要的思想，很多软件像Eclipse都支持这样的特性，插件化可以让我们的系统解耦，每个模块做到独立开发，而模块之间又不会相互影响，这样的特性对于大型项目来说是非常重要的。插件化是Astroboy框架中最核心的一个实现，它是服务（Service）、中间件（Middleware）和工具函数库（Lib）等的载体，它本质上还是NPM包，只不过是在NPM包的基础上，做了更深层次的抽象。基于Astroboy的应用，就是由一个一个的Plugin组成的，Plugin就是我们手中的积木，通过Astroboy的框架引擎把这些积木组织在一起，就形成了系统。那么插件跟普通的NPM包有什么区别呢？插件约定了目录结构，这样每个插件看起来都是类似的，这对于团队的协作是非常重要，如果每个模块看起来都不一样，那么团队的协作成本就会很高。应用启动后，插件的代码是自动注入到整个应用的，只需要在插件的配置文件里面开启这个插件即可。一个插件可以包含哪些信息？插件元数据，包括插件名称、版本、描述等；服务（Service）、中间件（Middleware）以及工具函数库（Lib）等；Koa内置对象的扩展，包括Context、Application、Request以及Response等；插件的管理安装插件，通过npminstall命令即可，例如：npminstall[<@scope>/]@启用插件，安装插件后还需要启用插件，插件才会真正生效。启用插件也很简单，只需要配置plugin.default.js即可，如果不同环境插件配置不一样，也只需修改相应*环境的配置（plugin.${env}.js）即可，这里env表示Node运行时的环境变量，例如：development、test、production等。如下代码所示：'astroboy-cookie':{enable:true,path:path.resolve(__dirname,'../plugins/astroboy-cookie')}复制代码enable设置成true就可以开启这个插件，path表示插件的绝对路径，这种一般适合于还在快速迭代中的插件，如果插件已经很稳定了，你就可以把这个插件打包发布成一个NPM包，然后通过package声明你的插件即可，如下代码所示：'astroboy-cookie':{enable:true,package:'astroboy-cookie'}复制代码禁用插件，禁用插件就更加简单了，只需将enable设置成false即可。三、Node接入有赞服务化体系的历程1.为什么要做服务化？随着公司业务的发展，网站应用的规模不断扩大，垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键，所以在这个时候，分布式服务架构就势在必行了。2.技术栈的选择在介绍技术栈选择之前，先讲一下公司的一些技术背景。在公司成立初期，为了能够快速开发，把产品快速做出来推出市场，所以我们选择用PHP语言，我想这也是大多数创业公司的选择。而随着业务的发展，PHP越来越难处理复杂的业务。所以等到了一定时候，我们开始做服务化拆分，那么首先考虑的就是底层技术的选择，我们从下面几点考虑：第一个是这门技术的生态是否足够完善，也就是相关的开源软件、工具是否成熟；第二个是否能够快速招到你需要的人才。3.服务化拆分之后，每一层职责分别是什么？对于Node层，我们的定位是一层很薄的中间层，Node这一层不会过多地处理业务逻辑，业务逻辑全部都交给Java来处理，它只负责下面三件事情：模板渲染：模板渲染说的就是HTML模板的渲染；业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。接口转发：Java的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node需要承担接口转发的角色。而对于Java这一层，就需要承担业务逻辑以及缓存等复杂的操作，这里就不做过多的介绍了。4.Node如何调用Java接口？那么服务化拆分之后，首先要解决的一个问题是：Node如何调用Java提供的接口。首先，我们想到的就是HTTP的方式，这里说明一下，我们公司采用的分布式服务化框架是阿里开源的Dubbo框架，而Dubbo框架本身是支持通过添加注解的方式生成RestfulAPI的，所以在初期，我们就是采用这个现成的方案。而随着应用数目的增加，这种方式的弊端也逐渐显现出来，主要有下面几点：如果某个接口需要暴露给Node使用，就需要手动再去添加额外的注解。每增加一个应用，运维都需要针对每个应用配置域名，不同的环境又需要配置不同的域名，所以随着应用数的增加，应用域名的管理越来越难维护。相应的，node也需要维护一份很长的域名配置文件。由于Java是直接提供HTTP接口，所以性能上相对RPC的方式会低一点。所以，我们就调研了下，看其他公司在使用Dubbo框架时，Node是如何调用Java的？如下图所示：\">首先，Java应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是ETCD或者Zookeeper，然后，Node应用在启动的时候，会先从服务注册中心拉取服务列表，接着Node会跟Java服务建立一条TCP长链接，除此之外，Node还需要负责Hession协议解析以及负载均衡等。不难发现，这种方式Node的职责就比较重，而且对Node开发的要求会很高。所以，我们对这种方式做了改进，如下图所示：\">我们在Node和Java之间添加了一层中间代理层Tether，Tether是用Go语言写的一个本地代理，Tether会对外暴露一个HTTP的服务，对Node来说，只需要通过HTTP方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由Tether来处理。这样，Node这一层就非常轻量了，那么，最终实现出来，Node是怎么调用Java服务的呢？如下代码所示：constService=require('../base/BaseService');classGoodsServiceextendsService{/***根据商品alias获取商品详情*@param{String}alias商品alias*/asyncgetGoodsDetailByAlias(alias){constresult=this.invoke('com.youzan.ic.service.GoodsService','getGoodsDetailByAlias',[alias]);returnresult;}}module.exports=GoodsService;复制代码对Node来说，调用Java服务它只需要关注三个点：服务名：服务名是由Java的包名+类名组成，例如上面的com.youzan.ic.service.GoodsService方法名：Java类对外暴露的方法，例如上面代码所示的根据商品alias查询商品详情的一个方法getGoodsDetailByAlias参数：参数就是传递给Java的参数列表最后，总结下这种方式都有哪些优点：第一个是使用简单，对前端开发非常友好，只需要通过HTTP方式调用本地的Tether服务即可；第二个是多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像Node一样，它们都只需要调用本地Tether暴露的HTTP服务即可，没有额外的开发成本了。第三个是后期更方便做协议层的优化，因为这种方式Tether其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化Tether的性能就可以了。那么，看到这里，有人可能又会想，这里Node也是通过HTTP方式调用Java的，性能上是不是也存在问题呢？所以这里我们就做了一些优化，如下代码所示：constAgent=require('agentkeepalive');module.exports=newAgent({maxSockets:100,maxFreeSockets:10,timeout:60000,freeSocketKeepAliveTimeout:30000,});复制代码这里，我们引用了一个agentkeepalive包，在HTTP早期，每个HTTP请求都要求打开一个TCPSocket连接，并且使用一次之后就断开这个TCP连接，使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。所以通过使用keep-alive机制，就可以减少TCP连接建立次数。四、参考资料https://github.com/apache/incubator-dubbohttps://github.com/QianmiOpen/dubbo2.jshttps://github.com/QianmiOpen/dubbo-node-clienthttps://github.com/p412726700/node-zookeeper-dubbohttps://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5\">",
      "time": "2018年05月22日"
    },
    {
      "source": "掘金",
      "id": "3lj2nlpubna0",
      "author": "",
      "title": "Node - 从0基础到实战企业官网",
      "content": "Createbyjsliangon2018-11-813:42:42Recentlyrevisedin2018-12-2321:59:20Hello小伙伴们，如果觉得本文还不错，记得点个赞或者给个star，你们的赞和star是我编写更多更精彩文章的动力！GitHub地址【2019-08-16】Hello小伙伴们，由于jsliang对文档库进行了重构，这篇文章的一些链接可能失效，而jsliang没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的GitHub地址，去文档库查看调整后的文章。本文重点内容Node基础-通过对Node基础的了解学习，打下Node基础NodeAPI-开启服务提供API给前端调用Node连接MySQL-通过npm安装mysql，从而实现数据库的链接Node实战-企业官网从0开始，打造能注册、登录以及留言的企业官网Node部署-如何通过部署云服务器，让小伙伴们可以查看到你的网站本文延伸链接Node部署项目、云服务器以及域名的使用：链接本文Node基础代码下载地址：链接本文Node成品代码下载地址：链接本文成品演示Node项目演示：jsliang前端有限公司\">一目录不折腾的前端，和咸鱼有什么区别目录一目录二前言三基础学习3.1HTTP-开始Node之旅3.2URL模块3.3CommonJS3.4包与npm3.5fs文件管理3.6fs案例3.7fs流3.8创建Web服务器3.9非阻塞I/O事件驱动3.10get与post3.11Node连接MySQL四Web实战——企业官网4.1编程环境4.2后端接口4.3注册功能4.4登录功能4.5留言功能五工具整合5.1supervisor-监听Node改动5.2PM2-Node进程管理六参考资料七线上部署八归纳总结二前言返回目录本文主要目的：整合Node基础，加深jsliang对Node的学习了解，并且方便日后复习。整合Node工具，方便查找在Node开发中，有哪些工具比较有利于开发。给初学Node的小伙伴做一个参考，如有疑问还请在QQ群：798961601中咨询。三基础返回目录万丈高楼平地起，地基还得自己起。3.1HTTP-开始Node之旅返回目录话不多说，先上代码：01_http.js//1.引入http模块varhttp=require(\"http\");//2.用http模块创建服务/***req获取url信息(request)*res浏览器返回响应信息(response)*/http.createServer(function(req,res){//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});//往页面打印值res.write('HelloNodeJS');//结束响应res.end();}).listen(3000);//监听的端口复制代码那么，上面代码，我们要怎么用呢？首先，将上面的代码复制粘贴到01_http.js中。然后，启动VSCode终端：Ctrl+~。接着，输入node01_http.js并回车。最后，打开localhost:3000：\">OK，搞定完事，现在我们一一讲解上面代码：首先，我们需要先开启仙人模式。哦，不是，是HTTP模式。我们都知道，像PHP这类老牌子的后端语言，需要Apache或者Nginx开启HTTP服务。然而我们的Node不需要：varhttp=require(\"http\");复制代码然后，开启HTTP服务，并设置开启的端口：/***req获取url信息(request)*res浏览器返回响应信息(response)*/http.createServer(function(req,res){//...步骤3代码}).listen(3000);//监听的端口复制代码接着，我们设置HTTP头部，并往页面打印值，最后结束响应：//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});//往页面打印值res.write('HelloNodeJS');//结束响应res.end();复制代码最后，我们往浏览器输入http://localhost:3000/，将访问到我们开启的Node服务，从而往页面渲染页面。至此，小伙伴们是不是也开启了自己的Node之旅？3.2URL模块返回目录URL模块是什么呢？我们在控制台（终端）开启Node模式，并打印出url来看一下：\">好家伙，它有Url、parse、resolve、resolveObject、format、URL、URLSearchParams、domainToASCII、domainToUnicode这么多模块。那么，这些模块都有什么用呢？话不多说，先上代码：02_url.js//1.引入url模块varurl=require(\"url\");//2.引入http模块varhttp=require(\"http\");//3.用http模块创建服务/***req获取url信息(request)*res浏览器返回响应信息(response)*/http.createServer(function(req,res){//4.获取服务器请求/***访问地址是：http://localhost:3000/?userName=jsliang&userAge=23*如果你执行console.log(req.url)，它将执行两次，分别返回下面的信息：*/?userName=jsliang&userAge=23*//favicon.ico*这里为了防止重复执行，所以排除req.url==/favicon.ico的情况*/if(req.url!=\"/favicon.ico\"){//5.使用url的parse方法/***parse方法需要两个参数：*第一个参数是地址*第二个参数是true的话表示把get传值转换成对象*/varresult=url.parse(req.url,true);console.log(result);/***Url{*protocol:null,*slashes:null,*auth:null,*host:null,*port:null,*hostname:null,*hash:null,*search:'?userName=jsliang&userAge=23',*query:{userName:'jsliang',userAge:'23'},*pathname:'/',*path:'/?userName=jsliang&userAge=23',*href:'/?userName=jsliang&userAge=23'}*/console.log(result.query.userName);//jsliangconsole.log(result.query.userAge);//23}//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});//往页面打印值res.write('HelloNodeJS');//结束响应res.end();}).listen(3000);复制代码在上面的代码中：首先，我们引入该章节的主角url模块：//1.引入url模块varurl=require(\"url\");复制代码然后，我们引入http模块：//2.引入http模块varhttp=require(\"http\");复制代码接着，我们创建http模块，因为url的监听，需要http模块的开启：//3.用http模块创建服务/***req获取url信息(request)*res浏览器返回响应信息(response)*/http.createServer(function(req,res){//...第4步、第5步代码//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});//往页面打印值res.write('HelloNodeJS');//结束响应res.end();}).listen(3000);复制代码最后，我们访问我们给出的地址：http://localhost:3000/?userName=jsliang&userAge=23，并通过它查看url的parse模块怎么用，输出啥：//4.获取服务器请求/***访问地址是：http://localhost:3000/?userName=jsliang&userAge=23*如果你执行console.log(req.url)，它将执行两次，分别返回下面的信息：*/?userName=jsliang&userAge=23*//favicon.ico*这里为了防止重复执行，所以排除req.url==/favicon.ico的情况*/if(req.url!=\"/favicon.ico\"){//5.使用url的parse方法/***parse方法需要两个参数：*第一个参数是地址*第二个参数是true的话表示把get传值转换成对象*/varresult=url.parse(req.url,true);console.log(result);/***Url{*protocol:null,*slashes:null,*auth:null,*host:null,*port:null,*hostname:null,*hash:null,*search:'?userName=jsliang&userAge=23',*query:{userName:'jsliang',userAge:'23'},*pathname:'/',*path:'/?userName=jsliang&userAge=23',*href:'/?userName=jsliang&userAge=23'}*/console.log(result.query.userName);//jsliangconsole.log(result.query.userAge);//23}复制代码从中，我们可以看出，我们可以通过query，获取到我们想要的路径字段。当然，上面只讲解了parse的用法，我们可以将上面代码中if语句里面的代码全部清空。然后，输入下面的内容，去学习url模块更多的内容：url模块所有内容：console.log(url);/***Console：{Url:[Function:Url],parse:[Function:urlParse],//获取地址信息resolve:[Function:urlResolve],//追加或者替换地址resolveObject:[Function:urlResolveObject],format:[Function:urlFormat],//逆向parse，根据地址信息获取原url信息URL:[Function:URL],URLSearchParams:[Function:URLSearchParams],domainToASCII:[Function:domainToASCII],domainToUnicode:[Function:domainToUnicode]}*/复制代码parse如何使用console.log(url.parse(\"http://www.baidu.com\"));/***Console：Url{protocol:'http:',slashes:true,auth:null,host:'www.baidu.com',port:null,hostname:'www.baidu.com',hash:null,search:null,query:null,pathname:'/',path:'/',href:'http://www.baidu.com/'}*/复制代码parse带参数：console.log(url.parse(\"http://www.baidu.com/new?name=zhangsan\"));/***Console：Url{protocol:'http:',slashes:true,auth:null,host:'www.baidu.com',port:null,hostname:'www.baidu.com',hash:null,search:'?name=zhangsan',query:'name=zhangsan',pathname:'/new',path:'/new?name=zhangsan',href:'http://www.baidu.com/new?name=zhangsan'}*/复制代码format的使用：console.log(url.format({protocol:'http:',slashes:true,auth:null,host:'www.baidu.com',port:null,hostname:'www.baidu.com',hash:null,search:'?name=zhangsan',query:'name=zhangsan',pathname:'/new',path:'/new?name=zhangsan',href:'http://www.baidu.com/new?name=zhangsan'}))//Console：//http://www.baidu.com/new?name=zhangsan复制代码resolve的使用：console.log(url.resolve(\"http://www.baidu.com/jsliang\",\"梁峻荣\"));//Console：//http://www.baidu.com/梁峻荣复制代码当然，url这里我们只讲解了个入门，更多的还请看官网API：url|Node.jsv10.14.1文档3.3CommonJS返回目录什么是CommonJS？CommonJS就是为JS的表现来制定规范，因为JS没有模块系统、标准库较少、缺乏包管理工具，所以CommonJS应运而生，它希望JS可以在任何地方运行，而不只是在浏览器中，从而达到Java、C#、PHP这些后端语言具备开发大型应用的能力。CommonJS的应用？服务器端JavaScript应用程序。（Node.js）命令行工具桌面图形界面应用程序。CommonJS与Node.js的关系？CommonJS就是模块化的标准，Node.js就是CommonJS（模块化）的实现。Node.js中的模块化？在Node中，模块分为两类：一是Node提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在Node源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP模块、URL模块、FS模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。我们可以将公共的功能抽离出一个单独的JS文件存放，然后在需要的情况下，通过exports或者module.exports将模块导出，并通过require引入这些模块。现在，我们通过三种使用方式，来讲解下Node中的模块化及exports/require的使用。我们先查看下目录：\">方法一：首先，我们新建03_CommonJS.js、03_tool-add.js、node_modules/03_tool-multiply.js、node_modules/jsliang-module/tools.js这4个文件/文件夹。其中package.json我们暂且不理会，稍后会讲解它如何自动生成。在03_tool-add.js中：03_tool-add.js//1.假设我们文件其中有个工具模块vartools={add:(...numbers)=>{letsum=0;for(letnumberinnumbers){sum+=numbers[number];}returnsum;}}/***2.暴露模块*exports.str=str;*module.exports=str;*区别：*module.exports是真正的接口*exports是一个辅助工具*如果module.exports为空，那么所有的exports收集到的属性和方法，都赋值给了module.exports*如果module.exports具有任何属性和方法，则exports会被忽略*///exports使用方法//varstr=\"jsliangisverygood!\";//exports.str=str;//{str:'jsliangisverygood!'}//module.exports使用方法module.exports=tools;复制代码那么，上面的代码有啥含义呢？第一步，我们定义了个工具库tools。第二步，我们通过modules.exports将tools进行了导出。所以，我们在03_CommonJS.js可以通过require导入使用：varhttp=require(\"http\");vartools1=require('./03_tool-add');http.createServer(function(req,res){res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});res.write('HelloNodeJS');console.log(tools1.add(1,2,3));/***Console：*6*6*这里要记得Node运行过程中，它请求了两次，*http://localhost:3000/为一次，*http://localhost:3000/favicon.ico为第二次*/res.end();}).listen(3000);复制代码这样，我们就完成了exports与require的初次使用。方法二：当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node就很靠谱，它规范我们可以将这些文件都放在node_modules目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。所以，我们在node_modules中新建一个03_tool-multiply.js文件，其内容如下：03_tool-multiply.jsvartools={multiply:(...numbers)=>{letsum=numbers[0];for(letnumberinnumbers){sum=sum*numbers[number];}returnsum;}}module.exports=tools;复制代码在引用方面，我们只需要通过：//如果Node在当前目录没找到tool.js文件，则会去node_modules里面去查找vartools2=require('03_tool-multiply');console.log(tools2.multiply(1,2,3,4));复制代码这样，就可以成功导入03_tool-multiply.js文件了。方法三：如果全部单个文件丢在node_modules上，它会显得杂乱无章，所以我们应该定义个自己的模块：jsliang-module，然后将我们的tools.js存放在该目录中：jsliang-module/tools.jsvartools={add:(...numbers)=>{letsum=0;for(letnumberinnumbers){sum+=numbers[number];}returnsum;},multiply:(...numbers)=>{letsum=numbers[0];for(letnumberinnumbers){sum=sum*numbers[number];}returnsum;}}module.exports=tools;复制代码这样，我们就定义好了自己的工具库。但是，如果我们通过vartools3=require('jsliang-module');去导入，会发现它报error了，所以，我们应该在jsliang-module目录下，通过下面命令行生成一个package.jsonPSE:\\MyWebode_modules\\jsliang-module>npminit--yes这样，在jsliang-module中就有了package.json。而我们在03_CommonJS.js就可以引用它了：03_CommonJS.jsvarhttp=require(\"http\");vartools1=require('./03_tool-add');//如果Node在当前目录没找到tool.js文件，则会去node_modules里面去查找vartools2=require('03_tool-multiply');/***通过package.json来引用文件*1.通过在jsliang-module中npminit--yes来生成package.json文件*2.package.json文件中告诉了程序入口文件为：\"main\":\"tools.js\",*3.Node通过require查找jsliang-module，发现它有个package.json*4.Node执行tools.js文件*/vartools3=require('jsliang-module');http.createServer(function(req,res){res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});res.write('HelloNodeJS');console.log(tools1.add(1,2,3));console.log(tools2.multiply(1,2,3,4));console.log(tools3.add(4,5,6));/***Console：*6*24*15*6*24*15*这里要记得Node运行过程中，它请求了两次，*http://localhost:3000/为一次，*http://localhost:3000/favicon.ico为第二次*/res.end();}).listen(3000);复制代码到此，我们就通过三种方法，了解了各种exports和require的姿势以及Node模块化的概念啦~参考文献：CommonJS规范|博客园-LittleBirdjs模块化编程之彻底弄懂CommonJS和AMD/CMD！|博客园-方便以后复习[js高手之路]es6系列教程-不定参数与展开运算符(...)|博客园-ghostwu3.4包与npm返回目录Node中除了它自己提供的核心模块之外，还可以自定义模块，以及使用第三方模块。Node中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。\">那么，假如我们需要使用一些第三方模块，应该去哪找呢？百度。百度查找你需要安装的第三方模块的对应内容。npm官网。如果你已经知道包的名字或者包的作用。那么，直接在npm官网上搜索，想必会更快找到想要安装的包。那么，npm是啥？npm是世界上最大的开放源代码的生态系统。我们可以通过npm下载各种各样的包。在我们安装Node的时候，它默认会顺带给你安装npm。npm-v：查看npm版本。npmlist：查看当前目录下都安装了哪些npm包。npminfo模块：查看该模块的版本及内容。npmi模块@版本号：安装该模块的指定版本。在平时使用npm安装包的过程中，你可能需要知道一些npm基本知识：i/install：安装。使用install或者它的简写i，都表明你想要下载这个包。uninstall：卸载。如果你发现这个模块你已经不使用了，那么可以通过uninstall卸载它。g：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。--save/-S：通过该种方式安装的包的名称及版本号会出现在package.json中的dependencies中。dependencies是需要发布在生成环境的。例如：ElementUI是部署后还需要的，所以通过-S形式来安装。--save-dev/-D：通过该种方式安装的包的名称及版本号会出现在package.json中的devDependencies中。devDependencies只在开发环境使用。例如：gulp只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过-D形式来安装。例子：cnpmiwebpack-cli-Dnpminstallelement-ui-S那么，这么多的npm包，我们通过什么管理呢？答案是package.json。如果我们需要创建package.json，那么我们只需要在指定的包管理目录（例如node_modules）中通过以下命名进行生成：npminit：按步骤创建package.json。npminit--yes：快速创建package.json当然，因为国内网络环境的原因，有些时候通过npm下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的npm镜像：cnpmnpminstall-gcnpm--registry=https://registry.npm.taobao.org3.5fs文件管理返回目录本章节我们讲解下fs文件管理：如需快速找到下面某个内容，请使用Ctrl+Ffs.stat检测是文件还是目录fs.mkdir创建目录fs.writeFile创建写入文件fs.appendFile追加文件fs.readFile读取文件fs.readdir读取目录fs.rename重命名fs.rmdir删除目录fs.unlink删除文件此章节文件目录：\">首先，我们通过fs.stat检查一个读取的是文件还是目录：05_fs.js//1.fs.statletfs=require('fs');fs.stat('index.js',(error,stats)=>{if(error){console.log(error);returnfalse;}else{console.log(stats);/***Console：*Stats{*dev:886875,*mode:33206,*nlink:1,*uid:0,*gid:0,*rdev:0,*blksize:undefined,*ino:844424931461390,*size:284,*blocks:undefined,*atimeMs:1542847157494,*mtimeMs:1543887546361.2158,*ctimeMs:1543887546361.2158,*birthtimeMs:1542847157493.663,*atime:2018-11-22T00:39:17.494Z,*mtime:2018-12-04T01:39:06.361Z,*ctime:2018-12-04T01:39:06.361Z,*birthtime:2018-11-22T00:39:17.494Z}*/console.log(`文件：${stats.isFile()}`);//Console：文件：trueconsole.log(`目录：${stats.isDirectory()}`);//Console：目录：falsereturnfalse;}})复制代码通过Console打印出来的信息，我们基础掌握了fs.stat的作用。然后，我们尝试通过fs.mkdir创建目录：05_fs.js//2.fs.mkdirletfs=require('fs');/***接收参数*path-将创建的目录路径*mode-目录权限（读写权限），默认0777*callback-回调，传递异常参数err*/fs.mkdir('css',(err)=>{if(err){console.log(err);returnfalse;}else{console.log(\"创建目录成功！\");//Console：创建目录成功！}})复制代码通过node05_fs.js，我们发现目录中多了一个css文件夹。那么，有创建就有删除，创建的目录如何删除呢？这里讲解下fs.rmdir：05_fs.js//8.fs.rmdirletfs=require('fs');/***接收参数*path-将创建的目录路径*mode-目录权限（读写权限），默认0777*callback-回调，传递异常参数err*/fs.rmdir('css',(err)=>{if(err){console.log(err);returnfalse;}else{console.log(\"创建目录成功！\");//Console：创建目录成功！}})复制代码通过node05_fs.js，我们发现目录中的css文件夹被删除了。接着，我们通过fs.writeFile来创建写入文件：05_fs.js//3.fs.writeFileletfs=require('fs');/***filename(String)文件名称*data(String|Buffer)将要写入的内容，可以是字符串或者buffer数据。*·encoding(String)可选。默认'utf-8'，当data是buffer时，该值应该为ignored。*·mode(Number)文件读写权限，默认438。*·flag(String)默认值'w'。*callback{Function}回调，传递一个异常参数err。*/fs.writeFile('index.js','Hellojsliang',(err)=>{if(err){console.log(err);returnfalse;}else{console.log('写入成功！');}})复制代码值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加Hellojsliang这句话。即：存在即覆盖，不存在即创建。有创建就有删除，感兴趣的可以使用fs.unlink进行文件的删除，再次不做过多讲解。既然，上面的是覆盖文件，那么有没有追加文件呢？有的，使用fs.appendFile吧：05_fs.js//4.fs.appendFileletfs=require('fs');fs.appendFile('index.js','这段文本是要追加的内容',(err)=>{if(err){console.log(err);returnfalse;}else{console.log(\"追加成功\");}})复制代码这样，我们就成功往里面追加了一段话，从而使index.js变成了：index.jsHellojsliang这段文本是要追加的内容复制代码在上面，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了：fs.readFile读取文件fs.readdir读取目录05_fs.jsletfs=require('fs');//5.fs.readFilefs.readFile('index.js',(err,data)=>{if(err){console.log(err);returnfalse;}else{console.log(\"读取文件成功！\");console.log(data);//Console：//读取文件成功！//<Buffer48656c6c6f206a736c69616e67e8bf99e6aeb5e69687e69cace698afe8a681e8bfbde58aa0e79a84e58685e5aeb9>}})//6.fs.readdir读取目录fs.readdir('node_modules',(err,data)=>{if(err){console.log(err);returnfalse;}else{console.log(\"读取目录成功！\");console.log(data);//Console：//读取目录成功！//['03_tool-multiply.js','jsliang-module']}})复制代码如上，我们成功做到了读取文件和读取目录。最后，我们再回顾一开始的目标：1.fs.stat检测是文件还是目录2.fs.mkdir创建目录3.fs.writeFile创建写入文件4.fs.appendFile追加文件5.fs.readFile读取文件6.fs.readdir读取目录7.fs.rename重命名8.fs.rmdir删除目录9.fs.unlink删除文件很好，我们就剩下重命名了：05_fs.jsletfs=require('fs');//7.fs.rename重命名fs.rename('index.js','jsliang.js',(err)=>{if(err){console.log(err);returnfalse;}else{console.log(\"重命名成功！\");}})复制代码当然，如果fs.rename还有更劲爆的功能：剪切05_fs.jsletfs=require('fs');//7.fs.rename重命名fs.rename('jsliang.js','node_modules/jsliang.js',(err)=>{if(err){console.log(err);returnfalse;}else{console.log(\"剪切成功！\");}})复制代码OK，通通搞定，现在目录变成了：\">3.6fs案例返回目录在上一章节中，我们了解了fs的文件管理。那么，在这里，我们尝试使用fs做点小事情：06_fsDemo.js/***1.fs.stat检测是文件还是目录*2.fs.mkdir创建目录*3.fs.writeFile创建写入文件*4.fs.appendFile追加文件*5.fs.readFile读取文件*6.fs.readdir读取目录*7.fs.rename重命名*8.fs.rmdir删除目录*9.fs.unlink删除文件*///1.判断服务器上面有没有upload目录，没有就创建这个目录//2.找出html目录下面的所有的目录，然后打印出来letfs=require('fs');//图片上传fs.stat('upload',(err,stats)=>{//判断有没有upload目录if(err){//如果没有fs.mkdir('upload',(error)=>{if(error){console.log(error);returnfalse;}else{console.log(\"创建upload目录成功！\");}})}else{//如果有console.log(stats.isDirectory());console.log(\"有upload目录，你可以做更多操作！\");}})//读取目录全部文件fs.readdir('node_modules',(err,files)=>{if(err){console.log(err);returnfalse;}else{//判断是目录还是文件夹console.log(files);letfilesArr=[];(functiongetFile(i){//循环结束if(i==files.length){//打印出所有目录console.log(\"目录：\");console.log(filesArr);returnfalse;}//判断目录是文件还是文件夹fs.stat('node_modules/'+files[i],(error,stats)=>{if(stats.isDirectory()){filesArr.push(files[i]);}//递归调用getFile(i+1);})})(0)}})复制代码3.7fs流返回目录话不多说，我们了解下fs流及其读取：//新建fsconstfs=require('fs');//流的方式读取文件letfileReadStream=fs.createReadStream('index.js');//读取次数letcount=0;//保存数据letstr='';//开始读取fileReadStream.on('data',(chunk)=>{console.log(`${++count}接收到：${chunk.length}`);//Console：1接收到：30str+=chunk;})//读取完成fileReadStream.on('end',()=>{console.log(\"——结束——\");console.log(count);console.log(str);//Console：——结束——//1//console.log(\"HelloWorld！\");})//读取失败fileReadStream.on('error',(error)=>{console.log(error);})复制代码在这里，我们通过fs模块的createReadStream创建了读取流，然后读取文件index.js，从而最后在控制台输出了：1接收到：259——结束——1console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\");console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\");console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\");复制代码其中console.log()那三行就是index.js的文本内容。然后，我们试下流的存入：letfs=require('fs');letdata='console.log(\"HelloWorld!我要存入数据！\")';//创建一个可以写入的流，写入到文件index.js中letwriteStream=fs.createWriteStream('index.js');//开始写入writeStream.write(data,'utf8');//写入完成writeStream.end();writeStream.on('finish',()=>{console.log('写入完成！');//Console：写入完成});复制代码我们打开index.js，会发现里面的内容变成了console.log(\"HelloWorld!我要存入数据！\")，依次，我们通过流的形式进行了读取和写入的操作。3.8创建Web服务器返回目录在这里，我们利用http模块、url模块、path模块、fs模块创建一个Web服务器。什么是Web服务器？Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、Nginx、IIS。下面，我们使用Node来创建一个Web服务：\">08_WebService.js//引入http模块lethttp=require(\"http\");//引入fs模块letfs=require(\"fs\");http.createServer((req,res)=>{//获取响应路径letpathName=req.url;//默认加载路径if(pathName==\"/\"){//默认加载的首页pathName=\"index.html\";}//过滤/favicon.ico的请求if(pathName!=\"/favicon.ico\"){//获取08_WebService下的index.htmlfs.readFile(\"./08_WebService/\"+pathName,(err,data)=>{if(err){//如果不存在这个文件console.log(\"404NotFound!\");fs.readFile('./08_WebService/404.html',(errorNotFound,dataNotFound)=>{if(errorNotFound){console.log(errorNotFound);}else{res.writeHead(200,{\"Content-Type\":\"text/html;charset='utf-8'\"});//读取写入文件res.write(dataNotFound);//结束响应res.end();}})return;}else{//返回这个文件//设置请求头res.writeHead(200,{\"Content-Type\":\"text/html;charset='utf-8'\"});//读取写入文件res.write(data);//结束响应res.end();}});}}).listen(8080);复制代码这样，我们在浏览器输入localhost:8080即可以看到：\">好家伙，感情它就加载了整个index.html文件，连CSS这些没引入么？所以，下一步，我们要动态加载html、css以及js：08_WebService.js//引入http模块lethttp=require(\"http\");//引入fs模块letfs=require(\"fs\");//引入url模块leturl=require(\"url\");//引入path模块letpath=require(\"path\");http.createServer((req,res)=>{//获取响应路径letpathName=url.parse(req.url).pathname;//默认加载路径if(pathName==\"/\"){//默认加载的首页pathName=\"index.html\";}//获取文件的后缀名letextName=path.extname(pathName);//过滤/favicon.ico的请求if(pathName!=\"/favicon.ico\"){//获取08_WebService下的index.htmlfs.readFile(\"./08_WebService/\"+pathName,(err,data)=>{//如果不存在这个文件if(err){console.log(\"404NotFound!\");fs.readFile(\"./08_WebService/404.html\",(errorNotFound,dataNotFound)=>{if(errorNotFound){console.log(errorNotFound);}else{res.writeHead(200,{\"Content-Type\":\"text/html;charset='utf-8'\"});//读取写入文件res.write(dataNotFound);//结束响应res.end();}});return;}//返回这个文件else{//获取文件类型letext=getExt(extName);//设置请求头res.writeHead(200,{\"Content-Type\":ext+\";charset='utf-8'\"});//读取写入文件res.write(data);//结束响应res.end();}});}}).listen(8080);//获取后缀名getExt=(extName)=>{switch(extName){case'.html':return'text/html';case'.css':return'text/css';case'.js':return'text/js';default:return'text/html';}}复制代码这样，当我们再次请求的时候，浏览器就变成了：\">当然，在上面，我们仅仅模拟了html、css、js这三种文件类型而已，我们需要模拟更多的文件类型：08_ext.json代码详情请点击上面的链接复制代码在上面的json文件中，我们定义了各种的文件类型，此刻文件目录如下所示：\">这时候，我们需要修改下我们的js文件，让它适应多种请求响应了：08_WebService.js//引入http模块lethttp=require(\"http\");//引入fs模块letfs=require(\"fs\");//引入url模块leturl=require(\"url\");//引入path模块letpath=require(\"path\");http.createServer((req,res)=>{//获取响应路径letpathName=url.parse(req.url).pathname;//默认加载路径if(pathName==\"/\"){//默认加载的首页pathName=\"index.html\";}//获取文件的后缀名letextName=path.extname(pathName);//过滤/favicon.ico的请求if(pathName!=\"/favicon.ico\"){//获取08_WebService下的index.htmlfs.readFile(\"./08_WebService/\"+pathName,(err,data)=>{//如果不存在这个文件if(err){console.log(\"404NotFound!\");fs.readFile(\"./08_WebService/404.html\",(errorNotFound,dataNotFound)=>{if(errorNotFound){console.log(errorNotFound);}else{res.writeHead(200,{\"Content-Type\":\"text/html;charset='utf-8'\"});//读取写入文件res.write(dataNotFound);//结束响应res.end();}});return;}//返回这个文件else{//获取文件类型letext=getExt(extName);console.log(ext);//设置请求头res.writeHead(200,{\"Content-Type\":ext+\";charset='utf-8'\"});//读取写入文件res.write(data);//结束响应res.end();}});}}).listen(8080);//获取后缀名getExt=(extName)=>{//readFile是异步操作，所以需要使用readFileSyncletdata=fs.readFileSync('./08_ext.json');letext=JSON.parse(data.toString());returnext[extName];}复制代码如此，我们做了个简单的Web服务器。3.9非阻塞I/O事件驱动返回目录Java、PHP或者.NET等服务端语言，会为每一个客户端的连接创建一个新的线程。Node不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就会触发一个内部事件，通过非租塞I/O、事件驱动机制，让Node程序宏观上也是并行的。使用Node，一个8GB内存的服务器，可以同时处理超过4万用户的连接。在这一章节中，主要解决：Node的非阻塞I/O是什么？Nodeevents模块是什么？首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的：09_io.jsconsole.log(\"1\");console.log(\"2\");console.log(\"3\");/***Console：*1*2*3*/复制代码但是，事与愿违。我们有时候，会执行一些异步方法（函数）：09_io.jsconsole.log(\"1\");//console.log(\"2\");letfs=require('fs');getExt=()=>{fs.readFile('08_ext.json',(err,data)=>{console.log(\"2\");})}getExt();console.log(\"3\");/***Console：*1*3*2*/复制代码在上面代码中，由于fs.readFile是Node的异步函数。所以，程序先执行了1和3，最后才执行fs.readFile的2部分。在这里，可以看出Node不会因为一段代码的逻辑错误，从而导致其他代码无法运行。这样子，就导致了一个问题：步骤3可能拿不到步骤2的执行结果了！这就是Node的非租塞性I/O驱动。那么，我们有没有办法解决这个问题呢？有的！通过回调函数通过Node的events模块首先，我们通过回调函数来解决这个异步问题：09_io.jsletfs=require(\"fs\");getExt=(callback)=>{fs.readFile('08_ext.json',(err,data)=>{callback(data);})}getExt((result)=>{console.log(result.toString());})复制代码通过回调，我们可以将getExt的数据提取出来。然后，我们通过Node的events模块来解决这个异步问题：//引入fs模块letfs=require(\"fs\");/***Node事件循环：*1.Node是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。*2.Node的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。*3.Node有多个内置的事件，我们可以通过引入events模块，并通过实例化EventEmitter类来绑定和监听事件。*///引入events模块letevents=require(\"events\");//实例化事件对象letEventEmitter=newevents.EventEmitter();getExt=()=>{fs.readFile('08_ext.json',(err,data)=>{//将data广播出去EventEmitter.emit('data',data.toString());})};getExt();//监听dataEventEmitter.on('data',(ext)=>{console.log(ext);});复制代码在这里，EventEmitter.on通过监听data的形式，获取了getExt内部的执行结果。如此，我们就了解了Node的I/O事件及events模块3.10get与post返回目录\">话不多说，先上代码：index.js//加载http模块varhttp=require('http');//虚拟SQL读取出来的数据varitems=[];//创建http服务http.createServer(function(req,res){//设置跨域的域名，*代表允许任意域名跨域res.setHeader('Access-Control-Allow-Origin','*');//设置header类型res.setHeader('Access-Control-Allow-Headers','Content-Type');//跨域允许的请求方式res.setHeader('Content-Type','application/json');//判断请求switch(req.method){//post请求时，浏览器会先发一次options请求，如果请求通过，则继续发送正式的post请求case'OPTIONS':res.statusCode=200;res.end();break;//如果是get请求，则直接返回items数组case'GET':letdata=JSON.stringify(items);res.write(data);res.end();break;//如果是post请求case'POST':letitem='';//读取每次发送的数据req.on('data',function(chunk){item+=chunk;});//数据发送完成req.on('end',function(){//存入item=JSON.parse(item);items.push(item.item);//将数据返回到客户端letdata=JSON.stringify(items);res.write(data);res.end();});break;}}).listen(3000)console.log('httpserverisstart...');复制代码首先，我们加载了http模块，并创建了服务。然后，我们设置了跨域的处理方式，允许进行跨域。接着，我们进行了请求的判断处理，由于只做简单演练，故只判断是get请求还是post请求。最后，我们将请求的结果返回给客户端。在上面，我们进行了后端Node的部署，那么前端页面要怎么做呢？index.html<!DOCTYPEhtml>\"en\">\"UTF-8\">\"viewport\"content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\"X-⌃-Compatible\"content=\"ie=edge\">NodeWeb\"app\">TodoList\"(item,index)initems\":key=\"index\">{{item}}type=\"text\"v-model=\"item\">\"postApi\">添加<!--cdn引用：Vue和Node-->\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">\"https://unpkg.com/axios/dist/axios.min.js\">newVue({el:document.getElementById('app'),data:function(){return{items:[],item:'',}},created(){//进入页面请求数据axios.get('http://localhost:3000/').then(res=>{console.log(\"【API-get数据】\");console.log(res);this.items=res.data;}).catch(function(err){console.log(err)})},methods:{//点击按钮提交数据postApi(){axios.post('http://localhost:3000/',{item:this.item}).then(res=>{console.log(\"【API-post数据】\")console.log(res);this.items=res.data;}).catch(function(err){console.log(err)})}}})复制代码我们通过Vue进行了布局，通过Axios进行了接口的请求。从而完成了对数据的操作。3.11Node连接MySQL返回目录关于MySQL的安装，可以查看jsliang写的：MySQL安装及图形化工具首先，我们通过可视化工具进行表的设计：名类型长度键idint11主键namevarchar255agevarchar255然后，我们进行表的填充：idnameage1jslliang232梁峻荣23接着，我们安装Node连接MySQL的包：npmimysql-D复制代码再来，我们编写Node的index.js：index.jsvarmysql=require('mysql');varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'node'});connection.connect();connection.query('SELECT*FROMuser',function(error,results,fields){if(error)throwerror;console.log(results);});connection.end();复制代码最后，我们通过nodeindex.js，打开该服务：[RowDataPacket{id:1,name:'jsliang',age:'23'},RowDataPacket{id:2,name:'梁峻荣',age:'23'}]复制代码如此，我们便完成了Node连接MySQL。———————华丽分割线———————当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。先看目录：\">新增表字段add.jsvarmysql=require('mysql');varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'node'});connection.connect();letaddSql=\"INSERTINTOuser(id,name,age)VALUES(0,?,?)\";letaddSqlParams=[\"jsliang\",\"23\"];connection.query(addSql,addSqlParams,function(err,res){if(err){console.log(\"新增错误：\");console.log(err);return;}else{console.log(\"新增成功：\");console.log(res);}});connection.end();复制代码我们只需要直接nodeadd.js，就能往数据库中新增数据了。删除表字段delete.js//连接MySQLvarmysql=require('mysql');//MySQL的连接信息varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'node'});//开始连接connection.connect();//新增的SQL语句及新增的字段信息vardelSql='DELETEFROMuserwhereid=2';//连接SQL并实施语句connection.query(delSql,function(err,res){if(err){console.log(\"删除错误：\");console.log(err);return;}else{console.log(\"删除成功：\");console.log(res);}});//终止连接connection.end();复制代码修改表字段update.js//连接MySQLvarmysql=require('mysql');//MySQL的连接信息varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'node'});//开始连接connection.connect();//新增的SQL语句及新增的字段信息letupdateSql=\"UPDATEuserSETname=?,age=?WHEREId=?\";letupdateSqlParams=[\"LiangJunrong\",\"23\",1];//连接SQL并实施语句connection.query(updateSql,updateSqlParams,function(err,res){if(err){console.log(\"修改错误：\");console.log(err);return;}else{console.log(\"修改成功：\");console.log(res);}});//终止连接connection.end();复制代码查询表字段read.js//连接MySQLvarmysql=require('mysql');//MySQL的连接信息varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'node'});//开始连接connection.connect();//新增的SQL语句及新增的字段信息letreadSql=\"SELECT*FROMuser\";//连接SQL并实施语句connection.query(readSql,function(err,res){if(err)throwerr;console.log(res);});//终止连接connection.end();复制代码以上，我们打通了Node与MySQL的壁垒，实现了数据的增删改查。四Web实战——企业官网返回目录在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo制作、ico制作、icon挑选等……下面这些都是jsliang平时碰到的，小伙伴有需要的可以mark啦~logo制作ico制作icon挑选另外，由于HTML与CSS没什么好讲的，所以本章节的前提静态页面jsliang已经写好了，小伙伴们在学习前可以预先下载：本文静态页面代码地址4.1编程环境返回目录首先，我们查看下我们的前端基本代码：地址\">如上，我们仅需要了解FrontEndCode目录以及NodeWeb目录即可，其他目录为上面章节练习参考。然后，我们进行后端功能分析：留言板。用户点击留言板的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到登录页；如果用户登录了，则显示留言板页面。在留言板页面中，存在两个接口：获取留言内容：调取getMessage接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。提交留言内容：调取sendMessage接口，将用户名、用户id、留言内容发送给后端。\">在登录页面中，存在一个接口：登录：调取login接口，提交用户填写的姓名和密码。\">在注册页面中，存在一个接口：注册：调取register接口，提交用户填写的姓名和密码。\">由此，我们可以设计下前后端的接口结合：接口文档接口类型参数返回信息getMessage：获取留言信息get无参n条记录：id(用户id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间)sendMessage：提交留言信息postid(用户id)、user_name(用户名)、user_message(用户留言内容)status状态login：登录postid(用户id)、user_name(用户名)、user_password(用户密码)status状态register：注册postid(用户id)、user_name(用户名)、user_password(用户密码)status状态最后，我们进行MySQL数据库的表设计：user表名类型长度键idint11主键user_namevarchar255user_passwordvarchar255timedatetimemessage表名类型长度键idint11主键user_messagevarchar255user_idvarchar255外键user_namevarchar255timedatetime4.2后端接口返回目录在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个test文件夹，里面放一个index.html以及一个index.js来测试一下。-text-index.html-index.js复制代码首先，我们就4.1提到的接口，提前进行后端接口的设置：index.js//连接MySQL：先安装npmimysql-Dvarmysql=require('mysql');//MySQL的连接信息varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'nodebase'});//开始连接connection.connect();//引入http模块：http是提供Web服务的基础consthttp=require(\"http\");//引入url模块：url是对用户提交的路径进行解析consturl=require(\"url\");//引入qs模块：qs是对路径进行json化或者将json转换为string路径constqs=require(\"querystring\");//用http模块创建服务/***req获取url信息(request)*res浏览器返回响应信息(response)*/http.createServer(function(req,res){//设置cors跨域res.setHeader(\"Access-Control-Allow-Origin\",\"*\");//设置header类型res.setHeader('Access-Control-Allow-Headers','Content-Type');//跨域允许的请求方式res.setHeader('Content-Type','application/json');if(req.method==\"POST\"){//接口POST形式console.log(\"【POST形式】\");//获取前端发来的路由地址letpathName=req.url;console.log(\"接口为：\"+pathName);//接收发送过来的参数lettempResult=\"\";//数据接入中req.addListener(\"data\",function(chunk){tempResult+=chunk;});//数据接收完成req.addListener(\"end\",function(){varresult=JSON.stringify(qs.parse(tempResult));console.log(\"参数为：\");console.log(result);if(pathName==\"/sendMessage\"){//提交留言信息console.log(\"【API-提交留言信息】\");}elseif(pathName==\"/login\"){//登录console.log(\"【API-登录】\");}elseif(pathName==\"/register\"){//注册console.log(\"【API-注册】\");}//接口信息处理完毕})//数据接收完毕}elseif(req.method==\"GET\"){//接口GET形式console.log(\"【GET形式】\");//解析url接口letpathName=url.parse(req.url).pathname;console.log(\"接口为：\"+pathName);if(pathName==\"/getMessage\"){//获取留言信息console.log(\"【API-获取留言信息】\");}elseif(pathName==\"/\"){//首页res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});res.write('jsliang前端有限公司服务已开启！详情可见：Node基础');res.end();}}}).listen(8888);//监听的端口//获取当前时间functiongetNowFormatDate(){vardate=newDate();varyear=date.getFullYear();//年varmonth=date.getMonth()+1;//月varstrDate=date.getDate();//日varhour=date.getHours();//时varminute=date.getMinutes();//分varsecond=date.getMinutes();//秒if(month>=1&&month<=9){month=\"0\"+month;}if(strDate>=0&&strDate<=9){strDate=\"0\"+strDate;}//返回yyyy-mm-ddhh:mm:ss形式varcurrentdate=year+\"-\"+month+\"-\"+strDate+\"\"+hour+\":\"+minute+\":\"+second;returncurrentdate;}复制代码通过判断req.method属于GET还是POST形式，从而确定加载的接口：在POST中，判断是属于提交留言信息、登录还是注册；在GET中，判断是不是获取留言信息。同时，我们在其中定义了MySQL的连接以及一个getNowFormatDate用来获取当前时间，格式为：2018-12-2110:03:59然后，我们通过一个前端页面来演示我们的接口是否能使用：index.html<!DOCTYPEhtml>\"en\">\"UTF-8\">\"viewport\"content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\"X-UA-Compatible\"content=\"ie=edge\">演示代码for=\"user\">用户名type=\"text\"id=\"user\">for=\"password\">密&nbsp;&nbsp;&nbsp;码type=\"password\"id=\"password\">\"register\">注册\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\">$(function(){//测试get接口$.ajax({url:\"http://localhost:8888/getMessage\",type:\"POST\",data:{username:\"jsliang\"},success:function(res){console.log(res);},error:function(err){console.log(err);}})$(\"#register\").click(function(){//测试post接口$.ajax({url:\"http://localhost:8888/login\",type:\"POST\",data:{username:$(\"#user\").val(),password:$(\"#password\").val()},success:function(res){console.log(res);},error:function(err){console.log(err);}})})});复制代码最后，我们通过nodeindex.js，并打开index.html，通过F12控制台查看我们的接口是否正常：\">可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这4个接口的设计了。如果小伙伴们觉得每次更新Node代码后，又要重启一遍nodeindex.js觉得麻烦，可以通过supervisor来监听Node代码的改动，supervisor的安装使用：supervisor4.3注册功能返回目录很好，我们回到仿企业网站的页面上，准备编写接口以及丰富Node的接口。首先，我们开启前端和Node服务：打开命令行/终端开启前端cdFrontEndCodelive-server安装live-server：npmilive-server-g开启后端cdNodeWebsupervisorindex.js安装supervisor：npmisupervisor-g然后，我们在注册页面通过点击事件来触发调接口：register.html<!DOCTYPEhtml>\"en\">\"UTF-8\">\"keywords\"content=\"前端,jsliang,bootstrap,企业建站\">\"description\"content=\"jsliang为你打造最好的企业服务\">\"shortcuticon\"href=\"./images/favicon.ico\"type=\"image/x-icon\"/>\"viewport\"content=\"width=device-width,initial-scale=1.0\">\"X-UA-Compatible\"content=\"ie=edge\">注册-jsliang前端有限公司\"stylesheet\"href=\"./css/index.css\">\"stylesheet\"href=\"./css/bootstrap.min.css\"><!--省略body中代码，有需要的请前往第四章开头下载查看全部代码-->\"./js/jquery-3.3.1.min.js\">\"./js/bootstrap.min.js\">\"./js/islogin.js\">$(function(){$(\"#register-submit\").click(function(){letuserName=$(\"#userName\").val();letuserPassword=$(\"#userPassword\").val();if(!userName){alert(\"请输入用户名\");$(\"#userName\").focus();}elseif(!userPassword){alert(\"请输入密码\");$(\"#userPassword\").focus();}elseif(userName.length>10){alert(\"请输入少于10位的用户名\");$(\"#userName\").focus();}elseif(userPassword.length>20){alert(\"请输入少于20位的密码\");$(\"#userPassword\").focus();}else{//如果用户输入的没毛病，那就加载接口$.ajax({url:\"http://localhost:8888/register\",type:'post',dataType:'json',data:{username:userName,password:userPassword},success:function(res){console.log(res);if(res.code==\"0\"){alert(\"注册成功，前往登录！\");window.location.href=\"./login.html\";}},error:function(err){console.log(err.responseText);if(err.responseText==\"注册失败，姓名重复！\"){alert(\"用户名已被注册！\");}elseif(err.responseText==\"注册失败，名额已满！\"){alert(\"注册失败，名额已满！\");}elseif(err.responseText==\"注册失败，密码为空！\"){alert(\"注册失败，密码为空！\");}elseif(err.responseText==\"注册失败，姓名过长！\"){alert(\"注册失败，姓名过长！\");}elseif(err.responseText==\"注册失败，密码过长！\"){alert(\"注册失败，密码过长！\");}else{alert(\"未知错误！\");}}})}})})复制代码如此，我们在用户点击注册按钮的时候，进行接口的调用，发送数据到了后端，如果成功了，那就弹窗，并跳转到登录页；如果没成功，就弹窗提示。接着，我们编写Node，前端调用接口后，Node判断这两个参数是否为空，如果不为空，则将数据存储到数据库。index.js//...其他代码省略，请自行前往章节4.2后端接口获取其他代码if(pathName==\"/sendMessage\"){//提交留言信息console.log(\"【API-提交留言信息】\");}elseif(pathName==\"/login\"){//登录console.log(\"【API-登录】\");}elseif(pathName==\"/register\"){//注册console.log(\"【API-注册】\");result=JSON.parse(result);letusername=result.username;//用户名letpassword=result.password;//密码lettime=getNowFormatDate();//时间if(!username){//用户名为空res.end(\"注册失败，用户名为空。\");return;}elseif(!password){//密码为空res.end(\"注册失败，密码为空！\");return;}elseif(username.length>10){//姓名过长res.end(\"注册失败，姓名过长！\");return;}elseif(password.length>20){//密码过长res.end(\"注册失败，密码过长！\");return;}else{//查询user表//使用Promise的原因是因为中间调用了两次数据库，而数据库查询是异步的，所以需要用Promise。newPromise((resolve,reject)=>{//新增的SQL语句及新增的字段信息letreadSql=\"SELECT*FROMuser\";//连接SQL并实施语句connection.query(readSql,function(error1,response1){if(error1){//如果SQL语句错误throwerror1;}else{console.log(\"SQL查询结果：\");//将结果先去掉RowDataPacket，再转换为json对象letnewRes=JSON.parse(JSON.stringify(response1));console.log(newRes);//判断姓名重复与否letuserNameRepeat=false;for(letiteminnewRes){if(newRes[item].user_name==username){userNameRepeat=true;}}//如果姓名重复if(userNameRepeat){res.end(\"注册失败，姓名重复！\");return;}elseif(newRes.length>300){//如果注册名额已满res.end(\"注册失败，名额已满！\");return;}else{//可以注册resolve();}}});}).then(()=>{console.log(\"第二步：\");//新增的SQL语句及新增的字段信息letaddSql=\"INSERTINTOuser(user_name,user_password,time)VALUES(?,?,?)\";letaddSqlParams=[result.username,result.password,time];//连接SQL并实施语句connection.query(addSql,addSqlParams,function(error2,response2){if(error2){//如果SQL语句错误console.log(\"新增错误：\");console.log(error2);return;}else{console.log(\"SQL查询结果：\");console.log(response2);console.log(\"注册成功！\");//返回数据res.write(JSON.stringify({code:\"0\",message:\"注册成功！\"}));//结束响应res.end();}});})//Promise结束}//注册流程结束}复制代码最后，我们在查看下该功能是否成功：\">4.4登录功能返回目录在上面，我们完成了注册功能，那么相对来说，登录功能就容易通了，因为查询部分我们已经试过了一次。login.html<!DOCTYPEhtml>\"en\">\"UTF-8\">\"keywords\"content=\"前端,jsliang,bootstrap,企业建站\">\"description\"content=\"jsliang为你打造最好的企业服务\">\"shortcuticon\"href=\"./images/favicon.ico\"type=\"image/x-icon\"/>\"viewport\"content=\"width=device-width,initial-scale=1.0\">\"X-UA-Compatible\"content=\"ie=edge\">登录-jsliang前端有限公司\"stylesheet\"href=\"./css/index.css\">\"stylesheet\"href=\"./css/bootstrap.min.css\"><!--代码省略，有需要的小伙伴请在第四章前言部分下载代码-->\"./js/jquery-3.3.1.min.js\">\"./js/bootstrap.min.js\">\"./js/islogin.js\">$(function(){$(\"#login-submit\").click(function(){letuserName=$(\"#userName\").val();//用户名letuserPassword=$(\"#userPassword\").val();//密码if(!userName){alert(\"请输入用户名\");$(\"#userName\").focus();}elseif(!userPassword){alert(\"请输入密码\");$(\"#userPassword\").focus();}elseif(userName.length>10){alert(\"请输入少于10位的用户名\");$(\"#userName\").focus();}elseif(userPassword.length>20){alert(\"请输入少于20位的密码\");$(\"#userPassword\").focus();}else{$.ajax({url:\"http://localhost:8888/login\",type:'post',dataType:'json',data:{username:userName,password:userPassword},success:function(res){console.log(res);if(res.code==\"0\"){sessionStorage.setItem(\"id\",res.data.id);sessionStorage.setItem(\"userName\",res.data.userName);alert(\"登录成功！\");window.location.href=\"./messageBoard.html\";}elseif(res.code==\"1\"){alert(\"登录失败，密码错误！\");}},error:function(err){console.log(err.responseText);if(err.responseText==\"不存在该用户！\"){alert(\"不存在该用户！\");}elseif(err.responseText==\"登录失败，用户名为空！\"){alert(\"登录失败，用户名为空！\");}elseif(err.responseText==\"登录失败，密码为空！\"){alert(\"登录失败，密码为空！\");}elseif(err.responseText==\"登录失败，姓名过长！\"){alert(\"登录失败，姓名过长！\");}elseif(err.responseText==\"登录失败，密码过长！\"){alert(\"登录失败，密码过长！\");}else{alert(\"未知错误！\");}}})}})})复制代码编写完前端的代码后，我们进行Node代码的编辑：index.js//...其他代码省略，请自行前往章节4.2后端接口获取其他代码if(pathName==\"/sendMessage\"){//提交留言信息console.log(\"【API-提交留言信息】\");}elseif(pathName==\"/login\"){//登录console.log(\"【API-登录】\");result=JSON.parse(result);letusername=result.username;//用户名letpassword=result.password;//密码if(!username){//用户名为空res.end(\"登录失败，用户名为空！\");return;}elseif(!password){//密码为空res.end(\"登录失败，密码为空！\");return;}elseif(username.length>10){res.end(\"登录失败，姓名过长！\");return;}elseif(password.length>20){res.end(\"登录失败，密码过长！\");return;}else{//新增的SQL语句及新增的字段信息letreadSql=\"SELECT*FROMuserWHEREuser_name='\"+username+\"'\";//连接SQL并实施语句connection.query(readSql,function(error1,response1){if(error1){throwerror1;}else{if(response1==undefined||response1.length==0){//不存在用户res.end(\"不存在该用户！\");return;}else{//存在用户console.log(\"存在该用户！\");letnewRes=JSON.parse(JSON.stringify(response1));console.log(newRes);if(newRes[0].user_password==password){//密码正确//返回数据res.write(JSON.stringify({code:\"0\",message:\"登录成功！\",data:{id:newRes[0].id,userName:newRes[0].user_name}}));res.end();}else{//密码错误//返回数据res.write(JSON.stringify({code:\"1\",message:\"登录失败，密码错误！\"}));res.end();}//判断密码正确与否完毕}//存在用户处理结束}});}//登录步骤结束}elseif(pathName==\"/register\"){//注册console.log(\"【API-注册】\");}复制代码很好，前端和后端都编写完毕，是时候查验下功能是否实现了：\">4.5留言功能返回目录现在，我们就剩下留言功能了，一鼓作气做好它吧！messageBoard.html<!--留言板--><!DOCTYPEhtml>\"en\">\"UTF-8\">\"keywords\"content=\"前端,jsliang,bootstrap,企业建站\">\"description\"content=\"jsliang为你打造最好的企业服务\">\"shortcuticon\"href=\"./images/favicon.ico\"type=\"image/x-icon\"/>\"viewport\"content=\"width=device-width,initial-scale=1.0\">\"X-UA-Compatible\"content=\"ie=edge\">留言板-jsliang前端有限公司\"stylesheet\"href=\"./css/index.css\">\"stylesheet\"href=\"./css/bootstrap.min.css\"><!--代码省略，基础代码请前往本章节前言下载-->\"./js/jquery-3.3.1.min.js\">\"./js/bootstrap.min.js\">\"./js/islogin.js\">$(function(){letuserName=sessionStorage.getItem(\"userName\");letuserId=sessionStorage.getItem(\"id\");//查询留言板if(userName&&userId){//如果有存储$.ajax({url:\"http://localhost:8888/getMessage\",type:'get',dataType:'json',success:function(res){console.log(res);letli=``;for(letiteminres.data){li=li+`\"text-warningfont-bold\">☆\"user-message\">${res.data[item].user_message}——\"user-name\">${res.data[item].user_name}[${res.data[item].user_id}]\"message-time\">${res.data[item].time}`;}$(\"#message-board-ul\").append(li);},error:function(err){console.log(err);}})}else{//如果没有存储window.location.href=\"../login.html\";}//提交留言$(\"#message-submit\").click(function(){letmessageText=$(\"#message\").val()if(!messageText){alert(\"留言内容不能为空\");}elseif(messageText.length>140){alert(\"留言长度不能超过140位！\");}else{$.ajax({url:\"http://localhost:8888/sendMessage\",type:'post',dataType:'json',data:{userid:userId,username:userName,message:messageText},success:function(res){console.log(res);if(res.code==\"0\"){alert(\"新增成功！\");window.location.reload();}},error:function(err){console.log(err);console.log(err.responseText);if(err.responseText==\"登录失败，留言内容为空！\"){alert(\"登录失败，留言内容为空！\");}elseif(err.responseText==\"登录失败，字数超过限制！\"){alert(\"登录失败，字数超过限制！\");}else{alert(\"未知错误！\");}}})}})})复制代码接着编写下Node后端：index.js//...其他代码省略，请自行前往章节4.2后端接口获取其他代码if(pathName==\"/sendMessage\"){//提交留言信息console.log(\"【API-提交留言信息】\");result=JSON.parse(result);letid=result.userid;//idletuserName=result.username;//用户名letmessageText=result.message;//留言内容lettime=getNowFormatDate();//时间if(!messageText){res.end(\"登录失败，留言内容为空！\");return;}elseif(messageText.length>140){res.end(\"登录失败，字数超过限制！\");return;}else{//新增的SQL语句及新增的字段信息letaddSql=\"INSERTINTOmessage(user_message,user_id,user_name,time)VALUES(?,?,?,?)\";letaddSqlParams=[messageText,id,userName,time];//连接SQL并实施语句connection.query(addSql,addSqlParams,function(error1,response1){if(error1){//如果SQL语句错误throwerror1;}else{console.log(\"新增成功！\");//返回数据res.write(JSON.stringify({code:\"0\",message:\"新增成功！\"}));//结束响应res.end();}})}}elseif(pathName==\"/login\"){//登录console.log(\"【API-登录】\");}elseif(pathName==\"/register\"){//注册console.log(\"【API-注册】\");}//...其他代码省略，请自行前往章节4.2后端接口获取其他代码if(pathName==\"/getMessage\"){//获取留言信息console.log(\"【API-获取留言信息】\");//解析url参数部分letparams=url.parse(req.url,true).query;console.log(\"参数为：\");console.log(params);//新增的SQL语句及新增的字段信息letreadSql=\"SELECT*FROMmessage\";//连接SQL并实施语句connection.query(readSql,function(error1,response1){if(error1){throwerror1;}else{letnewRes=JSON.parse(JSON.stringify(response1));console.log(newRes);//返回数据res.write(JSON.stringify({code:\"1\",message:\"查询成功！\",data:newRes}));//结束响应res.end();}});//查询完毕}elseif(pathName==\"/\"){//首页res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"});res.write('jsliang前端有限公司服务已开启！详情可见：Node基础');res.end();}复制代码敲完代码再看下功能是否实现：\">综上，我们完成了所有的功能模块：注册、登录以及留言。五工具整合返回目录工欲善其事，必先利其器。掌控好了工具，可以方便你更快地进行开发。5.1supervisor-监听Node改动返回目录supervisor官网正如其官网所说，它是一个进行控制系统：安装插件：npmisupervisor-g运行文件：supervisorapp.js查看运行：localhost:3000平时，我们nodeapp.js后，当我们修改了app.js的内容，就需要关闭node命令行再执行nodeapp.js。而我们使用supervisor后，我们修改了app.js中的内容，只要点击保存，即可生效保存后的代码，实现实时监听node代码的变动。关于这个工具，网上更详细的攻略有：详细版：用Supervisor守护你的Node.js进程|简书-Mike的读书季5.2PM2-Node进程管理返回目录PM2-npmPM2是Node进程管理工具，可以利用它来简化很多Node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置：全局安装PM2：npmipm2-g监听应用：pm2startindex.js查看所有进程：pm2list查看某个进程：pm2describeAppname/id停止某个进程：pm2stopAppname/id。例如：先通过pm2list查看：Appnameidstatusindex0online只需要执行pm2stopindex或者pm2stop0即可。停止所有进程：pm2stopall重启某个进程：pm2restartAppname/id删除某个进程：pm2deleteAppname/id如上，如果说我们的supervisor是监听单个进程的话，那么PM2就是监听多个进程。更多攻略：PM2官网PM2用法简介|简书-LeavesLifePM2实用入门指南|博客园-程序猿小卡六参考资料返回目录在编写这篇文章的过程中，有一些参考资料是值得保留阅读的：经典：该类值得我们研读经典，就是随着时间流逝，它还是那么有参考价值。API文档|Node.js中文网Node.js教程|菜鸟教程Express文档|Express中文网尝试：该类值得我们参考借鉴Node基础模块nodejs之querystring模块|博客园-whiteMuNode编写接口用Node编写RESTfulAPI接口|php中文网-不言MySQL学习MySQL教程|菜鸟教程Node连接数据库node.js前后台交互示例--使用node.js实现用户注册功能|博客园-返回主页党兴明node.js实现简单的登录注册页面-博客园-返回主页bestjarvanNode仿Expressnodejs模块：简单http请求路由，仿express|CSDN-TTUZ初学nodejs一：别被Express的API搞晕了|前端乱炖-飞天小黑神猪NodeJs实战——原生NodeJS\b轻仿Express框架从需求到实现（一）|倔强的石头-掘金NodeJs实战——原生NodeJS\b轻仿Express框架从需求到实现（二）|倔强的石头-掘金仿Express|Github-wallaceyuanNode.js封装仿照express的路由|CSDN-c.学习node中express框架中间件的相关知识及实践|Github-BadWaka七线上部署返回目录关于线上部署及域名、服务器相关的配置，jsliang在另外一篇文章有所交代：云服务器建站。如果小伙伴需要订购云服务器来存放像jsliang个人网站类的静态或者有Node后端的网页，但却不知道怎么选择，可以加jsliangQQ：1741020489咨询，下面是一些优惠推广：腾讯云推广：新用户点这里：新客户无门槛2775元代金券\">购买云服务器：12月优惠低至168元/年\">阿里云推广：新用户点这里：新用户云产品1888通用代金券\">购买云服务器：高性能云服务器-低至293元/年\">购买企业级云服务器：企业级高性能云服务器\">八归纳总结返回目录综上，搞定一切！兴许在前面代码的摧残下，能看到这里的小伙伴已经寥寥无几了，但我坚信我该交代的基本都交代了，不该交代的也交代了~所以，如果小伙伴看完真觉得不错，那就点个赞或者给个star吧！你们的赞和star是我编写更多更精彩文章的动力！GitHub地址如果小伙伴看完这里要评论的话，可以加个暗语：Node基础，***，这样jsliang看到必回，哈哈~Node基础，我完成了！Node基础，我想说jsliang肯定还偷懒了，没写成最完美的，我不管我打赏了你赶紧给我完善下！……so,that'sall,thanks~-----------------------后记撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的jsliang进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~\">\">\">jsliang的文档库由梁峻荣采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可。基于github.om/LiangJunron…上的作品创作。本许可协议授权之外的使用权限可以从creativecommons.org/licenses/by…处获得。",
      "time": "2018年12月23日"
    },
    {
      "source": "掘金",
      "id": "2r32jxn9cuw0",
      "author": "有赞技术",
      "title": "Node 爬虫入门",
      "content": "边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章为了验证“简书上，经验总结、资料归集类技术文章更容易上热榜”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的文章如果不是资料归集的话，多半就属于谈源码实现的了）目录知识点实现步骤拉取页面列表拉取页面详情，分析统计生成统计页面总结知识点http.request：nodehttp模块的request方法可以作为httpclient向服务器发起http请求，爬虫需要向目标链接发起http请求来获得页面信息cheerio：通过http请求到的页面信息，由于缺乏浏览器的dom解析，看起来就是一段凌乱的字符串，实在糟糕。好在我们可以使用cheerio库将其解析为dom，这样我们就可以使用类似jquery的语法去分析页面信息promise：由于node单线程的特性，不可避免的需要用到大量异步编程的写法，层层嵌套的回调写法已经low了，来试试promise的写法实现步骤拉取页面列表首先需要拿到程序员专题热门列表的请求链接\">列表链接ajax请求，需要使用chromedevtools，拉到底部还能加载更多：//order_by=likes_count表示按照热门进行排序//page是分页参数，每页9条，我们可以通过改变page=0~100来拉取900篇文章http://www.jianshu.com/collections/16/notes?order_by=likes_count&page=2复制代码下一步通过这个链接拉取列表数据/**-创建promise*/Seek.prototype.createPromise=function(i){varoptions={url:'http://www.jianshu.com/collections/16/notes?order_by=likes_count&page='+i,type:'get'}returnnewPromise(function(resolve,reject){options.callback=function(data,_setCookie){resolve(data);}request(options,null);});}复制代码可以创建一个promise对象来发起request请求（request的封装就不贴出来了，实验证明，代码块太多的文章不容易上热榜~~）起初我的做法是同时创建拉取1~100页数据的100个promise对象，同时异步的发起100个request请求，然而这样的做法会有几十个请求请求失败（兴许是简书那边做了限制），所以，还是耐心点，每次发起5个请求，直到100页都请求成功/***递归的请求，每次并发的请求5个*/Seek.prototype.seek=function(callback){varself=this;times++;varot=times;varpromise=Promise.all([self.createPromise(times),self.createPromise(++times),self.createPromise(++times),self.createPromise(++times),self.createPromise(++times)]);promise.then(function(result){console.log(\"seekListtotals:\"+times);pages=pages.concat(result);if(times<totalPage){self.seek(callback);}else{callback(pages);}});}复制代码拿到所有的列表数据之后，就可以使用cheerio库来分析列表页面，抓取文章详情链接(在这一步之前你同样需要使用chromedevtools工具分析页面结构)/***使用cheerio载入列表页面*/Analyse.prototype.load=function(data,i){returnnewPromise(function(resolve,reject){var$=cheerio.load(data);varpages=[];varels=$('.article-listli');if(els.length===0){console.warn('loaderrorpage:'+i);resolve([]);}els.each(function(index){if($(this).attr('class')==='have-img'){pages.push($(this).children('a').attr('href'));}else{pages.push($(this).children('div').children('.title').children('a').attr('href'));}if(index===els.length-1){resolve(pages);}});});}复制代码拉取页面详情，分析统计从上一步中拿到900篇热门文章的地址之后，需要再次去抓取文章详情页面，同样的每次查5篇，使用chromedevtools分析得知，简书文章的代码块使用的都是标签，统计此标签出现的数量就可以了/***创建promise*/Seek.prototype.createPromise=function(url){varoptions={url:'http://www.jianshu.com'+url,type:'get'}returnnewPromise(function(resolve,reject){options.callback=function(data,_setCookie){var$=cheerio.load(data);//页面标题vartitle=$('h1.title').text();//代码块数量varcodes=$('code').length;if(codes===0){//代码块为0的总数zeroCount++;}elseif(codes<=10){//代码块为<=10的总数oneToTen++;}elseif(codes<=20){//代码块<=20的总数elToTwo++;}else{//代码块>20的总数beyondTwo++;}resolve({title:title,codes:codes});}request(options,null);});}复制代码生成统计页面数据总需要一个展示的地方，使用nunjucks作为页面模板，注入抓取到的数据，在使用echarts生成统计图表，就是这个feel，结果页面\">统计结果总结开发爬虫是一件很酷的事情，在这个过程中还能学到知识，提升学习兴趣，从爬虫做起~~源码下一篇文章讲Node爬虫进阶，敬请关注补充说明：代码大半年前些的，简书的接口和页面结构已经做了改版，可能抓取不到想要的结果，如果感兴趣，可以按照思路和步骤改造现在的代码，自己动手丰衣足食",
      "time": "2017年05月31日"
    }
  ]
}