{
  "searchResList": [],
  "hotArticleDetailList": [
    {
      "content": "<p>笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。这是本系列的第二篇。</p>\n<p>扫了一眼目录后，也许你可能会说：这些八百年都用不到的东西，我为什么要会?是，我承认真实业务场景中遇到诸如手写splice、深拷贝的场景并不多，但我要说的是，问这些问题的初衷并不是让你拿到平时去用的，而是检验你对<code>JS语言的理解</code>有没有到达那样的水准，有一些<code>边界情况</code>是否能够考虑到，有没有基本的<code>计算机素养</code>(比如最基本的排序方法到底理不理解)，未来有没有潜力去设计出更加优秀的产品或者框架。如果你仅仅是想通过一篇文章来解决业务中的临时问题，那不好意思，请出门左拐，这篇文章确实不适合你。但如果你觉得自己的原生编程能力还有待提高，想让自己的思维能力上一个台阶，希望我这篇\"呕心沥血\"整理了1万六千多字的文章能够让你有所成长。另外补充一句，本文并不针对面试，但以下任何一篇的内容放在面试中，都是非常惊艳的操作：）</p>\n<h2 class=\"heading\" data-id=\"heading-0\">第七篇: 函数的arguments为什么不是数组？如何转化成数组？</h2>\n<p>因为arguments本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从0开始排，依次为0，1，2...最后还有callee和length属性。我们也把这样的对象称为类数组。</p>\n<p>常见的类数组还有：</p>\n<ul>\n<li>\n<ol>\n<li>用getElementsByTagName/ClassName()获得的HTMLCollection</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>用querySelector获得的nodeList</li>\n</ol>\n</li>\n</ul>\n<p>那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？</p>\n<h3 class=\"heading\" data-id=\"heading-1\">1. Array.prototype.slice.call()</h3>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-built_in\">console</span>.log(args.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, cur</span>) =></span> sum + cur));<span class=\"hljs-comment\">//args可以调用数组原生的方法啦</span>\n}\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//3</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-074</code></pre><h3 class=\"heading\" data-id=\"heading-2\">2.\tArray.from()</h3>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-built_in\">console</span>.log(args.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, cur</span>) =></span> sum + cur));<span class=\"hljs-comment\">//args可以调用数组原生的方法啦</span>\n}\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//3</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-075</code></pre><p>这种方法也可以用来转换Set和Map哦！</p>\n<h3 class=\"heading\" data-id=\"heading-3\">3. ES6展开运算符</h3>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> args = [...arguments];\n  <span class=\"hljs-built_in\">console</span>.log(args.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, cur</span>) =></span> sum + cur));<span class=\"hljs-comment\">//args可以调用数组原生的方法啦</span>\n}\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//3</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-076</code></pre><h3 class=\"heading\" data-id=\"heading-4\">4. 利用concat+apply</h3>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.concat.apply([], <span class=\"hljs-built_in\">arguments</span>);<span class=\"hljs-comment\">//apply方法会把第二个参数展开</span>\n  <span class=\"hljs-built_in\">console</span>.log(args.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, cur</span>) =></span> sum + cur));<span class=\"hljs-comment\">//args可以调用数组原生的方法啦</span>\n}\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//3</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-077</code></pre><p>当然，最原始的方法就是再创建一个数组，用for循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">第七篇: forEach中return有效果吗？如何中断forEach循环？</h2>\n<p>在forEach中用return不会返回，函数会继续执行。</p>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-keyword\">let</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\nnums.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span>;<span class=\"hljs-comment\">//无效</span>\n})\n<span class=\"copy-code-btn\">复制代码</span> copy-078</code></pre><p>中断方法：</p>\n<ol>\n<li>\n<p>使用try监视代码块，在需要中断的地方抛出异常。</p>\n</li>\n<li>\n<p>官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环</p>\n</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-6\">第八篇: JS判断数组中是否包含某个值</h2>\n<h3 class=\"heading\" data-id=\"heading-7\">方法一：array.indexOf</h3>\n<blockquote>\n<p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\"><span class=\"hljs-keyword\">var</span> arr=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">var</span> index=arr.indexOf(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-built_in\">console</span>.log(index);\n<span class=\"copy-code-btn\">复制代码</span> copy-079</code></pre><h3 class=\"heading\" data-id=\"heading-8\">方法二：array.includes(searcElement[,fromIndex])</h3>\n<blockquote>\n<p>此方法判断数组中是否存在某个值，如果存在返回true，否则返回false</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-keyword\">var</span> arr=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">if</span>(arr.includes(<span class=\"hljs-number\">3</span>))\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"存在\"</span>);\n<span class=\"hljs-keyword\">else</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"不存在\"</span>);\n<span class=\"copy-code-btn\">复制代码</span> copy-080</code></pre><h3 class=\"heading\" data-id=\"heading-9\">方法三：array.find(callback[,thisArg])</h3>\n<blockquote>\n<p>返回数组中满足条件的<strong>第一个元素的值</strong>，如果没有，返回undefined</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-07\" lang=\"js\"><span class=\"hljs-keyword\">var</span> arr=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">var</span> result = arr.find(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span>{\n    <span class=\"hljs-keyword\">return</span> item > <span class=\"hljs-number\">3</span>\n});\n<span class=\"hljs-built_in\">console</span>.log(result);\n<span class=\"copy-code-btn\">复制代码</span> copy-081</code></pre><h3 class=\"heading\" data-id=\"heading-10\">方法四：array.findeIndex(callback[,thisArg])</h3>\n<blockquote>\n<p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回<code>-1</code>]</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-keyword\">var</span> arr=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">var</span> result = arr.findIndex(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span>{\n    <span class=\"hljs-keyword\">return</span> item > <span class=\"hljs-number\">3</span>\n});\n<span class=\"hljs-built_in\">console</span>.log(result);\n<span class=\"copy-code-btn\">复制代码</span> copy-082</code></pre><p>当然，for循环当然是没有问题的，这里讨论的是数组方法，就不再展开了。</p>\n<h2 class=\"heading\" data-id=\"heading-11\">第九篇: JS中flat---数组扁平化</h2>\n<p>对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？</p>\n<p>需求:多维数组=>一维数组</p>\n<pre><code class=\"hljs js copyable code-09\" lang=\"js\"><span class=\"hljs-keyword\">let</span> ary = [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]]], <span class=\"hljs-number\">6</span>];<span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5, 6]</span>\n<span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-built_in\">JSON</span>.stringify(ary);\n<span class=\"copy-code-btn\">复制代码</span> copy-083</code></pre><h3 class=\"heading\" data-id=\"heading-12\">1. 调用ES6中的flat方法</h3>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\">ary = arr.flat(<span class=\"hljs-literal\">Infinity</span>);\n<span class=\"copy-code-btn\">复制代码</span> copy-084</code></pre><h3 class=\"heading\" data-id=\"heading-13\">2. replace + split</h3>\n<pre><code class=\"hljs js copyable code-011\" lang=\"js\">ary = str.replace(<span class=\"hljs-regexp\">/(\\[|\\])/g</span>, <span class=\"hljs-string\">''</span>).split(<span class=\"hljs-string\">','</span>)\n<span class=\"copy-code-btn\">复制代码</span> copy-085</code></pre><h3 class=\"heading\" data-id=\"heading-14\">3. replace + JSON.parse</h3>\n<pre><code class=\"hljs js copyable code-012\" lang=\"js\">str = str.replace(<span class=\"hljs-regexp\">/(\\[|\\])/g</span>, <span class=\"hljs-string\">''</span>);\nstr = <span class=\"hljs-string\">'['</span> + str + <span class=\"hljs-string\">']'</span>;\nary = <span class=\"hljs-built_in\">JSON</span>.parse(str);\n<span class=\"copy-code-btn\">复制代码</span> copy-086</code></pre><h3 class=\"heading\" data-id=\"heading-15\">4. 普通递归</h3>\n<pre><code class=\"hljs js copyable code-013\" lang=\"js\"><span class=\"hljs-keyword\">let</span> result = [];\n<span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ary</span>) </span>{\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < ary.length; i++) {\n    <span class=\"hljs-keyword\">let</span> item = ary[i];\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(ary[i])){\n      fn(item);\n    } <span class=\"hljs-keyword\">else</span> {\n      result.push(item);\n    }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-087</code></pre><h3 class=\"heading\" data-id=\"heading-16\">5. 利用reduce函数迭代</h3>\n<pre><code class=\"hljs js copyable code-014\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flatten</span>(<span class=\"hljs-params\">ary</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> ary.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">pre, cur</span>) =></span> {\n        <span class=\"hljs-keyword\">return</span> pre.concat(<span class=\"hljs-built_in\">Array</span>.isArray(cur) ? flatten(cur) : cur);\n    }, []);\n}\n<span class=\"hljs-keyword\">let</span> ary = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>]]]\n<span class=\"hljs-built_in\">console</span>.log(flatten(ary))\n<span class=\"copy-code-btn\">复制代码</span> copy-088</code></pre><h3 class=\"heading\" data-id=\"heading-17\">6：扩展运算符</h3>\n<pre><code class=\"hljs js copyable code-015\" lang=\"js\"><span class=\"hljs-comment\">//只要有一个元素有数组，那么循环继续</span>\n<span class=\"hljs-keyword\">while</span> (ary.some(<span class=\"hljs-built_in\">Array</span>.isArray)) {\n  ary = [].concat(...ary);\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-089</code></pre><p>这是一个比较实用而且很容易被问到的问题，欢迎大家交流补充。</p>\n<h2 class=\"heading\" data-id=\"heading-18\">第十篇: JS数组的高阶函数——基础篇</h2>\n<h3 class=\"heading\" data-id=\"heading-19\">1.什么是高阶函数</h3>\n<p>概念非常简单，如下:</p>\n<blockquote>\n<p><code>一个函数</code>就可以接收另一个函数作为参数或者返回值为一个函数，<code>这种函数</code>就称之为高阶函数。</p>\n</blockquote>\n<p>那对应到数组中有哪些方法呢？</p>\n<h3 class=\"heading\" data-id=\"heading-20\">2.数组中的高阶函数</h3>\n<h4 class=\"heading\" data-id=\"heading-21\">1.map</h4>\n<ul>\n<li>参数:接受两个参数，一个是回调函数，一个是回调函数的this值(可选)。</li>\n</ul>\n<p>其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。</p>\n<ul>\n<li>\n<p>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</p>\n</li>\n<li>\n<p>对原来的数组没有影响</p>\n</li>\n</ul>\n<pre><code class=\"hljs js copyable code-016\" lang=\"js\"><span class=\"hljs-keyword\">let</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> obj = {<span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">5</span>};\n<span class=\"hljs-keyword\">let</span> newNums = nums.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item,index,array</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> item + index + array[index] + <span class=\"hljs-keyword\">this</span>.val; \n  <span class=\"hljs-comment\">//对第一个元素，1 + 0 + 1 + 5 = 7</span>\n  <span class=\"hljs-comment\">//对第二个元素，2 + 1 + 2 + 5 = 10</span>\n  <span class=\"hljs-comment\">//对第三个元素，3 + 2 + 3 + 5 = 13</span>\n}, obj);\n<span class=\"hljs-built_in\">console</span>.log(newNums);<span class=\"hljs-comment\">//[7, 10, 13]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-090</code></pre><p>当然，后面的参数都是可选的 ，不用的话可以省略。</p>\n<h4 class=\"heading\" data-id=\"heading-22\">2. reduce</h4>\n<ul>\n<li>参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、整个数组。</li>\n</ul>\n<pre><code class=\"hljs js copyable code-017\" lang=\"js\"><span class=\"hljs-keyword\">let</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-comment\">// 多个数的加和</span>\n<span class=\"hljs-keyword\">let</span> newNums = nums.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">preSum,curVal,array</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> preSum + curVal; \n}, <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-built_in\">console</span>.log(newNums);<span class=\"hljs-comment\">//6</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-091</code></pre><p>不传默认值会怎样？</p>\n<p>不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。</p>\n<h4 class=\"heading\" data-id=\"heading-23\">3. filter</h4>\n<p>参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。</p>\n<p>filter方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。</p>\n<pre><code class=\"hljs js copyable code-018\" lang=\"js\"><span class=\"hljs-keyword\">let</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-comment\">// 保留奇数项</span>\n<span class=\"hljs-keyword\">let</span> oddNums = nums.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> item % <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(oddNums);\n<span class=\"copy-code-btn\">复制代码</span> copy-092</code></pre><h4 class=\"heading\" data-id=\"heading-24\">4. sort</h4>\n<p>参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。</p>\n<p>举个例子:</p>\n<pre><code class=\"hljs js copyable code-019\" lang=\"js\"><span class=\"hljs-keyword\">let</span> nums = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>];\n<span class=\"hljs-comment\">//两个比较的元素分别为a, b</span>\nnums.sort(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(a > b) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a < b) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a == b) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n})\n<span class=\"copy-code-btn\">复制代码</span> copy-093</code></pre><p>当比较函数返回值大于0，则 a 在 b 的后面，即a的下标应该比b大。</p>\n<p>反之，则 a 在 b 的后面，即 a 的下标比 b 小。</p>\n<p>整个过程就完成了一次升序的排列。</p>\n<p>当然还有一个需要注意的情况，就是比较函数不传的时候，是如何进行排序的？</p>\n<blockquote>\n<p>答案是将数字转换为字符串，然后根据字母unicode值进行升序排序，也就是根据字符串的比较规则进行升序排序。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-25\">第十一篇: 能不能实现数组map方法 ?</h2>\n<p>依照 <a target=\"_blank\" href=\"https://tc39.es/ecma262/#sec-array.prototype.map\" rel=\"nofollow noopener noreferrer\">ecma262 草案</a>，实现的map的规范如下:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e311d99e860405?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"726\" data-height=\"449\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"726\" height=\"449\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>下面根据草案的规定一步步来模拟实现map函数:</p>\n<pre><code class=\"hljs js copyable code-020\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.map = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callbackFn, thisArg</span>) </span>{\n  <span class=\"hljs-comment\">// 处理数组类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">null</span> || <span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Cannot read property 'map' of null or undefined\"</span>);\n  }\n  <span class=\"hljs-comment\">// 处理回调类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"hljs-string\">\"[object Function]\"</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>)\n  }\n  <span class=\"hljs-comment\">// 草案中提到要先转换为对象</span>\n  <span class=\"hljs-keyword\">let</span> O = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> T = thisArg;\n\n  \n  <span class=\"hljs-keyword\">let</span> len = O.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> A = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(len);\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>; k < len; k++) {\n    <span class=\"hljs-comment\">// 还记得原型链那一节提到的 in 吗？in 表示在原型链查找</span>\n    <span class=\"hljs-comment\">// 如果用 hasOwnProperty 是有问题的，它只能找私有属性</span>\n    <span class=\"hljs-keyword\">if</span> (k <span class=\"hljs-keyword\">in</span> O) {\n      <span class=\"hljs-keyword\">let</span> kValue = O[k];\n      <span class=\"hljs-comment\">// 依次传入this, 当前项，当前索引，整个数组</span>\n      <span class=\"hljs-keyword\">let</span> mappedValue = callbackfn.call(T, KValue, k, O);\n      A[k] = mappedValue;\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> A;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-094</code></pre><p>这里解释一下, length >>> 0, 字面意思是指\"右移 0 位\"，但实际上是把前面的空位用0填充，这里的作用是保证len为数字且为整数。</p>\n<p>举几个特例：</p>\n<pre><code class=\"hljs js copyable code-021\" lang=\"js\"><span class=\"hljs-literal\">null</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-literal\">undefined</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-keyword\">void</span>(<span class=\"hljs-number\">0</span>) >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span> (<span class=\"hljs-params\"></span>)</span>{};  a >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n[] >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-keyword\">var</span> a = {}; a >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-number\">123123</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//123123</span>\n\n<span class=\"hljs-number\">45.2</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//45</span>\n\n<span class=\"hljs-number\">0</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-number\">-0</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-number\">-1</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//4294967295</span>\n\n<span class=\"hljs-number\">-1212</span> >>> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">//4294966084</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-095</code></pre><p>总体实现起来并没那么难，需要注意的就是使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况。</p>\n<p>最后给大家奉上V8源码，参照源码检查一下，其实还是实现得很完整了。</p>\n<pre><code class=\"hljs js copyable code-022\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ArrayMap</span>(<span class=\"hljs-params\">f, receiver</span>) </span>{\n  CHECK_OBJECT_COERCIBLE(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"Array.prototype.map\"</span>);\n\n  <span class=\"hljs-comment\">// Pull out the length so that modifications to the length in the</span>\n  <span class=\"hljs-comment\">// loop will not affect the looping and side effects are visible.</span>\n  <span class=\"hljs-keyword\">var</span> array = TO_OBJECT(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">var</span> length = TO_LENGTH(array.length);\n  <span class=\"hljs-keyword\">if</span> (!IS_CALLABLE(f)) <span class=\"hljs-keyword\">throw</span> %make_type_error(kCalledNonCallable, f);\n  <span class=\"hljs-keyword\">var</span> result = ArraySpeciesCreate(array, length);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i < length; i++) {\n    <span class=\"hljs-keyword\">if</span> (i <span class=\"hljs-keyword\">in</span> array) {\n      <span class=\"hljs-keyword\">var</span> element = array[i];\n      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array));\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-096</code></pre><p>参考:</p>\n<p><a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132\" rel=\"nofollow noopener noreferrer\">V8源码</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d76f08ef265da03970be192#comment\" rel>Array 原型方法源码实现大揭秘</a></p>\n<p><a target=\"_blank\" href=\"https://tc39.es/ecma262/#sec-array.prototype.map\" rel=\"nofollow noopener noreferrer\">ecma262草案</a></p>\n<h2 class=\"heading\" data-id=\"heading-26\">第十二篇: 能不能实现数组reduce方法 ?</h2>\n<p>依照 <a target=\"_blank\" href=\"https://tc39.es/ecma262/#sec-array.prototype.reduce\" rel=\"nofollow noopener noreferrer\">ecma262 草案</a>，实现的reduce的规范如下:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e311ed2bfa8fad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其中有几个核心要点:</p>\n<p>1、初始值不传怎么处理</p>\n<p>2、回调函数的参数有哪些，返回值如何处理。</p>\n<pre><code class=\"hljs js copyable code-023\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.reduce  = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callbackfn, initialValue</span>) </span>{\n  <span class=\"hljs-comment\">// 异常处理，和 map 一样</span>\n  <span class=\"hljs-comment\">// 处理数组类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">null</span> || <span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Cannot read property 'reduce' of null or undefined\"</span>);\n  }\n  <span class=\"hljs-comment\">// 处理回调类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"hljs-string\">\"[object Function]\"</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>)\n  }\n  <span class=\"hljs-keyword\">let</span> O = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = O.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> accumulator = initialValue;\n  <span class=\"hljs-keyword\">if</span> (accumulator === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">for</span>(; k < len ; k++) {\n      <span class=\"hljs-comment\">// 查找原型链</span>\n      <span class=\"hljs-keyword\">if</span> (k <span class=\"hljs-keyword\">in</span> O) {\n        accumulator = O[k];\n        k++;\n        <span class=\"hljs-keyword\">break</span>;\n      }\n    }\n  }\n  <span class=\"hljs-comment\">// 表示数组全为空</span>\n  <span class=\"hljs-keyword\">if</span>(k === len && accumulator === <span class=\"hljs-literal\">undefined</span>) \n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Each element of the array is empty'</span>);\n  <span class=\"hljs-keyword\">for</span>(;k < len; k++) {\n    <span class=\"hljs-keyword\">if</span> (k <span class=\"hljs-keyword\">in</span> O) {\n      <span class=\"hljs-comment\">// 注意，核心！</span>\n      accumulator = callbackfn.call(<span class=\"hljs-literal\">undefined</span>, accumulator, O[k], k, O);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> accumulator;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-097</code></pre><p>其实是从最后一项开始遍历，通过原型链查找跳过空项。</p>\n<p>最后给大家奉上V8源码，以供大家检查:</p>\n<pre><code class=\"hljs js copyable code-024\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ArrayReduce</span>(<span class=\"hljs-params\">callback, current</span>) </span>{\n  CHECK_OBJECT_COERCIBLE(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"Array.prototype.reduce\"</span>);\n\n  <span class=\"hljs-comment\">// Pull out the length so that modifications to the length in the</span>\n  <span class=\"hljs-comment\">// loop will not affect the looping and side effects are visible.</span>\n  <span class=\"hljs-keyword\">var</span> array = TO_OBJECT(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">var</span> length = TO_LENGTH(array.length);\n  <span class=\"hljs-keyword\">return</span> InnerArrayReduce(callback, current, array, length,\n                          <span class=\"hljs-built_in\">arguments</span>.length);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">InnerArrayReduce</span>(<span class=\"hljs-params\">callback, current, array, length, argumentsLength</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (!IS_CALLABLE(callback)) {\n    <span class=\"hljs-keyword\">throw</span> %make_type_error(kCalledNonCallable, callback);\n  }\n\n  <span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>;\n  find_initial: <span class=\"hljs-keyword\">if</span> (argumentsLength < <span class=\"hljs-number\">2</span>) {\n    <span class=\"hljs-keyword\">for</span> (; i < length; i++) {\n      <span class=\"hljs-keyword\">if</span> (i <span class=\"hljs-keyword\">in</span> array) {\n        current = array[i++];\n        <span class=\"hljs-keyword\">break</span> find_initial;\n      }\n    }\n    <span class=\"hljs-keyword\">throw</span> %make_type_error(kReduceNoInitial);\n  }\n\n  <span class=\"hljs-keyword\">for</span> (; i < length; i++) {\n    <span class=\"hljs-keyword\">if</span> (i <span class=\"hljs-keyword\">in</span> array) {\n      <span class=\"hljs-keyword\">var</span> element = array[i];\n      current = callback(current, element, i, array);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> current;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-098</code></pre><p>参考:</p>\n<p><a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132\" rel=\"nofollow noopener noreferrer\">V8源码</a></p>\n<p><a target=\"_blank\" href=\"https://tc39.es/ecma262/#sec-array.prototype.map\" rel=\"nofollow noopener noreferrer\">ecma262草案</a></p>\n<h2 class=\"heading\" data-id=\"heading-27\">第十三篇: 能不能实现数组 push、pop 方法 ?</h2>\n<p>参照 ecma262 草案的规定，关于 push 和 pop 的规范如下图所示:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e311f4fa483cc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e311fa338c2ecb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"658\" data-height=\"489\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"658\" height=\"489\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>首先来实现一下 push 方法:</p>\n<pre><code class=\"hljs js copyable code-025\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.push = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...items</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> O = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-keyword\">this</span>.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> argCount = items.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-comment\">// 2 ** 53 - 1 为JS能表示的最大正整数</span>\n  <span class=\"hljs-keyword\">if</span> (len + argCount > <span class=\"hljs-number\">2</span> ** <span class=\"hljs-number\">53</span> - <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"The number of array is over the max value restricted!\"</span>)\n  }\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < argCount; i++) {\n    O[len + i] = items[i];\n  }\n  <span class=\"hljs-keyword\">let</span> newLength = len + argCount;\n  O.length = newLength;\n  <span class=\"hljs-keyword\">return</span> newLength;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-099</code></pre><p>亲测已通过MDN上所有测试用例。<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push\" rel=\"nofollow noopener noreferrer\">MDN链接</a></p>\n<p>然后来实现 pop 方法:</p>\n<pre><code class=\"hljs js copyable code-026\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.pop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> O = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = <span class=\"hljs-keyword\">this</span>.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) {\n    O.length = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;\n  }\n  len --;\n  <span class=\"hljs-keyword\">let</span> value = O[len];\n  <span class=\"hljs-keyword\">delete</span> O[len];\n  O.length = len;\n  <span class=\"hljs-keyword\">return</span> value;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0100</code></pre><p>亲测已通过MDN上所有测试用例。<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\" rel=\"nofollow noopener noreferrer\">MDN链接</a></p>\n<p>参考链接:</p>\n<p><a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js\" rel=\"nofollow noopener noreferrer\">V8数组源码</a></p>\n<p><a target=\"_blank\" href=\"https://tc39.es/ecma262\" rel=\"nofollow noopener noreferrer\">ecma262规范草案</a></p>\n<p><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" rel=\"nofollow noopener noreferrer\">MDN文档</a></p>\n<h2 class=\"heading\" data-id=\"heading-28\">第十四篇: 能不能实现数组filter方法 ?</h2>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e312629684aafb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"695\" data-height=\"551\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"695\" height=\"551\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>代码如下:</p>\n<pre><code class=\"hljs js copyable code-027\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.filter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callbackfn, thisArg</span>) </span>{\n  <span class=\"hljs-comment\">// 处理数组类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">null</span> || <span class=\"hljs-keyword\">this</span> === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Cannot read property 'filter' of null or undefined\"</span>);\n  }\n  <span class=\"hljs-comment\">// 处理回调类型异常</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"hljs-string\">\"[object Function]\"</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>)\n  }\n  <span class=\"hljs-keyword\">let</span> O = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = O.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> resLen = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> res = [];\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < len; i++) {\n    <span class=\"hljs-keyword\">if</span> (i <span class=\"hljs-keyword\">in</span> O) {\n      <span class=\"hljs-keyword\">let</span> element = O[i];\n      <span class=\"hljs-keyword\">if</span> (callbackfn.call(thisArg, O[i], i, O)) {\n        res[resLen++] = element;\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> res;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0101</code></pre><p>MDN上所有测试用例亲测通过。</p>\n<p>参考:</p>\n<p><a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js\" rel=\"nofollow noopener noreferrer\">V8数组部分源码第1025行</a></p>\n<p><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\" rel=\"nofollow noopener noreferrer\">MDN中filter文档</a></p>\n<h2 class=\"heading\" data-id=\"heading-29\">第十五篇: 能不能实现数组splice方法 ?</h2>\n<p>splice 可以说是最受欢迎的数组方法之一，api 灵活，使用方便。现在来梳理一下用法:</p>\n<ul>\n<li>\n<ol>\n<li>splice(position, count) 表示从 position 索引的位置开始，删除count个元素</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>splice(position, 0, ele1, ele2, ...) 表示从 position 索引的元素后面插入一系列的元素</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>splice(postion, count, ele1, ele2, ...) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>返回值为<code>被删除元素</code>组成的<code>数组</code>。</li>\n</ol>\n</li>\n</ul>\n<p>接下来我们实现这个方法。</p>\n<p>参照ecma262草案的规定，详情请<a target=\"_blank\" href=\"https://tc39.es/ecma262/#sec-array.prototype.splice\" rel=\"nofollow noopener noreferrer\">点击</a>。</p>\n<p>首先我们梳理一下实现的思路。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3121dad3976ea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1164\" data-height=\"467\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1164\" height=\"467\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-30\">初步实现</h3>\n<pre><code class=\"hljs js copyable code-028\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.splice = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">startIndex, deleteCount, ...addElements</span>)  </span>{\n  <span class=\"hljs-keyword\">let</span> argumentsLen = <span class=\"hljs-built_in\">arguments</span>.length;\n  <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = array.length;\n  <span class=\"hljs-keyword\">let</span> deleteArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(deleteCount);\n   \n  <span class=\"hljs-comment\">// 拷贝删除的元素</span>\n  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);\n  <span class=\"hljs-comment\">// 移动删除元素后面的元素</span>\n  movePostElements(array, startIndex, len, deleteCount, addElements);\n  <span class=\"hljs-comment\">// 插入新元素</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < addElements.length; i++) {\n    array[startIndex + i] = addElements[i];\n  }\n  array.length = len - deleteCount + addElements.length;\n  <span class=\"hljs-keyword\">return</span> deleteArr;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0102</code></pre><p>先拷贝删除的元素，如下所示:</p>\n<pre><code class=\"hljs js copyable code-029\" lang=\"js\"><span class=\"hljs-keyword\">const</span> sliceDeleteElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, deleteCount, deleteArr</span>) =></span> {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < deleteCount; i++) {\n    <span class=\"hljs-keyword\">let</span> index = startIndex + i;\n    <span class=\"hljs-keyword\">if</span> (index <span class=\"hljs-keyword\">in</span> array) {\n      <span class=\"hljs-keyword\">let</span> current = array[index];\n      deleteArr[i] = current;\n    }\n  }\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-0103</code></pre><p>然后对删除元素后面的元素进行挪动, 挪动分为三种情况:</p>\n<ol>\n<li>添加的元素和删除的元素个数相等</li>\n<li>添加的元素个数小于删除的元素</li>\n<li>添加的元素个数大于删除的元素</li>\n</ol>\n<p>当两者相等时，</p>\n<pre><code class=\"hljs js copyable code-030\" lang=\"js\"><span class=\"hljs-keyword\">const</span> movePostElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, len, deleteCount, addElements</span>) =></span> {\n  <span class=\"hljs-keyword\">if</span> (deleteCount === addElements.length) <span class=\"hljs-keyword\">return</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0104</code></pre><p>当添加的元素个数小于删除的元素时, 如图所示:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e31220582da903?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"993\" data-height=\"449\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"993\" height=\"449\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs js copyable code-031\" lang=\"js\"><span class=\"hljs-keyword\">const</span> movePostElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, len, deleteCount, addElements</span>) =></span> {\n  <span class=\"hljs-comment\">//...</span>\n  <span class=\"hljs-comment\">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span>\n  <span class=\"hljs-keyword\">if</span>(deleteCount > addElements.length) {\n    <span class=\"hljs-comment\">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span>\n    <span class=\"hljs-comment\">// 一共需要挪动 len - startIndex - deleteCount 个元素</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = startIndex + deleteCount; i < len; i++) {\n      <span class=\"hljs-keyword\">let</span> fromIndex = i;\n      <span class=\"hljs-comment\">// 将要挪动到的目标位置</span>\n      <span class=\"hljs-keyword\">let</span> toIndex = i - (deleteCount - addElements.length);\n      <span class=\"hljs-keyword\">if</span> (fromIndex <span class=\"hljs-keyword\">in</span> array) {\n        array[toIndex] = array[fromIndex];\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">delete</span> array[toIndex];\n      }\n    }\n    <span class=\"hljs-comment\">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span>\n    <span class=\"hljs-comment\">// 目前长度为 len + addElements - deleteCount</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = len - <span class=\"hljs-number\">1</span>; i >= len + addElements.length - deleteCount; i --) {\n      <span class=\"hljs-keyword\">delete</span> array[i];\n    }\n  } \n};\n<span class=\"copy-code-btn\">复制代码</span> copy-0105</code></pre><p>当添加的元素个数大于删除的元素时, 如图所示:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3122363235833?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"898\" data-height=\"428\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"898\" height=\"428\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs js copyable code-032\" lang=\"js\"><span class=\"hljs-keyword\">const</span> movePostElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, len, deleteCount, addElements</span>) =></span> {\n  <span class=\"hljs-comment\">//...</span>\n  <span class=\"hljs-keyword\">if</span>(deleteCount < addElements.length) {\n    <span class=\"hljs-comment\">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span>\n    <span class=\"hljs-comment\">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = len - <span class=\"hljs-number\">1</span>; i >= startIndex + deleteCount; i--) {\n      <span class=\"hljs-keyword\">let</span> fromIndex = i;\n      <span class=\"hljs-comment\">// 将要挪动到的目标位置</span>\n      <span class=\"hljs-keyword\">let</span> toIndex = i + (addElements.length - deleteCount);\n      <span class=\"hljs-keyword\">if</span> (fromIndex <span class=\"hljs-keyword\">in</span> array) {\n        array[toIndex] = array[fromIndex];\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">delete</span> array[toIndex];\n      }\n    }\n  }\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-0106</code></pre><h3 class=\"heading\" data-id=\"heading-31\">优化一: 参数的边界情况</h3>\n<p>当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。</p>\n<pre><code class=\"hljs js copyable code-033\" lang=\"js\"><span class=\"hljs-keyword\">const</span> computeStartIndex = <span class=\"hljs-function\">(<span class=\"hljs-params\">startIndex, len</span>) =></span> {\n  <span class=\"hljs-comment\">// 处理索引负数的情况</span>\n  <span class=\"hljs-keyword\">if</span> (startIndex < <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">return</span> startIndex + len > <span class=\"hljs-number\">0</span> ? startIndex + len: <span class=\"hljs-number\">0</span>;\n  } \n  <span class=\"hljs-keyword\">return</span> startIndex >= len ? len: startIndex;\n}\n\n<span class=\"hljs-keyword\">const</span> computeDeleteCount = <span class=\"hljs-function\">(<span class=\"hljs-params\">startIndex, len, deleteCount, argumentsLen</span>) =></span> {\n  <span class=\"hljs-comment\">// 删除数目没有传，默认删除startIndex及后面所有的</span>\n  <span class=\"hljs-keyword\">if</span> (argumentsLen === <span class=\"hljs-number\">1</span>) \n    <span class=\"hljs-keyword\">return</span> len - startIndex;\n  <span class=\"hljs-comment\">// 删除数目过小</span>\n  <span class=\"hljs-keyword\">if</span> (deleteCount < <span class=\"hljs-number\">0</span>) \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-comment\">// 删除数目过大</span>\n  <span class=\"hljs-keyword\">if</span> (deleteCount > len - startIndex) \n    <span class=\"hljs-keyword\">return</span> len - startIndex;\n  <span class=\"hljs-keyword\">return</span> deleteCount;\n}\n\n<span class=\"hljs-built_in\">Array</span>.prototype.splice = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">startIndex, deleteCount, ...addElements</span>) </span>{\n  <span class=\"hljs-comment\">//,...</span>\n  <span class=\"hljs-keyword\">let</span> deleteArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(deleteCount);\n  \n  <span class=\"hljs-comment\">// 下面参数的清洗工作</span>\n  startIndex = computeStartIndex(startIndex, len);\n  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);\n   \n  <span class=\"hljs-comment\">// 拷贝删除的元素</span>\n  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);\n  <span class=\"hljs-comment\">//...</span>\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0107</code></pre><h3 class=\"heading\" data-id=\"heading-32\">优化二: 数组为密封对象或冻结对象</h3>\n<p>什么是密封对象?</p>\n<blockquote>\n<p>密封对象是不可扩展的对象，而且已有成员的[[Configurable]]属性被设置为false，这意味着不能添加、删除方法和属性。但是属性值是可以修改的。</p>\n</blockquote>\n<p>什么是冻结对象？</p>\n<blockquote>\n<p>冻结对象是最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值。</p>\n</blockquote>\n<p>接下来，我们来把这两种情况一一排除。</p>\n<pre><code class=\"hljs js copyable code-034\" lang=\"js\"><span class=\"hljs-comment\">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.isSealed(array) && deleteCount !== addElements.length) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'the object is a sealed object!'</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Object</span>.isFrozen(array) && (deleteCount > <span class=\"hljs-number\">0</span> || addElements.length > <span class=\"hljs-number\">0</span>)) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'the object is a frozen object!'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0108</code></pre><p>好了，现在就写了一个比较完整的splice，如下:</p>\n<pre><code class=\"hljs js copyable code-035\" lang=\"js\"><span class=\"hljs-keyword\">const</span> sliceDeleteElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, deleteCount, deleteArr</span>) =></span> {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < deleteCount; i++) {\n    <span class=\"hljs-keyword\">let</span> index = startIndex + i;\n    <span class=\"hljs-keyword\">if</span> (index <span class=\"hljs-keyword\">in</span> array) {\n      <span class=\"hljs-keyword\">let</span> current = array[index];\n      deleteArr[i] = current;\n    }\n  }\n};\n\n<span class=\"hljs-keyword\">const</span> movePostElements = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, startIndex, len, deleteCount, addElements</span>) =></span> {\n  <span class=\"hljs-comment\">// 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动</span>\n  <span class=\"hljs-keyword\">if</span> (deleteCount === addElements.length) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-comment\">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span>\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(deleteCount > addElements.length) {\n    <span class=\"hljs-comment\">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span>\n    <span class=\"hljs-comment\">// 一共需要挪动 len - startIndex - deleteCount 个元素</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = startIndex + deleteCount; i < len; i++) {\n      <span class=\"hljs-keyword\">let</span> fromIndex = i;\n      <span class=\"hljs-comment\">// 将要挪动到的目标位置</span>\n      <span class=\"hljs-keyword\">let</span> toIndex = i - (deleteCount - addElements.length);\n      <span class=\"hljs-keyword\">if</span> (fromIndex <span class=\"hljs-keyword\">in</span> array) {\n        array[toIndex] = array[fromIndex];\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">delete</span> array[toIndex];\n      }\n    }\n    <span class=\"hljs-comment\">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span>\n    <span class=\"hljs-comment\">// 目前长度为 len + addElements - deleteCount</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = len - <span class=\"hljs-number\">1</span>; i >= len + addElements.length - deleteCount; i --) {\n      <span class=\"hljs-keyword\">delete</span> array[i];\n    }\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(deleteCount < addElements.length) {\n    <span class=\"hljs-comment\">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span>\n    <span class=\"hljs-comment\">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = len - <span class=\"hljs-number\">1</span>; i >= startIndex + deleteCount; i--) {\n      <span class=\"hljs-keyword\">let</span> fromIndex = i;\n      <span class=\"hljs-comment\">// 将要挪动到的目标位置</span>\n      <span class=\"hljs-keyword\">let</span> toIndex = i + (addElements.length - deleteCount);\n      <span class=\"hljs-keyword\">if</span> (fromIndex <span class=\"hljs-keyword\">in</span> array) {\n        array[toIndex] = array[fromIndex];\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">delete</span> array[toIndex];\n      }\n    }\n  }\n};\n\n<span class=\"hljs-keyword\">const</span> computeStartIndex = <span class=\"hljs-function\">(<span class=\"hljs-params\">startIndex, len</span>) =></span> {\n  <span class=\"hljs-comment\">// 处理索引负数的情况</span>\n  <span class=\"hljs-keyword\">if</span> (startIndex < <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">return</span> startIndex + len > <span class=\"hljs-number\">0</span> ? startIndex + len: <span class=\"hljs-number\">0</span>;\n  } \n  <span class=\"hljs-keyword\">return</span> startIndex >= len ? len: startIndex;\n}\n\n<span class=\"hljs-keyword\">const</span> computeDeleteCount = <span class=\"hljs-function\">(<span class=\"hljs-params\">startIndex, len, deleteCount, argumentsLen</span>) =></span> {\n  <span class=\"hljs-comment\">// 删除数目没有传，默认删除startIndex及后面所有的</span>\n  <span class=\"hljs-keyword\">if</span> (argumentsLen === <span class=\"hljs-number\">1</span>) \n    <span class=\"hljs-keyword\">return</span> len - startIndex;\n  <span class=\"hljs-comment\">// 删除数目过小</span>\n  <span class=\"hljs-keyword\">if</span> (deleteCount < <span class=\"hljs-number\">0</span>) \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-comment\">// 删除数目过大</span>\n  <span class=\"hljs-keyword\">if</span> (deleteCount > len - deleteCount) \n    <span class=\"hljs-keyword\">return</span> len - startIndex;\n  <span class=\"hljs-keyword\">return</span> deleteCount;\n}\n\n<span class=\"hljs-built_in\">Array</span>.prototype.splice = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">startIndex, deleteCount, ...addElements</span>)  </span>{\n  <span class=\"hljs-keyword\">let</span> argumentsLen = <span class=\"hljs-built_in\">arguments</span>.length;\n  <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> len = array.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> deleteArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(deleteCount);\n\n  startIndex = computeStartIndex(startIndex, len);\n  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);\n\n  <span class=\"hljs-comment\">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.isSealed(array) && deleteCount !== addElements.length) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'the object is a sealed object!'</span>)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Object</span>.isFrozen(array) && (deleteCount > <span class=\"hljs-number\">0</span> || addElements.length > <span class=\"hljs-number\">0</span>)) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'the object is a frozen object!'</span>)\n  }\n   \n  <span class=\"hljs-comment\">// 拷贝删除的元素</span>\n  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);\n  <span class=\"hljs-comment\">// 移动删除元素后面的元素</span>\n  movePostElements(array, startIndex, len, deleteCount, addElements);\n\n  <span class=\"hljs-comment\">// 插入新元素</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < addElements.length; i++) {\n    array[startIndex + i] = addElements[i];\n  }\n\n  array.length = len - deleteCount + addElements.length;\n\n  <span class=\"hljs-keyword\">return</span> deleteArr;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0109</code></pre><p>以上代码对照<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\" rel=\"nofollow noopener noreferrer\">MDN文档</a>中的所有测试用例亲测通过。</p>\n<p>相关测试代码请前往: <a target=\"_blank\" href=\"https://github.com/sanyuan0704/frontend_daily_question/blob/master/test_splice.js\" rel=\"nofollow noopener noreferrer\">传送门</a></p>\n<p>最后给大家奉上V8源码，供大家检查： <a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L660\" rel=\"nofollow noopener noreferrer\">V8数组 splice 源码第 660 行</a></p>\n<h2 class=\"heading\" data-id=\"heading-33\">第十六篇: 能不能实现数组sort方法？</h2>\n<p>估计大家对 JS 数组的sort 方法已经不陌生了，之前也对它的用法做了详细的总结。那，它的内部是如何来实现的呢？如果说我们能够进入它的内部去看一看，\n理解背后的设计，会使我们的思维和素养得到不错的提升。</p>\n<p>sort 方法在 V8 内部相对与其他方法而言是一个比较高深的算法，对于很多边界情况做了反复的优化，但是这里我们不会直接拿源码来干讲。我们会来根据源码的思路，实现一个\n跟引擎性能<strong>一样</strong>的排序算法，并且一步步拆解其中的奥秘。</p>\n<h3 class=\"heading\" data-id=\"heading-34\">V8 引擎的思路分析</h3>\n<p>首先大概梳理一下源码中排序的思路:</p>\n<p>设要排序的元素个数是n：</p>\n<ul>\n<li>当 n <= 10 时，采用<code>插入排序</code></li>\n<li>当 n > 10 时，采用<code>三路快速排序</code>\n<ul>\n<li>10 < n <= 1000, 采用中位数作为哨兵元素</li>\n<li>n > 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数</li>\n</ul>\n</li>\n</ul>\n<p>在动手之前，我觉得我们有必要<strong>为什么</strong>这么做搞清楚。</p>\n<p>第一、为什么元素个数少的时候要采用插入排序？</p>\n<p>虽然<code>插入排序</code>理论上说是O(n^2)的算法，<code>快速排序</code>是一个O(nlogn)级别的算法。但是别忘了，这只是理论上的估算，在实际情况中两者的算法复杂度前面都会有一个系数的，\n当 n 足够小的时候，快速排序<code>nlogn</code>的优势会越来越小，倘若插入排序O(n^2)前面的系数足够小，那么就会超过快排。而事实上正是如此，<code>插入排序</code>经过优化以后对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。</p>\n<p>因此，对于很小的数据量，应用<code>插入排序</code>是一个非常不错的选择。</p>\n<p>第二、为什么要花这么大的力气选择哨兵元素？</p>\n<p>因为<code>快速排序</code>的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行partition(一边是小于哨兵的元素，另一边是大于哨兵的元素)时，就会有一边是空的，那么这么排下去，递归的层数就达到了n, 而每一层的复杂度是O(n)，因此快排这时候会退化成O(n^2)级别。</p>\n<p>这种情况是要尽力避免的！如果来避免？</p>\n<p>就是让哨兵元素进可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的种种优化了。</p>\n<p>接下来，我们来一步步实现的这样的官方排序算法。</p>\n<h3 class=\"heading\" data-id=\"heading-35\">插入排序及优化</h3>\n<p>最初的插入排序可能是这样写的:</p>\n<pre><code class=\"hljs js copyable code-036\" lang=\"js\"><span class=\"hljs-keyword\">const</span> insertSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">arr, start = <span class=\"hljs-number\">0</span>, end</span>) =></span> {\n  end = end || arr.length;\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = start; i < end; i++) {\n    <span class=\"hljs-keyword\">let</span> j;\n    <span class=\"hljs-keyword\">for</span>(j = i; j > start && arr[j - <span class=\"hljs-number\">1</span>] > arr[j]; j --) {\n      <span class=\"hljs-keyword\">let</span> temp = arr[j];\n      arr[j] = arr[j - <span class=\"hljs-number\">1</span>];\n      arr[j - <span class=\"hljs-number\">1</span>] = temp;\n    }\n  }\n  <span class=\"hljs-keyword\">return</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0110</code></pre><p>看似可以正确的完成排序，但实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成，如图所示:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3124af5479387?imageslim\" data-width=\"811\" data-height=\"505\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"811\" height=\"505\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>优化后代码如下:</p>\n<pre><code class=\"hljs js copyable code-037\" lang=\"js\"><span class=\"hljs-keyword\">const</span> insertSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">arr, start = <span class=\"hljs-number\">0</span>, end</span>) =></span> {\n  end = end || arr.length;\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = start; i < end; i++) {\n    <span class=\"hljs-keyword\">let</span> e = arr[i];\n    <span class=\"hljs-keyword\">let</span> j;\n    <span class=\"hljs-keyword\">for</span>(j = i; j > start && arr[j - <span class=\"hljs-number\">1</span>] > e; j --)\n      arr[j] = arr[j<span class=\"hljs-number\">-1</span>];\n    arr[j] = e;\n  }\n  <span class=\"hljs-keyword\">return</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0111</code></pre><p>接下来正式进入到 sort 方法。</p>\n<h3 class=\"heading\" data-id=\"heading-36\">寻找哨兵元素</h3>\n<p>sort的骨架大致如下:</p>\n<pre><code class=\"hljs js copyable code-038\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.sort = <span class=\"hljs-function\">(<span class=\"hljs-params\">comparefn</span>) =></span> {\n  <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-keyword\">this</span>);\n  <span class=\"hljs-keyword\">let</span> length = array.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">return</span> InnerArraySort(array, length, comparefn);\n}\n\n<span class=\"hljs-keyword\">const</span> InnerArraySort = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, length, comparefn</span>) =></span> {\n  <span class=\"hljs-comment\">// 比较函数未传入</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.toString.call(callbackfn) !== <span class=\"hljs-string\">\"[object Function]\"</span>) {\n    comparefn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) </span>{\n      <span class=\"hljs-keyword\">if</span> (x === y) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n      x = x.toString();\n      y = y.toString();\n      <span class=\"hljs-keyword\">if</span> (x == y) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> x < y ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\n    };\n  }\n  <span class=\"hljs-keyword\">const</span> insertSort = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-comment\">//...</span>\n  }\n  <span class=\"hljs-keyword\">const</span> getThirdIndex = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n    <span class=\"hljs-comment\">// 元素个数大于1000时寻找哨兵元素</span>\n  }\n  <span class=\"hljs-keyword\">const</span> quickSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n    <span class=\"hljs-comment\">//哨兵位置</span>\n    <span class=\"hljs-keyword\">let</span> thirdIndex = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) {\n      <span class=\"hljs-keyword\">if</span>(to - <span class=\"hljs-keyword\">from</span> <= <span class=\"hljs-number\">10</span>) {\n        insertSort(a, <span class=\"hljs-keyword\">from</span>, to);\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-keyword\">if</span>(to - <span class=\"hljs-keyword\">from</span> > <span class=\"hljs-number\">1000</span>) {\n        thirdIndex = getThirdIndex(a, <span class=\"hljs-keyword\">from</span> , to);\n      }<span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 小于1000 直接取中点</span>\n        thirdIndex = <span class=\"hljs-keyword\">from</span> + ((to - <span class=\"hljs-keyword\">from</span>) >> <span class=\"hljs-number\">2</span>);\n      }\n    }\n    <span class=\"hljs-comment\">//下面开始快排</span>\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0112</code></pre><p>我们先来把求取哨兵位置的代码实现一下:</p>\n<pre><code class=\"hljs js copyable code-039\" lang=\"js\"><span class=\"hljs-keyword\">const</span> getThirdIndex = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n  <span class=\"hljs-keyword\">let</span> tmpArr = [];\n  <span class=\"hljs-comment\">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span>\n  <span class=\"hljs-keyword\">let</span> increment = <span class=\"hljs-number\">200</span> + ((to - <span class=\"hljs-keyword\">from</span>) & <span class=\"hljs-number\">15</span>);\n  <span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">from</span> += <span class=\"hljs-number\">1</span>;\n  to -= <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-keyword\">from</span>; i < to; i += increment) {\n    tmpArr[j] = [i, a[i]];\n    j++;\n  }\n  <span class=\"hljs-comment\">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span>\n  tmpArr.sort(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> comparefn(a[<span class=\"hljs-number\">1</span>], b[<span class=\"hljs-number\">1</span>]);\n  });\n  <span class=\"hljs-keyword\">let</span> thirdIndex = tmpArr[tmpArr.length >> <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">return</span> thirdIndex;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0113</code></pre><h3 class=\"heading\" data-id=\"heading-37\">完成快排</h3>\n<p>接下来我们来完成快排的具体代码：</p>\n<pre><code class=\"hljs js copyable code-040\" lang=\"js\"><span class=\"hljs-keyword\">const</span> _sort = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c</span>) =></span> {\n  <span class=\"hljs-keyword\">let</span> arr = [a, b, c];\n  insertSort(arr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-keyword\">return</span> arr;\n}\n\n<span class=\"hljs-keyword\">const</span> quickSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n  <span class=\"hljs-comment\">//...</span>\n  <span class=\"hljs-comment\">// 上面我们拿到了thirdIndex</span>\n  <span class=\"hljs-comment\">// 现在我们拥有三个元素，from, thirdIndex, to</span>\n  <span class=\"hljs-comment\">// 为了再次确保 thirdIndex 不是最值，把这三个值排序</span>\n  [a[<span class=\"hljs-keyword\">from</span>], a[thirdIndex], a[to - <span class=\"hljs-number\">1</span>]] = _sort(a[<span class=\"hljs-keyword\">from</span>], a[thirdIndex], a[to - <span class=\"hljs-number\">1</span>]);\n  <span class=\"hljs-comment\">// 现在正式把 thirdIndex 作为哨兵</span>\n  <span class=\"hljs-keyword\">let</span> pivot = a[thirdIndex];\n  <span class=\"hljs-comment\">// 正式进入快排</span>\n  <span class=\"hljs-keyword\">let</span> lowEnd = <span class=\"hljs-keyword\">from</span> + <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> highStart = to - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-comment\">// 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换</span>\n  <span class=\"hljs-keyword\">let</span> pivot = a[thirdIndex];\n  a[thirdIndex] = a[lowEnd];\n  a[lowEnd] = pivot;\n  \n  <span class=\"hljs-comment\">// [lowEnd, i)的元素是和pivot相等的</span>\n  <span class=\"hljs-comment\">// [i, highStart) 的元素是需要处理的</span>\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = lowEnd + <span class=\"hljs-number\">1</span>; i < highStart; i++) {\n    <span class=\"hljs-keyword\">let</span> element = a[i];\n    <span class=\"hljs-keyword\">let</span> order = comparefn(element, pivot);\n    <span class=\"hljs-keyword\">if</span> (order < <span class=\"hljs-number\">0</span>) {\n      a[i] = a[lowEnd];\n      a[lowEnd] = element;\n      lowEnd++;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(order > <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">do</span>{\n        highStart--;\n        <span class=\"hljs-keyword\">if</span>(highStart === i) <span class=\"hljs-keyword\">break</span>;\n        order = comparefn(a[highStart], pivot);\n      }<span class=\"hljs-keyword\">while</span>(order > <span class=\"hljs-number\">0</span>)\n      <span class=\"hljs-comment\">// 现在 a[highStart] <= pivot</span>\n      <span class=\"hljs-comment\">// a[i] > pivot</span>\n      <span class=\"hljs-comment\">// 两者交换</span>\n      a[i] = a[highStart];\n      a[highStart] = element;\n      <span class=\"hljs-keyword\">if</span>(order < <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// a[i] 和 a[lowEnd] 交换</span>\n        element = a[i];\n        a[i] = a[lowEnd];\n        a[lowEnd] = element;\n        lowEnd++;\n      }\n    }\n  }\n  <span class=\"hljs-comment\">// 永远切分大区间</span>\n  <span class=\"hljs-keyword\">if</span> (lowEnd - <span class=\"hljs-keyword\">from</span> > to - highStart) {\n    <span class=\"hljs-comment\">// 继续切分lowEnd ~ from 这个区间</span>\n    to = lowEnd;\n    <span class=\"hljs-comment\">// 单独处理小区间</span>\n    quickSort(a, highStart, to);\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(lowEnd - <span class=\"hljs-keyword\">from</span> <= to - highStart) {\n    <span class=\"hljs-keyword\">from</span> = highStart;\n    quickSort(a, <span class=\"hljs-keyword\">from</span>, lowEnd);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0114</code></pre><h3 class=\"heading\" data-id=\"heading-38\">测试结果</h3>\n<p>测试结果如下:</p>\n<p>一万条数据:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3124fa130ab19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"299\" data-height=\"123\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"299\" height=\"123\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>十万条数据:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e312533c86a644?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>一百万条数据:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3125824bfe0f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"291\" data-height=\"119\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"291\" height=\"119\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>一千万条数据:</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3125b7ba2ad38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"276\" data-height=\"120\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"276\" height=\"120\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>结果仅供大家参考，因为不同的node版本对于部分细节的实现可能不一样，我现在的版本是v10.15。</p>\n<p>从结果可以看到，目前版本的 node 对于有序程度较高的数据是处理的不够好的，而我们刚刚实现的排序通过反复确定哨兵的位置就能\n有效的规避快排在这一场景下的劣势。</p>\n<p>最后给大家完整版的sort代码:</p>\n<pre><code class=\"hljs js copyable code-041\" lang=\"js\"><span class=\"hljs-keyword\">const</span> sort = <span class=\"hljs-function\">(<span class=\"hljs-params\">arr, comparefn</span>) =></span> {\n  <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-built_in\">Object</span>(arr);\n  <span class=\"hljs-keyword\">let</span> length = array.length >>> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">return</span> InnerArraySort(array, length, comparefn);\n}\n\n<span class=\"hljs-keyword\">const</span> InnerArraySort = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, length, comparefn</span>) =></span> {\n  <span class=\"hljs-comment\">// 比较函数未传入</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.toString.call(comparefn) !== <span class=\"hljs-string\">\"[object Function]\"</span>) {\n    comparefn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) </span>{\n      <span class=\"hljs-keyword\">if</span> (x === y) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n      x = x.toString();\n      y = y.toString();\n      <span class=\"hljs-keyword\">if</span> (x == y) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> x < y ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\n    };\n  }\n  <span class=\"hljs-keyword\">const</span> insertSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">arr, start = <span class=\"hljs-number\">0</span>, end</span>) =></span> {\n    end = end || arr.length;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = start; i < end; i++) {\n      <span class=\"hljs-keyword\">let</span> e = arr[i];\n      <span class=\"hljs-keyword\">let</span> j;\n      <span class=\"hljs-keyword\">for</span> (j = i; j > start && comparefn(arr[j - <span class=\"hljs-number\">1</span>], e) > <span class=\"hljs-number\">0</span>; j--)\n        arr[j] = arr[j - <span class=\"hljs-number\">1</span>];\n      arr[j] = e;\n    }\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> getThirdIndex = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n    <span class=\"hljs-keyword\">let</span> tmpArr = [];\n    <span class=\"hljs-comment\">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span>\n    <span class=\"hljs-keyword\">let</span> increment = <span class=\"hljs-number\">200</span> + ((to - <span class=\"hljs-keyword\">from</span>) & <span class=\"hljs-number\">15</span>);\n    <span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">from</span> += <span class=\"hljs-number\">1</span>;\n    to -= <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-keyword\">from</span>; i < to; i += increment) {\n      tmpArr[j] = [i, a[i]];\n      j++;\n    }\n    <span class=\"hljs-comment\">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span>\n    tmpArr.sort(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) </span>{\n      <span class=\"hljs-keyword\">return</span> comparefn(a[<span class=\"hljs-number\">1</span>], b[<span class=\"hljs-number\">1</span>]);\n    });\n    <span class=\"hljs-keyword\">let</span> thirdIndex = tmpArr[tmpArr.length >> <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">return</span> thirdIndex;\n  };\n\n  <span class=\"hljs-keyword\">const</span> _sort = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c</span>) =></span> {\n    <span class=\"hljs-keyword\">let</span> arr = [];\n    arr.push(a, b, c);\n    insertSort(arr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-keyword\">return</span> arr;\n  }\n\n  <span class=\"hljs-keyword\">const</span> quickSort = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, <span class=\"hljs-keyword\">from</span>, to</span>) =></span> {\n    <span class=\"hljs-comment\">//哨兵位置</span>\n    <span class=\"hljs-keyword\">let</span> thirdIndex = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n      <span class=\"hljs-keyword\">if</span> (to - <span class=\"hljs-keyword\">from</span> <= <span class=\"hljs-number\">10</span>) {\n        insertSort(a, <span class=\"hljs-keyword\">from</span>, to);\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-keyword\">if</span> (to - <span class=\"hljs-keyword\">from</span> > <span class=\"hljs-number\">1000</span>) {\n        thirdIndex = getThirdIndex(a, <span class=\"hljs-keyword\">from</span>, to);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 小于1000 直接取中点</span>\n        thirdIndex = <span class=\"hljs-keyword\">from</span> + ((to - <span class=\"hljs-keyword\">from</span>) >> <span class=\"hljs-number\">2</span>);\n      }\n      <span class=\"hljs-keyword\">let</span> tmpArr = _sort(a[<span class=\"hljs-keyword\">from</span>], a[thirdIndex], a[to - <span class=\"hljs-number\">1</span>]);\n      a[<span class=\"hljs-keyword\">from</span>] = tmpArr[<span class=\"hljs-number\">0</span>]; a[thirdIndex] = tmpArr[<span class=\"hljs-number\">1</span>]; a[to - <span class=\"hljs-number\">1</span>] = tmpArr[<span class=\"hljs-number\">2</span>];\n      <span class=\"hljs-comment\">// 现在正式把 thirdIndex 作为哨兵</span>\n      <span class=\"hljs-keyword\">let</span> pivot = a[thirdIndex];\n      [a[<span class=\"hljs-keyword\">from</span>], a[thirdIndex]] = [a[thirdIndex], a[<span class=\"hljs-keyword\">from</span>]];\n      <span class=\"hljs-comment\">// 正式进入快排</span>\n      <span class=\"hljs-keyword\">let</span> lowEnd = <span class=\"hljs-keyword\">from</span> + <span class=\"hljs-number\">1</span>;\n      <span class=\"hljs-keyword\">let</span> highStart = to - <span class=\"hljs-number\">1</span>;\n      a[thirdIndex] = a[lowEnd];\n      a[lowEnd] = pivot;\n      <span class=\"hljs-comment\">// [lowEnd, i)的元素是和pivot相等的</span>\n      <span class=\"hljs-comment\">// [i, highStart) 的元素是需要处理的</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = lowEnd + <span class=\"hljs-number\">1</span>; i < highStart; i++) {\n        <span class=\"hljs-keyword\">let</span> element = a[i];\n        <span class=\"hljs-keyword\">let</span> order = comparefn(element, pivot);\n        <span class=\"hljs-keyword\">if</span> (order < <span class=\"hljs-number\">0</span>) {\n          a[i] = a[lowEnd];\n          a[lowEnd] = element;\n          lowEnd++;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (order > <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">do</span>{\n            highStart--;\n            <span class=\"hljs-keyword\">if</span> (highStart === i) <span class=\"hljs-keyword\">break</span>;\n            order = comparefn(a[highStart], pivot);\n          }<span class=\"hljs-keyword\">while</span> (order > <span class=\"hljs-number\">0</span>) ;\n          <span class=\"hljs-comment\">// 现在 a[highStart] <= pivot</span>\n          <span class=\"hljs-comment\">// a[i] > pivot</span>\n          <span class=\"hljs-comment\">// 两者交换</span>\n          a[i] = a[highStart];\n          a[highStart] = element;\n          <span class=\"hljs-keyword\">if</span> (order < <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// a[i] 和 a[lowEnd] 交换</span>\n            element = a[i];\n            a[i] = a[lowEnd];\n            a[lowEnd] = element;\n            lowEnd++;\n          }\n        }\n      }\n      <span class=\"hljs-comment\">// 永远切分大区间</span>\n      <span class=\"hljs-keyword\">if</span> (lowEnd - <span class=\"hljs-keyword\">from</span> > to - highStart) {\n        <span class=\"hljs-comment\">// 单独处理小区间</span>\n        quickSort(a, highStart, to);\n        <span class=\"hljs-comment\">// 继续切分lowEnd ~ from 这个区间</span>\n        to = lowEnd;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lowEnd - <span class=\"hljs-keyword\">from</span> <= to - highStart) {\n        quickSort(a, <span class=\"hljs-keyword\">from</span>, lowEnd);\n        <span class=\"hljs-keyword\">from</span> = highStart;\n      }\n    }\n  }\n  quickSort(array, <span class=\"hljs-number\">0</span>, length);\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0115</code></pre><p>参考链接:</p>\n<p><a target=\"_blank\" href=\"https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#997\" rel=\"nofollow noopener noreferrer\">V8 sort源码(点开第997行)</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/59e80dc6f265da432a7aaf15\" rel>冴羽排序源码专题</a></p>\n<h2 class=\"heading\" data-id=\"heading-39\">第十七篇: 能不能模拟实现一个new的效果？</h2>\n<p><code>new</code>被调用后做了三件事情:</p>\n<ol>\n<li>让实例可以访问到私有属性</li>\n<li>让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性</li>\n<li>如果构造函数返回的结果不是引用数据类型</li>\n</ol>\n<pre><code class=\"hljs js copyable code-042\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">newOperator</span>(<span class=\"hljs-params\">ctor, ...args</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> ctor !== <span class=\"hljs-string\">'function'</span>){\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">'newOperator function the first param must be a function'</span>;\n    }\n    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-built_in\">Object</span>.create(ctor.prototype);\n    <span class=\"hljs-keyword\">let</span> res = ctor.apply(obj, args);\n    \n    <span class=\"hljs-keyword\">let</span> isObject = <span class=\"hljs-keyword\">typeof</span> res === <span class=\"hljs-string\">'object'</span> && res !== <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">let</span> isFunction = typoof res === <span class=\"hljs-string\">'function'</span>;\n    <span class=\"hljs-keyword\">return</span> isObect || isFunction ? res : obj;\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-0116</code></pre><h2 class=\"heading\" data-id=\"heading-40\">第十八篇: 能不能模拟实现一个 bind 的效果？</h2>\n<p>实现bind之前，我们首先要知道它做了哪些事情。</p>\n<ol>\n<li>\n<p>对于普通函数，绑定this指向</p>\n</li>\n<li>\n<p>对于构造函数，要保证原函数的原型对象上的属性不能丢失</p>\n</li>\n</ol>\n<pre><code class=\"hljs js copyable code-043\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, ...args</span>) </span>{\n    <span class=\"hljs-comment\">// 异常处理</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">\"function\"</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"Function.prototype.bind - what is trying to be bound is not callable\"</span>);\n    }\n    <span class=\"hljs-comment\">// 保存this的值，它代表调用 bind 的函数</span>\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">var</span> fNOP = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{};\n\n    <span class=\"hljs-keyword\">var</span> fbound = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n        self.apply(<span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> self ? \n            <span class=\"hljs-keyword\">this</span> : \n            context, args.concat(<span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>)));\n    }\n\n    fNOP.prototype = <span class=\"hljs-keyword\">this</span>.prototype;\n    fbound.prototype = <span class=\"hljs-keyword\">new</span> fNOP();\n\n    <span class=\"hljs-keyword\">return</span> fbound;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0117</code></pre><p>也可以这么用 Object.create 来处理原型:</p>\n<pre><code class=\"hljs js copyable code-044\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, ...args</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">\"function\"</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"Function.prototype.bind - what is trying to be bound is not callable\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-keyword\">var</span> fbound = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n        self.apply(<span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> self ? \n            <span class=\"hljs-keyword\">this</span> : \n            context, args.concat(<span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>)));\n    }\n\n    fbound.prototype = <span class=\"hljs-built_in\">Object</span>.create(self.prototype);\n\n    <span class=\"hljs-keyword\">return</span> fbound;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0118</code></pre><h2 class=\"heading\" data-id=\"heading-41\">第十八篇: 能不能实现一个 call/apply 函数？</h2>\n<p>引自<code>冴羽</code>大佬的代码，可以说比较完整了。</p>\n<pre><code class=\"hljs js copyable code-045\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.call = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-built_in\">window</span>;\n    context.fn = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-keyword\">var</span> args = [];\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>, len = <span class=\"hljs-built_in\">arguments</span>.length; i < len; i++) {\n        args.push(<span class=\"hljs-string\">'arguments['</span> + i + <span class=\"hljs-string\">']'</span>);\n    }\n\n    <span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">'context.fn('</span> + args +<span class=\"hljs-string\">')'</span>);\n\n    <span class=\"hljs-keyword\">delete</span> context.fn\n    <span class=\"hljs-keyword\">return</span> result;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0119</code></pre><p>不过我认为换成 ES6 的语法会更精炼一些:</p>\n<pre><code class=\"hljs js copyable code-046\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.call = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, ...args</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-built_in\">window</span>;\n  context.fn = <span class=\"hljs-keyword\">this</span>;\n\n  <span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">'context.fn(...args)'</span>);\n\n  <span class=\"hljs-keyword\">delete</span> context.fn\n  <span class=\"hljs-keyword\">return</span> result;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0120</code></pre><p>类似的，有apply的对应实现:</p>\n<pre><code class=\"hljs js copyable code-047\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, args</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> context = context || <span class=\"hljs-built_in\">window</span>;\n  context.fn = <span class=\"hljs-keyword\">this</span>;\n  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">'context.fn(...args)'</span>);\n\n  <span class=\"hljs-keyword\">delete</span> context.fn\n  <span class=\"hljs-keyword\">return</span> result;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0121</code></pre><h2 class=\"heading\" data-id=\"heading-42\">第十九篇: 谈谈你对JS中this的理解。</h2>\n<p>其实JS中的this是一个非常简单的东西，只需要理解它的执行规则就OK。</p>\n<p>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。</p>\n<p>call/apply/bind可以显式绑定, 这里就不说了。</p>\n<p>主要这些场隐式绑定的场景讨论:</p>\n<ol>\n<li>全局上下文</li>\n<li>直接调用函数</li>\n<li>对象.方法的形式调用</li>\n<li>DOM事件绑定(特殊)</li>\n<li>new构造函数绑定</li>\n<li>箭头函数</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-43\">1. 全局上下文</h3>\n<p>全局上下文默认this指向window, 严格模式下指向undefined。</p>\n<h3 class=\"heading\" data-id=\"heading-44\">2. 直接调用函数</h3>\n<p>比如:</p>\n<pre><code class=\"hljs js copyable code-048\" lang=\"js\"><span class=\"hljs-keyword\">let</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n  }\n}\n<span class=\"hljs-keyword\">let</span> func = obj.a;\nfunc();\n<span class=\"copy-code-btn\">复制代码</span> copy-0122</code></pre><p>这种情况是直接调用。this相当于全局上下文的情况。</p>\n<h3 class=\"heading\" data-id=\"heading-45\">3. 对象.方法的形式调用</h3>\n<p>还是刚刚的例子，我如果这样写:</p>\n<pre><code class=\"hljs js copyable code-049\" lang=\"js\">obj.a();\n<span class=\"copy-code-btn\">复制代码</span> copy-0123</code></pre><p>这就是<code>对象.方法</code>的情况，this指向这个对象</p>\n<h3 class=\"heading\" data-id=\"heading-46\">4. DOM事件绑定</h3>\n<p>onclick和addEventerListener中 this 默认指向绑定事件的元素。</p>\n<p>IE比较奇异，使用attachEvent，里面的this默认指向window。</p>\n<h3 class=\"heading\" data-id=\"heading-47\">5. new+构造函数</h3>\n<p>此时构造函数中的this指向实例对象。</p>\n<h3 class=\"heading\" data-id=\"heading-48\">6. 箭头函数？</h3>\n<p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。比如:</p>\n<pre><code class=\"hljs js copyable code-050\" lang=\"js\"><span class=\"hljs-keyword\">let</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">do</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n    }\n    <span class=\"hljs-keyword\">do</span>();\n  }\n}\nobj.a(); <span class=\"hljs-comment\">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0124</code></pre><blockquote>\n<p>优先级: new  > call、apply、bind  > 对象.方法 > 直接调用。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-49\">第二十篇: JS中浅拷贝的手段有哪些？</h2>\n<h3 class=\"heading\" data-id=\"heading-50\">重要: 什么是拷贝？</h3>\n<p>首先来直观的感受一下什么是拷贝。</p>\n<pre><code class=\"hljs js copyable code-051\" lang=\"js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr = arr;\nnewArr[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">100</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(arr);<span class=\"hljs-comment\">//[100, 2, 3]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0125</code></pre><p>这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。</p>\n<p>现在进行浅拷贝:</p>\n<pre><code class=\"hljs js copyable code-052\" lang=\"js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr = arr.slice();\nnewArr[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">100</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(arr);<span class=\"hljs-comment\">//[1, 2, 3]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0126</code></pre><p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！</p>\n<p>这就是浅拷贝！</p>\n<p>但是这又会带来一个潜在的问题:</p>\n<pre><code class=\"hljs js copyable code-053\" lang=\"js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, {<span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">4</span>}];\n<span class=\"hljs-keyword\">let</span> newArr = arr.slice();\nnewArr[<span class=\"hljs-number\">2</span>].val = <span class=\"hljs-number\">1000</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(arr);<span class=\"hljs-comment\">//[ 1, 2, { val: 1000 } ]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0127</code></pre><p>咦!不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了。</p>\n<p>这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能\n解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。 现在先让大家有一个基本的概念。</p>\n<p>接下来，我们来研究一下JS中实现浅拷贝到底有多少种方式？</p>\n<h3 class=\"heading\" data-id=\"heading-51\">1. 手动实现</h3>\n<pre><code class=\"hljs js copyable code-054\" lang=\"js\"><span class=\"hljs-keyword\">const</span> shallowClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'object'</span> && target !== <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">const</span> cloneTarget = <span class=\"hljs-built_in\">Array</span>.isArray(target) ? []: {};\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> prop <span class=\"hljs-keyword\">in</span> target) {\n      <span class=\"hljs-keyword\">if</span> (target.hasOwnProperty(prop)) {\n          cloneTarget[prop] = target[prop];\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> cloneTarget;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0128</code></pre><h3 class=\"heading\" data-id=\"heading-52\">2. Object.assign</h3>\n<p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>\n<pre><code class=\"hljs js copyable code-055\" lang=\"js\"><span class=\"hljs-keyword\">let</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'sy'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> };\n<span class=\"hljs-keyword\">const</span> obj2 = <span class=\"hljs-built_in\">Object</span>.assign({}, obj, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'sss'</span>});\n<span class=\"hljs-built_in\">console</span>.log(obj2);<span class=\"hljs-comment\">//{ name: 'sss', age: 18 }</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0129</code></pre><h3 class=\"heading\" data-id=\"heading-53\">3. concat浅拷贝数组</h3>\n<pre><code class=\"hljs js copyable code-056\" lang=\"js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr = arr.concat();\nnewArr[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">100</span>;\n<span class=\"hljs-built_in\">console</span>.log(arr);<span class=\"hljs-comment\">//[ 1, 2, 3 ]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0130</code></pre><h3 class=\"heading\" data-id=\"heading-54\">4. slice浅拷贝</h3>\n<p>开头的例子不就说的这个嘛！</p>\n<h3 class=\"heading\" data-id=\"heading-55\">5. ...展开运算符</h3>\n<pre><code class=\"hljs js copyable code-057\" lang=\"js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr = [...arr];<span class=\"hljs-comment\">//跟arr.slice()是一样的效果</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0131</code></pre><h2 class=\"heading\" data-id=\"heading-56\">第二十一篇: 能不能写一个完整的深拷贝？</h2>\n<p>上一篇已经解释了什么是深拷贝，现在我们来一起实现一个完整且专业的深拷贝。</p>\n<h3 class=\"heading\" data-id=\"heading-57\">1. 简易版及问题</h3>\n<pre><code class=\"hljs js copyable code-058\" lang=\"js\"><span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-built_in\">JSON</span>.stringify());\n<span class=\"copy-code-btn\">复制代码</span> copy-0132</code></pre><p>估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：</p>\n<blockquote>\n<ol>\n<li>无法解决<code>循环引用</code>的问题。举个例子：</li>\n</ol>\n</blockquote>\n<pre><code class=\"hljs js copyable code-059\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = {<span class=\"hljs-attr\">val</span>:<span class=\"hljs-number\">2</span>};\na.target = a;\n<span class=\"copy-code-btn\">复制代码</span> copy-0133</code></pre><p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p>\n<blockquote>\n<ol start=\"2\">\n<li>无法拷贝一写<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>无法拷贝<code>函数</code>(划重点)。</li>\n</ol>\n</blockquote>\n<p>因此这个api先pass掉，我们重新写一个深拷贝，简易版如下:</p>\n<pre><code class=\"hljs js copyable code-060\" lang=\"js\"><span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'object'</span> && target !== <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">const</span> cloneTarget = <span class=\"hljs-built_in\">Array</span>.isArray(target) ? []: {};\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> prop <span class=\"hljs-keyword\">in</span> target) {\n      <span class=\"hljs-keyword\">if</span> (target.hasOwnProperty(prop)) {\n          cloneTarget[prop] = deepClone(target[prop]);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> cloneTarget;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0134</code></pre><p>现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。</p>\n<h3 class=\"heading\" data-id=\"heading-58\">2. 解决循环引用</h3>\n<p>现在问题如下:</p>\n<pre><code class=\"hljs js copyable code-061\" lang=\"js\"><span class=\"hljs-keyword\">let</span> obj = {<span class=\"hljs-attr\">val</span> : <span class=\"hljs-number\">100</span>};\nobj.target = obj;\n\ndeepClone(obj);<span class=\"hljs-comment\">//报错: RangeError: Maximum call stack size exceeded</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0135</code></pre><p>这就是循环引用。我们怎么来解决这个问题呢？</p>\n<p>创建一个Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。</p>\n<pre><code class=\"hljs js copyable code-062\" lang=\"js\"><span class=\"hljs-keyword\">const</span> isObject = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> (<span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'object'</span> || <span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'function'</span>) && target !== <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(</span>)) =></span> {\n  <span class=\"hljs-keyword\">if</span>(map.get(target)) \n    <span class=\"hljs-keyword\">return</span> target;\n\n\n  <span class=\"hljs-keyword\">if</span> (isObject(target)) {\n    map.put(target, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">const</span> cloneTarget = <span class=\"hljs-built_in\">Array</span>.isArray(target) ? []: {};\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> prop <span class=\"hljs-keyword\">in</span> target) {\n      <span class=\"hljs-keyword\">if</span> (target.hasOwnProperty(prop)) {\n          cloneTarget[prop] = deepClone(target[prop]);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> cloneTarget;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0136</code></pre><p>现在来试一试：</p>\n<pre><code class=\"hljs js copyable code-063\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = {<span class=\"hljs-attr\">val</span>:<span class=\"hljs-number\">2</span>};\na.target = a;\n<span class=\"hljs-keyword\">let</span> newA = deepClone(a);\n<span class=\"hljs-built_in\">console</span>.log(newA)<span class=\"hljs-comment\">//{ val: 2, target: { val: 2, target: [Circular] } }</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0137</code></pre><p>好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是map 上的 key 和 map 构成了<code>强引用关系</code>，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了：</p>\n<blockquote>\n<p>在计算机程序设计中，弱引用与强引用相对，\n是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 --百度百科</p>\n</blockquote>\n<p>说的有一点绕，我用大白话解释一下，被弱引用的对象可以在<code>任何时候被回收</code>，而对于强引用来说，只要这个强引用还在，那么对象<code>无法被回收</code>。拿上面的例子说，map 和 a一直是强引用的关系，\n在程序结束之前，a 所占的内存空间一直<code>不会被释放</code>。</p>\n<p>怎么解决这个问题？</p>\n<p>很简单，让 map 的 key 和 map 构成<code>弱引用</code>即可。ES6给我们提供了这样的数据结构，它的名字叫<code>WeakMap</code>，它是一种特殊的Map, 其中的键是<code>弱引用</code>的。其键必须是对象，而值可以是任意的。</p>\n<p>稍微改造一下即可:</p>\n<pre><code class=\"hljs js copyable code-064\" lang=\"js\"><span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>(</span>)) =></span> {\n  <span class=\"hljs-comment\">//...</span>\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0138</code></pre><h3 class=\"heading\" data-id=\"heading-59\">3. 拷贝特殊对象</h3>\n<h4 class=\"heading\" data-id=\"heading-60\">可继续遍历</h4>\n<p>对于特殊的对象，我们使用以下方式来鉴别:</p>\n<pre><code class=\"hljs js copyable code-065\" lang=\"js\"><span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n<span class=\"copy-code-btn\">复制代码</span> copy-0139</code></pre><p>梳理一下对于可遍历对象会有什么结果：</p>\n<pre><code class=\"hljs js copyable code-066\" lang=\"js\">[<span class=\"hljs-string\">\"object Map\"</span>]\n[<span class=\"hljs-string\">\"object Set\"</span>]\n[<span class=\"hljs-string\">\"object Array\"</span>]\n[<span class=\"hljs-string\">\"object Object\"</span>]\n[<span class=\"hljs-string\">\"object Arguments\"</span>]\n<span class=\"copy-code-btn\">复制代码</span> copy-0140</code></pre><p>好，以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。</p>\n<pre><code class=\"hljs js copyable code-067\" lang=\"js\"><span class=\"hljs-keyword\">const</span> getType = <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n\n<span class=\"hljs-keyword\">const</span> canTraverse = {\n  <span class=\"hljs-string\">'[object Map]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Set]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Array]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Object]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Arguments]'</span>: <span class=\"hljs-literal\">true</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(</span>)) =></span> {\n  <span class=\"hljs-keyword\">if</span>(!isObject(target)) \n    <span class=\"hljs-keyword\">return</span> target;\n  <span class=\"hljs-keyword\">let</span> type = getType(target);\n  <span class=\"hljs-keyword\">let</span> cloneTarget;\n  <span class=\"hljs-keyword\">if</span>(!canTraverse[type]) {\n    <span class=\"hljs-comment\">// 处理不能遍历的对象</span>\n    <span class=\"hljs-keyword\">return</span>;\n  }<span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 这波操作相当关键，可以保证对象的原型不丢失！</span>\n    <span class=\"hljs-keyword\">let</span> ctor = target.prototype;\n    cloneTarget = <span class=\"hljs-keyword\">new</span> ctor();\n  }\n\n  <span class=\"hljs-keyword\">if</span>(map.get(target)) \n    <span class=\"hljs-keyword\">return</span> target;\n  map.put(target, <span class=\"hljs-literal\">true</span>);\n\n  <span class=\"hljs-keyword\">if</span>(type === mapTag) {\n    <span class=\"hljs-comment\">//处理Map</span>\n    target.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, key</span>) =></span> {\n      cloneTarget.set(deepClone(key), deepClone(item));\n    })\n  }\n  \n  <span class=\"hljs-keyword\">if</span>(type === setTag) {\n    <span class=\"hljs-comment\">//处理Set</span>\n    target.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> {\n      target.add(deepClone(item));\n    })\n  }\n\n  <span class=\"hljs-comment\">// 处理数组和对象</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> prop <span class=\"hljs-keyword\">in</span> target) {\n    <span class=\"hljs-keyword\">if</span> (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = deepClone(target[prop]);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> cloneTarget;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0141</code></pre><h4 class=\"heading\" data-id=\"heading-61\">不可遍历的对象</h4>\n<pre><code class=\"hljs js copyable code-068\" lang=\"js\"><span class=\"hljs-keyword\">const</span> boolTag = <span class=\"hljs-string\">'[object Boolean]'</span>;\n<span class=\"hljs-keyword\">const</span> numberTag = <span class=\"hljs-string\">'[object Number]'</span>;\n<span class=\"hljs-keyword\">const</span> stringTag = <span class=\"hljs-string\">'[object String]'</span>;\n<span class=\"hljs-keyword\">const</span> dateTag = <span class=\"hljs-string\">'[object Date]'</span>;\n<span class=\"hljs-keyword\">const</span> errorTag = <span class=\"hljs-string\">'[object Error]'</span>;\n<span class=\"hljs-keyword\">const</span> regexpTag = <span class=\"hljs-string\">'[object RegExp]'</span>;\n<span class=\"hljs-keyword\">const</span> funcTag = <span class=\"hljs-string\">'[object Function]'</span>;\n<span class=\"copy-code-btn\">复制代码</span> copy-0142</code></pre><p>对于不可遍历的对象，不同的对象有不同的处理。</p>\n<pre><code class=\"hljs js copyable code-069\" lang=\"js\"><span class=\"hljs-keyword\">const</span> handleRegExp = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> { source, flags } = target;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> target.constructor(source, flags);\n}\n\n<span class=\"hljs-keyword\">const</span> handleFunc = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> {\n  <span class=\"hljs-comment\">// 待会的重点部分</span>\n}\n\n<span class=\"hljs-keyword\">const</span> handleNotTraverse = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, tag</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> Ctor = targe.constructor;\n  <span class=\"hljs-keyword\">switch</span>(tag) {\n    <span class=\"hljs-keyword\">case</span> boolTag:\n    <span class=\"hljs-keyword\">case</span> numberTag:\n    <span class=\"hljs-keyword\">case</span> stringTag:\n    <span class=\"hljs-keyword\">case</span> errorTag: \n    <span class=\"hljs-keyword\">case</span> dateTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n    <span class=\"hljs-keyword\">case</span> regexpTag:\n      <span class=\"hljs-keyword\">return</span> handleRegExp(target);\n    <span class=\"hljs-keyword\">case</span> funcTag:\n      <span class=\"hljs-keyword\">return</span> handleFunc(target);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0143</code></pre><h3 class=\"heading\" data-id=\"heading-62\">4. 拷贝函数</h3>\n<p>虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。</p>\n<p>提到函数，在JS种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是\nFunction的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要\n处理普通函数的情况，箭头函数直接返回它本身就好了。</p>\n<p>那么如何来区分两者呢？</p>\n<p>答案是: 利用原型。箭头函数是不存在原型的。</p>\n<p>代码如下:</p>\n<pre><code class=\"hljs js copyable code-070\" lang=\"js\"><span class=\"hljs-keyword\">const</span> handleFunc = <span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> {\n  <span class=\"hljs-comment\">// 箭头函数直接返回自身</span>\n  <span class=\"hljs-keyword\">if</span>(!func.prototype) <span class=\"hljs-keyword\">return</span> func;\n  <span class=\"hljs-keyword\">const</span> bodyReg = <span class=\"hljs-regexp\">/(?<={)(.|\\n)+(?=})/m</span>;\n  <span class=\"hljs-keyword\">const</span> paramReg = <span class=\"hljs-regexp\">/(?<=\\().+(?=\\)\\s+{)/</span>;\n  <span class=\"hljs-keyword\">const</span> funcString = func.toString();\n  <span class=\"hljs-comment\">// 分别匹配 函数参数 和 函数体</span>\n  <span class=\"hljs-keyword\">const</span> param = paramReg.exec(funcString);\n  <span class=\"hljs-keyword\">const</span> body = bodyReg.exec(funcString);\n  <span class=\"hljs-keyword\">if</span>(!body) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">if</span> (param) {\n    <span class=\"hljs-keyword\">const</span> paramArr = param[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">','</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>(...paramArr, body[<span class=\"hljs-number\">0</span>]);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>(body[<span class=\"hljs-number\">0</span>]);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0144</code></pre><p>到现在，我们的深拷贝就实现地比较完善了。不过在测试的过程中，我也发现了一个小小的bug。</p>\n<h3 class=\"heading\" data-id=\"heading-63\">5. 小小的bug</h3>\n<p>如下所示:</p>\n<pre><code class=\"hljs js copyable code-071\" lang=\"js\"><span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-keyword\">const</span> Ctor = target.constructor;\n<span class=\"hljs-keyword\">new</span> Ctor(target); <span class=\"hljs-comment\">// 结果为 Boolean {true} 而不是 false。</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-0145</code></pre><p>对于这样一个bug，我们可以对 Boolean 拷贝做最简单的修改，\n调用valueOf: new target.constructor(target.valueOf())。</p>\n<p>但实际上，这种写法是不推荐的。因为在ES6后不推荐使用【new 基本类型()】这\n样的语法，所以es6中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)。</p>\n<p>因此我们接下来统一一下:</p>\n<pre><code class=\"hljs js copyable code-072\" lang=\"js\"><span class=\"hljs-keyword\">const</span> handleNotTraverse = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, tag</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> Ctor = targe.constructor;\n  <span class=\"hljs-keyword\">switch</span>(tag) {\n    <span class=\"hljs-keyword\">case</span> boolTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">Boolean</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> numberTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">Number</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> stringTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">String</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> errorTag: \n    <span class=\"hljs-keyword\">case</span> dateTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n    <span class=\"hljs-keyword\">case</span> regexpTag:\n      <span class=\"hljs-keyword\">return</span> handleRegExp(target);\n    <span class=\"hljs-keyword\">case</span> funcTag:\n      <span class=\"hljs-keyword\">return</span> handleFunc(target);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0146</code></pre><h3 class=\"heading\" data-id=\"heading-64\">6. 完整代码展示</h3>\n<p>OK!是时候给大家放出完整版的深拷贝啦:</p>\n<pre><code class=\"hljs js copyable code-073\" lang=\"js\"><span class=\"hljs-keyword\">const</span> getType = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =></span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n\n<span class=\"hljs-keyword\">const</span> isObject = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> (<span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'object'</span> || <span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">'function'</span>) && target !== <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">const</span> canTraverse = {\n  <span class=\"hljs-string\">'[object Map]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Set]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Array]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Object]'</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-string\">'[object Arguments]'</span>: <span class=\"hljs-literal\">true</span>,\n};\n<span class=\"hljs-keyword\">const</span> mapTag = <span class=\"hljs-string\">'[object Map]'</span>;\n<span class=\"hljs-keyword\">const</span> setTag = <span class=\"hljs-string\">'[object Set]'</span>;\n<span class=\"hljs-keyword\">const</span> boolTag = <span class=\"hljs-string\">'[object Boolean]'</span>;\n<span class=\"hljs-keyword\">const</span> numberTag = <span class=\"hljs-string\">'[object Number]'</span>;\n<span class=\"hljs-keyword\">const</span> stringTag = <span class=\"hljs-string\">'[object String]'</span>;\n<span class=\"hljs-keyword\">const</span> symbolTag = <span class=\"hljs-string\">'[object Symbol]'</span>;\n<span class=\"hljs-keyword\">const</span> dateTag = <span class=\"hljs-string\">'[object Date]'</span>;\n<span class=\"hljs-keyword\">const</span> errorTag = <span class=\"hljs-string\">'[object Error]'</span>;\n<span class=\"hljs-keyword\">const</span> regexpTag = <span class=\"hljs-string\">'[object RegExp]'</span>;\n<span class=\"hljs-keyword\">const</span> funcTag = <span class=\"hljs-string\">'[object Function]'</span>;\n\n<span class=\"hljs-keyword\">const</span> handleRegExp = <span class=\"hljs-function\">(<span class=\"hljs-params\">target</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> { source, flags } = target;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> target.constructor(source, flags);\n}\n\n<span class=\"hljs-keyword\">const</span> handleFunc = <span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> {\n  <span class=\"hljs-comment\">// 箭头函数直接返回自身</span>\n  <span class=\"hljs-keyword\">if</span>(!func.prototype) <span class=\"hljs-keyword\">return</span> func;\n  <span class=\"hljs-keyword\">const</span> bodyReg = <span class=\"hljs-regexp\">/(?<={)(.|\\n)+(?=})/m</span>;\n  <span class=\"hljs-keyword\">const</span> paramReg = <span class=\"hljs-regexp\">/(?<=\\().+(?=\\)\\s+{)/</span>;\n  <span class=\"hljs-keyword\">const</span> funcString = func.toString();\n  <span class=\"hljs-comment\">// 分别匹配 函数参数 和 函数体</span>\n  <span class=\"hljs-keyword\">const</span> param = paramReg.exec(funcString);\n  <span class=\"hljs-keyword\">const</span> body = bodyReg.exec(funcString);\n  <span class=\"hljs-keyword\">if</span>(!body) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">if</span> (param) {\n    <span class=\"hljs-keyword\">const</span> paramArr = param[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">','</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>(...paramArr, body[<span class=\"hljs-number\">0</span>]);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>(body[<span class=\"hljs-number\">0</span>]);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> handleNotTraverse = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, tag</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> Ctor = target.constructor;\n  <span class=\"hljs-keyword\">switch</span>(tag) {\n    <span class=\"hljs-keyword\">case</span> boolTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">Boolean</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> numberTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">Number</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> stringTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">String</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> symbolTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(<span class=\"hljs-built_in\">Symbol</span>.prototype.valueOf.call(target));\n    <span class=\"hljs-keyword\">case</span> errorTag: \n    <span class=\"hljs-keyword\">case</span> dateTag:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n    <span class=\"hljs-keyword\">case</span> regexpTag:\n      <span class=\"hljs-keyword\">return</span> handleRegExp(target);\n    <span class=\"hljs-keyword\">case</span> funcTag:\n      <span class=\"hljs-keyword\">return</span> handleFunc(target);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Ctor(target);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>(</span>)) =></span> {\n  <span class=\"hljs-keyword\">if</span>(!isObject(target)) \n    <span class=\"hljs-keyword\">return</span> target;\n  <span class=\"hljs-keyword\">let</span> type = getType(target);\n  <span class=\"hljs-keyword\">let</span> cloneTarget;\n  <span class=\"hljs-keyword\">if</span>(!canTraverse[type]) {\n    <span class=\"hljs-comment\">// 处理不能遍历的对象</span>\n    <span class=\"hljs-keyword\">return</span> handleNotTraverse(target, type);\n  }<span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 这波操作相当关键，可以保证对象的原型不丢失！</span>\n    <span class=\"hljs-keyword\">let</span> ctor = target.constructor;\n    cloneTarget = <span class=\"hljs-keyword\">new</span> ctor();\n  }\n\n  <span class=\"hljs-keyword\">if</span>(map.get(target)) \n    <span class=\"hljs-keyword\">return</span> target;\n  map.set(target, <span class=\"hljs-literal\">true</span>);\n\n  <span class=\"hljs-keyword\">if</span>(type === mapTag) {\n    <span class=\"hljs-comment\">//处理Map</span>\n    target.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, key</span>) =></span> {\n      cloneTarget.set(deepClone(key, map), deepClone(item, map));\n    })\n  }\n  \n  <span class=\"hljs-keyword\">if</span>(type === setTag) {\n    <span class=\"hljs-comment\">//处理Set</span>\n    target.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> {\n      cloneTarget.add(deepClone(item, map));\n    })\n  }\n\n  <span class=\"hljs-comment\">// 处理数组和对象</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> prop <span class=\"hljs-keyword\">in</span> target) {\n    <span class=\"hljs-keyword\">if</span> (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = deepClone(target[prop], map);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> cloneTarget;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-0147</code></pre><h1 class=\"heading\" data-id=\"heading-65\">❤️ 看完两件事</h1>\n<p>如果你觉得这篇内容对你挺有启发，我想邀请你帮我两个小忙：</p>\n<ol>\n<li>\n<p>点赞，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）</p>\n</li>\n<li>\n<p>关注公众号「前端三元同学」，每日坚持灵魂之问，遇见更好的自己！</p>\n</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e319b9e5b60298?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"900\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "6vh4xmggffs0",
      "author": "神三元",
      "title": "(建议精读)原生JS灵魂之问(中)，检验自己是否真的熟悉JavaScript？",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>原文链接：<a target=\"_blank\" href=\"https://dev.to/simonholdorf/9-projects-you-can-do-to-become-a-frontend-master-in-2020-n2h\" rel=\"nofollow noopener noreferrer\">dev.to/simonholdor…</a></p>\n<p>DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。</p>\n<p>本篇文章一共涉及了9个流行的框架/库，没有具体的介绍使用方法，而是给了一些非常棒的实战教程。</p>\n<p>初学者(也许一些有经验的开发者也是一样)在读完官方文档，想写一个项目练手的时候不知道做什么项目好，或是有想法，但是无从下手。那么这篇文章将会给你带来很大的帮助。</p>\n<blockquote>\n<p>本篇翻译已征得原作者同意：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3e822a7f3ea92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"580\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"580\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>更多文章可戳:</strong> <a target=\"_blank\" href=\"https://github.com/YvetteLau/Blog\" rel=\"nofollow noopener noreferrer\">github.com/YvetteLau/B…</a></p>\n<h3 class=\"heading\" data-id=\"heading-0\">导读</h3>\n<p>无论你是编程新手还是经验丰富的开发人员。在这个行业中，我们不得不一直学习新概念和新语言或是框架，才能跟上快速变化。以React为例 —— FaceBook 四年前开源，现在它已经成为了全球JS开发者的首选。但是与此同时，Vue 和 Angular 也有自己的追求者。然后是 Svelte，Next 和 Nuxt.js，Gatsby，Gridsome,quasar 等等，如果你想成为专业的 JavaScript 开发人员，你在使用自己熟悉的框架进行开发的同时，还需要对不同的框架和库有一些了解。</p>\n<p>为了帮助你在2020年成为一个前端大神，我收集了9个使用了不同JS框架/库的项目，你可以去构建或者将他们加入到自己未来的开发计划中。记住，没什么比实际开发一个项目更有帮助。所以，不要犹豫，试着去开发一下。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">1. 使用React(with hooks)构建一个电影搜索应用</h3>\n<p>首先，你可以使用React构建一个电影搜索应用。展示如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36e1e7cd8ab0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"473\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"473\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-2\">你将学到什么？</h4>\n<p>构建这个项目，你可以使用较新的 Hook API 来提升你的 React 技能。示例项目使用了React组件，很多 hooks 以及一些外部的 API，当然还有一些CSS样式。</p>\n<h4 class=\"heading\" data-id=\"heading-3\">技术栈/点</h4>\n<ol>\n<li>React(Hooks)</li>\n<li>create-react-app</li>\n<li>JSX</li>\n<li>CSS</li>\n</ol>\n<p>你可以在这里看到这个示例项目：<a target=\"_blank\" href=\"https://www.freecodecamp.org/news/how-to-build-a-movie-search-app-using-react-hooks-24eb72ddfaf7/\" rel=\"nofollow noopener noreferrer\">www.freecodecamp.org/news/how-to…</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">2.使用Vue构建一个聊天应用</h3>\n<p>另外一个要介绍给你的很棒的项目是使用Vue构建的聊天应用程序。展示如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36ef6e6862c45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"581\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"581\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-5\">你将学到什么？</h4>\n<p>您将学习到如何从头开始设置Vue应用，创建组件，处理状态，创建路由，连接到第三方服务，甚至是处理身份验证。</p>\n<h4 class=\"heading\" data-id=\"heading-6\">技术栈/点</h4>\n<ol>\n<li>Vue</li>\n<li>Vuex</li>\n<li>Vue Router</li>\n<li>Vue CLI</li>\n<li>Pusher</li>\n<li>CSS</li>\n</ol>\n<p>这真的是一个非常棒的项目，不管是用来学习Vue或者是提升现有的技能，以应对2020年的发展。你可以查看这个教程： <a target=\"_blank\" href=\"https://www.sitepoint.com/pusher-vue-real-time-chat-app/\" rel=\"nofollow noopener noreferrer\">www.sitepoint.com/pusher-vue-…</a></p>\n<h3 class=\"heading\" data-id=\"heading-7\">3. 使用Augular8构建一款漂亮的天气应用</h3>\n<p>此示例将帮助你使用 Google 的 Angular 8 来构建一块漂亮的天气应用程序：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36f7497c75a37?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"495\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"495\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-8\">你将学到什么？</h4>\n<p>该项目将教你一些宝贵的技能，例如从头开始创建应用，从设计到开发，一直到生产就绪部署。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">技术栈/点</h4>\n<ol>\n<li>Angular 8</li>\n<li>Firebase</li>\n<li>SSR</li>\n<li>网络布局和Flexbox</li>\n<li>移动端友好 && 响应式布局</li>\n<li>深色模式</li>\n<li>漂亮的用户界面</li>\n</ol>\n<p>对于这个综合项目，我真正喜欢的是，不是孤立地学习东西，而是从设计到最终部署的整个开发过程。</p>\n<p><a target=\"_blank\" href=\"https://medium.com/@hamedbaatour/build-a-real-world-beautiful-web-app-with-angular-6-a-to-z-ultimate-guide-2018-part-i-e121dd1d55e\" rel=\"nofollow noopener noreferrer\">medium.com/@hamedbaato…</a></p>\n<h3 class=\"heading\" data-id=\"heading-10\">4. 使用 Svelte 构建一个 To-Do 应用</h3>\n<p>与React，Vue和Angular相比，Svelte 还很新，但仍是热门之一。好的，To-Do应用不一定是那里最热门的项目，但这确实可以帮助你提高Svelte技能，如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36ff0d5669eca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"680\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"680\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">你将学到什么？</h4>\n<p>本教程将向你展示如何从头到尾使用Svelte3制作应用。 它利用了组件，样式和事件处理程序。</p>\n<h4 class=\"heading\" data-id=\"heading-12\">技术栈/点</h4>\n<ol>\n<li>Svelte 3</li>\n<li>Components</li>\n<li>CSS</li>\n<li>ES6语法</li>\n</ol>\n<p>Svelte 没有太多优秀的入门项目，这个是我觉得不错的一个上手项目：<a target=\"_blank\" href=\"https://medium.com/codingthesmartway-com-blog/building-a-svelte-3-todo-app-from-start-to-deployment-1737f72c23a6\" rel=\"nofollow noopener noreferrer\">medium.com/codingthesm…</a></p>\n<h3 class=\"heading\" data-id=\"heading-13\">5. 使用 Next.js 构建购物车</h3>\n<p>Next.js 是一个轻量级的 React 服务端渲染应用框架，该项目将向你展示如何构建一个如下所示的购物车：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e372177dcab8bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"727\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"727\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">你将学到什么？</h4>\n<p>在这个项目中，你将学习如何设置 Next.js 的开发环境，创建新页面和组件，获取数据，设置样式并部署一个 next 应用。</p>\n<h4 class=\"heading\" data-id=\"heading-15\">技术栈/点</h4>\n<ol>\n<li>Next.js</li>\n<li>组件和页面</li>\n<li>数据获取</li>\n<li>样式</li>\n<li>部署</li>\n<li>SSR和SPA</li>\n</ol>\n<p>你可以在此处找到该教程：<a target=\"_blank\" href=\"https://snipcart.com/blog/next-js-ecommerce-tutorial\" rel=\"nofollow noopener noreferrer\">snipcart.com/blog/next-j…</a></p>\n<h3 class=\"heading\" data-id=\"heading-16\">6. 使用 Nuxt.js 构建一个多语言博客网站</h3>\n<p>Nuxt.js 是 Vue 服务端渲染应用框架。你可以创建一个如下所示的应用程序：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e37208490b64ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"840\" data-height=\"458\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"840\" height=\"458\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-17\">你将学到什么？</h4>\n<p>这个示例项目从初始设置到最终部署一步一步教你如何使用 Nuxt.js 构建一个完整的网站。它使用了 Nuxt 提供的许多出色功能，如页面和组件以及SCSS样式。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">技术栈/点</h4>\n<ul>\n<li>Nuxt.js</li>\n<li>组件和页面</li>\n<li>Storyblok模块</li>\n<li>Mixins</li>\n<li>Vuex</li>\n<li>SCSS</li>\n<li>Nuxt中间件</li>\n</ul>\n<p>这个项目包含了涵盖了 Nuxt.js 的许多出色功能。我个人很喜欢使用 Nuxt 进行开发，你应该尝试使用它，这将使你成为更好的 Vue 开发人员！<a target=\"_blank\" href=\"https://www.storyblok.com/tp/nuxt-js-multilanguage-website-tutorial\" rel=\"nofollow noopener noreferrer\">www.storyblok.com/tp/nuxt-js-…</a></p>\n<p>除此之外，我还找到了一个B站的视频：<a target=\"_blank\" href=\"https://www.bilibili.com/video/av21130191/\" rel=\"nofollow noopener noreferrer\">www.bilibili.com/video/av211…</a></p>\n<h3 class=\"heading\" data-id=\"heading-19\">7. 使用 Gatsby 构建一个博客</h3>\n<p>Gatsby是一个出色的静态站点生成器，它允许使用React作为渲染引擎引擎来搭建一个静态站点，它真正具有现代web应用程序所期望的所有优点。该项目如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e372de5456f4c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"426\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"426\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-20\">你将学到什么？</h4>\n<p>在本教程中，你将学习如何利用 Gatsby 构建出色的博客。</p>\n<h4 class=\"heading\" data-id=\"heading-21\">技术栈/点</h4>\n<ol>\n<li>Gatsby</li>\n<li>React</li>\n<li>GraphQL</li>\n<li>Plugins & Themes</li>\n<li>MDX / Markdown</li>\n<li>Bootstrap CSS</li>\n<li>Templates</li>\n</ol>\n<p>如果你想创建博客，这个示例教你如何利用 React 和 GraphQL 来搭建。并不是说 Wordpress 是一个不好的选择，但是有了 Gatsby ，你可以在使用 React 的同时创建高性能站点！</p>\n<p><a target=\"_blank\" href=\"https://blog.bitsrc.io/how-to-build-a-blog-with-gatsby-and-boostrap-d1270212b3dc\" rel=\"nofollow noopener noreferrer\">blog.bitsrc.io/how-to-buil…</a></p>\n<h3 class=\"heading\" data-id=\"heading-22\">8. 使用 Gridsome 构建一个博客</h3>\n<p>Gridsome 和 Vue的关系与 Gatsby 和 React 的关系一样。Gridsome 和 Gatsby 都使用 GraphQL 作为数据层，但是 Gridsome 使用的是 VueJS。这也是一个很棒的静态站点生成器，它将帮助您创建出色的博客：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3735054979c7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"442\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"442\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-23\">你将学到什么？</h4>\n<p>该项目将教你如何使用 Gridsome，GraphQL 和 Markdown 构建一个简单的博客，它还介绍了如何通过Netlify 部署应用程序。</p>\n<h4 class=\"heading\" data-id=\"heading-24\">技术栈/点</h4>\n<ol>\n<li>Gridsome</li>\n<li>Vue</li>\n<li>GraphQL</li>\n<li>Markdown</li>\n<li>Netlify</li>\n</ol>\n<p>当然，这不是最全面的教程，但涵盖了 Gridsome 和 Markdown 的基本概念，可能是一个很好的起点。</p>\n<p><a target=\"_blank\" href=\"https://www.telerik.com/blogs/building-a-blog-with-vue-and-markdown-using-gridsome\" rel=\"nofollow noopener noreferrer\">www.telerik.com/blogs/build…</a></p>\n<h3 class=\"heading\" data-id=\"heading-25\">9.使用 Quasar 构建一个类似 SoundCloud 的音频播放器</h3>\n<p>Quasar 是另一个 Vue 框架，也可以用于构建移动应用程序。 在这个项目中，你将创建一个音频播放器应用程序，如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3738a9976f631?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"597\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"597\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-26\">你将学到什么？</h4>\n<p>不少项目主要关注Web应用程序，但这个项目展示了如何通过 Quasar 框架创建移动应用程序。你应该已经配置了可工作的 Cordova 设置，并配置了 android studio / xcode。 如果没有，在教程中有一个指向quasar 网站的链接，在那里你可以学习如何进行设置。</p>\n<h4 class=\"heading\" data-id=\"heading-27\">技术栈/点</h4>\n<ul>\n<li>Quasar</li>\n<li>Vue</li>\n<li>Cordova</li>\n<li>Wavesurfer</li>\n<li>UI Components</li>\n</ul>\n<p>一个展示了Quasar在构建移动应用程序方面的强大功能的小项目：<a target=\"_blank\" href=\"https://www.learningsomethingnew.com/how-to-build-a-sound-cloud-like-audio-player-app-with-vue-js-quasar-and-wave-surfer\" rel=\"nofollow noopener noreferrer\">www.learningsomethingnew.com/how-to-buil…</a></p>\n<h3 class=\"heading\" data-id=\"heading-28\">总结</h3>\n<p>本文展示了你可以构建的9个项目，每个项目专注于一个JavaScript框架或库。现在，你可以自行决定：使用以前未使用的框架来尝试一些新的东西或是通过做一个项目来提升已有的技能，或者在2020年完成所有项目？</p>\n<hr>\n<h3 class=\"heading\" data-id=\"heading-29\">关注公众号，加入技术交流群</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/8/16d1120a80282ab5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"900\" data-height=\"383\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"383\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "11fhu0v01i1c",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>2019年6月中旬，实在厌倦了之前平平淡淡的工作和毫不起眼的薪资，不顾亲人的反对，毅然决然地决定只身前往沿海城市，想着找到一份更加具有挑战性的工作，来彻彻底底地重新打磨自己，同时去追求更好的薪资待遇。当然在此之前，自己每天下班后都会利用业余时间抓紧复习巩固刷题等等，大概从3月份开始的吧，持续了3个多月。而后从6月中旬面试一直到6月底，中间大概两个星期，其实我的学历和背景并不突出，但是我个人感觉可能是因为自己简历做的稍微还行(<strong>后面我可能会单独出一篇文章，来聊聊我做简历时的一点点心得</strong>)，让大厂的HR能够多看几眼，中间面过的公司包括<strong>喜马拉雅、携程、哔哩哔哩、流利说、蜻蜓FM、爱回收</strong>等，陆陆续续拿到4，5个Offer吧，如今已经转正，所以在这里记录下之前的部分面试题，和大家一起分享交流。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">正文</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 烈熊网络</h3>\n<blockquote>\n<p>这家公司其实我也没有太了解过，是我前同事推荐的，说里面的薪资待遇不错，然后我当时也有空闲时间，所以就去试试了，虽然公司名气没有上面提到的公司大，但是他的面试题我觉得还是挺有分量的。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-3\">1.1 请说出下面代码的执行顺序</h4>\n<pre><code class=\"hljs javascript copyable code-00\" lang=\"javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> async2();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>);\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);\n}\n\n<span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>);\n});\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>);\n});\n\nasync1();\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">6</span>);\n<span class=\"copy-code-btn\">复制代码</span> copy-017</code></pre><p>我的回答是[1,2,6,4,3,5]。这道题目主要考对JS<strong>宏任务</strong>和<strong>微任务</strong>的理解程度，JS的事件循环中每个宏任务称为一个<strong>Tick</strong>(标记)，在每个标记的末尾会追加一个微任务队列，一个宏任务执行完后会执行所有的微任务，直到队列清空。上题中我觉得稍微复杂点的在于async1函数，async1函数本身会返回一个Promise，同时await后面紧跟着async2函数返回的Promise，<code>console.log(3)</code>其实是在async2函数返回的Promise的then语句中执行的，then语句本身也会返回一个Promise然后追加到微任务队列中，所以在微任务队列中<code>console.log(3)</code>在<code>console.log(4)</code>后面，不太清楚的同学可以网上查下资料或者关注我的公众号「前端之境」，我们可以一起交流学习。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">1.2 手动实现Promise，写出伪代码</h4>\n<p>幸运的是在面试前刚好查阅了下这部分的资料，所以回答过程中还算得心应手，主要是需要遵循Promise/A+规范：<br>\n(1) 一个promise必须具备三种状态(pending|fulfilled(resolved)|rejected)，当处于pending状态时，可以转移到fulfilled(resolved)状态或rejected状态，处于fulfilled(resolved)状态或rejected状态时，状态不再可变；<br>\n(2) 一个promise必须有then方法，then方法必须接受两个参数：</p>\n<pre><code class=\"hljs javascript copyable code-01\" lang=\"javascript\"><span class=\"hljs-comment\">// onFulfilled在状态由pending -> fulfilled(resolved) 时执行，参数为resolve()中传递的值</span>\n<span class=\"hljs-comment\">// onRejected在状态由pending -> rejected 时执行，参数为reject()中传递的值</span>\npromise.then(onFulfilled,onRejected)\n<span class=\"copy-code-btn\">复制代码</span> copy-018</code></pre><p>(3) then方法必须返回一个promise：</p>\n<pre><code class=\"hljs javascript copyable code-02\" lang=\"javascript\">promise2 = promise1.then(onFulfilled, onRejected);\n<span class=\"copy-code-btn\">复制代码</span> copy-019</code></pre><p>实现代码直接贴出来吧：</p>\n<blockquote>\n<p>参考自：<a target=\"_blank\" href=\"https://github.com/forthealllight/blog/issues/4\" rel=\"nofollow noopener noreferrer\">实现一个完美符合Promise/A+规范的Promise</a></p>\n</blockquote>\n<pre><code class=\"hljs javascript copyable code-03\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPromise</span>(<span class=\"hljs-params\">constructor</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> self=<span class=\"hljs-keyword\">this</span>;\n    self.status=<span class=\"hljs-string\">\"pending\"</span> <span class=\"hljs-comment\">//定义状态改变前的初始状态</span>\n    self.value=<span class=\"hljs-literal\">undefined</span>;<span class=\"hljs-comment\">//定义状态为resolved的时候的状态</span>\n    self.reason=<span class=\"hljs-literal\">undefined</span>;<span class=\"hljs-comment\">//定义状态为rejected的时候的状态</span>\n    self.onFullfilledArray=[];\n    self.onRejectedArray=[];\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>)</span>{\n       <span class=\"hljs-keyword\">if</span>(self.status===<span class=\"hljs-string\">\"pending\"</span>){\n          self.value=value;\n          self.status=<span class=\"hljs-string\">\"resolved\"</span>;\n          self.onFullfilledArray.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">f</span>)</span>{\n                f(self.value);\n                <span class=\"hljs-comment\">//如果状态从pending变为resolved，</span>\n                <span class=\"hljs-comment\">//那么就遍历执行里面的异步方法</span>\n          });\n        \n       }\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>)</span>{\n       <span class=\"hljs-keyword\">if</span>(self.status===<span class=\"hljs-string\">\"pending\"</span>){\n          self.reason=reason;\n          self.status=<span class=\"hljs-string\">\"rejected\"</span>;\n          self.onRejectedArray.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">f</span>)</span>{\n              f(self.reason);\n             <span class=\"hljs-comment\">//如果状态从pending变为rejected， </span>\n             <span class=\"hljs-comment\">//那么就遍历执行里面的异步方法</span>\n          })\n       }\n    }\n    <span class=\"hljs-comment\">//捕获构造异常</span>\n    <span class=\"hljs-keyword\">try</span>{\n       <span class=\"hljs-keyword\">constructor</span>(resolve,reject);\n    }catch(e){\n       reject(e);\n    }\n}\n\nmyPromise.prototype.then=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onFullfilled,onRejected</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> self=<span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">let</span> promise2;\n    <span class=\"hljs-keyword\">switch</span>(self.status){\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"pending\"</span>:\n        promise2 = <span class=\"hljs-keyword\">new</span> myPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{\n             self.onFullfilledArray.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                  <span class=\"hljs-keyword\">try</span>{\n\t                 <span class=\"hljs-keyword\">let</span> temple=onFullfilled(self.value);\n\t                 resolvePromise(temple)\n\t                }<span class=\"hljs-keyword\">catch</span>(e){\n\t                   reject(e) <span class=\"hljs-comment\">//error catch</span>\n\t                }\n                })\n             });\n             self.onRejectedArray.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                   <span class=\"hljs-keyword\">try</span>{\n\t                   <span class=\"hljs-keyword\">let</span> temple=onRejected(self.reason);\n\t                   resolvePromise(temple)\n\t                 }<span class=\"hljs-keyword\">catch</span>(e){\n\t                   reject(e)<span class=\"hljs-comment\">// error catch</span>\n\t               }\n                })\n             });\n        })\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"resolved\"</span>:\n        promise2=<span class=\"hljs-keyword\">new</span> myPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{\n           setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n               <span class=\"hljs-keyword\">try</span>{\n\t              <span class=\"hljs-keyword\">let</span> temple=onFullfilled(self.value);\n\t              <span class=\"hljs-comment\">//将上次一then里面的方法传递进下一个Promise状态</span>\n\t              resolvePromise(temple);\n\t            }<span class=\"hljs-keyword\">catch</span>(e){\n                  reject(e);<span class=\"hljs-comment\">//error catch</span>\n               }\n           })\n        })\n        <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"rejected\"</span>:\n        promise2=<span class=\"hljs-keyword\">new</span> myPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{\n           setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n             <span class=\"hljs-keyword\">try</span>{\n               <span class=\"hljs-keyword\">let</span> temple=onRejected(self.reason);\n               <span class=\"hljs-comment\">//将then里面的方法传递到下一个Promise的状态里</span>\n               resolvePromise(temple);   \n             }<span class=\"hljs-keyword\">catch</span>(e){\n               reject(e);\n             }\n           })\n        })\n        <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">default</span>:       \n   }\n   <span class=\"hljs-keyword\">return</span> promise2;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolvePromise</span>(<span class=\"hljs-params\">promise,x,resolve,reject</span>)</span>{\n  <span class=\"hljs-keyword\">if</span>(promise===x){\n     <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"type error\"</span>)\n  }\n  <span class=\"hljs-keyword\">let</span> isUsed;\n  <span class=\"hljs-keyword\">if</span>(x!==<span class=\"hljs-literal\">null</span>&&(<span class=\"hljs-keyword\">typeof</span> x===<span class=\"hljs-string\">\"object\"</span>||<span class=\"hljs-keyword\">typeof</span> x===<span class=\"hljs-string\">\"function\"</span>)){\n      <span class=\"hljs-keyword\">try</span>{\n        <span class=\"hljs-keyword\">let</span> then=x.then;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> then===<span class=\"hljs-string\">\"function\"</span>){\n           <span class=\"hljs-comment\">//是一个promise的情况</span>\n           then.call(x,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">y</span>)</span>{\n              <span class=\"hljs-keyword\">if</span>(isUsed)<span class=\"hljs-keyword\">return</span>;\n              isUsed=<span class=\"hljs-literal\">true</span>;\n              resolvePromise(promise,y,resolve,reject);\n           },<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>{\n              <span class=\"hljs-keyword\">if</span>(isUsed)<span class=\"hljs-keyword\">return</span>;\n              isUsed=<span class=\"hljs-literal\">true</span>;\n              reject(e);\n           })\n        }<span class=\"hljs-keyword\">else</span>{\n           <span class=\"hljs-comment\">//仅仅是一个函数或者是对象</span>\n           resolve(x)\n        }\n      }<span class=\"hljs-keyword\">catch</span>(e){\n         <span class=\"hljs-keyword\">if</span>(isUsed)<span class=\"hljs-keyword\">return</span>;\n         isUsed=<span class=\"hljs-literal\">true</span>;\n         reject(e);\n      }\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-comment\">//返回的基本类型，直接resolve</span>\n    resolve(x)\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-020</code></pre><h4 class=\"heading\" data-id=\"heading-5\">1.3 请说出以下打印结果</h4>\n<pre><code class=\"hljs javascript copyable code-04\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span> a = {<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">10</span>};\n<span class=\"hljs-keyword\">let</span> b = {<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">10</span>};\n<span class=\"hljs-keyword\">let</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">10</span>\n};\nobj[b] = <span class=\"hljs-number\">20</span>;\n<span class=\"hljs-built_in\">console</span>.log(obj[a]);\n<span class=\"copy-code-btn\">复制代码</span> copy-021</code></pre><p>我的回答是：20。这道题目主要考对JS数据类型的熟练度以及对ES6中<strong>属性名表达式</strong>的理解。在上题中<code>obj[b] = 20</code>的赋值操作后，<code>obj</code>其实已经变成了<code>{a: 10, [object Object]: 20}</code>，这是因为如果属性名表达式是一个对象的话，那么默认情况下会自动将对象转为字符串<code>[object Object]</code>，最后一步获取<code>obj[a]</code>时，a本身也是一个对象，所以会被转换为获取<code>obj['[object Object]']</code>也就是上一步赋值的20。</p>\n<h4 class=\"heading\" data-id=\"heading-6\">1.4 说出几种数组去重的方式</h4>\n<p>这个其实网上已经有大把大把的实现方案了，我也就大概给出了以下几种：</p>\n<pre><code class=\"hljs javascript copyable code-05\" lang=\"javascript\"><span class=\"hljs-keyword\">let</span> originalArray = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">1</span>];\n\n<span class=\"hljs-comment\">// 方式1</span>\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(originalArray));\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5]</span>\n\n<span class=\"hljs-comment\">// 方式2</span>\n<span class=\"hljs-keyword\">const</span> result = [];\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> originalArray) {\n    <span class=\"hljs-keyword\">if</span> (!map.has(v)) {\n        map.set(v, <span class=\"hljs-literal\">true</span>);\n        result.push(v);\n    }\n}\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5]</span>\n\n<span class=\"hljs-comment\">// 方式3</span>\n<span class=\"hljs-keyword\">const</span> result = [];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> originalArray) {\n    <span class=\"hljs-keyword\">if</span> (!result.includes(v)) {\n        result.push(v);\n    }\n}\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5]</span>\n\n<span class=\"hljs-comment\">// 方式4</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < originalArray.length; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = i + <span class=\"hljs-number\">1</span>; j < originalArray.length; j++) {\n        <span class=\"hljs-keyword\">if</span> (originalArray[i] === originalArray[j]) {\n            originalArray.splice(j, <span class=\"hljs-number\">1</span>);\n            j--;\n        }\n    }\n}\n<span class=\"hljs-built_in\">console</span>.log(originalArray); <span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5]</span>\n\n<span class=\"hljs-comment\">// 方式5</span>\n<span class=\"hljs-keyword\">const</span> obj = {};\n<span class=\"hljs-keyword\">const</span> result = originalArray.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> obj.hasOwnProperty(<span class=\"hljs-keyword\">typeof</span> item + item) ? <span class=\"hljs-literal\">false</span> : (obj[<span class=\"hljs-keyword\">typeof</span> item + item] = <span class=\"hljs-literal\">true</span>));\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// -> [1, 2, 3, 4, 5]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-022</code></pre><h4 class=\"heading\" data-id=\"heading-7\">1.5 对象数组如何去重？</h4>\n<p>这个题目不只一家公司问到了，开始的时候一脸懵逼，心里想着每个对象的内存地址本身就不一样，去重的意义何在，非要去重的话，那只能通过<code>JSON.stringify</code>序列化成字符串(这个方法有一定的缺陷)后进行对比，或者递归的方式进行键-值对比，但是对于大型嵌套对象来说还是比较耗时的，所以还是没有答好，后来面试官跟我说是根据每个对象的某一个具体属性来进行去重，因为考虑到服务端返回的数据中可能存在id重复的情况，需要前端进行过滤，如下：</p>\n<pre><code class=\"hljs javascript copyable code-06\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> responseList = [\n  { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> },\n  { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span> },\n  { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span> },\n  { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">4</span> },\n];\n<span class=\"hljs-keyword\">const</span> result = responseList.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> ids = acc.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> item.id);\n    <span class=\"hljs-keyword\">return</span> ids.includes(cur.id) ? acc : [...acc, cur];\n}, []);\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// -> [ { id: 1, a: 1}, {id: 2, a: 2}, {id: 3, a: 3} ]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-023</code></pre><h3 class=\"heading\" data-id=\"heading-8\">2. 携程</h3>\n<blockquote>\n<p>当时是前一天进行了一次电面，然后第二天现场面，两个面试官轮流问，大概持续了一个半小时吧，问的问题还是比较多的，有些问题时间久了还是不太记得了，多多见谅！</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-9\">2.1 理解深拷贝和浅拷贝吗？</h4>\n<p><strong>浅拷贝</strong>是指创建一个对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，那么拷贝的就是基本类型的值，如果属性是引用类型，那么拷贝的就是内存地址，所以如果其中一个对象修改了某些属性，那么另一个对象就会受到影响。<br>\n<strong>深拷贝</strong>是指从内存中完整地拷贝一个对象出来，并在堆内存中为其分配一个新的内存区域来存放，并且修改该对象的属性不会影响到原来的对象。</p>\n<h4 class=\"heading\" data-id=\"heading-10\">2.2 深拷贝和浅拷贝的实现方式分别有哪些？</h4>\n<p>浅拷贝：(1) Object.assign的方式 (2) 通过对象扩展运算符 (3) 通过数组的slice方法 (4) 通过数组的concat方法。<br>\n深拷贝：(1) 通过JSON.stringify来序列化对象 (2) 手动实现递归的方式。</p>\n<h4 class=\"heading\" data-id=\"heading-11\">2.3 大概说下实现无缝轮播的思路？</h4>\n<p>先简单说了下实现轮播的思路，多张图片从左至右依次排列，点击左右侧按钮切换图片的时候，让图片的父级容器的left偏移值增加或减少单张图片的宽度大小，同时配合CSS3 transition过渡或者手写一个动画函数，这样可以实现一个比较平滑的动画效果。对于无缝轮播，我当时的思路是再拷贝一个图片的父级容器出来，例如原来一个<code><ul><li></li><li></li></ul></code>对应两张图片，现在变为两个<code>ul</code>对应4张图片，同时<code>ul</code>的父容器监听自身的<code>scrollLeft</code>，如果值已经大于等于一个<code>ul</code>的宽度，则立即将自身的<code>scrollLeft</code>值重置为0，这样就又可以从起点开始轮播，实现无缝的效果。</p>\n<h4 class=\"heading\" data-id=\"heading-12\">2.3 说出以下代码的执行结果</h4>\n<pre><code class=\"hljs javascript copyable code-07\" lang=\"javascript\">  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">var</span> obj = {\n      <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n          <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.a);\n      }\n  };\n  obj.say();\n<span class=\"copy-code-btn\">复制代码</span> copy-024</code></pre><p>这个是被我简化后的版本，具体题目记不太清了，反正就是考的this的指向问题，上题中答案为20。然后面试官继续追问，如何才能打印出10，给出如下方式：</p>\n<pre><code class=\"hljs javascript copyable code-08\" lang=\"javascript\">  <span class=\"hljs-comment\">// 方式1</span>\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">var</span> obj = {\n      <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {  <span class=\"hljs-comment\">// 此处改为箭头函数</span>\n          <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.a);\n      }\n  };\n  obj.say(); <span class=\"hljs-comment\">// -> 10</span>\n  \n  <span class=\"hljs-comment\">// 方式2</span>\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">var</span> obj = {\n      <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n          <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.a);\n      }\n  };\n  obj.say.call(<span class=\"hljs-keyword\">this</span>); <span class=\"hljs-comment\">// 此处显示绑定this为全局window对象</span>\n  \n  <span class=\"hljs-comment\">// 方式3</span>\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">var</span> obj = {\n      <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n          <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.a);\n      }\n  };\n  \n  <span class=\"hljs-keyword\">var</span> say = obj.say; <span class=\"hljs-comment\">// 此处先创建一个临时变量存放函数定义，然后单独调用</span>\n  say();\n<span class=\"copy-code-btn\">复制代码</span> copy-025</code></pre><h4 class=\"heading\" data-id=\"heading-13\">2.4 Vue的生命周期有哪些？</h4>\n<p>创建：beforeCreate，created；<br>\n载入：beforeMount，mounted；<br>\n更新：beforeUpdate，updated；<br>\n销毁：beforeDestroy，destroyed；</p>\n<h4 class=\"heading\" data-id=\"heading-14\">2.5 移动端如何设计一个比较友好的Header组件？</h4>\n<p>当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格。</p>\n<h4 class=\"heading\" data-id=\"heading-15\">2.6 说出space-between和space-around的区别？</h4>\n<p>这个是flex布局的内容，其实就是一个边距的区别，按水平布局来说，<code>space-between</code>在左右两侧没有边距，而<code>space-around</code>在左右两侧会留下边距，垂直布局同理，如下图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e135b984bca7ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"468\" data-height=\"87\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"468\" height=\"87\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/29/16e135bbc55f7326?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"446\" data-height=\"89\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"446\" height=\"89\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-16\">2.7 你所知道的前端性能优化方案</h4>\n<p>这个其实方案还是比较多的，可以从<strong>DOM层面</strong>，<strong>CSS样式层面</strong>和<strong>JS逻辑层面</strong>分别入手，大概给出以下几种：<br>\n(1) 减少DOM的访问次数，可以将DOM缓存到变量中；<br>\n(2) 减少<strong>重绘</strong>和<strong>回流</strong>，任何会导致<strong>重绘</strong>和<strong>回流</strong>的操作都应减少执行，可将<strong>多次操作合并为一次</strong>；<br>\n(3) 尽量采用<strong>事件委托</strong>的方式进行事件绑定，避免大量绑定导致内存占用过多；<br>\n(4) css层级尽量<strong>扁平化</strong>，避免过多的层级嵌套，尽量使用<strong>特定的选择器</strong>来区分；<br>\n(5) 动画尽量使用CSS3<strong>动画属性</strong>来实现，开启GPU硬件加速；<br>\n(6) 图片在加载前提前<strong>指定宽高</strong>或者<strong>脱离文档流</strong>，可避免加载后的重新计算导致的页面回流；<br>\n(7) css文件在<code><head></code>标签中引入，js文件在<code><body></code>标签中引入，优化<strong>关键渲染路径</strong>；<br>\n(8) 加速或者减少HTTP请求，使用<strong>CDN加载静态资源</strong>，合理使用浏览器<strong>强缓存</strong>和<strong>协商缓存</strong>，小图片可以使用<strong>Base64</strong>来代替，合理使用浏览器的<strong>预取指令prefetch</strong>和<strong>预加载指令preload</strong>；<br>\n(9) <strong>压缩混淆代码</strong>，<strong>删除无用代码</strong>，<strong>代码拆分</strong>来减少文件体积；<br>\n(10) <strong>小图片使用雪碧图</strong>，图片选择合适的<strong>质量</strong>、<strong>尺寸</strong>和<strong>格式</strong>，避免流量浪费。</p>\n<h4 class=\"heading\" data-id=\"heading-17\">2.8 git多人协作时如何解决冲突</h4>\n<p>冲突主要是出现在多人在修改同一个文件的同一部分内容时，对方当你之前<code>push</code>，然后你后<code>push</code>的时候git检测到两次提交内容不匹配，提示你<code>Conflict</code>，然后你<code>pull</code>下来的代码会在冲突的地方使用<code>=====</code>隔开，此时你需要找到对应的开发人员商量代码的取舍，切<strong>不可随意修改并强制提交</strong>，解决冲突后再次<code>push</code>即可。</p>\n<h3 class=\"heading\" data-id=\"heading-18\">3. 喜马拉雅</h3>\n<blockquote>\n<p>当时是两轮技术面，一次电面，一次现场面，电面有部分题目还是答得很模糊，现场面自我感觉还可以吧。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-19\">3.1 手动实现一个bind方法</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs javascript copyable code-09\" lang=\"javascript\"><span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context, ...args1</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'not a function'</span>);\n    }\n    \n    <span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">let</span> resFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...args2</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> fn.apply(<span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> resFn ? <span class=\"hljs-keyword\">this</span> : context, args1.concat(args2));\n    };\n    <span class=\"hljs-keyword\">const</span> DumpFunction = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">DumpFunction</span>(<span class=\"hljs-params\"></span>) </span>{};\n    DumpFunction.prototype = <span class=\"hljs-keyword\">this</span>.prototype;\n    resFn.prototype = <span class=\"hljs-keyword\">new</span> DumpFunction();\n    \n    <span class=\"hljs-keyword\">return</span> resFn;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-026</code></pre><h4 class=\"heading\" data-id=\"heading-20\">3.2 说说对React Hooks的理解</h4>\n<p>在React中我们一般有两种方式来创建组件，<strong>类定义</strong>或者<strong>函数定义</strong>；在类定义中我们可以使用许多React的特性，比如state或者各种生命周期钩子，但是在函数定义中却无法使用。所以在React 16.8版本中新推出了React Hooks的功能，通过React Hooks我们就可以在函数定义中来使用类定义当中才能使用的特性。当然React Hooks的出现本身也是为了组件复用，以及相比于类定义当中的生命周期钩子，React Hooks中提供的<code>useEffect</code>将多个生命周期钩子进行结合，使得原先在类定义中分散的逻辑变得更加集中，方便维护和管理。</p>\n<h4 class=\"heading\" data-id=\"heading-21\">3.3 React Hooks当中的useEffect是如何区分生命周期钩子的</h4>\n<p><code>useEffect</code>可以看成是<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>三者的结合。<code>useEffect(callback, [source])</code>接收两个参数，调用方式如下：</p>\n<pre><code class=\"hljs javascript copyable code-010\" lang=\"javascript\"> useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'mounted'</span>);\n   \n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n       <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'willUnmount'</span>);\n   }\n }, [source]);\n<span class=\"copy-code-btn\">复制代码</span> copy-027</code></pre><p>生命周期函数的调用主要是通过第二个参数<code>[source]</code>来进行控制，有如下几种情况：<br>\n(1) <code>[source]</code>参数不传时，则每次都会优先调用上次保存的函数中返回的那个函数，然后再调用外部那个函数；<br>\n(2) <code>[source]</code>参数传<code>[]</code>时，则外部的函数只会在初始化时调用一次，返回的那个函数也只会最终在组件卸载时调用一次；<br>\n(3) <code>[source]</code>参数有值时，则只会监听到数组中的值发生变化后才优先调用返回的那个函数，再调用外部的函数。</p>\n<h4 class=\"heading\" data-id=\"heading-22\">3.4 什么是高阶组件(HOC)</h4>\n<p>高阶组件(Higher Order Componennt)本身其实不是组件，而是一个函数，这个函数接收一个<strong>元组件</strong>作为参数，然后返回一个新的<strong>增强组件</strong>，高阶组件的出现本身也是为了逻辑复用，举个例子：</p>\n<pre><code class=\"hljs javascript copyable code-011\" lang=\"javascript\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withLoginAuth</span>(<span class=\"hljs-params\">WrappedComponent</span>) </span>{\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n          \n          <span class=\"hljs-keyword\">constructor</span>(props) {\n              <span class=\"hljs-keyword\">super</span>(props);\n              <span class=\"hljs-keyword\">this</span>.state = {\n                <span class=\"hljs-attr\">isLogin</span>: <span class=\"hljs-literal\">false</span>\n              };\n          }\n          \n          <span class=\"hljs-keyword\">async</span> componentDidMount() {\n              <span class=\"hljs-keyword\">const</span> isLogin = <span class=\"hljs-keyword\">await</span> getLoginStatus();\n              <span class=\"hljs-keyword\">this</span>.setState({ isLogin });\n          }\n          \n          render() {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.state.isLogin) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...this.props</span>} /></span>;\n            }\n            \n            return (<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span>></span>您还未登录...<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>);\n          }\n      }\n  }\n</span><span class=\"copy-code-btn\">复制代码</span> copy-028</code></pre><h4 class=\"heading\" data-id=\"heading-23\">3.5 说出以下代码的执行结果</h4>\n<pre><code class=\"hljs javascript copyable code-012\" lang=\"javascript\"><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">'2017-07-01'</span>) <span class=\"hljs-comment\">// -> 2017</span>\n<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">'2017abcdef'</span>) <span class=\"hljs-comment\">// -> 2017</span>\n<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">'abcdef2017'</span>) <span class=\"hljs-comment\">// -> NaN</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-029</code></pre><h4 class=\"heading\" data-id=\"heading-24\">3.6 React实现的移动应用中，如果出现卡顿，有哪些可以考虑的优化方案</h4>\n<p>(1) 增加<code>shouldComponentUpdate</code>钩子对新旧<code>props</code>进行比较，如果值相同则阻止更新，避免不必要的渲染，或者使用<code>PureReactComponent</code>替代<code>Component</code>，其内部已经封装了<code>shouldComponentUpdate</code>的浅比较逻辑；<br>\n(2) 对于列表或其他结构相同的节点，为其中的每一项增加唯一<code>key</code>属性，以方便React的<code>diff</code>算法中对该节点的复用，减少节点的创建和删除操作；<br>\n(3) <code>render</code>函数中减少类似<code>onClick={() => {doSomething()}}</code>的写法，每次调用<code>render</code>函数时均会创建一个新的函数，即使内容没有发生任何变化，也会导致节点没必要的重渲染，建议将函数保存在组件的成员对象中，这样只会创建一次；<br>\n(4) 组件的<code>props</code>如果需要经过一系列运算后才能拿到最终结果，则可以考虑使用<code>reselect</code>库对结果进行缓存，如果<code>props</code>值未发生变化，则结果直接从缓存中拿，避免高昂的运算代价；<br>\n(5) <code>webpack-bundle-analyzer</code>分析当前页面的依赖包，是否存在不合理性，如果存在，找到优化点并进行优化。</p>\n<h4 class=\"heading\" data-id=\"heading-25\">3.7 (算法题) 如何从10000个数中找到最大的10个数</h4>\n<blockquote>\n<p>这题没答好，两个字形容：稀烂！一碰到算法题就容易紧张蒙圈，来个正解吧。</p>\n</blockquote>\n<p>创建一个最小堆结构，初始值为10000个数的前10个，堆顶为10个数里的最小数。然后遍历剩下的9990个数，如果数字小于堆顶的数，则直接丢弃，否则把堆顶的数删除，将遍历的数插入堆中，堆结构进行自动调整，所以可以保证堆顶的数一定是10个数里最小的。遍历完毕后，堆里的10个数就是这10000个数里面最大的10个。</p>\n<h3 class=\"heading\" data-id=\"heading-26\">4. 流利说</h3>\n<blockquote>\n<p>当时是提前有一次电面，然后过了几天才去现场面，现场两轮技术面，公司很注重底层原理，所以答得不是很好。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-27\">4.1 React实现一个防抖的模糊查询输入框</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs javascript copyable code-013\" lang=\"javascript\">  <span class=\"hljs-comment\">// 防抖函数</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">fn, wait, immediate</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;\n    \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> context = <span class=\"hljs-keyword\">this</span>;\n        \n        <span class=\"hljs-keyword\">if</span> (immediate && !timer) {\n            fn.apply(context, args);\n        }\n        \n        <span class=\"hljs-keyword\">if</span> (timer) clearTimeout(timer);\n        timer = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n            fn.apply(context, args);\n        }, wait);\n    }\n  }\n  \n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SearchInput</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  \n      <span class=\"hljs-keyword\">constructor</span>(props) {\n          <span class=\"hljs-keyword\">super</span>(props);\n          <span class=\"hljs-keyword\">this</span>.state = {\n              <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">''</span>\n          };\n          <span class=\"hljs-keyword\">this</span>.handleChange = <span class=\"hljs-keyword\">this</span>.handleChange.bind(<span class=\"hljs-keyword\">this</span>);\n          <span class=\"hljs-keyword\">this</span>.callAjax = debounce(<span class=\"hljs-keyword\">this</span>.callAjax, <span class=\"hljs-number\">500</span>, <span class=\"hljs-literal\">true</span>);\n      }\n      \n      handleChange(e) {\n          <span class=\"hljs-keyword\">this</span>.setState({\n              <span class=\"hljs-attr\">value</span>: e.target.value\n          });\n          <span class=\"hljs-keyword\">this</span>.callAjax();\n      }\n      \n      callAjax() {\n          <span class=\"hljs-comment\">// 此处根据输入值调用服务端接口</span>\n          <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.state.value);\n      }\n      \n      render() {\n          <span class=\"hljs-keyword\">return</span> (<span class=\"xml\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{this.state.value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{this.handleChange}</span> /></span>);\n      }\n      \n  }\n</span><span class=\"copy-code-btn\">复制代码</span> copy-030</code></pre><h4 class=\"heading\" data-id=\"heading-28\">4.2 手动封装一个请求函数，可以设置最大请求次数，请求成功则不再请求，请求失败则继续请求直到超过最大次数</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs javascript copyable code-014\" lang=\"javascript\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">request</span>(<span class=\"hljs-params\">url, body, successCallback, errorCallback, maxCount = <span class=\"hljs-number\">3</span></span>) </span>{\n      <span class=\"hljs-keyword\">return</span> fetch(url, body)\n               .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> successCallback(response))\n               .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n                   <span class=\"hljs-keyword\">if</span> (maxCount <= <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> errorCallback(<span class=\"hljs-string\">'请求超时'</span>);\n                   <span class=\"hljs-keyword\">return</span> request(url, body, successCallback, errorCallback, --maxCount);\n               });\n  }\n  \n  <span class=\"hljs-comment\">// 调用</span>\n  request(<span class=\"hljs-string\">'https://some/path'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'GET'</span>, <span class=\"hljs-attr\">headers</span>: {} }, (response) => {\n      <span class=\"hljs-built_in\">console</span>.log(response.json());\n  }, (err) => <span class=\"hljs-built_in\">console</span>.error(err));\n<span class=\"copy-code-btn\">复制代码</span> copy-031</code></pre><h4 class=\"heading\" data-id=\"heading-29\">4.3 JS中==和===的区别</h4>\n<p><code>==</code>表示<strong>抽象相等</strong>，两边值类型不同的时候，会先做<strong>隐式类型转换</strong>，再对值进行比较；<br>\n<code>===</code>表示<strong>严格相等</strong>，不会做类型转换，两边的类型不同一定不相等。</p>\n<h4 class=\"heading\" data-id=\"heading-30\">4.4 GET和POST的区别</h4>\n<p>(1) GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交；<br>\n(2) GET请求可以收藏为书签，POST请求不可以收藏为书签；<br>\n(3) GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响；<br>\n(4) GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。<br>\n(5) GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留；<br>\n(6) GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制；<br>\n(7) GET请求只允许ASCII字符，POST请求无限制，支持二进制数据；<br>\n(8) GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中；<br>\n(9) GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等；<br>\n(10) GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方\"握手\"，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。</p>\n<h4 class=\"heading\" data-id=\"heading-31\">4.5 说下浏览器的缓存机制</h4>\n<p>浏览器的缓存机制可分为<strong>强缓存</strong>和<strong>协商缓存</strong>，服务端可以在响应头中增加<strong>Cache-Control/Expires</strong>来为当前资源设置缓存有效期(<strong>Cache-Control的max-age的优先级高于Expires</strong>)，浏览器再次发送请求时，会先判断缓存是否过期，如果未过期则命中强缓存，直接使用浏览器的本地缓存资源，如果已过期则使用协商缓存，协商缓存大致有以下两种方案：<br>\n(1) 唯一标识：<strong>Etag(服务端响应携带) & If-None-Match(客户端请求携带)</strong>；<br>\n(2) 最后修改时间： <strong>Last-Modified(服务端响应携带) & If-Modified-Since (客户端请求携带) ，其优先级低于Etag</strong>。<br>\n服务端判断值是否一致，如果一致，则直接返回<strong>304</strong>通知浏览器使用本地缓存，如果不一致则返回新的资源。</p>\n<h3 class=\"heading\" data-id=\"heading-32\">5. 哔哩哔哩</h3>\n<blockquote>\n<p>现场两轮技术面，问了很多考验基础知识的题目，整体来说回答的还算比较满意吧。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-33\">5.1 CSS3中transition和animation的属性分别有哪些</h4>\n<p><code>transition</code> 过渡动画：<br>\n(1) <code>transition-property</code>：属性名称<br>\n(2) <code>transition-duration</code>: 间隔时间<br>\n(3) <code>transition-timing-function</code>: 动画曲线<br>\n(4) <code>transition-delay</code>: 延迟</p>\n<p><code>animation</code> 关键帧动画：<br>\n(1) <code>animation-name</code>：动画名称<br>\n(2) <code>animation-duration</code>: 间隔时间<br>\n(3) <code>animation-timing-function</code>: 动画曲线<br>\n(4) <code>animation-delay</code>: 延迟<br>\n(5) <code>animation-iteration-count</code>：动画次数<br>\n(6) <code>animation-direction</code>: 方向<br>\n(7) <code>animation-fill-mode</code>: 禁止模式</p>\n<h4 class=\"heading\" data-id=\"heading-34\">5.2 盒模型</h4>\n<p>指的是页面在渲染时，DOM元素所采用的布局模型，一个元素占用的空间大小由几个部分组成，内容(content)、内边距(padding)，边框(border)和外边距(margin)。可以通过<code>box-sizing</code>来进行设置，其中IE盒模型的content包含了padding和border，这是区别于W3C标准盒模型的地方。</p>\n<h4 class=\"heading\" data-id=\"heading-35\">5.3 选择器优先级</h4>\n<p>!important > 行内样式 > id选择器 > class选择器 > 标签选择器 > * > 继承 > 默认</p>\n<h4 class=\"heading\" data-id=\"heading-36\">5.4 forEach，map和filter的区别</h4>\n<p><code>forEach</code>遍历数组，参数为一个回调函数，回调函数接收三个参数，当前元素，元素索引，整个数组；<br>\n<code>map</code>与<code>forEach</code>类似，遍历数组，但其回调函数的返回值会组成一个新数组，新数组的索引结构和原数组一致，原数组不变；<br>\n<code>filter</code>会返回原数组的一个子集，回调函数用于逻辑判断，返回<code>true</code>则将当前元素添加到返回数组中，否则排除当前元素，原数组不变。</p>\n<h4 class=\"heading\" data-id=\"heading-37\">5.5 实现函数柯里化</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs javascript copyable code-015\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> curry = <span class=\"hljs-function\">(<span class=\"hljs-params\">fn, ...args1</span>) =></span> (...args2) => (\n <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> arg.length === fn.length ? fn(...arg) : curry(fn, ...arg)\n)([...args1, ...args2]);\n\n<span class=\"hljs-comment\">// 调用</span>\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c</span>) =></span> a * b * c;\ncurry(foo)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// -> 24</span>\ncurry(foo, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// -> 24</span>\ncurry(foo, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// -> 24</span>\ncurry(foo, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)(); <span class=\"hljs-comment\">// -> 24</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-032</code></pre><h4 class=\"heading\" data-id=\"heading-38\">5.6 跨标签页的通讯方式有哪些</h4>\n<p>(1) BroadCast Channel<br>\n(2) Service Worker<br>\n(3) LocalStorage + window.onstorage监听<br>\n(4) Shared Worker + 定时器轮询(setInterval)<br>\n(5) IndexedDB + 定时器轮询(setInterval)<br>\n(6) cookie + 定时器轮询(setInterval)<br>\n(7) window.open + window.postMessage<br>\n(8) Websocket</p>\n<h4 class=\"heading\" data-id=\"heading-39\">5.7 实现一个函数判断数据类型</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs javascript copyable code-016\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getType</span>(<span class=\"hljs-params\">obj</span>) </span>{\n   <span class=\"hljs-keyword\">if</span> (obj === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">String</span>(obj);\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> obj === <span class=\"hljs-string\">'object'</span> \n   ? <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj).replace(<span class=\"hljs-string\">'[object '</span>, <span class=\"hljs-string\">''</span>).replace(<span class=\"hljs-string\">']'</span>, <span class=\"hljs-string\">''</span>).toLowerCase()\n   : <span class=\"hljs-keyword\">typeof</span> obj;\n}\n\n<span class=\"hljs-comment\">// 调用</span>\ngetType(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// -> null</span>\ngetType(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// -> undefined</span>\ngetType({}); <span class=\"hljs-comment\">// -> object</span>\ngetType([]); <span class=\"hljs-comment\">// -> array</span>\ngetType(<span class=\"hljs-number\">123</span>); <span class=\"hljs-comment\">// -> number</span>\ngetType(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// -> boolean</span>\ngetType(<span class=\"hljs-string\">'123'</span>); <span class=\"hljs-comment\">// -> string</span>\ngetType(<span class=\"hljs-regexp\">/123/</span>); <span class=\"hljs-comment\">// -> regexp</span>\ngetType(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()); <span class=\"hljs-comment\">// -> date</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-033</code></pre><h2 class=\"heading\" data-id=\"heading-40\">总结</h2>\n<p>有些面试题实在是想不起来了，上面的题目其实大部分还是比较基础的，问到的频率也比较高，这里只是做一个简单的分享，希望对大家多多少少有点帮助，也希望能和大家一起交流学习，如果有疑惑欢迎留言讨论。</p>\n<h2 class=\"heading\" data-id=\"heading-41\">交流</h2>\n<p>今天先分享到这里，笔者刚新开公众号，如果大家有兴趣和笔者一起学习，相互讨论技术，可以关注咱们的公众号，一起见证公众号的成长。</p>\n<p><strong>文章已同步更新至<a target=\"_blank\" href=\"https://github.com/qq591468061/xwfe\" rel=\"nofollow noopener noreferrer\">Github博客</a>，若觉文章尚可，欢迎前往star！</strong></p>\n<p><strong>你的一个点赞，值得让我付出更多的努力！</strong></p>\n<p><strong>逆境中成长，只有不断地学习，才能成为更好的自己，与君共勉！</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/2/16e2b919cdf81336?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"900\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4m57m0bc3zc0",
      "author": "小维FE",
      "title": "记一次大厂的面试过程",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https://www.zoo.team/article/text-overflow\" rel=\"nofollow noopener noreferrer\">可能是最全的 “文本溢出截断省略” 方案合集</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3e907ab0e218d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"200\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">前言</h2>\n<p>在我们的日常开发工作中，文本溢出截断省略是很常见的一种需考虑的业务场景细节。看上去 “稀松平常” ，但在实现上却有不同的区分，是单行截断还是多行截断？多行的截断判断是基于行数还是基于高度？这些问题之下，都有哪些实现方案？他们之间的差异性和场景适应性又是如何？凡事就怕较真，较真必有成长。本文试图通过编码实践，给出一些答案。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">先来点基础的，单行文本溢出省略</h2>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>overflow: hidden；（文字长度超出限定宽度，则隐藏超出的内容）</li>\n<li>white-space: nowrap；（设置文字在一行显示，不能换行）</li>\n<li>text-overflow: ellipsis；（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n<li>省略号位置显示刚好</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>只支持单行文本截断</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于单行文本溢出显示省略号的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-00\" lang=\"javascript\"><style>\n    .demo {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n</style>\n<body>\n\t<div class=\"demo\">这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span> copy-06</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c405615623?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">进阶一下，多行文本溢出省略（按行数）</h2>\n<h3 class=\"heading\" data-id=\"heading-4\">○ 纯 CSS 实现方案</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>-webkit-line-clamp: 2；（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。 为了实现该效果，它需要组合其他的WebKit属性）</li>\n<li>display: -webkit-box；（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li>\n<li>-webkit-box-orient: vertical；（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li>\n<li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li>\n<li>text-overflow: ellipsis；（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n<li>省略号显示位置刚好</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>兼容性一般： -webkit-line-clamp 属性只有  WebKit  内核的浏览器才支持</li>\n</ul>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c406bdaa3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1212\" data-height=\"438\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1212\" height=\"438\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>多适用于移动端页面，因为移动设备浏览器更多是基于 WebKit 内核</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-01\" lang=\"javascript\"><style>\n\t.demo {\n\t\t  display: -webkit-box;\n\t    overflow: hidden;\n\t    -webkit-line-clamp: 2;\n\t    -webkit-box-orient: vertical;\n\t}\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span> copy-07</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c40876a945?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-5\">○ 基于 JavaScript 的实现方案</h3>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>需要 JS 实现，背离展示和行为相分离原则</li>\n<li>文本为中英文混合时，省略号显示位置略有偏差</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于响应式截断，多行文本溢出省略的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<p>当前仅适用于文本为中文，若文本中有英文，可自行修改</p>\n<pre><code class=\"hljs javascript copyable code-02\" lang=\"javascript\"><script type=\"text/javascript\">\n    const text = '这是一段很长的文本';\n    const totalTextLen = text.length;\n    const formatStr = () => {\n        const ele = document.getElementsByClassName('demo')[0];\n        const lineNum = 2;\n        const baseWidth = window.getComputedStyle(ele).width;\n        const baseFontSize = window.getComputedStyle(ele).fontSize;\n        const lineWidth = +baseWidth.slice(0, -2);\n\n        // 所计算的strNum为元素内部一行可容纳的字数(不区分中英文)\n        const strNum = Math.floor(lineWidth / +baseFontSize.slice(0, -2));\n\n        let content = '';\n        \n      \t// 多行可容纳总字数\n        const totalStrNum = Math.floor(strNum * lineNum);\n\n        const lastIndex = totalStrNum - totalTextLen;\n\n        if (totalTextLen > totalStrNum) {\n            content = text.slice(0, lastIndex - 3).concat('...');\n        } else {\n            content = text;\n        }\n        ele.innerHTML = content;\n    }\n    \n    formatStr();\n    \n\t\twindow.onresize = () => {\n        formatStr();\n    };\n</script>\n\n<body>\n\t<div class='demo'></div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span> copy-08</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4099041ae?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">再进阶一步，多行文本溢出省略（按高度）</h2>\n<h3 class=\"heading\" data-id=\"heading-7\">○ 多行文本溢出不显示省略号</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li>\n<li>line-height: 20px；（结合元素高度，高度固定的情况下，设定行高， 控制显示行数）</li>\n<li>max-height: 40px；（设定当前元素最大高度）</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>单纯截断文字, 不展示省略号，观感上较为生硬</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于文本溢出不需要显示省略号的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-03\" lang=\"javascript\"><style>\n\t.demo {\n\t\toverflow: hidden;\n\t\tmax-height: 40px;\n\t\tline-height: 20px;\n\t}\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n\n<span class=\"copy-code-btn\">复制代码</span> copy-09</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4096f17c9?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-8\">○ 伪元素 + 定位实现多行省略</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>\n<p>position: relative; （为伪元素绝对定位）</p>\n</li>\n<li>\n<p>overflow: hidden; （文本溢出限定的宽度就隐藏内容）</p>\n</li>\n<li>\n<p>position: absolute;（给省略号绝对定位）</p>\n</li>\n<li>\n<p>line-height: 20px; （结合元素高度,高度固定的情况下,设定行高, 控制显示行数）</p>\n</li>\n<li>\n<p>height: 40px; （设定当前元素高度）</p>\n</li>\n<li>\n<p>::after {}  （设置省略号样式）</p>\n</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>\n<p>无兼容问题</p>\n</li>\n<li>\n<p>响应式截断</p>\n</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>\n<p>无法识别文字的长短，无论文本是否溢出范围, 一直显示省略号</p>\n</li>\n<li>\n<p>省略号显示可能不会刚刚好，有时会遮住一半文字</p>\n</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于对省略效果要求较低，文本一定会溢出元素的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-04\" lang=\"javascript\"><style>\n    .demo {\n        position: relative;\n        line-height: 20px;\n        height: 40px;\n        overflow: hidden;\n    }\n    .demo::after {\n        content: \"...\";\n        position: absolute;\n        bottom: 0;\n        right: 0;\n        padding: 0 20px 0 10px;\n    }\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span> copy-010</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c40d1eefac?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-9\">○ 利用 Float 特性，纯 CSS 实现多行省略</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>\n<p>line-height: 20px；（结合元素高度,高度固定的情况下,设定行高, 控制显示行数）</p>\n</li>\n<li>\n<p>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</p>\n</li>\n<li>\n<p>float: right/left；（利用元素浮动的特性实现）</p>\n</li>\n<li>\n<p>position: relative；（根据自身位置移动省略号位置, 实现文本溢出显示省略号效果）</p>\n</li>\n<li>\n<p>word-break: break-all；（使一个单词能够在换行时进行拆分）</p>\n</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>\n<p>无兼容问题</p>\n</li>\n<li>\n<p>响应式截断</p>\n</li>\n<li>\n<p>文本溢出范围才显示省略号，否则不显示省略号</p>\n</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>省略号显示可能不会刚刚好，有时会遮住一半文字</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于对省略效果要求较低，多行文本响应式截断的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-05\" lang=\"javascript\"><style>\n    .demo {\n        background: #099;\n        max-height: 40px;\n        line-height: 20px;\n        overflow: hidden;\n    }\n    .demo::before{\n        float: left;\n        content:'';\n        width: 20px;\n        height: 40px;\n    }\n\n    .demo .text {\n        float: right;\n        width: 100%;\n        margin-left: -20px;\n        word-break: break-all;\n    }\n    .demo::after{\n        float:right;\n        content:'...';\n        width: 20px;\n        height: 20px;\n        position: relative;\n        left:100%;\n        transform: translate(-100%,-100%);\n    }\n</style>\n\n<body>\n    <div class='demo'>\n    \t<div class=\"text\">这是一段很长的文本</div>\n    </div>\n</body>\n<span class=\"copy-code-btn\">复制代码</span> copy-011</code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4375581cb?imageslim\" data-width=\"730\" data-height=\"494\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"730\" height=\"494\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>原理讲解</strong></p>\n<p>有 A、B、C 三个盒子，A 左浮动，B、C 右浮动。设置 A 盒子的高度与 B 盒子高度（或最大高度）要保持一致</p>\n<ol>\n<li>\n<p>当的 B 盒子高度低于 A 盒子，C 盒子仍会处于 B 盒子右下方。</p>\n</li>\n<li>\n<p>如果 B 盒子文本过多，高度超过了 A 盒子，则 C 盒子不会停留在右下方，而是掉到了 A 盒子下。</p>\n</li>\n<li>\n<p>接下来对 C 盒子进行相对定位，将 C 盒子位置向右侧移动 100%，并向左上方向拉回一个 C 盒子的宽高（不然会看不到哟）。这样在文本未溢出时不会看到 C 盒子，在文本溢出时，显示 C 盒子。</p>\n</li>\n</ol>\n<p></p><figure><img alt=\"yuanli.gif\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c444cf3295?imageslim\" data-width=\"730\" data-height=\"494\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"730\" height=\"494\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">收，大道归简，能力封装</h2>\n<blockquote>\n<p>凡重复的，让它单一；凡复杂的，让它简单。</p>\n</blockquote>\n<p>每次都要搞一坨代码，太麻烦。这时候你需要考虑将文本截断的能力，封装成一个可随时调用的自定义容器组件。市面上很多 UI 组件库，都提供了同类组件的封装，如基于 Vue 的 ViewUI Pro，或面向小程序提供组件化解决能力的 MinUI 。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c44af83125?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1194\" data-height=\"700\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1194\" height=\"700\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c44857bc88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"940\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"940\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">结语</h2>\n<p>本文介绍了几种目前常见的文本截断省略的方案，各有利弊，各位同学可根据实际开发情况及需求选择方案。如果你还知道更好其他实现方案，欢迎在评论区留下宝贵评论。</p>\n<h2 class=\"heading\" data-id=\"heading-12\">参考文章</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/happylindz/blog/issues/12\" rel=\"nofollow noopener noreferrer\">纯 CSS 实现多行文字截断</a></li>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/qq_40072782/article/details/82908581\" rel=\"nofollow noopener noreferrer\">【 CSS / JS 】限制一行和多行文字数量，溢出部分用省略号显示</a></li>\n<li><a target=\"_blank\" href=\"https://baijiahao.baidu.com/s?id=1621362934713048315&wfr=spider&for=pc\" rel=\"nofollow noopener noreferrer\">HTML技巧篇：如何让单行文本以及多行文本溢出显示省略号(…)</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-13\">招贤纳士</h2>\n<p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p>\n<p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/29/16cddbe09f60b388?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">推荐阅读</h2>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5dafa3d35188257b1549bad1\" rel>1024 巨献！！一文看尽前端过去一年的精华沉淀（700 篇好文大汇总）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" rel>前端工程实践之可视化搭建系统（一）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6de51de51d45620771f12c\" rel>自动化 Web 性能优化分析方案</a></p>\n",
      "id": "2opsua62ov40",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。</p>\n</blockquote>\n<ul>\n<li>call、apply、bind 实现</li>\n<li>new 实现</li>\n<li>class 实现继承</li>\n<li>async/await 实现</li>\n<li>reduce 实现</li>\n<li>实现一个双向数据绑定</li>\n<li>instanceof 实现</li>\n<li>Array.isArray 实现</li>\n<li>Object.create 的基本实现原理</li>\n<li>getOwnPropertyNames 实现</li>\n<li>promise 实现</li>\n<li>手写一个防抖/节流函数</li>\n<li>柯里化函数的实现</li>\n<li>手写一个深拷贝</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-0\">call、apply、bind 实现</h2>\n<blockquote>\n<p><code>call、apply、bind</code> 本质都是改变 <code>this</code> 的指向，不同点 <code>call、apply</code> 是直接调用函数，<code>bind</code> 是返回一个新的函数。<code>call</code> 跟 <code>apply</code> 就只有参数上不同。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-1\">bind 实现</h3>\n<ul>\n<li>箭头函数的 <code>this</code> 永远指向它所在的作用域</li>\n<li>函数作为构造函数用 <code>new</code> 关键字调用时，不应该改变其 <code>this</code> 指向，因为 <code>new绑定</code> 的优先级高于 <code>显示绑定</code> 和 <code>硬绑定</code></li>\n</ul>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mybind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Bind must be called on a function\"</span>);\n    }\n    <span class=\"hljs-comment\">// 拿到参数，为了传给调用者</span>\n    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>),\n      <span class=\"hljs-comment\">// 保存 this</span>\n      self = <span class=\"hljs-keyword\">this</span>,\n      <span class=\"hljs-comment\">// 构建一个干净的函数，用于保存原函数的原型</span>\n      nop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{},\n      <span class=\"hljs-comment\">// 绑定的函数</span>\n      bound = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-comment\">// this instanceof nop, 判断是否使用 new 来调用 bound</span>\n        <span class=\"hljs-comment\">// 如果是 new 来调用的话，this的指向就是其实例，</span>\n        <span class=\"hljs-comment\">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span>\n        <span class=\"hljs-keyword\">return</span> self.apply(\n          <span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> nop ? <span class=\"hljs-keyword\">this</span> : thisArg,\n          args.concat(<span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>))\n        );\n      };\n\n    <span class=\"hljs-comment\">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.prototype) {\n      nop.prototype = <span class=\"hljs-keyword\">this</span>.prototype;\n    }\n    <span class=\"hljs-comment\">// 修改绑定函数的原型指向</span>\n    bound.prototype = <span class=\"hljs-keyword\">new</span> nop();\n\n    <span class=\"hljs-keyword\">return</span> bound;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-028</code></pre><ol start=\"3\">\n<li><code>测试 mybind</code></li>\n</ol>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\n<span class=\"hljs-keyword\">const</span> bound = bar.mybind(foo, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">44</span>);\n<span class=\"hljs-keyword\">new</span> bound(); <span class=\"hljs-comment\">// bar, [22, 33, 44]</span>\nbound(); <span class=\"hljs-comment\">// foo, [22, 33, 44]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-029</code></pre><h3 class=\"heading\" data-id=\"heading-2\">call 实现</h3>\n<blockquote>\n<p><code>bind</code> 是封装了 <code>call</code> 的方法改变了 <code>this</code> 的指向并返回一个新的函数，那么 <code>call</code> 是如何做到改变 <code>this</code> 的指向呢？原理很简单，在方法调用模式下，<code>this</code> 总是指向调用它所在方法的对象，<code>this</code> 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）。先写一个小 <code>demo</code> 来理解一下下。</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-keyword\">const</span> foo = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span> };\n\nfoo.fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 这里的 this 指向了 foo</span>\n  <span class=\"hljs-comment\">// 因为 foo 调用了 fn，</span>\n  <span class=\"hljs-comment\">// fn 的 this 就指向了调用它所在方法的对象 foo 上</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// foo</span>\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-030</code></pre><p>利用 <code>this</code> 的机制来实现 <code>call</code></p>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mycall = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-comment\">// this指向调用call的对象</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-comment\">// 调用call的若不是函数则报错</span>\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Error'</span>);\n    }\n    <span class=\"hljs-comment\">// 声明一个 Symbol 属性，防止 fn 被占用</span>\n    <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n    <span class=\"hljs-keyword\">const</span> args = [...arguments].slice(<span class=\"hljs-number\">1</span>);\n    thisArg = thisArg || <span class=\"hljs-built_in\">window</span>;\n    <span class=\"hljs-comment\">// 将调用call函数的对象添加到thisArg的属性中</span>\n    thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 执行该属性</span>\n    <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...args);\n    <span class=\"hljs-comment\">// 删除该属性</span>\n    <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n    <span class=\"hljs-comment\">// 返回函数执行结果</span>\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n<span class=\"copy-code-btn\">复制代码</span> copy-031</code></pre><h3 class=\"heading\" data-id=\"heading-3\">apply 实现</h3>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.myapply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">' is not a function'</span>;\n  }\n\n  <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n  thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n\n  <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...arg);\n\n  <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n\n  <span class=\"hljs-keyword\">return</span> result;\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-032</code></pre><p><code>测试 mycall myapply</code></p>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\nbar.mycall(foo, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\nbar.myapply(foo, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-033</code></pre><h2 class=\"heading\" data-id=\"heading-4\">reduce 实现原理</h2>\n<blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.myreduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reduce</span>(<span class=\"hljs-params\">callbackfn</span>) </span>{\n  <span class=\"hljs-comment\">// 拿到数组</span>\n  <span class=\"hljs-keyword\">const</span> O = <span class=\"hljs-keyword\">this</span>,\n    len = O.length;\n  <span class=\"hljs-comment\">// 下标值</span>\n  <span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-comment\">// 累加器</span>\n    accumulator = <span class=\"hljs-literal\">undefined</span>,\n    <span class=\"hljs-comment\">// k下标对应的值是否存在</span>\n    kPresent = <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-comment\">// 初始值</span>\n    initialValue = <span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span> ? <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>] : <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callbackfn !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 数组为空，并且有初始值，报错</span>\n  <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span> && <span class=\"hljs-built_in\">arguments</span>.length < <span class=\"hljs-number\">2</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Reduce of empty array with no initial value'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 如果初始值存在</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// 设置累加器为初始值</span>\n    accumulator = initialValue;\n    <span class=\"hljs-comment\">// 初始值不存在</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    accumulator = O[k];\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">while</span> (k < len) {\n    <span class=\"hljs-comment\">// 判断是否为 empty [,,,]</span>\n    kPresent = O.hasOwnProperty(k);\n\n    <span class=\"hljs-keyword\">if</span> (kPresent) {\n      <span class=\"hljs-keyword\">const</span> kValue = O[k];\n      <span class=\"hljs-comment\">// 调用 callbackfn</span>\n      accumulator = callbackfn.apply(<span class=\"hljs-literal\">undefined</span>, [accumulator, kValue, k, O]);\n    }\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">return</span> accumulator;\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-034</code></pre><p><code>测试</code></p>\n<pre><code class=\"hljs js copyable code-07\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> mReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].myreduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(rReduce, mReduce);\n<span class=\"hljs-comment\">// 31nullundefined34 31nullundefined34</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-035</code></pre><h2 class=\"heading\" data-id=\"heading-5\">new 实现</h2>\n<blockquote>\n<p>我们需要知道当 <code>new</code> 的时候做了什么事情</p>\n</blockquote>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）</li>\n<li>返回新对象。</li>\n</ol>\n<p>因为 new 没办法重写，我们使用 <code>myNew</code> 函数来模拟 <code>new</code></p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 创建一个实例对象</span>\n  <span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n  <span class=\"hljs-comment\">// 取得外部传入的构造器</span>\n  <span class=\"hljs-keyword\">var</span> Constructor = <span class=\"hljs-built_in\">Array</span>.prototype.shift.call(<span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 实现继承，实例可以访问构造器的属性</span>\n  obj.__proto__ = Constructor.prototype;\n  <span class=\"hljs-comment\">// 调用构造器，并改变其 this 指向到实例</span>\n  <span class=\"hljs-keyword\">var</span> ret = Constructor.apply(obj, <span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> ret === <span class=\"hljs-string\">'object'</span> && ret !== <span class=\"hljs-literal\">null</span> ? ret : obj;\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-036</code></pre><p><code>测试 myNew</code></p>\n<pre><code class=\"hljs js copyable code-09\" lang=\"js\"><span class=\"hljs-comment\">// ========= 无返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// { name: \"foo\" }</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// ========= 有返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n  <span class=\"hljs-keyword\">return</span> {};\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// {}</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// false</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-037</code></pre><h2 class=\"heading\" data-id=\"heading-6\">class 实现继承</h2>\n<blockquote>\n<p>主要使用 <code>es5</code> 跟 <code>es6</code> 对比看下 <code>class</code> 继承的原理</p>\n</blockquote>\n<p>实现继承 <code>A extends B</code></p>\n<p>使用 <code>es6</code> 语法</p>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(opt) {\n    <span class=\"hljs-keyword\">this</span>.BName = opt.name;\n  }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-comment\">// 向父类传参</span>\n    <span class=\"hljs-keyword\">super</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> });\n    <span class=\"hljs-comment\">// this 必须在 super() 下面使用</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-038</code></pre><p>使用 <code>es5</code> 语法</p>\n<p>使用寄生组合继承的方式</p>\n<ol>\n<li>原型链继承，使子类可以调用父类原型上的方法和属性</li>\n<li>借用构造函数继承，可以实现向父类传参</li>\n<li>寄生继承，创造干净的没有构造方法的函数，用来寄生父类的 prototype</li>\n</ol>\n<pre><code class=\"hljs js copyable code-011\" lang=\"js\"><span class=\"hljs-comment\">// 实现继承，通过继承父类 prototype</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__extends</span>(<span class=\"hljs-params\">child, parent</span>) </span>{\n  <span class=\"hljs-comment\">// 修改对象原型</span>\n  <span class=\"hljs-built_in\">Object</span>.setPrototypeOf(child, parent);\n  <span class=\"hljs-comment\">// 寄生继承，创建一个干净的构造函数，用于继承父类的 prototype</span>\n  <span class=\"hljs-comment\">// 这样做的好处是，修改子类的 prototype 不会影响父类的 prototype</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 修正 constructor 指向子类</span>\n    <span class=\"hljs-keyword\">this</span>.constructor = child;\n  }\n  <span class=\"hljs-comment\">// 原型继承，继承父类原型属性，但是无法向父类构造函数传参</span>\n  child.prototype =\n    parent === <span class=\"hljs-literal\">null</span>\n      ? <span class=\"hljs-built_in\">Object</span>.create(parent)\n      : ((__.prototype = parent.prototype), <span class=\"hljs-keyword\">new</span> __());\n}\n\n<span class=\"hljs-keyword\">var</span> B = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\">opt</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = opt.name;\n  }\n  <span class=\"hljs-keyword\">return</span> B;\n})();\n\n<span class=\"hljs-keyword\">var</span> A = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_super</span>) </span>{\n  __extends(A, _super);\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 借用继承，可以实现向父类传参, 使用 super 可以向父类传参</span>\n    <span class=\"hljs-keyword\">return</span> (_super !== <span class=\"hljs-literal\">null</span> && _super.apply(<span class=\"hljs-keyword\">this</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> })) || <span class=\"hljs-keyword\">this</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> A;\n})(B);\n<span class=\"copy-code-btn\">复制代码</span> copy-039</code></pre><p><code>测试 class</code></p>\n<pre><code class=\"hljs js copyable code-012\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">new</span> A();\n\n<span class=\"hljs-built_in\">console</span>.log(a.BName, a.constructor); <span class=\"hljs-comment\">// B ,ƒ A() {}</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-040</code></pre><h2 class=\"heading\" data-id=\"heading-7\">async/await 实现</h2>\n<blockquote>\n<p>原理就是利用 <code>generator</code>（生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个<code>yield</code> 用 <code>promise</code> 包裹起来。执行下一步的时机由 <code>promise</code> 来控制</p>\n</blockquote>\n<p><code>async/await</code> 是关键字，不能重写它的方法，我们使用函数来模拟</p>\n<p>异步迭代，模拟异步函数</p>\n<pre><code class=\"hljs js copyable code-013\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_asyncToGenerator</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>,\n      args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-comment\">// 将返回值promise化</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n      <span class=\"hljs-comment\">// 获取迭代器实例</span>\n      <span class=\"hljs-keyword\">var</span> gen = fn.apply(self, args);\n      <span class=\"hljs-comment\">// 执行下一步</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_next</span>(<span class=\"hljs-params\">value</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'next'</span>, value);\n      }\n      <span class=\"hljs-comment\">// 抛出异常</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_throw</span>(<span class=\"hljs-params\">err</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'throw'</span>, err);\n      }\n      <span class=\"hljs-comment\">// 第一次触发</span>\n      _next(<span class=\"hljs-literal\">undefined</span>);\n    });\n  };\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-041</code></pre><p>执行迭代步骤，处理下次迭代结果</p>\n<pre><code class=\"hljs js copyable code-014\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGeneratorStep</span>(<span class=\"hljs-params\">gen, resolve, reject, _next, _throw, key, arg</span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">var</span> info = gen[key](arg);\n    <span class=\"hljs-keyword\">var</span> value = info.value;\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    reject(error);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (info.done) {\n    <span class=\"hljs-comment\">// 迭代器完成</span>\n    resolve(value);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// -- 这行代码就是精髓 --</span>\n    <span class=\"hljs-comment\">// 将所有值promise化</span>\n    <span class=\"hljs-comment\">// 比如 yield 1</span>\n    <span class=\"hljs-comment\">// const a = Promise.resolve(1) a 是一个 promise</span>\n    <span class=\"hljs-comment\">// const b = Promise.resolve(a) b 是一个 promise</span>\n    <span class=\"hljs-comment\">// 可以做到统一 promise 输出</span>\n    <span class=\"hljs-comment\">// 当 promise 执行完之后再执行下一步</span>\n    <span class=\"hljs-comment\">// 递归调用 next 函数，直到 done == true</span>\n    <span class=\"hljs-built_in\">Promise</span>.resolve(value).then(_next, _throw);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-042</code></pre><p><code>测试 _asyncToGenerator</code></p>\n<pre><code class=\"hljs js copyable code-015\" lang=\"js\"><span class=\"hljs-keyword\">const</span> asyncFunc = _asyncToGenerator(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> e = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      resolve(<span class=\"hljs-string\">'e'</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n  });\n  <span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'a'</span>);\n  <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'d'</span>;\n  <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'b'</span>);\n  <span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'c'</span>);\n  <span class=\"hljs-keyword\">return</span> [a, b, c, d, e];\n});\n\nasyncFunc().then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(res); <span class=\"hljs-comment\">// ['a', 'b', 'c', 'd', 'e']</span>\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-043</code></pre><h2 class=\"heading\" data-id=\"heading-8\">实现一个双向绑定</h2>\n<p><code>defineProperty</code> 版本</p>\n<pre><code class=\"hljs js copyable code-016\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-built_in\">Object</span>.defineProperty(data, <span class=\"hljs-string\">'text'</span>, {\n  <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n  set(newVal) {\n    input.value = newVal;\n    span.innerHTML = newVal;\n  }\n});\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  data.text = e.target.value;\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-044</code></pre><p><code>proxy</code> 版本</p>\n<pre><code class=\"hljs js copyable code-017\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-keyword\">const</span> handler = {\n  set(target, key, value) {\n    target[key] = value;\n    <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n    input.value = value;\n    span.innerHTML = value;\n    <span class=\"hljs-keyword\">return</span> value;\n  }\n};\n<span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(data, handler);\n\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  proxy.text = e.target.value;\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-045</code></pre><h2 class=\"heading\" data-id=\"heading-9\">Object.create 的基本实现原理</h2>\n<pre><code class=\"hljs js copyable code-018\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.create !== <span class=\"hljs-string\">\"function\"</span>) {\n  <span class=\"hljs-built_in\">Object</span>.create = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">prototype, properties</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> prototype !== <span class=\"hljs-string\">\"object\"</span>) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ctor</span>(<span class=\"hljs-params\"></span>) </span>{}\n    Ctor.prototype = prototype;\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Ctor();\n    <span class=\"hljs-keyword\">if</span> (prototype) { o.constructor = Ctor; }\n    <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-literal\">undefined</span>) {\n      <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-built_in\">Object</span>(properties)) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n      <span class=\"hljs-built_in\">Object</span>.defineProperties(o, properties);\n    }\n    <span class=\"hljs-keyword\">return</span> o;\n  };\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-046</code></pre><h2 class=\"heading\" data-id=\"heading-10\">instanceof 实现</h2>\n<blockquote>\n<p>原理： <code>L</code> 的 <code>__proto__</code> 是不是等于 <code>R.prototype</code>，不等于再找 <code>L.__proto__.__proto__</code> 直到 <code>__proto__</code> 为 <code>null</code></p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-019\" lang=\"js\"><span class=\"hljs-comment\">// L 表示左表达式，R 表示右表达式</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">instance_of</span>(<span class=\"hljs-params\">L, R</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> O = R.prototype;\n  L = L.__proto__;\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-comment\">// 这里重点：当 O 严格等于 L 时，返回 true</span>\n    <span class=\"hljs-keyword\">if</span> (O === L) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    L = L.__proto__;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-047</code></pre><h2 class=\"heading\" data-id=\"heading-11\">Array.isArray 实现</h2>\n<pre><code class=\"hljs js copyable code-020\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.myIsArray = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(<span class=\"hljs-built_in\">Object</span>(o)) === <span class=\"hljs-string\">'[object Array]'</span>;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Array</span>.myIsArray([])); <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-048</code></pre><h2 class=\"heading\" data-id=\"heading-12\">getOwnPropertyNames 实现</h2>\n<p>备注：不能拿到不可枚举的属性</p>\n<pre><code class=\"hljs js copyable code-021\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames !== <span class=\"hljs-string\">'function'</span>) {\n  <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (o !== <span class=\"hljs-built_in\">Object</span>(o)) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Object.getOwnPropertyNames called on non-object'</span>);\n    }\n    <span class=\"hljs-keyword\">var</span> props = [],\n      p;\n    <span class=\"hljs-keyword\">for</span> (p <span class=\"hljs-keyword\">in</span> o) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(o, p)) {\n        props.push(p);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> props;\n  };\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-049</code></pre><h2 class=\"heading\" data-id=\"heading-13\">Promise 实现</h2>\n<blockquote>\n<p>实现原理：其实就是一个发布订阅者模式</p>\n</blockquote>\n<ol>\n<li>构造函数接收一个 <code>executor</code> 函数，并会在 <code>new Promise()</code> 时立即执行该函数</li>\n<li><code>then</code> 时收集依赖，将回调函数收集到 <code>成功/失败队列</code></li>\n<li><code>executor</code> 函数中调用 <code>resolve/reject</code> 函数</li>\n<li><code>resolve/reject</code> 函数被调用时会通知触发队列中的回调</li>\n</ol>\n<p>先看一下整体代码，有一个大致的概念</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e43d1799b13cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"758\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"758\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>完整代码</p>\n<pre><code class=\"hljs js copyable code-022\" lang=\"js\"><span class=\"hljs-keyword\">const</span> isFunction = <span class=\"hljs-function\"><span class=\"hljs-params\">variable</span> =></span> <span class=\"hljs-keyword\">typeof</span> variable === <span class=\"hljs-string\">'function'</span>;\n\n<span class=\"hljs-comment\">// 定义Promise的三种状态常量</span>\n<span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">'pending'</span>;\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">'fulfilled'</span>;\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">'rejected'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyPromise</span> </span>{\n  <span class=\"hljs-comment\">// 构造函数，new 时触发</span>\n  <span class=\"hljs-keyword\">constructor</span>(handle: Function) {\n    <span class=\"hljs-keyword\">try</span> {\n      handle(<span class=\"hljs-keyword\">this</span>._resolve, <span class=\"hljs-keyword\">this</span>._reject);\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      <span class=\"hljs-keyword\">this</span>._reject(err);\n    }\n  }\n  <span class=\"hljs-comment\">// 状态 pending fulfilled rejected</span>\n  private _status: string = PENDING;\n  <span class=\"hljs-comment\">// 储存 value，用于 then 返回</span>\n  private _value: string | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-comment\">// 失败队列，在 then 时注入，resolve 时触发</span>\n  private _rejectedQueues: any = [];\n  <span class=\"hljs-comment\">// 成功队列，在 then 时注入，resolve 时触发</span>\n  private _fulfilledQueues: any = [];\n  <span class=\"hljs-comment\">// resovle 时执行的函数</span>\n  private _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">this</span>._status = FULFILLED;\n      <span class=\"hljs-comment\">// 依次执行成功队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runFulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._fulfilledQueues.shift())) {\n          cb(value);\n        }\n      };\n      <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runRejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n          cb(error);\n        }\n      };\n      <span class=\"hljs-comment\">/*\n       * 如果resolve的参数为Promise对象，\n       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变\n       * 且状态取决于参数Promsie对象的状态\n       */</span>\n      <span class=\"hljs-keyword\">if</span> (val <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n        val.then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n            <span class=\"hljs-keyword\">this</span>._value = value;\n            runFulfilled(value);\n          },\n          err => {\n            <span class=\"hljs-keyword\">this</span>._value = err;\n            runRejected(err);\n          }\n        );\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>._value = val;\n        runFulfilled(val);\n      }\n    };\n    <span class=\"hljs-comment\">// 异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// reject 时执行的函数</span>\n  private _reject = <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">this</span>._status = REJECTED;\n      <span class=\"hljs-keyword\">this</span>._value = err;\n      <span class=\"hljs-keyword\">let</span> cb;\n      <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n        cb(err);\n      }\n    };\n    <span class=\"hljs-comment\">// 为了支持同步的Promise，这里采用异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// then 方法</span>\n  then(onFulfilled?, onRejected?) {\n    <span class=\"hljs-keyword\">const</span> { _value, _status } = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 返回一个新的Promise对象</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">onFulfilledNext, onRejectedNext</span>) =></span> {\n      <span class=\"hljs-comment\">// 封装一个成功时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> fulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onFulfilled)) {\n            onFulfilledNext(value);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onFulfilled(value);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-comment\">// 封装一个失败时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> rejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onRejected)) {\n            onRejectedNext(error);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onRejected(error);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-keyword\">switch</span> (_status) {\n        <span class=\"hljs-comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span>\n        <span class=\"hljs-keyword\">case</span> PENDING:\n          <span class=\"hljs-keyword\">this</span>._fulfilledQueues.push(fulfilled);\n          <span class=\"hljs-keyword\">this</span>._rejectedQueues.push(rejected);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-comment\">// 当状态已经改变时，立即执行对应的回调函数</span>\n        <span class=\"hljs-keyword\">case</span> FULFILLED:\n          fulfilled(_value);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> REJECTED:\n          rejected(_value);\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// catch 方法</span>\n  <span class=\"hljs-keyword\">catch</span>(onRejected) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(<span class=\"hljs-literal\">undefined</span>, onRejected);\n  }\n  <span class=\"hljs-comment\">// finally 方法</span>\n  <span class=\"hljs-keyword\">finally</span>(cb) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> value),\n      reason =>\n        MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n          <span class=\"hljs-keyword\">throw</span> reason;\n        })\n    );\n  }\n  <span class=\"hljs-comment\">// 静态 resolve 方法</span>\n  <span class=\"hljs-keyword\">static</span> resolve(value) {\n    <span class=\"hljs-comment\">// 如果参数是MyPromise实例，直接返回这个实例</span>\n    <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> MyPromise) <span class=\"hljs-keyword\">return</span> value;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> resolve(value));\n  }\n  <span class=\"hljs-comment\">// 静态 reject 方法</span>\n  <span class=\"hljs-keyword\">static</span> reject(value) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> reject(value));\n  }\n  <span class=\"hljs-comment\">// 静态 all 方法</span>\n  <span class=\"hljs-keyword\">static</span> all(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-comment\">// 返回值的集合</span>\n      <span class=\"hljs-keyword\">let</span> values = [];\n      <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [i, p] <span class=\"hljs-keyword\">of</span> list.entries()) {\n        <span class=\"hljs-comment\">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            values[i] = res;\n            count++;\n            <span class=\"hljs-comment\">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span>\n            <span class=\"hljs-keyword\">if</span> (count === list.length) resolve(values);\n          },\n          err => {\n            <span class=\"hljs-comment\">// 有一个被rejected时返回的MyPromise状态就变成rejected</span>\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// 添加静态race方法</span>\n  <span class=\"hljs-keyword\">static</span> race(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> list) {\n        <span class=\"hljs-comment\">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            resolve(res);\n          },\n          err => {\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-050</code></pre><h2 class=\"heading\" data-id=\"heading-14\">防抖/节流</h2>\n<blockquote>\n<p><code>防抖函数</code> onscroll 结束时触发一次，延迟执行</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-023\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">func, wait</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> timeout;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> context = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-keyword\">if</span> (timeout) clearTimeout(timeout);\n    timeout = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      func.apply(context, args);\n    }, wait);\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-built_in\">window</span>.onscroll = debounce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'debounce'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"copy-code-btn\">复制代码</span> copy-051</code></pre><blockquote>\n<p><code>节流函数</code> onscroll 时，每隔一段时间触发一次，像水滴一样</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-024\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">fn, delay</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> prevTime = <span class=\"hljs-built_in\">Date</span>.now();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> curTime = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-keyword\">if</span> (curTime - prevTime > delay) {\n      fn.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n      prevTime = curTime;\n    }\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">var</span> throtteScroll = throttle(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'throtte'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-built_in\">window</span>.onscroll = throtteScroll;\n<span class=\"copy-code-btn\">复制代码</span> copy-052</code></pre><h2 class=\"heading\" data-id=\"heading-15\">函数柯里化实现</h2>\n<blockquote>\n<p>其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。</p>\n</blockquote>\n<p>实际应用中：</p>\n<ul>\n<li>延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）</li>\n<li>动态创建函数 （参数不够时会返回接受剩下参数的函数）</li>\n<li>参数复用（每个参数可以多次复用）</li>\n</ul>\n<pre><code class=\"hljs js copyable code-025\" lang=\"js\"><span class=\"hljs-keyword\">const</span> curry = <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =></span>\n  (judge = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =></span>\n    args.length >= fn.length\n      ? fn(...args)\n      : <span class=\"hljs-function\">(<span class=\"hljs-params\">...arg</span>) =></span> judge(...args, ...arg));\n\n<span class=\"hljs-keyword\">const</span> sum = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c, d</span>) =></span> a + b + c + d;\n<span class=\"hljs-keyword\">const</span> currySum = curry(sum);\n\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-053</code></pre><h2 class=\"heading\" data-id=\"heading-16\">手写一个深拷贝</h2>\n<blockquote>\n<p>浅拷贝只复制地址值，实际上还是指向同一堆内存中的数据，深拷贝则是重新创建了一个相同的数据，二者指向的堆内存的地址值是不同的。这个时候修改赋值前的变量数据不会影响赋值后的变量。</p>\n</blockquote>\n<p>要实现一个完美的神拷贝太复杂了，这里简单介绍一下吧，可以应用于大部分场景了</p>\n<p>判断类型函数</p>\n<pre><code class=\"hljs js copyable code-026\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getType</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n  <span class=\"hljs-keyword\">const</span> map = {\n    <span class=\"hljs-string\">'[object Boolean]'</span>: <span class=\"hljs-string\">'boolean'</span>,\n    <span class=\"hljs-string\">'[object Number]'</span>: <span class=\"hljs-string\">'number'</span>,\n    <span class=\"hljs-string\">'[object String]'</span>: <span class=\"hljs-string\">'string'</span>,\n    <span class=\"hljs-string\">'[object Function]'</span>: <span class=\"hljs-string\">'function'</span>,\n    <span class=\"hljs-string\">'[object Array]'</span>: <span class=\"hljs-string\">'array'</span>,\n    <span class=\"hljs-string\">'[object Date]'</span>: <span class=\"hljs-string\">'date'</span>,\n    <span class=\"hljs-string\">'[object RegExp]'</span>: <span class=\"hljs-string\">'regExp'</span>,\n    <span class=\"hljs-string\">'[object Undefined]'</span>: <span class=\"hljs-string\">'undefined'</span>,\n    <span class=\"hljs-string\">'[object Null]'</span>: <span class=\"hljs-string\">'null'</span>,\n    <span class=\"hljs-string\">'[object Object]'</span>: <span class=\"hljs-string\">'object'</span>\n  };\n  <span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> Element) {\n    <span class=\"hljs-comment\">// 判断是否是dom元素，如div等</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'element'</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> map[str];\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-054</code></pre><p>简单版深拷贝，列举三个例子 <code>array</code> <code>object</code> <code>function</code>，可以自行扩展。主要是引发大家的思考</p>\n<pre><code class=\"hljs js copyable code-027\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepCopy</span>(<span class=\"hljs-params\">ori</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> type = getType(ori);\n  <span class=\"hljs-keyword\">let</span> copy;\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'array'</span>:\n      <span class=\"hljs-keyword\">return</span> copyArray(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'object'</span>:\n      <span class=\"hljs-keyword\">return</span> copyObject(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'function'</span>:\n      <span class=\"hljs-keyword\">return</span> copyFunction(ori, type, copy);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> ori;\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyArray</span>(<span class=\"hljs-params\">ori, type, copy = []</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [index, value] <span class=\"hljs-keyword\">of</span> ori.entries()) {\n    copy[index] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyObject</span>(<span class=\"hljs-params\">ori, type, copy = {}</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.entries(ori)) {\n    copy[key] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyFunction</span>(<span class=\"hljs-params\">ori, type, copy = (</span>) => </span>{}) {\n  <span class=\"hljs-keyword\">const</span> fun = <span class=\"hljs-built_in\">eval</span>(ori.toString());\n  fun.prototype = ori.prototype\n  <span class=\"hljs-keyword\">return</span> fun\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-055</code></pre><h2 class=\"heading\" data-id=\"heading-17\">最后有几件小事</h2>\n<ol>\n<li>有想入群的学习前端进阶的加我微信 <code>luoxue2479</code> 回复加群即可</li>\n<li>有错误的话欢迎在留言区指出，一起讨论，也可以加我微信</li>\n<li>每天在群里会有专题讨论 <a target=\"_blank\" href=\"https://github.com/luoxue-victor/source-code/issues/\" rel=\"nofollow noopener noreferrer\">github.com/luoxue-vict…</a></li>\n<li>鄙人公众号【前端技匠】，一起来学习吧。</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e448312ce00d07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"768\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"768\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>参考文章</p>\n<p><a target=\"_blank\" href=\"https://cloud.tencent.com/developer/article/1431398\" rel=\"nofollow noopener noreferrer\">cloud.tencent.com/developer/a…</a></p>\n<p><a target=\"_blank\" href=\"https://www.jianshu.com/p/b4f0425b22a1\" rel=\"nofollow noopener noreferrer\">www.jianshu.com/p/b4f0425b2…</a></p>\n<p><a target=\"_blank\" href=\"https://blog.csdn.net/LL18781132750/article/details/79700089\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/LL187811327…</a></p>\n",
      "id": "545hxyr9ops0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>如果你符合JavaScript高级开发人员的资格，在编码面试中很有可能会被问到一些刁钻的问题。</p>\n<p>我知道这不公平。一些不知名的人把你放在角落上下打量，似乎想看你是什么做成的。这是一次不愉快的经历。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e43a74c6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e43a74c6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>你能做什么?</p>\n<p>遵循这个建议：“熟能生巧”。通过投入足够的时间，更好地定期深入了解JavaScript，将改善你的编码，并顺便提高你的面试技巧。</p>\n<p>在这篇文章中，你会发现7个乍一看很简单，但实际上很棘手的JavaScript面试题。</p>\n<p>虽然一开始这些问题看起来是随机的，但是它们试图与JavaScript的重要概念挂钩。所以你最好在下次面试前练习一下!</p>\n<h2 class=\"heading\" data-id=\"heading-0\">1. 意外的全局变量</h2>\n<h4 class=\"heading\" data-id=\"heading-1\">问题</h4>\n<p>在以下代码中，<code>typeof a</code>和<code>typeof b</code>的值分别是什么：</p>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span></span>() {\n  <span class=\"hljs-built_in\">let</span> a = b = 0;\n  a++;\n  <span class=\"hljs-built_in\">return</span> a;\n}\n\nfoo();\ntypeof a; // => ???typeof b; // => ???\n<span class=\"copy-code-btn\">复制代码</span> copy-011</code></pre><h4 class=\"heading\" data-id=\"heading-2\">答案</h4>\n<p>让我们仔细看看第2行：<code>let a = b = 0</code>。这个语句确实声明了一个局部变量<code>a</code>。但是，它确实声明了一个<em>全局</em>变量<code>b</code>。</p>\n<p>在<code>foo()</code>作用域或全局作用域中都没有声明变量 <code>b</code> ”。因此JavaScript将表达式 <code>b = 0</code> 解释为 <code>window.b = 0</code>。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e3d0539ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><code>b</code>是一个偶然创建的全局变量。</p>\n<p>在浏览器中，上述代码片段相当于:</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span></span>() {\n  <span class=\"hljs-built_in\">let</span> a;  window.b = 0;  a = window.b;  a++;\n  <span class=\"hljs-built_in\">return</span> a;\n}\n\nfoo();\ntypeof a;        // => <span class=\"hljs-string\">'undefined'</span>\ntypeof window.b; // => <span class=\"hljs-string\">'number'</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-012</code></pre><p><code>typeof a</code>是 <code>'undefined'</code>。变量<code>a</code>仅在 <code>foo()</code>范围内声明，在外部范围内不可用。</p>\n<p><code>typeof b</code>等于<code>'number'</code>。<code>b</code>是一个值为 <code>0</code>的全局变量。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">2. 数组 length 属性</h2>\n<h4 class=\"heading\" data-id=\"heading-4\">问题</h4>\n<p><code>clothes[0]</code> 的值是什么：</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">const clothes = [<span class=\"hljs-string\">'jacket'</span>, <span class=\"hljs-string\">'t-shirt'</span>];\nclothes.length = 0;\n\nclothes[0]; // => ???\n<span class=\"copy-code-btn\">复制代码</span> copy-013</code></pre><h4 class=\"heading\" data-id=\"heading-5\">答案</h4>\n<p>数组对象的 <code>length</code> 属性有一个 <a target=\"_blank\" href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-array-instances-length\" rel=\"nofollow noopener noreferrer\">特殊的行为</a>:</p>\n<blockquote>\n<p>减少<code>length</code>属性的值有一个副作用，就是会删除索引位于新旧长度值之间的元素。</p>\n</blockquote>\n<p>因为 <code>length</code>的这种行为，当JavaScript执行<code>clothes.length = 0</code> 时，数组 <code>clothes</code> 中的所有项都被删除了。</p>\n<p><code>clothes[0]</code> 是<code>undefined</code>，因为 <code>clothes</code> 数组被清空了。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">3. 鹰眼测试</h2>\n<h4 class=\"heading\" data-id=\"heading-7\">问题</h4>\n<p><code>numbers</code> 数组的内容是什么：</p>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">const length = 4;\nconst numbers = [];\n<span class=\"hljs-keyword\">for</span> (var i = 0; i < length; i++);{\n  numbers.push(i + 1);\n}\n\nnumbers; // => ???\n<span class=\"copy-code-btn\">复制代码</span> copy-014</code></pre><h4 class=\"heading\" data-id=\"heading-8\">答案</h4>\n<p>让我们仔细看看出现在左花括号<code>{</code>前面的分号<code>;</code> ：</p>\n<p></p><figure><img alt=\"image.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e43dce4a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>很容易忽略这个分号，而它创建了一个<em>空语句</em>。空语句是不做任何事情的语句。</p>\n<p><code>for()</code> 在空语句（什么也不做）上循环了 4 次，忽略了实际上往数组里添加元素的代码块<code>{ numbers.push(i + 1); }</code>。</p>\n<p>上述代码等同于：</p>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">const length = 4;\nconst numbers = [];\nvar i;\n<span class=\"hljs-keyword\">for</span> (i = 0; i < length; i++) {\n  // does nothing\n}\n{ \n  // a simple block\n  numbers.push(i + 1);\n}\n\nnumbers; // => [5]\n<span class=\"copy-code-btn\">复制代码</span> copy-015</code></pre><p><code>for()</code>递增变量<code>i</code>直到<code>4</code>。然后JavaScript 进入代码块 <code>{ numbers.push(i + 1); }</code>，将<code>4 + 1</code> 添加 到<code>numbers</code>数组中。</p>\n<p>这样 <code>numbers</code> 就是 <code>[5]</code>.</p>\n<h4 class=\"heading\" data-id=\"heading-9\">这个问题背后我的故事</h4>\n<blockquote>\n<p><em>很久以前，当我面试我的第一份工作时，我被问到这个问题。</em>\n<em>面试时，我被要求在1小时内回答20个编码问题。空语句问题位列其中。</em>\n<em>当我在匆忙中解决这个问题时，我没有看到逗号<code>;</code> 就在花括号 <code>{</code> 的前面。所以我答错成 [1,2,3,4]</em>\n<em>我对这些不公平的伎俩有点失望。我问面试官这样做的原因是什么?面试官回答：</em>\n<em>“因为我们需要注重细节的人。”</em>\n<em>幸运的是，我最终没有在那家公司上班。</em></p>\n</blockquote>\n<p>你怎么看这个问题？</p>\n<h2 class=\"heading\" data-id=\"heading-10\">4. 自动插入分号</h2>\n<h4 class=\"heading\" data-id=\"heading-11\">问题</h4>\n<p><code>arrayFromValue()</code> 返回什么值？</p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> arrayFromValue(item) {\n  <span class=\"hljs-built_in\">return</span>\n    [items];\n}\n\narrayFromValue(10); // => ???\n<span class=\"copy-code-btn\">复制代码</span> copy-016</code></pre><h4 class=\"heading\" data-id=\"heading-12\">答案</h4>\n<p>很容易忽略<code>return</code>关键字和<code>[items]</code>表达式之间的换行。</p>\n<p>换行使JavaScript自动在<code>return</code>和<code>[items]</code>表达式之间插入一个分号。</p>\n<p>这里有一段等价的代码，它在<code>return</code>后插入分号：</p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> arrayFromValue(item) {\n  <span class=\"hljs-built_in\">return</span>;  [items];\n}\n\narrayFromValue(10); // => undefined\n<span class=\"copy-code-btn\">复制代码</span> copy-017</code></pre><p>函数中的 <code>return;</code> 导致它返回 <code>undefined</code>。</p>\n<p>因此 <code>arrayFromValue(10)</code> 的值是 <code>undefined</code>。</p>\n<p>查看 <a target=\"_blank\" href=\"https://dmitripavlutin.com/7-tips-to-handle-undefined-in-javascript/#24-function-return-value\" rel=\"nofollow noopener noreferrer\">这篇文章</a> 阅读更多关于自动插入分号的内容。</p>\n<h2 class=\"heading\" data-id=\"heading-13\">5. 经典问题：坑爹的闭包</h2>\n<h4 class=\"heading\" data-id=\"heading-14\">问题</h4>\n<p>以下脚本将会在控制台输出什么：</p>\n<pre><code class=\"hljs bash copyable code-07\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> i;\n<span class=\"hljs-keyword\">for</span> (i = 0; i < 3; i++) {\n  const <span class=\"hljs-built_in\">log</span> = () => {\n    console.log(i);  }\n  <span class=\"hljs-built_in\">set</span>Timeout(<span class=\"hljs-built_in\">log</span>, 100);\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-018</code></pre><h4 class=\"heading\" data-id=\"heading-15\">答案</h4>\n<p>如果你之前没有听说过这个棘手的问题，你的答案很可能是<code>0</code>, <code>1</code> 和 <code>2</code>，这是不正确的。当我第一次尝试解答它时，我的答案也是这样！</p>\n<p>执行这个代码段包含两个步骤。\n<strong>步骤 1</strong></p>\n<ol>\n<li><code>for()</code>迭代3次。在每次迭代过程中，都会创建一个新的函数<code>log()</code>，它捕获变量 <code>i</code>。然后<code>setTimout()</code>执行<code>log()</code>。</li>\n<li>当<code>for()</code>循环完成时，<code>i</code>变量的值为<code>3</code>。</li>\n</ol>\n<p><code>log()</code>是一个捕获变量 <code>i</code> 的闭包，它在<code>for()</code>循环的外部作用域定义。重要的是要理解闭包从词法上捕获了<em>变量</em><code>i</code> 。\n<strong>步骤 2</strong></p>\n<p>第2步在 100 毫秒后发生：</p>\n<p><code>setTimeout()</code>调用了队列中的3个<code>log()</code> 回调。<code>log()</code> 读取变量 <code>i</code>的<em>当前值</em>，即<code>3</code>，并记录到控制台<code>3</code>。</p>\n<p>这就是为什么控制台输出<code>3</code>, <code>3</code> 和<code>3</code>。</p>\n<p><em>你知道怎样让代码输出 <code>0</code>, <code>1</code>, 和 <code>2</code>吗？请在评论里写出你的方案。</em></p>\n<h2 class=\"heading\" data-id=\"heading-16\">6. 浮点数问题</h2>\n<h4 class=\"heading\" data-id=\"heading-17\">问题</h4>\n<p>等号判断的结果是什么？</p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">0.1 + 0.2 === 0.3 // => ???\n<span class=\"copy-code-btn\">复制代码</span> copy-019</code></pre><h4 class=\"heading\" data-id=\"heading-18\">答案</h4>\n<p>首先，我们看看<code>0.1 + 0.2</code> 的值：</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">0.1 + 0.2; // => 0.30000000000000004\n<span class=\"copy-code-btn\">复制代码</span> copy-020</code></pre><p><code>0.1</code> 和 <code>0.2</code> 的和 <em>不完全等于</em>  <code>0.3</code>，而是略大于 <code>0.3</code>。</p>\n<p>由于浮点数在二进制中的编码机制，像浮点数的加法这样的操作会受到舍入误差的影响。</p>\n<p>简单地说，直接比较浮点数是不精确的。</p>\n<p>因此 <code>0.1 + 0.2 === 0.3</code> 是 <code>false</code>.</p>\n<p>查看 <a target=\"_blank\" href=\"https://0.30000000000000004.com/\" rel=\"nofollow noopener noreferrer\">0.30000000000000004.com</a> 获取更多信息。</p>\n<h2 class=\"heading\" data-id=\"heading-19\">7. 变量提升</h2>\n<h4 class=\"heading\" data-id=\"heading-20\">问题</h4>\n<p>如果在声明之前访问<code>myVar</code>和<code>myConst</code>会发生什么?</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\">myVar;   // => ???myConst; // => ???\nvar myVar = <span class=\"hljs-string\">'value'</span>;\nconst myConst = 3.14;\n<span class=\"copy-code-btn\">复制代码</span> copy-021</code></pre><h4 class=\"heading\" data-id=\"heading-21\">答案</h4>\n<p>变量提升和暂时性死区是影响JavaScript变量生命周期的两个重要概念。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e446efb4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"1086\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"1086\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>在声明之前访问 <code>myVar</code> 结果为<code>undefined</code>。一个被提升的<code>var</code>变量，在它的初始化之前，有一个 <code>undefined</code>的值。</p>\n<p>但是，在声明之前访问<code>myConst</code>会抛出 <code>ReferenceError</code>。在声明行<code>const myConst = 3.14</code>之前，<code>const</code> 变量处于暂时死区。</p>\n<p>查看指南 <a target=\"_blank\" href=\"https://dmitripavlutin.com/javascript-hoisting-in-details/\" rel=\"nofollow noopener noreferrer\">JavaScript 变量提升详解</a> ，彻底掌握变量提升的概念。</p>\n<h2 class=\"heading\" data-id=\"heading-22\">8. 思考</h2>\n<p>你可以认为有些问题对面试毫无用处。我也有同样的感觉，尤其是关于<a target=\"_blank\" href=\"https://dmitripavlutin.com/simple-but-tricky-javascript-interview-questions/#3-eagle-eye-test\" rel=\"nofollow noopener noreferrer\">鹰眼测试</a>。尽管如此，还是有人会问这些问题。</p>\n<p>不管怎样，这些问题中的大多数都可以测试你是否熟悉JavaScript。如果你在阅读这篇文章的时候很难答出其中一些问题，这就是提示你接下来要学习什么了!</p>\n<p><em>在面试中问一些刁钻的问题公平吗？说说你的看法。</em></p>\n<p><a target=\"_blank\" href=\"https://dmitripavlutin.com/simple-but-tricky-javascript-interview-questions/\" rel=\"nofollow noopener noreferrer\">原文</a></p>\n<h4 class=\"heading\" data-id=\"heading-23\">交流</h4>\n<p>欢迎关注我的微信公众号“1024译站”，为你奉上更多技术干货！\n</p><figure><img alt=\"公众号：1024译站\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e2f103587468a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"129\" data-height=\"129\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"129\" height=\"129\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2ktvteae0nm0",
      "author": "云中桥",
      "title": "7道简单的 JavaScript 面试题，三个月没招到一个人",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>推荐一款优秀的UI框架<br>\n原文链接：<a target=\"_blank\" href=\"https://juejin.im/post/5dbbfe7a51882521d67c2858\" rel>juejin.im/post/5dbbfe…</a></p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-0\">来迎接一款让你心动的UI框架</h1>\n<p>今天要为大家安利的是冰山工作室出即将推出的前端框架CMUI，本文会抽取框架的一部分进行介绍（布局，列表，动态辅助），让你了解一下这款框架的强大与便捷，但这只是框架的冰山一角。如果你想了解更加详细的信息，可以破解本文底部的二维码，加入我们的群聊来获取。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">起源</h2>\n<p>2011左右的时候我开始着手研究响应式网页设计，并基于less语言设计了一套CSS布局框架，起初的设计包括12列，15列，16列三种结构，最终确定了12+15差值双列的结构，并考虑申请相应的专利，意外的是几个月之后推特发布了前端界家喻户晓的bootstrap框架。后来我进入一家建站公司并基于这套样式框架开发了一个高速建站系统feebless（一款Windows下的应用程序），为了防止以后有新的想法做出来之后没有推广而落后于人的情况发生，还在系统上线后对响应式结构申请了对应专利保护（<a target=\"_blank\" href=\"http://cprs.patentstar.com.cn/Search/Detail?ANE=9CHC9EFA6DCA9AIC9BIB4DBA2AAAFHIA9HAG8GAA9BIF9EHF\" rel=\"nofollow noopener noreferrer\">点击了解一下</a>），这是现在要为大家介绍的CMUI最早的雏形，值得庆幸的是我在准备这篇文章的时候竟然翻到了9年前的手稿，当你了解CMUI之后再后头看这些手稿的时候你会发现很多当年残留的影子或者一些思想雏形，包括组件化，异步组件，高速布局，组合，继承等。</p>\n<p>14年左右的时候我基于模板引擎封装了一套UI系统，取名为CMUI，后用VUE重新封装为组件库用于我们的项目，在我们的实际使用中发现这套结构的开发效率非常之高，并且能够精准匹配设计稿，现在我们决定将其重新封装并开源，希望更多的开发者能够参与其中。</p>\n<h3 class=\"heading\" data-id=\"heading-2\">九年前的手稿</h3>\n<p></p><figure><img alt=\"2011年双列差值网格系统手稿\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/30/16e1d1a062ba6704?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"645\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"645\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">重要说明</h2>\n<h3 class=\"heading\" data-id=\"heading-4\">真假美猴王</h3>\n<p>CMUI是框架的简称，GitHub上的CMUI并不是本次介绍的框架。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">专利保护</h3>\n<p>CMUI以MIT协议进行开源，你可以随意使用到你的项目中，但是其内部的部分结构（如布局系统，组合样式）依旧受专利保护，如果你需要应用到你的框架并再次发布，请提前联系我们，以免引起对应法律纠纷。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">PC端还是移动端</h3>\n<p>CMUI主要用于移动端，但是样式部分完全适用于PC端，组件方面PC端使用的组件目前提供的还不全面。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">为什么要自己写一套组件库？</h2>\n<p>虽然目前市面上有非常多的组件库，其中也有一很多非常优秀的代表，但是存在一些非技术性的问题</p>\n<h3 class=\"heading\" data-id=\"heading-8\">糟糕的C端应对方案</h3>\n<p>你所知的大部分框架大量保留了bootstrap的思想，这一点从栅格系统和按钮及表单的描述就能看出来，我始终不认为用success表示绿色，用primary代表主色是一个优秀的方案，这种结构的优势在于开发没有设计师参与的项目时（如中台系统）可以达到风格的高度统一并且实现主题变色，但是如果针对C端开发，设计稿千变万化，尤其是你的设计团队并不十分严格的情况下就会变得非常尴尬。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">完善不代表适用</h3>\n<p>提供了完善的组件系统，小到一个按钮，大到完善的表单，首先要承认这是非常优秀的设计，但并不是最实用的。因为你可能只需要用到一种样式上的展示，却要引入一个完整的组件，当然你可以只引入它的样式文件，但是如果你这么做，你就需要记忆大量的class命名，并且在很多情况下根据你的需要去重写默认的样式。比如下面这样</p>\n<ol>\n<li>\n<pre><code class=\"hljs html copyable code-00\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"xx-button xx-button--text\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"float: right;padding: 3px 0px;\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>操作按钮<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-014</code></pre></li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-10\">我一眼就知道你是谁</h3>\n<p>如果你使用了一套UI框架，在你不进行海量修改的的情况下几乎一眼就能看出是哪个框架搭建的，就像所有使用bootstrap搭建的网站几乎都长得差不多。</p>\n<h3 class=\"heading\" data-id=\"heading-11\">API是个头痛的问题</h3>\n<p>记忆API和使用方式是一件非常麻烦的事情，当你使用一套UI框架进行页面开发的时候，脱离了官网的DEMO和API文档，你可能寸步难行，当你想实现一个类似的效果的时候，你也许会经常把代码来回复制，以防止写错。</p>\n<h3 class=\"heading\" data-id=\"heading-12\">你只是个使用者而非创造者</h3>\n<p>如果你使用了一款UI框架，而在这套框架里没有提供你所需的UI功能，这就变的非常尴尬，如果你再次封装，可能你的结构可能和原有的结构完全不搭，甚至完全没有关系，换句话讲，你只是一款工具的使用者，而非基于一款工具的创造者。</p>\n<h2 class=\"heading\" data-id=\"heading-13\">抛砖引玉的开始</h2>\n<h3 class=\"heading\" data-id=\"heading-14\">简介</h3>\n<p>现在要为大家介绍的框架名为CMUI，这只是一个简称，一共包括三个部分：样式库，组件库，方法库，每个部分都可以独立使用，你甚至可以直接把它直接插入你的项目，和你现在所使用的UI库一起使用。</p>\n<p>**样式库：**全称cyan，就是赤橙黄绿青蓝紫中你唯一不会的那个英文单词（这一点非常重要）使用sass对css进行了重新的抽取和封装，基于这套样式库你几乎可以在不书写额外的CSS的情况下，仅凭借样式组合完成页面的拆分。更重要的是所有的命名都简单到令人发指，以至于在你用过一次之后再也不需要去看API文档。</p>\n<p>**组件库：**得益于样式库提供了强大的VIEW层展示，因此我们提供的组件也相对较少，仅在单凭样式无法解决的问题上提供对应的组件，其目的也是为了降低开发者的门槛</p>\n<p>**方法库：**这里对常用的WEB功能提供了对应的方法，用于减少你的代码量</p>\n<p>无图无真相，秀个logo</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e265bafe095dd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"292\" data-height=\"292\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"292\" height=\"292\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-15\">Cyan不让你思考，不让你写错</h3>\n<p>我们在开发的过程中为模块起名字是一个非常痛苦而费脑的过程。主要包括以下几个方面：</p>\n<ul>\n<li>命名中存在不常用的英文单词，不易理解和阅读（你一定用过百度翻译😁）</li>\n<li>模块在经过多次需求修改后名称已经和实际用途不相符</li>\n<li>两个样式完全相同的模块使用不同的命名，多次编写样式，比如一个品牌列表和一个用户列表在样式上完全相同，鬼知道你的产品和设计什么时候会修改，那么你该如何复用？</li>\n<li>同一个页面存在两个类似的模块时命名混乱，如porductTop productBottom productRecommend productNew</li>\n<li>为准确描述而使用过长的名称</li>\n<li>...</li>\n</ul>\n<p>为了解决这一问题，Cyan在命名上做了大量的调研和优化，我们希望我们用到的单词所有人都能一次理解，所有人都能一次写对，先来看一下样式库默认的的所有关键字。</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">颜色类：red orange yellow green cyan blue purple coffee\n调整类：margin padding top left bottom center full\n边框类：border item radius round light shadow pill\n尺寸类：big small block\n元素类：img form swich btn reverse badge\n布局类：flex ratio list item img scroll container\n辅助类：disabled square <span class=\"hljs-built_in\">float</span> pos clearfix overflow delete justify <span class=\"hljs-built_in\">limit</span> fixed\n<span class=\"copy-code-btn\">复制代码</span> copy-015</code></pre><p>你看到的这些词就是CMUI样式库整合后的的全部class名称，其中颜色类和尺寸类是用户自定义的，你可能很难想象紧靠这些简单的单词就能完成一个页面的拆分，但事实确实如此。</p>\n<h3 class=\"heading\" data-id=\"heading-16\">随手写个京东</h3>\n<p>我们先用Cyan的结构来还原一个京东首页商品列表作为一个小小的DEMO。</p>\n<pre><code class=\"hljs html copyable code-02\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list list-col2 border\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"ratio-container img-container\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"图片地址\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\" reverse red badge square pos-a top10 left10\"</span>></span>抢<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"padding10\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"text-limit2 fs-13\"</span>></span>日本进口FaSoLa 瓷砖贴纸对角贴 美缝地板贴防水耐磨地贴客厅装饰墙贴自粘 波西风情(12个/张) 大<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex-container margint10\"</span>></span>\n                <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"text-delete text-light marginr10\"</span>></span>999<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n                <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"text-red fs-13 right\"</span>></span>222<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n              \t<span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"badge reverse\"</span>></span>找相似<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n            <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>\n        <span class=\"hljs-comment\"><!--此处代码和上面的相同--></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-016</code></pre><p>输出效果</p>\n<img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1dbe3e52d8f79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"708\" data-height=\"1064\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"708\" height=\"1064\"></svg>\">\n<h3 class=\"heading\" data-id=\"heading-17\">描述型样式库</h3>\n<p>在这案例中你可以看到我们没有使用任何额外的CSS就完成了样式布局。使用Cyan样式库的一个特点就是你不需要关心你做的是什么，你只需要将你看到的设计稿用class组合描述出来就可以。从另一个角度来说，当你看到HTML结构的时候，你不需要看页面就知道最终的效果是什么样子，因此我们将Cyan称为描述型样式库。</p>\n<h3 class=\"heading\" data-id=\"heading-18\">业务逻辑拓展库</h3>\n<p>虽然我认为起名字是个非常麻烦的事情，但是如果你觉得使用class进行描述不是你的风格，一定要使用标识业务的命名，你还可以直接引用我们的拓展库。</p>\n<pre><code class=\"hljs html copyable code-03\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"productList\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"productItem\"</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"productImg\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"productName\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"productInfo\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"info_oldPrice\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>      \n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"info_newPrice\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"p_find\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-017</code></pre><pre><code class=\"hljs scss copyable code-04\" lang=\"scss\">@<span class=\"hljs-keyword\">import</span> cyan/<span class=\"hljs-keyword\">extend</span>;\n<span class=\"hljs-selector-class\">.productList</span>{\n    @<span class=\"hljs-keyword\">extend</span> list;\n    <span class=\"hljs-selector-class\">.productItem</span>{@<span class=\"hljs-keyword\">extend</span> list-item;}\n    <span class=\"hljs-selector-class\">.productImg</span>{ @<span class=\"hljs-keyword\">extend</span> ratio-container img-container;}\n    <span class=\"hljs-selector-class\">.productName</span>{@<span class=\"hljs-keyword\">extend</span> text-limit2 fs-13;}\n    <span class=\"hljs-selector-class\">.productInfo</span>{\n        @<span class=\"hljs-keyword\">extend</span> flex-container margint10;\n        <span class=\"hljs-selector-class\">.info_oldPrice</span>{@<span class=\"hljs-keyword\">extend</span> text-delete text-light marginl10}\n        .info_newPrice{@<span class=\"hljs-keyword\">extend</span> text-red fs-13 right}\n        .p_find{@<span class=\"hljs-keyword\">extend</span> badge reverse}\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-018</code></pre><h2 class=\"heading\" data-id=\"heading-19\">真正的开篇</h2>\n<h3 class=\"heading\" data-id=\"heading-20\">六大布局容器</h3>\n<p>Cyan提供了6个布局容器，几乎可以满足你所有的布局需求，一起来看一下</p>\n<h4 class=\"heading\" data-id=\"heading-21\">网格容器</h4>\n<p>类似于bootstrap的栅格系统，同时提供12或15两种阵列方式。</p>\n<h4 class=\"heading\" data-id=\"heading-22\">盒容器</h4>\n<p>与网格容器唯一的区别是没有间距。</p>\n<p>网格容器和盒容器是由于历史原因以及今后要在PC端实现实现响应式而保留下来的，在实际的移动端开发中并不常用，当然如果你习惯了使用栅格系统也完全可以使用。</p>\n<h4 class=\"heading\" data-id=\"heading-23\">比例容器</h4>\n<p>在任何宽度内创建任何比例的区域，通常用于制作头像或商品列表，比如上面的案例，视窗宽度不固定，两列之间的的间距甚至列数设计随时有可能调整，使用的图片不一定是正方形，还要保证图片以某种比例（通常是一比一）进行展现，此时你会用到比例容器。</p>\n<blockquote>\n<p>为了方便你理解，我们先用网格系统来创建列，后面会有更好的方式</p>\n</blockquote>\n<pre><code class=\"hljs html copyable code-05\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"row\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"span6 margint20\"</span>></span> 先不用关心这个margint20是干什么用的，虽然你能猜出来\n      <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"ratio-container\"</span>></span>此处添加比例容器，内部节点默认会以1：1进行展示\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span>\n      <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-019</code></pre><p>输出效果</p>\n<p>​\t</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659f3c986f9b?imageslim\" data-width=\"389\" data-height=\"625\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"389\" height=\"625\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>你可以看到在无论可视区宽度是多少，图片均已固定比例展示，如果你需要其他的比例尺寸，直接在后面标识出来就可以了</p>\n<pre><code class=\"hljs html copyable code-06\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"ratio-container\"</span> <span class=\"hljs-attr\">ratio</span>=<span class=\"hljs-string\">\"2:3\"</span>></span>\n  这里的节点会以2：3的比例展示\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-020</code></pre><p>比例容器的作用不光如此，他还可以实现非常多的效果，比如下面这样，你能想到怎么做吗?我们后面再说</p>\n<img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1dbe3a69ff3d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"946\" data-height=\"1266\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"946\" height=\"1266\"></svg>\">\n<h4 class=\"heading\" data-id=\"heading-24\">图片容器</h4>\n<p>直接将图片放入比例容器会产生一个问题，就是如果使用的图片不是对应比例的，会被拉伸变形，这一定不是你想要的，因此我们需要图片容器。只需要添加几个额外的class他就能支持非常多的效果，可以满足你的各种需要，</p>\n<pre><code class=\"hljs html copyable code-07\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"img-container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span> 图片默认显示在容器居中的位置\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"img-container round\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span> 图片将以圆形显示\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-021</code></pre><p>为了方便你理解案例中使用了不同数字来标识位置，选项中蓝色的字就是你可以额外添加的class，而且可以随意组合，你能用到的所有图片展示效果都可以组装出来。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659f45605386?imageslim\" data-width=\"697\" data-height=\"619\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"697\" height=\"619\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-25\">滚动容器</h4>\n<p>想创建一个如丝般顺滑的滚动展示效果何须那么麻烦，一个class搞定</p>\n<pre><code class=\"hljs html copyable code-08\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"scroll-container\"</span>></span>默认是横向滚动\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span>/></span>\n\t...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"scroll-container-y\"</span>></span>如果是纵向的滚动就加个-y\n  ...\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-022</code></pre><p>效果</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1dbe3a9b6d9b1?imageslim\" data-width=\"320\" data-height=\"420\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"420\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-26\">flex容器</h4>\n<p>我想你一定记不住CSS3中flex的具体用法，因此我们对flex进行了细致的封装，形成了这个最为强大的布局容器，他的功能可以说是丧心病狂，但是用法之简单却令人发指。</p>\n<pre><code class=\"hljs html copyable code-09\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex-container\"</span>></span>\n  这里填写内部结构，横向排列\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex-container-col\"</span>></span>\n  这里填写内部结构，纵向排列\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-023</code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1dbe3abecd4dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"500\" data-height=\"330\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"500\" height=\"330\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>WTF?这就完了，嗯，完了，你没看错，就是这么简单。下面来看看它都能完成那些操作</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659f84b467a0?imageslim\" data-width=\"686\" data-height=\"502\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"686\" height=\"502\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>你可以额外添加下面4种类别，一共10个辅助class，他可以满足你的任何需求，如果直接添加到外层节点可以对所有子节点统一控制，如果添加到子节点上，可以额外的对子节点进行单独的控制。</p>\n<table>\n<thead>\n<tr>\n<th>间隔类型选择</th>\n<th>顺序翻转</th>\n<th>位置控制</th>\n<th>子节点横纵向填满</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>round/between</td>\n<td>reverse</td>\n<td>top/left/right/bottom/center</td>\n<td>vfull/hfull</td>\n</tr>\n</tbody>\n</table>\n<p>我想这些API的封装已经简单到让我懒得去解释其作用了。妈妈再也不用担心我记不住flex的用法了。</p>\n<h4 class=\"heading\" data-id=\"heading-27\">总结</h4>\n<p>容器类能够实现的布局非常强大，而且使用起来非常简单，所有的关键字class都是非常常用的，更重要的是他们还可以随意组合，来实现更加复杂的布局，从你用上Cyan开始，你已经是一个创造者，限制你的不是框架功能，而是你的想象力。</p>\n<h3 class=\"heading\" data-id=\"heading-28\">列表</h3>\n<p>容器类的功能已经足够强大，但是仍有很大的改进空间。比如我们要实现一个5列的导航，可以使用下面三种方式。</p>\n<pre><code class=\"hljs html copyable code-010\" lang=\"html\">方式一：网格容器或盒容器\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"row\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"col3 text-center\"</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in  5\"</span>></span>\n    \t<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>导航{{i}}<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n方式二：flex容器\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex-container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex1 text-center\"</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in  5\"</span>></span>\n  \t<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>导航{{i}}<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n方式三：滚动容器\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"scroll-container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in  5\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width:20%\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"text-center\"</span>></span>\n  \t<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>导航{{i}}<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-024</code></pre><img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659fadbdfb05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"782\" data-height=\"192\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"782\" height=\"192\"></svg>\">\n<p>但是如果有两排或者更多排呢？网格容器可以无修改继续使用，flex容器需要添加换行属性，并设置每一个的宽度，滚动容器已经不能使用了（除非放置两个滚动容器）</p>\n<pre><code class=\"hljs html copyable code-011\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex-container\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"text-center wrap\"</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in  10\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width:20%\"</span>></span>\n  \t<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>导航{{i}}<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-025</code></pre><img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659fb34217fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"776\" data-height=\"384\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"776\" height=\"384\"></svg>\">\n<p>如果此时需要添加分割线呢？你当然可以为使用我们的边框类为节点添加一个border的class，但是这会导致相邻的边框加粗。虽然通过添加我们提供的辅助类完全可以处理这些问题，但是都显得麻烦，因此我们需要list类</p>\n<h4 class=\"heading\" data-id=\"heading-29\">基础list</h4>\n<p>list类可以随意控制列数以及边框的显示，每一列所占的宽度均相等，并且自动在每行的第一个进行浮动的清除，以保证即使在每一项高度不同的时候也能很好的展示。与此同时你可以在将list和前面讲过的布局类容器随意组合，在此基础上没有什么布局结构能够难得住你了。</p>\n<pre><code class=\"hljs html copyable code-012\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list list-col5 border\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item padding20 text-center\"</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in  10\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>></span><span class=\"hljs-tag\"><<span class=\"hljs-name\">span</span>></span>导航{{i}}<span class=\"hljs-tag\"></<span class=\"hljs-name\">span</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-026</code></pre><img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659ff32e7b0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"774\" data-height=\"414\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"774\" height=\"414\"></svg>\">\n<h4 class=\"heading\" data-id=\"heading-30\">组件list</h4>\n<p>现在考虑下面几种更复杂的情况：</p>\n<ul>\n<li>list的每一项宽度不同</li>\n<li>每一项之间有间隔</li>\n<li>边框颜色不同意，甚至有的有，有的没有</li>\n<li>list需要分组，形成类似通讯录的页面效果</li>\n</ul>\n<p>前三种情况通过list 和flex-container的组合可以解决，但是需要多写一层DIV，第四种情况需要单独开发虽然并不复杂。此时我们可以开始使用我们的组件系统了。</p>\n<pre><code class=\"hljs html copyable code-013\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">cmui-list</span> <span class=\"hljs-attr\">:col</span>=<span class=\"hljs-string\">'[2,7,5]'</span> <span class=\"hljs-attr\">:space</span>=<span class=\"hljs-string\">'20'</span> <span class=\"hljs-attr\">border</span>=<span class=\"hljs-string\">'#ab2c4f'</span>></span>三列2：7：5展示，间距20，边框颜色#ab2c4f\n\t<span class=\"hljs-tag\"><<span class=\"hljs-name\">cmui-list-item</span>></span>\n    ...\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">cmui-list-item</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">cmui-list</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-027</code></pre><p>通过组件我们可以随意设置每一列所占的比例，边框，间距，在item上我们同样可以对这些属性进行微调，如果边框贴合，会自动合并，而且可以无限嵌套，如此一来所有的行列结构就都能实现，通常这种结构会在广告位的展示上使用，</p>\n<img style=\"zoom:50%;\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659f87a8b2be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"736\" data-height=\"1100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"736\" height=\"1100\"></svg>\">\n<h3 class=\"heading\" data-id=\"heading-31\">动态辅助</h3>\n<p>布局搞定了，但只是结构相似，想要完美匹配设计稿还需要微调，padding/margin /top/bottom/left/right这些值在不同的设计稿中变数非常大，好在移动端屏幕尺寸较小，只需要将所有可能的值提前在CSS中定义好就可以了。padding12表示12像素响应式填充，paddingh12表示只有水平方向填充。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1dbe3abecd4dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"500\" data-height=\"330\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"500\" height=\"330\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>开玩笑的，CMUI会自动解析你的html结构，并监听符合格式的class定义，当你为一个DOM节点添加paddingXXX的class的时候，会自动在动态样式表中生成对应的样式，并且根据不同的设备响应成不同的值。你只需要直接用就行了。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/1/16e2659fa4040690?imageslim\" data-width=\"729\" data-height=\"432\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"729\" height=\"432\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-32\">提前尝鲜</h2>\n<p>前文说过，CMUI包括三个模块，本文也仅对Cyan中的的布局，组件库中的列表，方法库中的动态辅助做了简介，CMUI的功能远不止如此，我们正在对文档，案例，主题库做最后的完善，如果你想提前尝鲜，可以点击下方链接破解我们官网的二维码，加入我们的讨论群来获取。</p>\n<p><a target=\"_blank\" href=\"http://www.bingshangroup.com/#/qc\" rel=\"nofollow noopener noreferrer\">有本事来扫个码啊</a></p>\n",
      "id": "3o06m3x909k0",
      "author": "云音乐前端技术团队",
      "title": "来迎接一款让你心动的UI框架",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">1. 内容概要</h2>\n<p>本文主要讨论以下两个问题：</p>\n<ul>\n<li>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</li>\n<li>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-1\">2. JavaScript 位运算</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">2.1. Number</h3>\n<p>在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。</p>\n<p>在 JavaScript 里，数字均为<a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8\" rel=\"nofollow noopener noreferrer\">基于 IEEE 754 标准的双精度 64 位的浮点数</a>，引用维基百科的图片，它的结构长这样：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e436aa3a4ad2e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"594\" data-height=\"96\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"594\" height=\"96\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li>sign bit（符号）: 用来表示正负号</li>\n<li>exponent（指数）: 用来表示次方数</li>\n<li>mantissa（尾数）: 用来表示精确度</li>\n</ul>\n<p>也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。</p>\n<blockquote>\n<p>既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 <a target=\"_blank\" href=\"https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors\" rel=\"nofollow noopener noreferrer\">math.js</a> 等工具库。</p>\n</blockquote>\n<p>此外还有四种数字进制：</p>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-comment\">// 十进制</span>\n<span class=\"hljs-number\">123456789</span>\n<span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\">// 二进制：前缀 0b，0B</span>\n<span class=\"hljs-number\">0b10000000000000000000000000000000</span> <span class=\"hljs-comment\">// 2147483648</span>\n<span class=\"hljs-number\">0b01111111100000000000000000000000</span> <span class=\"hljs-comment\">// 2139095040</span>\n<span class=\"hljs-number\">0B00000000011111111111111111111111</span> <span class=\"hljs-comment\">// 8388607</span>\n\n<span class=\"hljs-comment\">// 八进制：前缀 0o，0O（以前支持前缀 0）</span>\n<span class=\"hljs-number\">0o755</span> <span class=\"hljs-comment\">// 493</span>\n<span class=\"hljs-number\">0o644</span> <span class=\"hljs-comment\">// 420</span>\n\n<span class=\"hljs-comment\">// 十六进制：前缀 0x，0X</span>\n<span class=\"hljs-number\">0xFFFFFFFFFFFFFFFFF</span> <span class=\"hljs-comment\">// 295147905179352830000</span>\n<span class=\"hljs-number\">0x123456789ABCDEF</span>   <span class=\"hljs-comment\">// 81985529216486900</span>\n<span class=\"hljs-number\">0XA</span>                 <span class=\"hljs-comment\">// 10</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-09</code></pre><p>好了，Number 就说这么多，接下来看 JavaScript 中的位运算。</p>\n<h3 class=\"heading\" data-id=\"heading-3\">2.2. 位运算</h3>\n<p>按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">用法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">按位与（AND）</td>\n<td style=\"text-align:left\"><code>a & b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位或（OR）</td>\n<td style=\"text-align:left\"><code>a | b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位异或（XOR）</td>\n<td style=\"text-align:left\"><code>a ^ b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位非（NOT）</td>\n<td style=\"text-align:left\"><code>~a</code></td>\n<td style=\"text-align:left\">反转操作数的比特位，即 0 变成 1，1 变成 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">左移（Left shift）</td>\n<td style=\"text-align:left\"><code>a << b</code></td>\n<td style=\"text-align:left\">将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有符号右移</td>\n<td style=\"text-align:left\"><code>a >> b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">无符号右移</td>\n<td style=\"text-align:left\"><code>a >>> b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>\n</tr>\n</tbody>\n</table>\n<p>下面举几个例子，主要看下 <code>AND</code> 和 <code>OR</code>：</p>\n<pre><code class=\"hljs shell copyable code-01\" lang=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 例子1</span>\n    A = 10001001\n    B = 10010000\nA | B = 10011001\n<span class=\"hljs-meta\">\n#</span><span class=\"bash\"> 例子2</span>\n    A = 10001001\n    C = 10001000\nA | C = 10001001\n<span class=\"copy-code-btn\">复制代码</span> copy-010</code></pre><pre><code class=\"hljs shell copyable code-02\" lang=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 例子1</span>\n    A = 10001001\n    B = 10010000\nA & B = 10000000\n<span class=\"hljs-meta\">\n#</span><span class=\"bash\"> 例子2</span>\n    A = 10001001\n    C = 10001000\nA & C = 10001000\n<span class=\"copy-code-btn\">复制代码</span> copy-011</code></pre><h2 class=\"heading\" data-id=\"heading-4\">3. 位运算在权限系统中的使用</h2>\n<p>传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。</p>\n<p>在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，<strong>下文所有的讨论都是基于这两个前提的</strong>：</p>\n<ol>\n<li>每种权限码都是唯一的（这是显然的）</li>\n<li>所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（<code>2^n</code>）</li>\n</ol>\n<p>如果用户权限和权限码，全部使用二级制数字表示，再结合上面 <code>AND</code> 和 <code>OR</code> 的例子，分析位运算的特点，不难发现：</p>\n<ul>\n<li><code>|</code> 可以用来赋予权限</li>\n<li><code>&</code> 可以用来校验权限</li>\n</ul>\n<p>为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限</th>\n<th style=\"text-align:left\">字母表示</th>\n<th style=\"text-align:left\">数字表示</th>\n<th style=\"text-align:left\">二进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">读</td>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0b100</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">写</td>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">0b010</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">执行</td>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0b001</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，权限用 1、2、4（也就是 <code>2^n</code>）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">3.1. 添加权限</h3>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-keyword\">let</span> r = <span class=\"hljs-number\">0b100</span>\n<span class=\"hljs-keyword\">let</span> w = <span class=\"hljs-number\">0b010</span>\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0b001</span>\n\n<span class=\"hljs-comment\">// 给用户赋全部权限（使用前面讲的 | 操作）</span>\n<span class=\"hljs-keyword\">let</span> user = r | w | x\n\n<span class=\"hljs-built_in\">console</span>.log(user)\n<span class=\"hljs-comment\">// 7</span>\n\n<span class=\"hljs-built_in\">console</span>.log(user.toString(<span class=\"hljs-number\">2</span>))\n<span class=\"hljs-comment\">// 111</span>\n\n<span class=\"hljs-comment\">//     r = 0b100</span>\n<span class=\"hljs-comment\">//     w = 0b010</span>\n<span class=\"hljs-comment\">//     r = 0b001</span>\n<span class=\"hljs-comment\">// r|w|x = 0b111</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-012</code></pre><p>可以看到，执行 <code>r | w | x</code> 后，<code>user</code> 的三位都是 1，表明拥有了全部三个权限。</p>\n<blockquote>\n<p>Linux 下出现权限问题时，最粗暴的解决方案就是 <code>chmod 777 xxx</code>，这里的 <code>7</code> 就代表了：可读，可写，可执行。而三个 <code>7</code> 分别代表：文件所有者，文件所有者所在组，所有其他用户。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-6\">3.2. 校验权限</h3>\n<p>刚才演示了权限的添加，下面演示权限校验：</p>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-keyword\">let</span> r = <span class=\"hljs-number\">0b100</span>\n<span class=\"hljs-keyword\">let</span> w = <span class=\"hljs-number\">0b010</span>\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0b001</span>\n\n<span class=\"hljs-comment\">// 给用户赋 r w 两个权限</span>\n<span class=\"hljs-keyword\">let</span> user = r | w\n<span class=\"hljs-comment\">// user = 6</span>\n<span class=\"hljs-comment\">// user = 0b110 (二进制)</span>\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// true  有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-013</code></pre><p>如前所料，通过 <code>用户权限 & 权限 code === 权限 code</code> 就可以判断出用户是否拥有该权限。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">3.3. 删除权限</h3>\n<p>我们讲了用 <code>|</code> 赋予权限，使用 <code>&</code> 判断权限，那么删除权限呢？删除权限的本质其实是<strong>将指定位置上的 1 重置为 0</strong>。上个例子里用户权限是 <code>0b110</code>，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 <code>0b010</code>：</p>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\"><span class=\"hljs-keyword\">let</span> r = <span class=\"hljs-number\">0b100</span>\n<span class=\"hljs-keyword\">let</span> w = <span class=\"hljs-number\">0b010</span>\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0b001</span>\n\n<span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-number\">0b010</span>;\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// false 没有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-014</code></pre><p>那么具体怎么操作呢？其实有两种方案，最简单的就是异或 <code>^</code>，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：</p>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-keyword\">let</span> r    = <span class=\"hljs-number\">0b100</span>\n<span class=\"hljs-keyword\">let</span> w    = <span class=\"hljs-number\">0b010</span>\n<span class=\"hljs-keyword\">let</span> x    = <span class=\"hljs-number\">0b001</span>\n<span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-number\">0b110</span> <span class=\"hljs-comment\">// 有 r w 两个权限</span>\n\n<span class=\"hljs-comment\">// 执行异或操作，删除 r 权限</span>\nuser = user ^ r\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// false 没有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n\n<span class=\"hljs-built_in\">console</span>.log(user.toString(<span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 现在 user 是 0b010</span>\n\n<span class=\"hljs-comment\">// 再执行一次异或操作</span>\nuser = user ^ r\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// true  有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n\n<span class=\"hljs-built_in\">console</span>.log(user.toString(<span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 现在 user 又变回 0b110</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-015</code></pre><p>那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 <code>&(~code)</code>，先取反，再执行与操作：</p>\n<pre><code class=\"hljs js copyable code-07\" lang=\"js\"><span class=\"hljs-keyword\">let</span> r    = <span class=\"hljs-number\">0b100</span>\n<span class=\"hljs-keyword\">let</span> w    = <span class=\"hljs-number\">0b010</span>\n<span class=\"hljs-keyword\">let</span> x    = <span class=\"hljs-number\">0b001</span>\n<span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-number\">0b110</span> <span class=\"hljs-comment\">// 有 r w 两个权限</span>\n\n<span class=\"hljs-comment\">// 删除 r 权限</span>\nuser = user & (~r)\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// false 没有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n\n<span class=\"hljs-built_in\">console</span>.log(user.toString(<span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 现在 user 是 0b010</span>\n\n<span class=\"hljs-comment\">// 再执行一次</span>\nuser = user & (~r)\n\n<span class=\"hljs-built_in\">console</span>.log((user & r) === r) <span class=\"hljs-comment\">// false 没有 r 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & w) === w) <span class=\"hljs-comment\">// true  有 w 权限</span>\n<span class=\"hljs-built_in\">console</span>.log((user & x) === x) <span class=\"hljs-comment\">// false 没有 x 权限</span>\n\n<span class=\"hljs-built_in\">console</span>.log(user.toString(<span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 现在 user 还是 0b010，并不会新增</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-016</code></pre><h2 class=\"heading\" data-id=\"heading-8\">4. 局限性和解决办法</h2>\n<p>前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。</p>\n<p>上述的所有都有前提条件：1、<strong>每种权限码都是唯一的</strong>；2、<strong>每个权限码的二进制数形式，有且只有一位值为 1（<code>2^n</code>）</strong>。也就是说，权限码只能是 1, 2, 4, 8,...,1024,...而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 <strong>32 位</strong>比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。</p>\n<p>为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。</p>\n<p>基于权限空间，我们定义两个格式：</p>\n<ol>\n<li><strong>权限 code</strong>，字符串，形如 <code>index,pos</code>。其中 <code>pos</code> 表示 32 位二进制数中 1 的位置（其余全是 0）； <code>index</code> 表示<strong>权限空间</strong>，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。<code>index</code> 和 <code>pos</code> 使用英文逗号隔开。</li>\n<li><strong>用户权限</strong>，字符串，形如 <code>1,16,16</code>。英文逗号分隔每一个<strong>权限空间</strong>的权限值。例如 <code>1,16,16</code> 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。</li>\n</ol>\n<p>干说可能不好懂，直接上代码：</p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-comment\">// 用户的权限 code</span>\n<span class=\"hljs-keyword\">let</span> userCode = <span class=\"hljs-string\">\"\"</span>\n\n<span class=\"hljs-comment\">// 假设系统里有这些权限</span>\n<span class=\"hljs-comment\">// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个</span>\n<span class=\"hljs-keyword\">const</span> permissions = {\n  <span class=\"hljs-attr\">SYS_SETTING</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"0,0\"</span>,   <span class=\"hljs-comment\">// index = 0, pos = 0</span>\n    info: <span class=\"hljs-string\">\"系统权限\"</span>\n  },\n  <span class=\"hljs-attr\">DATA_ADMIN</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"0,8\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"数据库权限\"</span>\n  },\n  <span class=\"hljs-attr\">USER_ADD</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"0,22\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"用户新增权限\"</span>\n  },\n  <span class=\"hljs-attr\">USER_EDIT</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"0,30\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"用户编辑权限\"</span>\n  },\n  <span class=\"hljs-attr\">USER_VIEW</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"1,2\"</span>,   <span class=\"hljs-comment\">// index = 1, pos = 2</span>\n    info: <span class=\"hljs-string\">\"用户查看权限\"</span>\n  },\n  <span class=\"hljs-attr\">USER_DELETE</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"1,17\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"用户删除权限\"</span>\n  },\n  <span class=\"hljs-attr\">POST_ADD</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"1,28\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"文章新增权限\"</span>\n  },\n  <span class=\"hljs-attr\">POST_EDIT</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"2,4\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"文章编辑权限\"</span>\n  },\n  <span class=\"hljs-attr\">POST_VIEW</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"2,19\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"文章查看权限\"</span>\n  },\n  <span class=\"hljs-attr\">POST_DELETE</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"2,26\"</span>,\n    <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">\"文章删除权限\"</span>\n  }\n}\n\n<span class=\"hljs-comment\">// 添加权限</span>\n<span class=\"hljs-keyword\">const</span> addPermission = <span class=\"hljs-function\">(<span class=\"hljs-params\">userCode, permission</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"hljs-string\">\",\"</span>) : []\n  <span class=\"hljs-keyword\">const</span> [index, pos] = permission.value.split(<span class=\"hljs-string\">\",\"</span>)\n\n  userPermission[index] = (userPermission[index] || <span class=\"hljs-number\">0</span>) | <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, pos)\n\n  <span class=\"hljs-keyword\">return</span> userPermission.join(<span class=\"hljs-string\">\",\"</span>)\n}\n\n<span class=\"hljs-comment\">// 删除权限</span>\n<span class=\"hljs-keyword\">const</span> delPermission = <span class=\"hljs-function\">(<span class=\"hljs-params\">userCode, permission</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"hljs-string\">\",\"</span>) : []\n  <span class=\"hljs-keyword\">const</span> [index, pos] = permission.value.split(<span class=\"hljs-string\">\",\"</span>)\n\n  userPermission[index] = (userPermission[index] || <span class=\"hljs-number\">0</span>) & (~<span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, pos))\n\n  <span class=\"hljs-keyword\">return</span> userPermission.join(<span class=\"hljs-string\">\",\"</span>)\n}\n\n<span class=\"hljs-comment\">// 判断是否有权限</span>\n<span class=\"hljs-keyword\">const</span> hasPermission = <span class=\"hljs-function\">(<span class=\"hljs-params\">userCode, permission</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"hljs-string\">\",\"</span>) : []\n  <span class=\"hljs-keyword\">const</span> [index, pos] = permission.value.split(<span class=\"hljs-string\">\",\"</span>)\n  <span class=\"hljs-keyword\">const</span> permissionValue = <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, pos)\n\n  <span class=\"hljs-keyword\">return</span> (userPermission[index] & permissionValue) === permissionValue\n}\n\n<span class=\"hljs-comment\">// 列出用户拥有的全部权限</span>\n<span class=\"hljs-keyword\">const</span> listPermission = <span class=\"hljs-function\"><span class=\"hljs-params\">userCode</span> =></span> {\n  <span class=\"hljs-keyword\">const</span> results = []\n\n  <span class=\"hljs-keyword\">if</span> (!userCode) {\n    <span class=\"hljs-keyword\">return</span> results\n  }\n\n  <span class=\"hljs-built_in\">Object</span>.values(permissions).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">permission</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (hasPermission(userCode, permission)) {\n      results.push(permission.info)\n    }\n  })\n\n  <span class=\"hljs-keyword\">return</span> results\n}\n\n<span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`userCode: <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(userCode, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\" \"</span>)}</span>`</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`权限列表: <span class=\"hljs-subst\">${listPermission(userCode).join(<span class=\"hljs-string\">\"; \"</span>)}</span>`</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"\"</span>)\n}\n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限</span>\n\nuserCode = addPermission(userCode, permissions.POST_EDIT)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1,,16\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限; 文章编辑权限</span>\n\nuserCode = addPermission(userCode, permissions.USER_EDIT)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1073741825,,16\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限</span>\n\nuserCode = addPermission(userCode, permissions.USER_DELETE)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1073741825,131072,16\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限</span>\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1,131072,16\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span>\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1,131072,16\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span>\n\nuserCode = delPermission(userCode, permissions.USER_DELETE)\nuserCode = delPermission(userCode, permissions.SYS_SETTING)\nuserCode = delPermission(userCode, permissions.POST_EDIT)\nlog()\n<span class=\"hljs-comment\">// userCode: \"0,0,0\"</span>\n<span class=\"hljs-comment\">// 权限列表: </span>\n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n<span class=\"hljs-comment\">// userCode: \"1,0,0\"</span>\n<span class=\"hljs-comment\">// 权限列表: 系统权限</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-017</code></pre><p>除了通过引入<strong>权限空间</strong>的概念突破二进制运算的位数限制，还可以使用 <a target=\"_blank\" href=\"http://mathjs.org\" rel=\"nofollow noopener noreferrer\">math.js</a> 的 <code>bignumber</code>，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">5. 适用场景和问题</h2>\n<p>如果按照当前使用最广泛的 <a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\" rel=\"nofollow noopener noreferrer\">RBAC</a> 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：</p>\n<ul>\n<li>一个应用下有多个权限</li>\n<li>权限和角色是多对多的关系</li>\n<li>用户和角色是多对多的关系</li>\n<li>用户和权限是多对多的关系</li>\n</ul>\n<p>在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。</p>\n<p>而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：</p>\n<ul>\n<li>如何高效的查找我的权限？</li>\n<li>如何高效的查找拥有某权限的所有用户？</li>\n<li>如何控制权限的有效期？</li>\n</ul>\n<p>所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。</p>\n<h2 class=\"heading\" data-id=\"heading-10\">6. 其他方案</h2>\n<p>除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。</p>\n<p>还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 * 7 * 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。</p>\n<h2 class=\"heading\" data-id=\"heading-11\">7. 参考</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates\" rel=\"nofollow noopener noreferrer\">MDN：JavaScript 数字和日期</a></li>\n<li><a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8\" rel=\"nofollow noopener noreferrer\">双精度浮点类型</a></li>\n<li><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" rel=\"nofollow noopener noreferrer\">MDN：按位操作符</a></li>\n<li><a target=\"_blank\" href=\"https://www.jianshu.com/p/11f331d97ec2\" rel=\"nofollow noopener noreferrer\">【小知识大道理】被忽视的位运算</a></li>\n<li><a target=\"_blank\" href=\"http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/\" rel=\"nofollow noopener noreferrer\">为什么不要在 JavaScript 中使用位操作符？</a></li>\n<li><a target=\"_blank\" href=\"https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw\" rel=\"nofollow noopener noreferrer\">角色权限设计的100种解法</a></li>\n<li><a target=\"_blank\" href=\"http://www.cnblogs.com/shijiaqi1066/p/3793894.html\" rel=\"nofollow noopener noreferrer\">权限系统与RBAC模型概述</a></li>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/yingchunhua365/article/details/14090461\" rel=\"nofollow noopener noreferrer\">权限设计及算法</a></li>\n<li><a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\" rel=\"nofollow noopener noreferrer\">基于角色的访问控制</a></li>\n</ul>\n<blockquote>\n<p>本文发布自 <a target=\"_blank\" href=\"https://github.com/x-orpheus\" rel=\"nofollow noopener noreferrer\">网易云音乐前端团队</a>，欢迎自由转载，转载请保留出处。我们一直在招人，如果你恰好准备换工作，又恰好喜欢云音乐，那就 <a target=\"_blank\" href=\"mailto:grp.music-fe@corp.netease.com\" rel=\"nofollow noopener noreferrer\">加入我们</a>！</p>\n</blockquote>\n",
      "id": "ce95ncely1s",
      "author": "前端小智",
      "title": "JavaScript 中的位运算和权限设计",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>作者：Alex</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong><a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBEDBE5CCBE365B176BB470C64C499DD647C88CF896EF535&userCode=pxuujn3r&share_source=copy_link\" rel=\"nofollow noopener noreferrer\">上个月自己花了 1300 买了阿(a)里(li)的 服 务 器来学习 node 及对应的框架，在 <code>11</code> 号之前它们有做活动，1300 的配置现在一年只要 86 元，三年只要229元，真心觉得很划算了，可以点击本条内容进行参与</a></strong></p>\n<hr>\n<h4 class=\"heading\" data-id=\"heading-0\">问题1：什么是虚拟DOM？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐</p>\n</blockquote>\n<p><strong>虚拟 DOM (VDOM)<strong>是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为</strong>调和</strong>。</p>\n<h4 class=\"heading\" data-id=\"heading-1\">问题2：类组件和函数组件之间的区别是啥？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>类组件</strong>可以使用其他特性，如状态 <code>state</code> 和生命周期钩子。</p>\n</li>\n<li>\n<p>当组件只是接收 <code>props</code> 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</p>\n</li>\n</ul>\n<p>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>函数组件</th>\n<th>类组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否有 <code>this</code></td>\n<td>没有</td>\n<td>有</td>\n</tr>\n<tr>\n<td>是否有生命周期</td>\n<td>没有</td>\n<td>有</td>\n</tr>\n<tr>\n<td>是否有状态 <code>state</code></td>\n<td>没有</td>\n<td>有</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-2\">问题 3：React 中 refs 干嘛用的？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p><code>Refs</code> 提供了一种访问在<code>render</code>方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，<code>props</code> 是父子组件交互的唯一方式，想要修改子组件，需要使用新的<code>pros</code>重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 <code>Refs</code>。</p>\n<p>咱们可以在组件添加一个 <code>ref</code> 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。</p>\n<pre><code class=\"copyable code-00\">class UnControlledForm extends Component {\n  handleSubmit = () => {\n    console.log(\"Input Value: \", this.input.value)\n  }\n  render () {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input\n          type='text'\n          ref={(input) => this.input = input} />\n        <button type='submit'>Submit</button>\n      </form>\n    )\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-030</code></pre>\n<p>请注意，<code>input</code> 元素有一个<code>ref</code>属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 <code>handleSubmit</code> 函数内部访问它。</p>\n<p>经常被误解的只有在类组件中才能使用 <code>refs</code>，但是<code>refs</code>也可以通过利用 JS 中的闭包与函数组件一起使用。</p>\n<pre><code class=\"copyable code-01\">function CustomForm ({handleSubmit}) {\n  let inputElement\n  return (\n    <form onSubmit={() => handleSubmit(inputElement.value)}>\n      <input\n        type='text'\n        ref={(input) => inputElement = input} />\n      <button type='submit'>Submit</button>\n    </form>\n  )\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-031</code></pre>\n<h4 class=\"heading\" data-id=\"heading-3\">问题 4：在 React 中如何处理事件</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p>为了解决跨浏览器的兼容性问题，<code>SyntheticEvent</code> 实例将被传递给你的事件处理函数，<code>SyntheticEvent</code>是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>。</p>\n<p>比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">问题 5：state 和 props 区别是啥？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p><code>props</code>和<code>state</code>是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</p>\n<ul>\n<li><code>state</code> 是组件自己管理数据，控制自己的状态，可变；</li>\n<li><code>props</code> 是外部传入的数据参数，不可变；</li>\n<li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li>\n<li>多用 <code>props</code>，少用 <code>state</code>，也就是多写无状态组件。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-5\">问题 6：如何创建 refs</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 <code>Refs</code> 分配给实例属性，以便可以在整个组件中引用它们。</p>\n<pre><code class=\"copyable code-02\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return <div ref={this.myRef} />;\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-032</code></pre>\n<p>或者这样用：</p>\n<pre><code class=\"copyable code-03\">class UserForm extends Component {\n  handleSubmit = () => {\n    console.log(\"Input Value is: \", this.input.value)\n  }\n  render () {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input\n          type='text'\n          ref={(input) => this.input = input} /> // Access DOM input in handle submit\n        <button type='submit'>Submit</button>\n      </form>\n    )\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-033</code></pre>\n<h4 class=\"heading\" data-id=\"heading-6\">问题 7：什么是高阶组件？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p><strong>高阶组件(HOC)<strong>是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为</strong>纯组件</strong>，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。</p>\n<pre><code class=\"copyable code-04\">const EnhancedComponent = higherOrderComponent(WrappedComponent);\n<span class=\"copy-code-btn\">复制代码</span> copy-034</code></pre>\n<p>HOC 可以用于以下许多用例</p>\n<ul>\n<li>代码重用、逻辑和引导抽象</li>\n<li>渲染劫持</li>\n<li>state 抽象和操作</li>\n<li>props 处理</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-7\">问题 8：在构造函数调用 <code>super</code> 并将 <code>props</code> 作为参数传入的作用是啥？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐</p>\n</blockquote>\n<p>在调用 <code>super()</code> 方法之前，子类构造函数无法使用<code>this</code>引用，ES6 子类也是如此。将 <code>props</code> 参数传递给 <code>super()</code> 调用的主要原因是在子构造函数中能够通过<code>this.props</code>来获取传入的 <code>props</code>。</p>\n<p><strong>传递 props</strong></p>\n<pre><code class=\"copyable code-05\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log(this.props);  // { name: 'sudheer',age: 30 }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-035</code></pre>\n<p><strong>没传递 props</strong></p>\n<pre><code class=\"copyable code-06\">class MyComponent extends React.Component {\n  constructor(props) {\n    super();\n    console.log(this.props); // undefined\n    // 但是 Props 参数仍然可用\n    console.log(props); // Prints { name: 'sudheer',age: 30 }\n  }\n\n  render() {\n    // 构造函数外部不受影响\n    console.log(this.props) // { name: 'sudheer',age: 30 }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-036</code></pre>\n<p>上面示例揭示了一点。<code>props</code> 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</p>\n<h4 class=\"heading\" data-id=\"heading-8\">问题 9：什么是控制组件？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>在 HTML 中，表单元素如 <code><input></code>、<code><textarea></code>和<code><select></code>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</p>\n<p>而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如<code>onChange</code>)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为<strong>受控组件</strong>。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">问题 10：如何 React.createElement ？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p><strong>问题：</strong></p>\n<pre><code class=\"copyable code-07\">const element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n<span class=\"copy-code-btn\">复制代码</span> copy-037</code></pre>\n<p>上述代码如何使用 <code>React.createElement</code> 来实现:</p>\n<pre><code class=\"copyable code-08\">const element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n<span class=\"copy-code-btn\">复制代码</span> copy-038</code></pre>\n<h4 class=\"heading\" data-id=\"heading-10\">问题 11：讲讲什么是 JSX ？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>当 <strong>Facebook</strong> 第一次发布 React 时，他们还引入了一种新的 JS 方言 <code>JSX</code>，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。</p>\n<pre><code class=\"copyable code-09\">class MyComponent extends React.Component {\n  render() {\n    let props = this.props;  \n    return (\n      <div className=\"my-component\">\n      <a href={props.url}>{props.name}</a>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-039</code></pre>\n<h4 class=\"heading\" data-id=\"heading-11\">问题 12：根据下面定义的代码，可以找出存在的两个问题吗 ？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>请看下面的代码：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3df8afe5c3fcc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"767\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"767\" height=\"800\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>答案：</p>\n<p>1.在构造函数没有将 <code>props</code> 传递给 <code>super</code>，它应该包括以下行</p>\n<pre><code class=\"copyable code-010\">constructor(props) {\n  super(props);\n  // ...\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-040</code></pre>\n<p>2.事件监听器(通过<code>addEventListener()</code>分配时)的作用域不正确，因为 ES6 不提供自动绑定。因此，开发人员可以在构造函数中重新分配<code>clickHandler</code>来包含正确的绑定:</p>\n<pre><code class=\"copyable code-011\">constructor(props) {\n  super(props);\n  this.clickHandler = this.clickHandler.bind(this);\n  // ...\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-041</code></pre>\n<h4 class=\"heading\" data-id=\"heading-12\">问题 13：为什么不直接更新 <code>state</code> 呢 ?</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>如果试图直接更新 <code>state</code> ，则不会重新渲染组件。</p>\n<pre><code class=\"copyable code-012\"> // 错误\n This.state.message = 'Hello world';\n<span class=\"copy-code-btn\">复制代码</span> copy-042</code></pre>\n<p>需要使用<code>setState()</code>方法来更新 <code>state</code>。它调度对组件<code>state</code>对象的更新。当<code>state</code>改变时，组件通过重新渲染来响应：</p>\n<pre><code class=\"copyable code-013\">// 正确做法\nThis.setState({message: ‘Hello World’});\n<span class=\"copy-code-btn\">复制代码</span> copy-043</code></pre>\n<h4 class=\"heading\" data-id=\"heading-13\">问题 14：React 组件生命周期有哪些不同阶段？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>在组件生命周期中有四个不同的阶段：</p>\n<ol>\n<li>\n<p><strong>Initialization</strong>：在这个阶段，组件准备设置初始化状态和默认属性。</p>\n</li>\n<li>\n<p><strong>Mounting</strong>：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括<code>componentWillMount</code>和<code>componentDidMount</code>生命周期方法。</p>\n</li>\n<li>\n<p><strong>Updating</strong>：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>和<code>componentDidUpdate</code>生命周期方法。</p>\n</li>\n<li>\n<p><strong>Unmounting</strong>：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 <code>componentWillUnmount</code> 生命周期方法。</p>\n</li>\n</ol>\n<p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p>\n<p><strong>Error Handling</strong>：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 <code>componentDidCatch</code> 生命周期方法。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3df8cee593053?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"370\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"370\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">问题 15：React 的生命周期方法有哪些？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<ul>\n<li>\n<p><code>componentWillMount</code>:在渲染之前执行，用于根组件中的 App 级配置。</p>\n</li>\n<li>\n<p><code>componentDidMount</code>：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。</p>\n</li>\n<li>\n<p><code>componentWillReceiveProps</code>：在初始化<code>render</code>的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</p>\n</li>\n<li>\n<p><code>shouldComponentUpdate</code>：确定是否更新组件。默认情况下，它返回<code>true</code>。如果确定在 <code>state</code> 或 <code>props</code> 更新后组件不需要在重新渲染，则可以返回<code>false</code>，这是一个提高性能的方法。</p>\n</li>\n<li>\n<p><code>componentWillUpdate</code>：在<code>shouldComponentUpdate</code>返回 <code>true</code> 确定要更新组件之前件之前执行。</p>\n</li>\n<li>\n<p><code>componentDidUpdate</code>：它主要用于更新DOM以响应<code>props</code>或<code>state</code>更改。</p>\n</li>\n<li>\n<p><code>componentWillUnmount</code>：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</p>\n</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-15\">问题 16：这三个点(...)在 React 干嘛用的？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p><code>...</code> 在React（使用JSX）代码中做什么？它叫什么？</p>\n<pre><code class=\"copyable code-014\"><Modal {...this.props} title='Modal heading'  animation={false}/>\n<span class=\"copy-code-btn\">复制代码</span> copy-044</code></pre>\n<p>这个叫扩展操作符号或者展开操作符，例如，如果<code>this.props</code>包含<code>a：1</code>和<code>b：2</code>，则</p>\n<pre><code class=\"copyable code-015\"><Modal {...this.props} title='Modal heading' animation={false}>\n<span class=\"copy-code-btn\">复制代码</span> copy-045</code></pre>\n<p>等价于下面内容：</p>\n<pre><code class=\"copyable code-016\"><Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}>\n<span class=\"copy-code-btn\">复制代码</span> copy-046</code></pre>\n<p>扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新<code>state</code> 咱们就经常这么做：</p>\n<pre><code class=\"copyable code-017\">this.setState(prevState => {\n    return {foo: {...prevState.foo, a: \"updated\"}};\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-047</code></pre>\n<h4 class=\"heading\" data-id=\"heading-16\">问题 17：使用 React Hooks 好处是啥？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 <code>props</code> 的负担。<code>Hooks</code> 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</p>\n<p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>。相反，使用像<code>useEffect</code>这样的内置钩子。</p>\n<h4 class=\"heading\" data-id=\"heading-17\">问题 18：什么是 React Hooks？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p><strong>Hooks</strong>是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用<code>state</code>和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">问题 19：React 中的 <code>useState()</code> 是什么？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>下面说明<code>useState(0)</code>的用途：</p>\n<pre><code class=\"copyable code-018\">...\nconst [count, setCounter] = useState(0);\nconst [moreStuff, setMoreStuff] = useState(...);\n...\n\nconst setCount = () => {\n    setCounter(count + 1);\n    setMoreStuff(...);\n    ...\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-048</code></pre>\n<p><code>useState</code> 是一个内置的 React Hook。<code>useState(0)</code> 返回一个元组，其中第一个参数<code>count</code>是计数器的当前状态，<code>setCounter</code> 提供更新计数器状态的方法。</p>\n<p>咱们可以在任何地方使用<code>setCounter</code>方法更新计数状态-在这种情况下，咱们在<code>setCount</code>函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</p>\n<h4 class=\"heading\" data-id=\"heading-19\">问题 20：React 中的StrictMode(严格模式)是什么？？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>React 的<code>StrictMode</code>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<code><StrictMode /></code>包装一组组件，并且可以帮咱们以下检查：</p>\n<ul>\n<li>\n<p>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</p>\n</li>\n<li>\n<p>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</p>\n</li>\n<li>\n<p>通过识别潜在的风险预防一些副作用。</p>\n</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-20\">问题 21：为什么类方法需要绑定到类实例？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>在 JS 中，<code>this</code> 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 <code>this</code> 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</p>\n<pre><code class=\"copyable code-019\">class SubmitButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isFormSubmitted: false\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit() {\n    this.setState({\n      isFormSubmitted: true\n    });\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleSubmit}>Submit</button>\n    )\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-049</code></pre>\n<h4 class=\"heading\" data-id=\"heading-21\">问题 22：什么是 prop drilling，如何避免？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 <code>prop</code> 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做<strong>prop drilling</strong>。</p>\n<p><code>prop drilling</code>的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</p>\n<p>为了避免<code>prop drilling</code>，一种常用的方法是使用<strong>React Context</strong>。通过定义提供数据的<code>Provider</code>组件，并允许嵌套的组件通过<code>Consumer</code>组件或<code>useContext</code> Hook 使用上下文数据。</p>\n<h4 class=\"heading\" data-id=\"heading-22\">问题 23：描述 Flux 与 MVC？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<p>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p>\n<p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p>\n<p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</p>\n<p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 <code>store</code> 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</p>\n<h4 class=\"heading\" data-id=\"heading-23\">问题 24：受控组件和非受控组件区别是啥？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐</p>\n</blockquote>\n<ul>\n<li><strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。</li>\n<li>非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。</li>\n</ul>\n<p>尽管非受控组件通常更易于实现，因为只需使用<code>refs</code>即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。</p>\n<p>这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</p>\n<h4 class=\"heading\" data-id=\"heading-24\">问题 25：这段代码有什么问题吗？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>这段代码有什么问题:</p>\n<pre><code class=\"copyable code-020\">this.setState((prevState, props) => {\n  return {\n    streak: prevState.streak + props.count\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span> copy-050</code></pre>\n<p><strong>答案：</strong></p>\n<p>没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给<code>setState</code>，该函数接收上一个 <code>state</code> 的值和当前的<code>props</code>，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</p>\n<h4 class=\"heading\" data-id=\"heading-25\">问题 26：什么是 React Context?</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p><code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 <code>props</code> 属性。</p>\n<h4 class=\"heading\" data-id=\"heading-26\">问题 27：什么是 React Fiber?</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p><strong>Fiber</strong> 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。<strong>React Fiber</strong> 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</p>\n<p>React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</p>\n<h4 class=\"heading\" data-id=\"heading-27\">问题 28：如何在 ReactJS 的 Props上应用验证？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 <code>props</code>，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 <code>props</code> 用 <code>isRequired</code>定义的。</p>\n<p>下面是一组预定义的 prop 类型:</p>\n<ul>\n<li>React.PropTypes.string</li>\n<li>React.PropTypes.number</li>\n<li>React.PropTypes.func</li>\n<li>React.PropTypes.node</li>\n<li>React.PropTypes.bool</li>\n</ul>\n<p>例如，咱们为用户组件定义了如下的<code>propTypes</code></p>\n<pre><code class=\"copyable code-021\">import PropTypes from 'prop-types';\n\nclass User extends React.Component {\n  render() {\n    return (\n      <h1>Welcome, {this.props.name}</h1>\n      <h2>Age, {this.props.age}\n    );\n  }\n}\n\nUser.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number.isRequired\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-051</code></pre>\n<h4 class=\"heading\" data-id=\"heading-28\">问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>构造函数和<code>getInitialState</code>之间的区别就是<code>ES6</code>和<code>ES5</code>本身的区别。在使用<code>ES6</code>类时，应该在构造函数中初始化<code>state</code>，并在使用<code>React.createClass</code>时定义<code>getInitialState</code>方法。</p>\n<pre><code class=\"copyable code-022\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { /* initial state */ };\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-052</code></pre>\n<p>等价于：</p>\n<pre><code class=\"copyable code-023\">var MyComponent = React.createClass({\n  getInitialState() {\n    return { /* initial state */ };\n  },\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-053</code></pre>\n<h4 class=\"heading\" data-id=\"heading-29\">问题 30：如何有条件地向 React 组件添加属性？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</p>\n<pre><code class=\"copyable code-024\">var InputComponent = React.createClass({\n    render: function() {\n      var required = true;\n      var disabled = false;\n\n      return (\n        <input type=\"text\" disabled={disabled} required={required} />\n      );\n    }\n});\n<span class=\"copy-code-btn\">复制代码</span> copy-054</code></pre>\n<p>渲染结果：</p>\n<pre><code class=\"copyable code-025\"><input type=\"text\" required>\n<span class=\"copy-code-btn\">复制代码</span> copy-055</code></pre>\n<p>另一种可能的方法是：</p>\n<pre><code class=\"copyable code-026\">var condition = true;\n\nvar component = (\n  <div\n    value=\"foo\"\n    { ...( condition && { disabled: true } ) } />\n);\n<span class=\"copy-code-btn\">复制代码</span> copy-056</code></pre>\n<h4 class=\"heading\" data-id=\"heading-30\">问题 31：Hooks会取代 <code>render props</code> 和高阶组件吗？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>通常，<code>render props</code>和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</p>\n<p>这两种模式仍然有一席之地(例如，一个虚拟的 <code>scroller</code> 组件可能有一个 <code>renderItem prop</code>，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</p>\n<h4 class=\"heading\" data-id=\"heading-31\">问题 32：如何避免组件的重新渲染？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p>\n<ul>\n<li>\n<p><code>React.memo()</code>:这可以防止不必要地重新渲染函数组件</p>\n</li>\n<li>\n<p><code>PureComponent</code>:这可以防止不必要地重新渲染类组件</p>\n</li>\n</ul>\n<p>这两种方法都依赖于对传递给组件的<code>props</code>的浅比较，如果 <code>props</code> 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p>\n<p>通过使用 <strong>React Profiler</strong>，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</p>\n<h4 class=\"heading\" data-id=\"heading-32\">问题 33：什么是纯函数？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p>\n<h4 class=\"heading\" data-id=\"heading-33\">问题 34：当调用<code>setState</code>时，React <code>render</code> 是如何工作的？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>咱们可以将\"<code>render</code>\"分为两个步骤：</p>\n<ol>\n<li>\n<p>虚拟 DOM 渲染:当<code>render</code>方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用<code>setState()</code>时，<code>render</code>会被再次调用，因为默认情况下<code>shouldComponentUpdate</code>总是返回<code>true</code>，所以默认情况下 React 是没有优化的。</p>\n</li>\n<li>\n<p>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</p>\n</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-34\">问题 35：如何避免在React重新绑定实例？</h4>\n<blockquote>\n<p>主题: React</p>\n<p>难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>有几种常用方法可以避免在 React 中绑定方法：</p>\n<p>1.将事件处理程序定义为内联箭头函数</p>\n<pre><code class=\"copyable code-027\">class SubmitButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isFormSubmitted: false\n    };\n  }\n\n  render() {\n    return (\n      <button onClick={() => {\n        this.setState({ isFormSubmitted: true });\n      }}>Submit</button>\n    )\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-057</code></pre>\n<p>2.使用箭头函数来定义方法：</p>\n<pre><code class=\"copyable code-028\">class SubmitButton extends React.Component {\n  state = {\n    isFormSubmitted: false\n  }\n\n  handleSubmit = () => {\n    this.setState({\n      isFormSubmitted: true\n    });\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleSubmit}>Submit</button>\n    )\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-058</code></pre>\n<p>3.使用带有 Hooks 的函数组件</p>\n<pre><code class=\"copyable code-029\">const SubmitButton = () => {\n  const [isFormSubmitted, setIsFormSubmitted] = useState(false);\n\n  return (\n    <button onClick={() => {\n        setIsFormSubmitted(true);\n    }}>Submit</button>\n  )\n};\n<span class=\"copy-code-btn\">复制代码</span> copy-059</code></pre>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a target=\"_blank\" href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noopener noreferrer\">Fundebug</a>。</strong></p>\n<p>原文：<a target=\"_blank\" href=\"https://www.gangboard.com/blog/reactjs-interview-questions-and-answers/\" rel=\"nofollow noopener noreferrer\">www.gangboard.com/blog/reactj…</a></p>\n<h2 class=\"heading\" data-id=\"heading-35\">交流（欢迎加入群，群工作日都会发红包，互动讨论技术）</h2>\n<p>阿里云最近在做活动，低至2折，有兴趣可以看看：<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<p>干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noopener noreferrer\">github.com/qq449245884…</a></p>\n</blockquote>\n<p>因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。</p>\n<p></p><figure><img alt=\"clipboard.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/31/16e1f15e27993537?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/29/16d7c9e2a5bfb741?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"200\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"200\" height=\"260\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2pcjo1io9ak0",
      "author": "政采云前端团队",
      "title": "35 道咱们必须要清楚的 React 面试题",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https://www.zoo.team/article/share\" rel=\"nofollow noopener noreferrer\">Winter 在政采云分享实录 -《前端团队的成长》</a></p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-1\">前言</h3>\n<p><code><FDay></code>前端技术分享会，是政采云前端团队（ZooTeam）的月度分享会。 2019 年的 10 月期，我们有幸邀请到了 Winter（程劭非）  ，为我们的前端同学做了一期关于前端团队成长的主题分享。之前也邀请过其他大牛来政采云 <code><FDay></code> 分享，如阿里云 IoT 高级技术专家@额台，宋小菜大前端负责人@Scott 等，可惜当时都没做现场记录。Winter 这一期，我们的同学现场做了一下分享记录，全程 Winter 大大妙语连珠，大家笑声阵阵，现场速记难免存在细节遗漏，文章部分内容存在简略，但相信依然能传递一些有价值的认知和思考，帮助到列位看官。</p>\n<p>什么是一个好的前端团队？氛围好？技术强？机会多？一千个读者心中有一千个哈姆雷特，相信每个人都有不同的答案。就拿刚毕业的应届生就业来说，有人想去大厂，因为大厂基础设施完善，有大牛带，成长快；也有人想去小公司，因为小公司的基础设施不完善，就会有很多的机遇，有晋升的空间。本次分享 Winter 从前端团队的基石、前端团队的核心因素和前端团队的亮点三方面来谈一谈这个话题。</p>\n<h3 class=\"heading\" data-id=\"heading-2\">分享嘉宾简介</h3>\n<p>Winter（程劭非），先后任职于微软、盛大、阿里巴巴，阿里时期担任手机淘宝前端负责人，带领团队产出 Weex 等跨平台的移动端解决方案。极客时间《重学前端》系列课程作者。</p>\n<p></p><figure><img alt=\"IMG_6321.JPG\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f822eb1dba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"960\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"960\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-3\">前端团队的需求模型</h3>\n<p></p><figure><img alt=\"A72F8AE5-4D42-4D25-BA1F-49DDC71555BA.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315fa85312ec1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>我们先通过一张模型图来解读一个前端团队中存在的角色以及各个角色之间的联系。</p>\n<p>这张图可以从两个角度看，一是从公司的角度往下看，二是从员工的角度往上看。其中，团队在模型中出现了两次，它的地位和重要性显而易见。</p>\n<p>团队 Leader 是一个很重要的角色，既要应对团队成员的需求，又要从公司的角度来应对上级的需求。对公司来说，公司给团队的是一定的资源，这些资源包括薪酬、工位、电脑等等。</p>\n<p>团队给员工的是成长，团队给队员的机会是均等的，团队就像是培育小树苗的土壤，外部条件都是一样的，但小树苗能长多高长多大还是要看个人了。</p>\n<p>员工给团队的是技术和劳动，技术是专业的代名词，它和劳动不能划等号，不是任何一个人过来工作两小时的产出都是一样的。</p>\n<p>团队给公司的是业务价值，业务价值就和大家年终的绩效挂钩了。</p>\n<p>这四个环节缺一不可，都齐活了才是一个完整的前端团队需求模型。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">前端团队的基石——质量和效率</h2>\n<p>一个技术团队安身立命的根本，是有着过硬的技术实力。那么如何才能做到高效率的开发进而产生高质量的交付呢？咱们来看一下 Winter 大大价值几千万的认知~~</p>\n<h3 class=\"heading\" data-id=\"heading-5\">工具链</h3>\n<p>首先，要形成工程体系，建立一套属于自己的工具链。所谓工具链，包含两层含义。工具，顾名思义，是用来干活的，此处要干的活是为了生成可以运行的程序或库文件；链，即链条，之所以能称之为链条，说明不止一个东西，然后，按照对应的逻辑串起来就成了我们所说的工具链。</p>\n<p>工具不是一个独立的个体，它们之间是有协同，有合作的。工具链是在每一个大型开放源码项目（包括 Linux 内核本身）背后默默支撑的力量。它们由一组必要的工具和软件构成，用于编译和调试从最小的工具软件到你可以想象的最复杂的具有 Linux 内核特征的各种软件。</p>\n<p></p><figure><img alt=\"5DBD132C-1E5C-47C5-ADE9-5BB988F70D21.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f8232fa065?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"301\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"301\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>在一套工具链中最核心的就是项目初始化（Init）、项目启动（Run）、测试（Test）以及项目的发布（Publish）四个节点。在一个项目启动前，就必须要想清楚这四个节点要用什么样的工具去实现。</p>\n<p>需要注意的是，在工具链的使用过程中需要建立一个数据统计体系，在使用过程中有问题可以及时反馈而不是自己默默的想办法解决，你不是红领巾，做好事要留名。</p>\n<p>另外，经过数据的分析可以清晰的定位哪些工具是大家常用的，哪些是基本不用的，后续可以根据这些数据对常用的工具进行优化，淘汰不常用的工具。</p>\n<p>微软资深工程师 Scott Hanselman 说过，“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如 Amazon 的 VP 兼 CTO Werner Vogels 那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it）。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">持续集成</h3>\n<p>其次，要做到持续集成。持续集成是客户端发明的一个概念，它里面有两个核心的概念，Daily Build 和 BVT。那么什么是持续集成？在软件工程中，持续集成（CI）是指将所有开发者工作副本每天多次合并到主干的做法。怎么样才算是“持续”？对于一天需要集成多少次，并没有一个明确的定义。一般就是按照自己项目的实际需要来设置一定的频率，少则可能几次，多则可能达几十次。持续集成的优势在于：</p>\n<ul>\n<li>减少等待时间：持续集成缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时间。</li>\n<li>解放了重复性劳动：自动化部署工作可以解放集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工高很多。</li>\n<li>更高的产品质量：集成服务器往往提供 Code Review、代码质量检测等功能。对代码不规范或者有错误的地方会进行标识，也可以设置邮件、短信等进行告警。而开发人员通过 Code Review 也可以持续提高编程的能力。</li>\n</ul>\n<p>近几年，伴随着前端技术日新月异的发展，前端开发中前后端分离，工程化，自动化等现代化的开发模式越来普及，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节，这样大大提高了前端的开发效率和业务交付能力。</p>\n<p>前端持续集成主要包含 Check-in Build 和 Lint + Rule Check 两部分。其中，Check-in Build  就是每次提交代码都 Check 一次，及时发现问题，Lint 指的是代码规范的校验，Rule Check 包含了业务相关的检查，DOM 相关的性能方面的检查（例：页面上一张图片的体积过大）以及 JS 报错方面的检查。</p>\n<p>说白了，前端持续集成就是把代码测试、打包、发布等工作交给一些工具来自动完成。这样可以提高效率，减少失误，开发人员再也不用关心代码 Push 以后的事情，写代码更加专注和自信。</p>\n<p></p><figure><img alt=\"bg2015092301.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315fa854bd03c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-7\">技术架构</h3>\n<p>最后，要建立一套 <strong>高复用性的</strong> 技术架构。</p>\n<p>客户端架构主要是用来解决软件需求规模带来的复杂性问题的；服务端架构主要是用来解决大量用户访问带来的复杂性问题的；而前端架构主要是用来解决大量页面需求带来的重复劳动问题的。</p>\n<p>那么，问题来了，前端架构是如何解决大量页面需求带来的重复性劳动的问题的呢？下面将从库、组件、模块、搭建系统、全栈方案五个方面来阐述：</p>\n<ul>\n<li>\n<p>库指的是有复用价值的代码，例如开发过程中经常会用碰到 URL 解析、AJAX 请求、ENV（用于判断当前属于什么环境）等问题，这些代码可以封装在方法库中，方便调用。</p>\n</li>\n<li>\n<p>组件指的是 UI 上多次出现的元素，例如轮播、Tab 等，组件可以在页面上多次复用。有句话怎么说来着，组件复用一小步，开发提效一大步。</p>\n</li>\n<li>\n<p>模块指的是经常被使用的业务模块，例如登录模块，它的特点是隔离性比较高，可以做到即插即用。</p>\n</li>\n<li>\n<p>搭建系统包括模板化搭建和模块化搭建。我们在 <a target=\"_blank\" href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" rel>前端工程实践之可视化搭建系统（一）</a>中分享过我们政采云的基于业务组件快速生成页面的搭建系统，它把已经成型的组件像乐高玩具的零件一样，使用拖拽的方式组装成最终的页面，同时能够让各个业务快速的接入，提升人效，节约成本。</p>\n</li>\n<li>\n<p>全栈方案包括框架和组建体系两部分。框架的建设与体系的组件与团队息息相关，对于这两点只需定义两个关键词 <strong>面向未来</strong> 和 <strong>面向场景</strong>。</p>\n</li>\n<li>\n<p>在有了库、组件、模块、搭建系统、全栈方案这些“武器”后，前端架构就能轻松的解决大量页面需求带来的重复性劳动的问题。</p>\n</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-8\">前端团队的核心——业务价值</h2>\n<p>大部分技术同学都会认为，个人技术是核心竞争力，那只要安安心心做技术就好了，管什么业务？我的技术好了，业务方肯定会乖乖来用我的系统的。这种想法当然是有道理的，技术是我们的立身之本，这是一定要抓好的。但是，如果只这样去思考问题，那么你是很危险的。因为，你会发现，很多同学不仅技术好，同时也具备良好的产品思维和业务推动逻辑的能力，比技术更重要的是思维的转变。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">数据驱动思考方式的方法论</h3>\n<p>在做项目的时候，首先要分析业务，结合一些数据指标，制定一个合理的目标。接着要采集一些数据，建立数据展示系统，数据能帮助我们精准的定位业务的痛点、难点。有了这些前期准备后，就可以制定技术方案。之后就是按照既定的方案从小规模实践到推广全公司落地再到形成制度。最后，在一个项目完成后，复盘，对数据进行分析，总结经验与不足。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">淘宝详情页优化背后的故事</h3>\n<p>淘宝和政采云一样都是做电商的，电商公司都遵循这样一个规律：成交 = 访问量 * 转化率 * 客单价，淘宝团队经过小规模的实验：通过一个完全没有改变功能纯粹提高性能的小版本的上线，对数据进行分析，发现加载时长的曲线下降一个台阶，用户的访问率上升了一个台阶，形成了一个黄金交叉，证明了性能与转化率是强关联的。</p>\n<p>页面的加载时长是页面性能的一个重要指标。有一个指标叫秒开率，关于秒开率，有一个 <strong>1秒钟法则</strong> 的说法：2G 网络 <strong>1秒进入页面</strong>，3G 网络 <strong>1 秒首屏</strong>，4G 网络 <strong>1秒页面加载完毕</strong>。当时淘宝就是以秒开率作为数据指标，自从有了秒开率，大家工作都有了动力，提效很高。</p>\n<h2 class=\"heading\" data-id=\"heading-11\">前端团队的亮点——技术驱动创新</h2>\n<p>Weex 在双十一项目中，参与并支撑了的移动端主会场界面展示和动态处理。在云端实现了天猫前端运营发布系统“斑马”的对接，在前端开发实现了主会场的界面模块和业务逻辑处理，同时在客户端上对接了手机天猫、手机淘宝。想做到这些，光凭一个好的创意和想法、或凭借员工超强的执行力、或靠砸钱砸机器，都是没有办法做到的，这个问题需要技术驱动力来解决，也就是我们这里所说的技术驱动创新！Weex 的诞生正是技术驱动创新的结果！</p>\n<h3 class=\"heading\" data-id=\"heading-12\">Weex 的前世今生</h3>\n<p>Weex 是一个动态化的高扩展跨平台解决方案，实现思路来源于 RN 与 Vue。官方文档：<a target=\"_blank\" href=\"https://weex.apache.org/zh/guide/introduction.html\" rel=\"nofollow noopener noreferrer\">什么是 Weex?</a> WEEX 是由人称 Vue 的亚洲第二狂热粉（亚洲第一粉是日本一哥们，做了一个 Vue 的日本整站，哈哈）的勾三股四（原名：赵锦江）牵头，一期开发成本 <strong>10</strong> 人客户端团队，<strong>2</strong> 个月专职开发，后期开发成本 <strong>20</strong> 人（峰值 <strong>40</strong> 人以上）客户端专职团队。 Weex 相对 Web 来说有一个体验升级，对于客户端来说 Weex 又是一个动态搭建的方案。</p>\n<p></p><figure><img alt=\"CE7BB921-3C3E-4DCC-ABA0-F8D3F92D1F60.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315fa855a4b02?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-13\">Weex 的业务价值</h3>\n<p>Weex 的业务价值在于开源 P/R、大促 Native 化。Weex 团队在整个双十一的筹备过程中和需求方进行了深入的沟通和交流，并拿出了切实有效的技术方案，很好的解决了其中的很多关键环节问题，并且 Weex 作为一个新的技术方案很好的经受住了如此重要的“考验”！</p>\n<h2 class=\"heading\" data-id=\"heading-14\">总结</h2>\n<p>从公司的角度来看，衡量一个前端团队价值的方式是相似的，前端团队的基石是质量和效率。在此基础上，区分前端团队的核心因素是业务价值，对于少数前端团队，可能还会为公司和行业带来创新。</p>\n<p></p><figure><img alt=\"F824E2BB-BEFA-4D91-8BA8-F660918F63C5.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315fa856dccf9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>感谢各位的阅读，有任何建议和意见都可以在下方留言，小编定当积极改正。</p>\n<h2 class=\"heading\" data-id=\"heading-15\">活动照片展示</h2>\n<p></p><figure><img alt=\"1.JPG\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f3b3fec5f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"2.JPG\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f3b3c70282?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"3.JPG\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f3b407bb7d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"5.JPG\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f3b4fe6115?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1279\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1279\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"6.jpg\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e315f3b49dca11?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-16\">参考文章</h2>\n<ul>\n<li>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d5251fbe51d453b7403f96b\" rel>DevOps概念、关键问题、工具链及文化等详细介绍</a></p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://juejin.im/entry/5aab2351518825555d4700ef\" rel>前端开发如何让持续集成/持续部署(CI/CD)跑起来</a></p>\n</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-17\">招贤纳士</h2>\n<p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p>\n<p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/29/16cddbe09f60b388?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-18\">推荐阅读</h2>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5dafa3d35188257b1549bad1\" rel>1024 巨献！！一文看尽前端过去一年的精华沉淀（700 篇好文大汇总）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" rel>前端工程实践之可视化搭建系统（一）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6de51de51d45620771f12c\" rel>自动化 Web 性能优化分析方案</a></p>\n",
      "id": "1e2sjnlumd28",
      "author": "前端先锋",
      "title": "Winter 在政采云分享实录 -《前端团队的成长》",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>作者：Filip Rakowski</p>\n<p>翻译：疯狂的技术宅</p>\n<p>原文：<a target=\"_blank\" href=\"https://vueschool.io/articles/vuejs-tutorials/exciting-new-features-in-vue-3/\" rel=\"nofollow noopener noreferrer\">vueschool.io/articles/vu…</a></p>\n<p><strong>未经允许严禁转载</strong></p>\n</blockquote>\n<p>在上一篇文章中，我们<a target=\"_blank\" href=\"https://mp.weixin.qq.com/s/g5S4N78lUl4jPFsqnYLB4g\" rel=\"nofollow noopener noreferrer\">了解了 Vue 3 将带来的性能改进</a>。我们已经知道，用新的 Vue 3 编写的程序效果会很好，但性能并不是最重要的部分。对开发人员而言，最重要的是新版本将会怎样影响我们编写代码的方式。</p>\n<p>如你所料，Vue 3 带来了许多令人兴奋的新功能。值得庆幸的是，Vue 团队主要介绍了对当前 API 的添加和改进，而不是重大更改，所以已经了解 Vue 2 的人们应该很快就会对新语法感到满意。</p>\n<p>Let's start with the API that most of you probably heard about...\n让我们从大多数人可能听说过的API开始...</p>\n<h2 class=\"heading\" data-id=\"heading-0\">组件 API（Composition API）</h2>\n<p>组件 API 是 Vue 的下一个主要版本中最常用的讨论和特色语法。这是一种全新的逻辑重用和代码组织方法。</p>\n<p>当前，我们使用所谓的 Options API 构建组件。为了向 Vue 组件添加逻辑，我们填充（可选）属性，例如 <code>data</code>、<code>methods</code>、<code>computed</code>等。这种方法的最大缺点是其本身并不是有效的 JavaScript 代码。你需要确切地知道模板中可以访问哪些属性以及 <code>this</code> 关键字的行为。在后台，Vue 编译器需要将此属性转换为工作代码。因此我们无法从自动建议或类型检查中受益。</p>\n<p>组件 API 旨在通过将组件属性中当前可用的机制公开为 JavaScript 函数来解决这个问题。 Vue 核心团队将组件 API 描述为 <em>“一组基于函数的附加 API，可以灵活地组合组件逻辑。”</em> 用组件 API 编写的代码更具有可读性，并且其背后没有任何魔力，因此更易于阅读和学习。</p>\n<p>让我们通过一个用了新的组件 API 的组件的简单示例，来了解其工作原理。</p>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><template>\n  <button @click=\"increment\">\n    Count is: {{ count }}, double is {{ double }}, click to increment.\n  </button>\n</template>\n\n<script>\nimport { ref, computed, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const double = computed(() => count.value * 2)\n\n    function increment() {\n      count.value++\n    }\n\n    onMounted(() => console.log('component mounted!'))\n\n    return {\n      count,\n      double,\n      increment\n    }\n  }\n}\n</script>\n<span class=\"copy-code-btn\">复制代码</span> copy-024</code></pre><p>现在，让我们把代码分解为几部分，来了解发生了些什么：</p>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { ref, computed, onMounted } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"copy-code-btn\">复制代码</span> copy-025</code></pre><p>正如我之前提到的，组件 API 将组件属性公开为函数，因此第一步是导入所需的函数。在例子中，需要使用 <code>ref</code> 创建响应性引用，用 <code>computed</code> 建立计算属性，并用 <code>onMounted</code> 访问安装的生命周期 hook。</p>\n<p>现在你可能很想知道这神秘的 <code>setup</code> 方法到底是什么？</p>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  setup() {\n<span class=\"copy-code-btn\">复制代码</span> copy-026</code></pre><p>简而言之，它只是一个将属性和函数返回到模板的函数而已。我们在这里声明所有响应性属性、计算属性、观察者和生命周期 hook，然后将它们返回，以便可以在模板中使用它们。</p>\n<p>我们不从 <code>setup</code> 函数返回的内容在模板中将会不可用。</p>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>)\n<span class=\"copy-code-btn\">复制代码</span> copy-027</code></pre><p>根据上面的内容，我们声明了带有 <code>ref</code> 函数的名为 <code>count</code> 的响应属性。它可以包装任何原语或对象并返回其响应性引用。传递的元素的值将会保留在所创建引用的 <code>value</code> 属性中。例如，如果你想访问 <code>count</code> 引用的值，则需要明确要求 <code>count.value</code>。</p>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> count.value * <span class=\"hljs-number\">2</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span>(<span class=\"hljs-params\"></span>) </span>{\n  count.value++\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-028</code></pre><p>这正是我们在声明计算属性 <code>double</code> 和 <code>increment</code> 函数时所要做的。</p>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\">onMounted(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'component mounted!'</span>))\n<span class=\"copy-code-btn\">复制代码</span> copy-029</code></pre><p>使用 <code>onMounted</code> hook，我们会在安装组件时记录一些消息，只是向你展示可以做到！😉</p>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-keyword\">return</span> {\n  count,\n  double,\n  increment\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-030</code></pre><p>最后，我们将使用 <code>increment</code> 方法返回 <code>count</code> 和 <code>double</code> 属性，以使它们在模板中可用。</p>\n<pre><code class=\"hljs html copyable code-07\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"increment\"</span>></span>\n    Count is: {{ count }}, double is {{ double }}. Click to increment.\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-031</code></pre><p>瞧！现在我们可以访问模板中 <code>setup</code> 方法返回的属性和函数，就像通过旧的 Options API 声明它们一样。</p>\n<p>这是一个简单的例子，也可以通过 Options API 轻松实现。新的组件 API 的真正好处不仅在于能以不同的方式进行编码，在对我们的代码和逻辑进行重用时，这些好处也能显示出来。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">用组件 API 进行代码重用</h3>\n<p>新的组件 API 具有更多优点。考虑一下代码重用。目前如果我们要在其他组件之间共享一些代码，则有两个可用的选择：mixins 和作用域插槽（ scoped slots）。但是两者都有缺点。</p>\n<p>假设我们要提取 <code>counter</code> 中的功能并在其他组件中重用。在下面，你可以看到如何将其与可用的 API 和新的组件 API 结合使用：</p>\n<p>让我们从 mixins 开始：</p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-keyword\">import</span> CounterMixin <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./mixins/counter'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">mixins</span>: [CounterMixin]\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-032</code></pre><p>mixins 的最大缺点在于我们对它实际上添加到组件中的行为一无所知。这不仅使代码变得难以理解，而且还可能导致名称与现有属性和函数发生冲突。</p>\n<p>下面是作用域插槽：</p>\n<pre><code class=\"hljs html copyable code-09\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">Counter</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"{ count, increment }\"</span>></span>\n     {{ count }}\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"increment\"</span>></span>Increment<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span> \n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">Counter</span>></span> \n<span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-033</code></pre><p>通过使用作用域插槽，我们确切地知道可以通过 <code>v-slot</code> 属性访问了哪些属性，因此代码更容易理解。这种方法的缺点是我们只能在模板中访问它，并且只能在 <code>Counter</code> 组件作用域内使用。</p>\n<p>现在该用组件 API 了：</p>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useCounter</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span> (<span class=\"hljs-params\"></span>) </span>{ count.value++ }\n\n  <span class=\"hljs-keyword\">return</span> {\n    count,\n    incrememt\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  setup () {\n    <span class=\"hljs-keyword\">const</span> { count, increment } = useCounter()\n    <span class=\"hljs-keyword\">return</span> {\n      count,\n      increment\n    }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-034</code></pre><p>是不是更优雅？我们不受模板和组件作用域的限制，并且能够确切地知道可以从 counter 访问哪些属性。另外我们可以受益于编辑器中可用的代码补全功能，因为 <code>useCounter</code> 只是一个返回某些属性的函数，因此编辑器可以帮助我们进行类型检查和建议。</p>\n<p>这也是使用第三方库的更优雅的方式。例如，如果我们想使用 Vuex，则可以显式地使用 <code>useStore</code> 函数，而不是污染 Vue 原型（<code>this.$store</code>）。这种方法也消除了 Vue 插件的幕后魔力。</p>\n<pre><code class=\"hljs js copyable code-011\" lang=\"js\"><span class=\"hljs-keyword\">const</span> { commit, dispatch } = useStore()\n<span class=\"copy-code-btn\">复制代码</span> copy-035</code></pre><p>如果你想了解有关组件 API 及其使用案例的更多信息，我强烈建议你阅读 Vue 团队的<a target=\"_blank\" href=\"https://vue-composition-api-rfc.netlify.com/\" rel=\"nofollow noopener noreferrer\">这篇文章</a>，其中解释了新 API 背后的原因，并提出了最好的用例建议。还有 <a target=\"_blank\" href=\"https://github.com/LinusBorg/composition-api-demos\" rel=\"nofollow noopener noreferrer\">great repository</a> ，其中包含来自 Vue 核心团队的 Thorsten Lünborg 使用的组件 API 的例子。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">全局挂载/配置 API 更改</h2>\n<p>我们可以在实例化和配置程序的方式中找到另一个重大变化。让我们看看它现在是如何工作的：</p>\n<pre><code class=\"hljs js copyable code-012\" lang=\"js\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App.vue'</span>\n\nVue.config.ignoredElements = [<span class=\"hljs-regexp\">/^app-/</span>]\nVue.use(<span class=\"hljs-comment\">/* ... */</span>)\nVue.mixin(<span class=\"hljs-comment\">/* ... */</span>)\nVue.component(<span class=\"hljs-comment\">/* ... */</span>)\nVue.directive(<span class=\"hljs-comment\">/* ... */</span>)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =></span> h(App)\n}).$mount(<span class=\"hljs-string\">'#app'</span>)\n<span class=\"copy-code-btn\">复制代码</span> copy-036</code></pre><p>当前，我们正在用全局 <code>Vue</code> 对象提供所有配置并创建新的 Vue 实例。对 <code>Vue</code> 对象所做的任何更改都会影响每个 Vue 实例和组件。</p>\n<p>现在，让我们看看它如何在 Vue 3 中运行：</p>\n<pre><code class=\"hljs js copyable code-013\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App.vue'</span>\n\n<span class=\"hljs-keyword\">const</span> app = createApp(App)\n\napp.config.ignoredElements = [<span class=\"hljs-regexp\">/^app-/</span>]\napp.use(<span class=\"hljs-comment\">/* ... */</span>)\napp.mixin(<span class=\"hljs-comment\">/* ... */</span>)\napp.component(<span class=\"hljs-comment\">/* ... */</span>)\napp.directive(<span class=\"hljs-comment\">/* ... */</span>)\n\napp.mount(<span class=\"hljs-string\">'#app'</span>)\n<span class=\"copy-code-btn\">复制代码</span> copy-037</code></pre><p>你可能已经注意到，每个配置都限于使用 <code>createApp</code> 定义的某个 Vue 程序。</p>\n<p>它可以使你的代码更易于理解，并且不易出现由第三方插件引发的意外问题。目前，如果某些第三方解决方案正在修改 Vue 对象，那么它可能会以意想不到的方式（尤其是全局混合）影响你的程序，而 Vue 3 则没有这个问题。</p>\n<p>目前，此 API 的更改正在 <a target=\"_blank\" href=\"https://github.com/vuejs/rfcs/pull/29\" rel=\"nofollow noopener noreferrer\">这个 RFC</a> 中进行讨论，这意味着将来可能会有所更改。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">片段（Fragments）</h2>\n<p>我们可以在 Vue 3 中期待的另一个激动人心的附加功能是片段。</p>\n<p>你可能会问什么片段？好吧，如果你创建了一个 Vue 组件，那么它只能有一个根节点。</p>\n<p>这意味着无法创建这样的组件：</p>\n<pre><code class=\"hljs html copyable code-014\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span>></span>Hello<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span>></span>World<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-038</code></pre><p>原因是代表任何 Vue 组件的 Vue 实例都需要绑定到单个 DOM 元素中。创建具有多个 DOM 节点的组件的唯一方法是创建一个没有基础 Vue 实例的功能组件。</p>\n<p>事实证明，React 社区也有同样的问题。他们提出的解决方案是一个名为 Fragment 的虚拟元素。看上去是这样的；</p>\n<pre><code class=\"hljs js copyable code-015\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Columns</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">React.Fragment</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">td</span>></span>Hello<span class=\"hljs-tag\"></<span class=\"hljs-name\">td</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">td</span>></span>World<span class=\"hljs-tag\"></<span class=\"hljs-name\">td</span>></span>\n      <span class=\"hljs-tag\"></<span class=\"hljs-name\">React.Fragment</span>></span>\n    );\n  }\n}\n</span><span class=\"copy-code-btn\">复制代码</span> copy-039</code></pre><p>尽管 Fragment 看起来像是普通的 DOM 元素，但它是虚拟的，根本不会在 DOM 树中渲染。这样我们就可以将组件功能绑定到单个元素中，而无需创建冗余的 DOM 节点。</p>\n<p>现在你可以在带有 <a target=\"_blank\" href=\"https://vuejsdevelopers.com/2018/09/11/vue-multiple-root-fragments/\" rel=\"nofollow noopener noreferrer\">vue-fragments</a> 库的 Vue 2 中使用片段，而在 Vue 3 中你可以直接使用它！</p>\n<h2 class=\"heading\" data-id=\"heading-4\">Suspense</h2>\n<p>将被用在 Vue 3 中的另一个从 React 学来的功能是 Suspense 组件。</p>\n<p>Suspense 能够暂停你的组件渲染，并渲染后备组件，直到条件满足为止。在 Vue London 期间，尤雨溪简短地谈到了这个主题，并向我们展示了可以期望的 API。事实证明，Suspense 只是带有插槽的组件：</p>\n<pre><code class=\"hljs html copyable code-016\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">Suspense</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span> ></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">Suspended-component</span> /></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">fallback</span>></span>\n    Loading...\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">template</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">Suspense</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-040</code></pre><p>直到 <code>Suspended-component</code> 完全渲染前将会显示后备内容。挂起可以等待，直到该组件被下载（如果该组件是异步组件的话），或者在 <code>setup</code> 函数中执行一些异步操作。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">Multiple v-models</h2>\n<p>V-model 是一种指令，可用于在给定组件上实现双向绑定。我们可以传递响应性属性，并从组件内部对其进行修改。</p>\n<p>我们可以从表单元素上很好的了解 <code>v-model</code>：</p>\n<pre><code class=\"hljs html copyable code-017\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"property />\n</span></span><span class=\"copy-code-btn\">复制代码</span> copy-041</code></pre><p>但是你知道可以对每个组件都使用 <code>v-model</code> 吗？在内部， <code>v-model</code> 只是传递 <code>value</code> 属性和侦听 <code>input</code> 事件的捷径。把上面的例子重写为以下语法，将具有完全相同的效果：</p>\n<pre><code class=\"hljs html copyable code-018\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">input</span> \n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"property\"</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"property = $event.target.value\"</span>\n/></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-042</code></pre><p>我们甚至可以用组件 <code>model</code> 属性来更改默认属性和事件的名称：</p>\n<pre><code class=\"hljs json copyable code-019\" lang=\"json\">model: {\n  prop: 'checked',\n  event: 'change'\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-043</code></pre><p>如你所见，如果我们想要在组件中进行双向绑定，<code>v-model</code> 指令可能是一个非常有用的语法。不幸的是，每个组件只能有一个 <code>v-model</code>。</p>\n<p>幸运的是，这在 Vue 3 中不会有问题！你将能够给 <code>v-model</code> 属性名，并根据需要拥有尽可能多的属性名。在下面的例子中，你可以在表单组件中找到两个 <code>v-model</code>：</p>\n<pre><code class=\"hljs html copyable code-020\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">InviteeForm</span>\n  <span class=\"hljs-attr\">v-model:name</span>=<span class=\"hljs-string\">\"inviteeName\"</span>\n  <span class=\"hljs-attr\">v-model:email</span>=<span class=\"hljs-string\">\"inviteeEmail\"</span>\n/></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-044</code></pre><p>目前，此 API 的更改已在<a target=\"_blank\" href=\"https://github.com/vuejs/rfcs/pull/31\" rel=\"nofollow noopener noreferrer\">这个 RFC</a> 中进行讨论，这意味着将来可能会有更改。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">Portals</h2>\n<p>Portals 是特殊的组件，用来在当前组件之外渲染某些内容。它也是<a target=\"_blank\" href=\"https://pl.reactjs.org/docs/portals.html\" rel=\"nofollow noopener noreferrer\">在 React 中实现</a>的功能之一。这就是 React 文档关于 Portals 的内容：</p>\n<p>“<em>Portals 提供了一种独特的方法来将子级渲染到父组件的 DOM 层次结构之外的 DOM 节点中。</em>”</p>\n<p>这种处理模式，是弹出式窗口以及通常显示在页面顶部的组件所使用的一种非常好的方法。通过使用 Portals，你可以确保没有任何主机组件 CSS 规则会影响你要显示的组件，并且可以避免用 <code>z-index</code> 进行的黑客攻击。</p>\n<p>对于每个 Portal，我们需要为其指定目标位置，在该目标位置将渲染 Portals 内容。在下面，你可以从 <a target=\"_blank\" href=\"https://github.com/LinusBorg/portal-vue\" rel=\"nofollow noopener noreferrer\">portal-vue</a> 库中看到实现，该库将此功能添加到了 Vue 2：</p>\n<pre><code class=\"hljs html copyable code-021\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">portal</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"destination\"</span>></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">p</span>></span>This slot content will be rendered wherever thportal-target with name 'destination'\n    is  located.<span class=\"hljs-tag\"></<span class=\"hljs-name\">p</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">portal</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">portal-target</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"destination\"</span>></span>\n  <span class=\"hljs-comment\"><!--\n  This component can be located anywhere in your App.\n  The slot content of the above portal component wilbe rendered here.\n  --></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">portal-target</span>></span>\n<span class=\"copy-code-btn\">复制代码</span> copy-045</code></pre><p>Vue 3 对 Portals 提供开箱即用的支持！</p>\n<h2 class=\"heading\" data-id=\"heading-7\">新的自定义指令 API</h2>\n<p>自定义指令 API 在 Vue 3 中将略有变化，以便更好地与组件生命周期保持一致。这项改进应使 API 更加直观，从而使新手更容易理解和学习 API。</p>\n<p>这是当前的自定义指令 API：</p>\n<pre><code class=\"hljs js copyable code-022\" lang=\"js\"><span class=\"hljs-keyword\">const</span> MyDirective = {\n  bind(el, binding, vnode, prevVnode) {},\n  inserted() {},\n  update() {},\n  componentUpdated() {},\n  unbind() {}\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-046</code></pre><p>这是在 Vue 3 中的样子。</p>\n<pre><code class=\"hljs js copyable code-023\" lang=\"js\"><span class=\"hljs-keyword\">const</span> MyDirective = {\n  beforeMount(el, binding, vnode, prevVnode) {},\n  mounted() {},\n  beforeUpdate() {},\n  updated() {},\n  beforeUnmount() {}, <span class=\"hljs-comment\">// new</span>\n  unmounted() {}\n}\n<span class=\"copy-code-btn\">复制代码</span> copy-047</code></pre><p>即使这是一项重大改进，也应很容易被 Vue 兼容版本涵盖到。</p>\n<p><a target=\"_blank\" href=\"https://github.com/vuejs/rfcs/pull/32/files\" rel=\"nofollow noopener noreferrer\">在此 RFC</a> 中讨论了这个 API 的更改，这意味着将来可能会改进。</p>\n<h2 class=\"heading\" data-id=\"heading-8\">摘要</h2>\n<p>除了 Composition API（它是 Vue 3 中最大的主要新 API）之外，我们还可以找到很多较小的改进。可以看到 Vue 正在朝着更友好的开发体验和更简单、更直观的 API 迈进。十分高兴看到 Vue 团队决定在框架的核心采用了许多目前只能通过第三方库获得的想法。</p>\n<p>上面的列表仅表示主要的 API 更改和改进。如果你对其他的内容感到好奇，请务必检查 <a target=\"_blank\" href=\"https://github.com/vuejs/rfcs/\" rel=\"nofollow noopener noreferrer\">Vue RFCs 信息库</a>。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">欢迎关注前端公众号：前端先锋，免费领取webpack教程。</h2>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e44e4e206245b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"258\" data-height=\"258\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"258\" height=\"258\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "58c5c9q3e5c0",
      "author": "荒山",
      "title": "Vue 3 中令人兴奋的新功能",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dbebbfa51882524c507fddb",
      "k": "juejin",
      "id": "6vh4xmggffs0",
      "author": "神三元",
      "title": "(建议精读)原生JS灵魂之问(中)，检验自己是否真的熟悉JavaScript？",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>笔者最近在对原生JS的知识做系统梳理，因为我觉得JS作为前端工程师的根本技术，学再多遍都不为过。打算来做一个系列，一共分三次发，以一系列的问题为驱动，当然也会有追问和扩展，内容系统且完整，对初中级选手会有很好的提升，高级选手也会得到复习和巩固。这是本系列的第二篇。</p>\n<p>扫了一眼目录后，也许你可能会说：这些八百年都用不到的东西，我为什么要会?是，我承认真实业务场景中遇到诸如手写splice、深拷贝的场景并不多，但我要说的是，问这些问题的初衷并不是让你拿到平时去用的，而是检验你对<c..."
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "11fhu0v01i1c",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "4天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>原文链接：<a target=\"_blank\" href=\"https://dev.to/simonholdorf/9-projects-you-can-do-to-become-a-frontend-master-in-2020-n2h\" rel=\"nofollow noopener noreferrer\">dev.to/simonholdor…</a></p>\n<p>DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。</p..."
    },
    {
      "url": "https://juejin.im/post/5db556376fb9a0207a6ddce7",
      "k": "juejin",
      "id": "4m57m0bc3zc0",
      "author": "小维FE",
      "title": "记一次大厂的面试过程",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>2019年6月中旬，实在厌倦了之前平平淡淡的工作和毫不起眼的薪资，不顾亲人的反对，毅然决然地决定只身前往沿海城市，想着找到一份更加具有挑战性的工作，来彻彻底底地重新打磨自己，同时去追求更好的薪资待遇。当然在此之前，自己每天下班后都会利用业余时间抓紧复习巩固刷题等等，大概从3月份开始的吧，持续了3个多月。而后从6月中旬面试一直到6月底，中间大概两个星期，其实我的学历和背景并不突出，但是我个人感觉可..."
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "2opsua62ov40",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https:/..."
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "545hxyr9ops0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。</p>\n</blockquote>\n<ul>\n<li>call、apply、bind 实现</li>\n<li>new 实现</li>\n<li>class 实现继承</li>\n<li>async/await 实现</li>\n<li>reduce 实现</li>\n<li>实现一个双向数据绑定</li>\n<li>i..."
    },
    {
      "url": "https://juejin.im/post/5dbe818a6fb9a0203c34e4bb",
      "k": "juejin",
      "id": "2ktvteae0nm0",
      "author": "云中桥",
      "title": "7道简单的 JavaScript 面试题，三个月没招到一个人",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>如果你符合JavaScript高级开发人员的资格，在编码面试中很有可能会被问到一些刁钻的问题。</p>\n<p>我知道这不公平。一些不知名的人把你放在角落上下打量，似乎想看你是什么做成的。这是一次不愉快的经历。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/3/16e3029e43a74c6b?imageView2/..."
    },
    {
      "url": "https://juejin.im/post/5dc0c8e1f265da4d12067f4b",
      "k": "juejin",
      "id": "3o06m3x909k0",
      "author": "云音乐前端技术团队",
      "title": "来迎接一款让你心动的UI框架",
      "time": "4天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>推荐一款优秀的UI框架<br>\n原文链接：<a target=\"_blank\" href=\"https://juejin.im/post/5dbbfe7a51882521d67c2858\" rel>juejin.im/post/5dbbfe…</a></p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-0\">来迎接一款让你心动的UI框架</h1>\n<p>今天要为大家安利的是冰山工作室出即将推出的前端框架CM..."
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "ce95ncely1s",
      "author": "前端小智",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">1. 内容概要</h2>\n<p>本文主要讨论以下两个问题：</p>\n<ul>\n<li>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</li>\n<li>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-1\">2. JavaScript 位运算</h2>\n<h..."
    },
    {
      "url": "https://juejin.im/post/5dc20a4ff265da4d4e30040b",
      "k": "juejin",
      "id": "2pcjo1io9ak0",
      "author": "政采云前端团队",
      "title": "35 道咱们必须要清楚的 React 面试题",
      "time": "3天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>作者：Alex</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong><a target=\"_blank\" href=\"https://www.aliyun.com/1111/2019/group-buying-share?ptCode=FBEDBE5CCBE365B176BB470C64C499DD647C88CF896EF535&userCode=pxuujn3r&share_sou..."
    },
    {
      "url": "https://juejin.im/post/5dbed095e51d456f28370ca1",
      "k": "juejin",
      "id": "1e2sjnlumd28",
      "author": "前端先锋",
      "title": "Winter 在政采云分享实录 -《前端团队的成长》",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https:/..."
    },
    {
      "url": "https://juejin.im/post/5dc3cfce6fb9a04a665f100e",
      "k": "juejin",
      "id": "58c5c9q3e5c0",
      "author": "荒山",
      "title": "Vue 3 中令人兴奋的新功能",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>作者：Filip Rakowski</p>\n<p>翻译：疯狂的技术宅</p>\n<p>原文：<a target=\"_blank\" href=\"https://vueschool.io/articles/vuejs-tutorials/exciting-new-features-in-vue-3/\" rel=\"nofollow noopener noreferrer\">vueschool.io/articles/vu…</a></p>\n<p><strong>未经允许严..."
    }
  ]
}