{
  "searchResList": [],
  "hotArticleDetailList": [
    {
      "content": "<blockquote>\n<p>阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。</p>\n</blockquote>\n<ul>\n<li>call、apply、bind 实现</li>\n<li>new 实现</li>\n<li>class 实现继承</li>\n<li>async/await 实现</li>\n<li>reduce 实现</li>\n<li>实现一个双向数据绑定</li>\n<li>instanceof 实现</li>\n<li>Array.isArray 实现</li>\n<li>Object.create 的基本实现原理</li>\n<li>getOwnPropertyNames 实现</li>\n<li>promise 实现</li>\n<li>手写一个防抖/节流函数</li>\n<li>柯里化函数的实现</li>\n<li>手写一个深拷贝</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-0\">call、apply、bind 实现</h2>\n<blockquote>\n<p><code>call、apply、bind</code> 本质都是改变 <code>this</code> 的指向，不同点 <code>call、apply</code> 是直接调用函数，<code>bind</code> 是返回一个新的函数。<code>call</code> 跟 <code>apply</code> 就只有参数上不同。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-1\">bind 实现</h3>\n<ul>\n<li>箭头函数的 <code>this</code> 永远指向它所在的作用域</li>\n<li>函数作为构造函数用 <code>new</code> 关键字调用时，不应该改变其 <code>this</code> 指向，因为 <code>new绑定</code> 的优先级高于 <code>显示绑定</code> 和 <code>硬绑定</code></li>\n</ul>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mybind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Bind must be called on a function\"</span>);\n    }\n    <span class=\"hljs-comment\">// 拿到参数，为了传给调用者</span>\n    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>),\n      <span class=\"hljs-comment\">// 保存 this</span>\n      self = <span class=\"hljs-keyword\">this</span>,\n      <span class=\"hljs-comment\">// 构建一个干净的函数，用于保存原函数的原型</span>\n      nop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{},\n      <span class=\"hljs-comment\">// 绑定的函数</span>\n      bound = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-comment\">// this instanceof nop, 判断是否使用 new 来调用 bound</span>\n        <span class=\"hljs-comment\">// 如果是 new 来调用的话，this的指向就是其实例，</span>\n        <span class=\"hljs-comment\">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span>\n        <span class=\"hljs-keyword\">return</span> self.apply(\n          <span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> nop ? <span class=\"hljs-keyword\">this</span> : thisArg,\n          args.concat(<span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>))\n        );\n      };\n\n    <span class=\"hljs-comment\">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.prototype) {\n      nop.prototype = <span class=\"hljs-keyword\">this</span>.prototype;\n    }\n    <span class=\"hljs-comment\">// 修改绑定函数的原型指向</span>\n    bound.prototype = <span class=\"hljs-keyword\">new</span> nop();\n\n    <span class=\"hljs-keyword\">return</span> bound;\n  }\n}\n<span class=\"copy-code-btn copy-028\">复制代码</span></code></pre><ol start=\"3\">\n<li><code>测试 mybind</code></li>\n</ol>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\n<span class=\"hljs-keyword\">const</span> bound = bar.mybind(foo, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">44</span>);\n<span class=\"hljs-keyword\">new</span> bound(); <span class=\"hljs-comment\">// bar, [22, 33, 44]</span>\nbound(); <span class=\"hljs-comment\">// foo, [22, 33, 44]</span>\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-2\">call 实现</h3>\n<blockquote>\n<p><code>bind</code> 是封装了 <code>call</code> 的方法改变了 <code>this</code> 的指向并返回一个新的函数，那么 <code>call</code> 是如何做到改变 <code>this</code> 的指向呢？原理很简单，在方法调用模式下，<code>this</code> 总是指向调用它所在方法的对象，<code>this</code> 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）。先写一个小 <code>demo</code> 来理解一下下。</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-keyword\">const</span> foo = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span> };\n\nfoo.fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 这里的 this 指向了 foo</span>\n  <span class=\"hljs-comment\">// 因为 foo 调用了 fn，</span>\n  <span class=\"hljs-comment\">// fn 的 this 就指向了调用它所在方法的对象 foo 上</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// foo</span>\n};\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre><p>利用 <code>this</code> 的机制来实现 <code>call</code></p>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mycall = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-comment\">// this指向调用call的对象</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-comment\">// 调用call的若不是函数则报错</span>\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Error'</span>);\n    }\n    <span class=\"hljs-comment\">// 声明一个 Symbol 属性，防止 fn 被占用</span>\n    <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n    <span class=\"hljs-keyword\">const</span> args = [...arguments].slice(<span class=\"hljs-number\">1</span>);\n    thisArg = thisArg || <span class=\"hljs-built_in\">window</span>;\n    <span class=\"hljs-comment\">// 将调用call函数的对象添加到thisArg的属性中</span>\n    thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 执行该属性</span>\n    <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...args);\n    <span class=\"hljs-comment\">// 删除该属性</span>\n    <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n    <span class=\"hljs-comment\">// 返回函数执行结果</span>\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-3\">apply 实现</h3>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.myapply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">' is not a function'</span>;\n  }\n\n  <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n  thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n\n  <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...arg);\n\n  <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n\n  <span class=\"hljs-keyword\">return</span> result;\n};\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><p><code>测试 mycall myapply</code></p>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\nbar.mycall(foo, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\nbar.myapply(foo, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-4\">reduce 实现原理</h2>\n<blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.myreduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reduce</span>(<span class=\"hljs-params\">callbackfn</span>) </span>{\n  <span class=\"hljs-comment\">// 拿到数组</span>\n  <span class=\"hljs-keyword\">const</span> O = <span class=\"hljs-keyword\">this</span>,\n    len = O.length;\n  <span class=\"hljs-comment\">// 下标值</span>\n  <span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-comment\">// 累加器</span>\n    accumulator = <span class=\"hljs-literal\">undefined</span>,\n    <span class=\"hljs-comment\">// k下标对应的值是否存在</span>\n    kPresent = <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-comment\">// 初始值</span>\n    initialValue = <span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span> ? <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>] : <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callbackfn !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 数组为空，并且有初始值，报错</span>\n  <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span> && <span class=\"hljs-built_in\">arguments</span>.length < <span class=\"hljs-number\">2</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Reduce of empty array with no initial value'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 如果初始值存在</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// 设置累加器为初始值</span>\n    accumulator = initialValue;\n    <span class=\"hljs-comment\">// 初始值不存在</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    accumulator = O[k];\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">while</span> (k < len) {\n    <span class=\"hljs-comment\">// 判断是否为 empty [,,,]</span>\n    kPresent = O.hasOwnProperty(k);\n\n    <span class=\"hljs-keyword\">if</span> (kPresent) {\n      <span class=\"hljs-keyword\">const</span> kValue = O[k];\n      <span class=\"hljs-comment\">// 调用 callbackfn</span>\n      accumulator = callbackfn.apply(<span class=\"hljs-literal\">undefined</span>, [accumulator, kValue, k, O]);\n    }\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">return</span> accumulator;\n};\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><p><code>测试</code></p>\n<pre><code class=\"hljs js copyable code-07\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> mReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].myreduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(rReduce, mReduce);\n<span class=\"hljs-comment\">// 31nullundefined34 31nullundefined34</span>\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">new 实现</h2>\n<blockquote>\n<p>我们需要知道当 <code>new</code> 的时候做了什么事情</p>\n</blockquote>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）</li>\n<li>返回新对象。</li>\n</ol>\n<p>因为 new 没办法重写，我们使用 <code>myNew</code> 函数来模拟 <code>new</code></p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 创建一个实例对象</span>\n  <span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n  <span class=\"hljs-comment\">// 取得外部传入的构造器</span>\n  <span class=\"hljs-keyword\">var</span> Constructor = <span class=\"hljs-built_in\">Array</span>.prototype.shift.call(<span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 实现继承，实例可以访问构造器的属性</span>\n  obj.__proto__ = Constructor.prototype;\n  <span class=\"hljs-comment\">// 调用构造器，并改变其 this 指向到实例</span>\n  <span class=\"hljs-keyword\">var</span> ret = Constructor.apply(obj, <span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> ret === <span class=\"hljs-string\">'object'</span> && ret !== <span class=\"hljs-literal\">null</span> ? ret : obj;\n}\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre><p><code>测试 myNew</code></p>\n<pre><code class=\"hljs js copyable code-09\" lang=\"js\"><span class=\"hljs-comment\">// ========= 无返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// { name: \"foo\" }</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// ========= 有返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n  <span class=\"hljs-keyword\">return</span> {};\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// {}</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// false</span>\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-6\">class 实现继承</h2>\n<blockquote>\n<p>主要使用 <code>es5</code> 跟 <code>es6</code> 对比看下 <code>class</code> 继承的原理</p>\n</blockquote>\n<p>实现继承 <code>A extends B</code></p>\n<p>使用 <code>es6</code> 语法</p>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(opt) {\n    <span class=\"hljs-keyword\">this</span>.BName = opt.name;\n  }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-comment\">// 向父类传参</span>\n    <span class=\"hljs-keyword\">super</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> });\n    <span class=\"hljs-comment\">// this 必须在 super() 下面使用</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n  }\n}\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><p>使用 <code>es5</code> 语法</p>\n<p>使用寄生组合继承的方式</p>\n<ol>\n<li>原型链继承，使子类可以调用父类原型上的方法和属性</li>\n<li>借用构造函数继承，可以实现向父类传参</li>\n<li>寄生继承，创造干净的没有构造方法的函数，用来寄生父类的 prototype</li>\n</ol>\n<pre><code class=\"hljs js copyable code-011\" lang=\"js\"><span class=\"hljs-comment\">// 实现继承，通过继承父类 prototype</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__extends</span>(<span class=\"hljs-params\">child, parent</span>) </span>{\n  <span class=\"hljs-comment\">// 修改对象原型</span>\n  <span class=\"hljs-built_in\">Object</span>.setPrototypeOf(child, parent);\n  <span class=\"hljs-comment\">// 寄生继承，创建一个干净的构造函数，用于继承父类的 prototype</span>\n  <span class=\"hljs-comment\">// 这样做的好处是，修改子类的 prototype 不会影响父类的 prototype</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 修正 constructor 指向子类</span>\n    <span class=\"hljs-keyword\">this</span>.constructor = child;\n  }\n  <span class=\"hljs-comment\">// 原型继承，继承父类原型属性，但是无法向父类构造函数传参</span>\n  child.prototype =\n    parent === <span class=\"hljs-literal\">null</span>\n      ? <span class=\"hljs-built_in\">Object</span>.create(parent)\n      : ((__.prototype = parent.prototype), <span class=\"hljs-keyword\">new</span> __());\n}\n\n<span class=\"hljs-keyword\">var</span> B = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\">opt</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = opt.name;\n  }\n  <span class=\"hljs-keyword\">return</span> B;\n})();\n\n<span class=\"hljs-keyword\">var</span> A = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_super</span>) </span>{\n  __extends(A, _super);\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 借用继承，可以实现向父类传参, 使用 super 可以向父类传参</span>\n    <span class=\"hljs-keyword\">return</span> (_super !== <span class=\"hljs-literal\">null</span> && _super.apply(<span class=\"hljs-keyword\">this</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> })) || <span class=\"hljs-keyword\">this</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> A;\n})(B);\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p><code>测试 class</code></p>\n<pre><code class=\"hljs js copyable code-012\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">new</span> A();\n\n<span class=\"hljs-built_in\">console</span>.log(a.BName, a.constructor); <span class=\"hljs-comment\">// B ,ƒ A() {}</span>\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-7\">async/await 实现</h2>\n<blockquote>\n<p>原理就是利用 <code>generator</code>（生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个<code>yield</code> 用 <code>promise</code> 包裹起来。执行下一步的时机由 <code>promise</code> 来控制</p>\n</blockquote>\n<p><code>async/await</code> 是关键字，不能重写它的方法，我们使用函数来模拟</p>\n<p>异步迭代，模拟异步函数</p>\n<pre><code class=\"hljs js copyable code-013\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_asyncToGenerator</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>,\n      args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-comment\">// 将返回值promise化</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n      <span class=\"hljs-comment\">// 获取迭代器实例</span>\n      <span class=\"hljs-keyword\">var</span> gen = fn.apply(self, args);\n      <span class=\"hljs-comment\">// 执行下一步</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_next</span>(<span class=\"hljs-params\">value</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'next'</span>, value);\n      }\n      <span class=\"hljs-comment\">// 抛出异常</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_throw</span>(<span class=\"hljs-params\">err</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'throw'</span>, err);\n      }\n      <span class=\"hljs-comment\">// 第一次触发</span>\n      _next(<span class=\"hljs-literal\">undefined</span>);\n    });\n  };\n}\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>执行迭代步骤，处理下次迭代结果</p>\n<pre><code class=\"hljs js copyable code-014\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGeneratorStep</span>(<span class=\"hljs-params\">gen, resolve, reject, _next, _throw, key, arg</span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">var</span> info = gen[key](arg);\n    <span class=\"hljs-keyword\">var</span> value = info.value;\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    reject(error);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (info.done) {\n    <span class=\"hljs-comment\">// 迭代器完成</span>\n    resolve(value);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// -- 这行代码就是精髓 --</span>\n    <span class=\"hljs-comment\">// 将所有值promise化</span>\n    <span class=\"hljs-comment\">// 比如 yield 1</span>\n    <span class=\"hljs-comment\">// const a = Promise.resolve(1) a 是一个 promise</span>\n    <span class=\"hljs-comment\">// const b = Promise.resolve(a) b 是一个 promise</span>\n    <span class=\"hljs-comment\">// 可以做到统一 promise 输出</span>\n    <span class=\"hljs-comment\">// 当 promise 执行完之后再执行下一步</span>\n    <span class=\"hljs-comment\">// 递归调用 next 函数，直到 done == true</span>\n    <span class=\"hljs-built_in\">Promise</span>.resolve(value).then(_next, _throw);\n  }\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p><code>测试 _asyncToGenerator</code></p>\n<pre><code class=\"hljs js copyable code-015\" lang=\"js\"><span class=\"hljs-keyword\">const</span> asyncFunc = _asyncToGenerator(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> e = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      resolve(<span class=\"hljs-string\">'e'</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n  });\n  <span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'a'</span>);\n  <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'d'</span>;\n  <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'b'</span>);\n  <span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'c'</span>);\n  <span class=\"hljs-keyword\">return</span> [a, b, c, d, e];\n});\n\nasyncFunc().then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(res); <span class=\"hljs-comment\">// ['a', 'b', 'c', 'd', 'e']</span>\n});\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-8\">实现一个双向绑定</h2>\n<p><code>defineProperty</code> 版本</p>\n<pre><code class=\"hljs js copyable code-016\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-built_in\">Object</span>.defineProperty(data, <span class=\"hljs-string\">'text'</span>, {\n  <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n  set(newVal) {\n    input.value = newVal;\n    span.innerHTML = newVal;\n  }\n});\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  data.text = e.target.value;\n});\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><p><code>proxy</code> 版本</p>\n<pre><code class=\"hljs js copyable code-017\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-keyword\">const</span> handler = {\n  set(target, key, value) {\n    target[key] = value;\n    <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n    input.value = value;\n    span.innerHTML = value;\n    <span class=\"hljs-keyword\">return</span> value;\n  }\n};\n<span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(data, handler);\n\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  proxy.text = e.target.value;\n});\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-9\">Object.create 的基本实现原理</h2>\n<pre><code class=\"hljs js copyable code-018\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.create !== <span class=\"hljs-string\">\"function\"</span>) {\n  <span class=\"hljs-built_in\">Object</span>.create = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">prototype, properties</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> prototype !== <span class=\"hljs-string\">\"object\"</span>) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ctor</span>(<span class=\"hljs-params\"></span>) </span>{}\n    Ctor.prototype = prototype;\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Ctor();\n    <span class=\"hljs-keyword\">if</span> (prototype) { o.constructor = Ctor; }\n    <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-literal\">undefined</span>) {\n      <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-built_in\">Object</span>(properties)) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n      <span class=\"hljs-built_in\">Object</span>.defineProperties(o, properties);\n    }\n    <span class=\"hljs-keyword\">return</span> o;\n  };\n}\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-10\">instanceof 实现</h2>\n<blockquote>\n<p>原理： <code>L</code> 的 <code>__proto__</code> 是不是等于 <code>R.prototype</code>，不等于再找 <code>L.__proto__.__proto__</code> 直到 <code>__proto__</code> 为 <code>null</code></p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-019\" lang=\"js\"><span class=\"hljs-comment\">// L 表示左表达式，R 表示右表达式</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">instance_of</span>(<span class=\"hljs-params\">L, R</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> O = R.prototype;\n  L = L.__proto__;\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-comment\">// 这里重点：当 O 严格等于 L 时，返回 true</span>\n    <span class=\"hljs-keyword\">if</span> (O === L) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    L = L.__proto__;\n  }\n}\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-11\">Array.isArray 实现</h2>\n<pre><code class=\"hljs js copyable code-020\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.myIsArray = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(<span class=\"hljs-built_in\">Object</span>(o)) === <span class=\"hljs-string\">'[object Array]'</span>;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Array</span>.myIsArray([])); <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-12\">getOwnPropertyNames 实现</h2>\n<p>备注：不能拿到不可枚举的属性</p>\n<pre><code class=\"hljs js copyable code-021\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames !== <span class=\"hljs-string\">'function'</span>) {\n  <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (o !== <span class=\"hljs-built_in\">Object</span>(o)) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Object.getOwnPropertyNames called on non-object'</span>);\n    }\n    <span class=\"hljs-keyword\">var</span> props = [],\n      p;\n    <span class=\"hljs-keyword\">for</span> (p <span class=\"hljs-keyword\">in</span> o) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(o, p)) {\n        props.push(p);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> props;\n  };\n}\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-13\">Promise 实现</h2>\n<blockquote>\n<p>实现原理：其实就是一个发布订阅者模式</p>\n</blockquote>\n<ol>\n<li>构造函数接收一个 <code>executor</code> 函数，并会在 <code>new Promise()</code> 时立即执行该函数</li>\n<li><code>then</code> 时收集依赖，将回调函数收集到 <code>成功/失败队列</code></li>\n<li><code>executor</code> 函数中调用 <code>resolve/reject</code> 函数</li>\n<li><code>resolve/reject</code> 函数被调用时会通知触发队列中的回调</li>\n</ol>\n<p>先看一下整体代码，有一个大致的概念</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e43d1799b13cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"758\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"758\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>完整代码</p>\n<pre><code class=\"hljs js copyable code-022\" lang=\"js\"><span class=\"hljs-keyword\">const</span> isFunction = <span class=\"hljs-function\"><span class=\"hljs-params\">variable</span> =></span> <span class=\"hljs-keyword\">typeof</span> variable === <span class=\"hljs-string\">'function'</span>;\n\n<span class=\"hljs-comment\">// 定义Promise的三种状态常量</span>\n<span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">'pending'</span>;\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">'fulfilled'</span>;\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">'rejected'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyPromise</span> </span>{\n  <span class=\"hljs-comment\">// 构造函数，new 时触发</span>\n  <span class=\"hljs-keyword\">constructor</span>(handle: Function) {\n    <span class=\"hljs-keyword\">try</span> {\n      handle(<span class=\"hljs-keyword\">this</span>._resolve, <span class=\"hljs-keyword\">this</span>._reject);\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      <span class=\"hljs-keyword\">this</span>._reject(err);\n    }\n  }\n  <span class=\"hljs-comment\">// 状态 pending fulfilled rejected</span>\n  private _status: string = PENDING;\n  <span class=\"hljs-comment\">// 储存 value，用于 then 返回</span>\n  private _value: string | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-comment\">// 失败队列，在 then 时注入，resolve 时触发</span>\n  private _rejectedQueues: any = [];\n  <span class=\"hljs-comment\">// 成功队列，在 then 时注入，resolve 时触发</span>\n  private _fulfilledQueues: any = [];\n  <span class=\"hljs-comment\">// resovle 时执行的函数</span>\n  private _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">this</span>._status = FULFILLED;\n      <span class=\"hljs-comment\">// 依次执行成功队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runFulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._fulfilledQueues.shift())) {\n          cb(value);\n        }\n      };\n      <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runRejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n          cb(error);\n        }\n      };\n      <span class=\"hljs-comment\">/*\n       * 如果resolve的参数为Promise对象，\n       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变\n       * 且状态取决于参数Promsie对象的状态\n       */</span>\n      <span class=\"hljs-keyword\">if</span> (val <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n        val.then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n            <span class=\"hljs-keyword\">this</span>._value = value;\n            runFulfilled(value);\n          },\n          err => {\n            <span class=\"hljs-keyword\">this</span>._value = err;\n            runRejected(err);\n          }\n        );\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>._value = val;\n        runFulfilled(val);\n      }\n    };\n    <span class=\"hljs-comment\">// 异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// reject 时执行的函数</span>\n  private _reject = <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">this</span>._status = REJECTED;\n      <span class=\"hljs-keyword\">this</span>._value = err;\n      <span class=\"hljs-keyword\">let</span> cb;\n      <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n        cb(err);\n      }\n    };\n    <span class=\"hljs-comment\">// 为了支持同步的Promise，这里采用异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// then 方法</span>\n  then(onFulfilled?, onRejected?) {\n    <span class=\"hljs-keyword\">const</span> { _value, _status } = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 返回一个新的Promise对象</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">onFulfilledNext, onRejectedNext</span>) =></span> {\n      <span class=\"hljs-comment\">// 封装一个成功时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> fulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onFulfilled)) {\n            onFulfilledNext(value);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onFulfilled(value);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-comment\">// 封装一个失败时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> rejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onRejected)) {\n            onRejectedNext(error);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onRejected(error);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-keyword\">switch</span> (_status) {\n        <span class=\"hljs-comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span>\n        <span class=\"hljs-keyword\">case</span> PENDING:\n          <span class=\"hljs-keyword\">this</span>._fulfilledQueues.push(fulfilled);\n          <span class=\"hljs-keyword\">this</span>._rejectedQueues.push(rejected);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-comment\">// 当状态已经改变时，立即执行对应的回调函数</span>\n        <span class=\"hljs-keyword\">case</span> FULFILLED:\n          fulfilled(_value);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> REJECTED:\n          rejected(_value);\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// catch 方法</span>\n  <span class=\"hljs-keyword\">catch</span>(onRejected) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(<span class=\"hljs-literal\">undefined</span>, onRejected);\n  }\n  <span class=\"hljs-comment\">// finally 方法</span>\n  <span class=\"hljs-keyword\">finally</span>(cb) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> value),\n      reason =>\n        MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n          <span class=\"hljs-keyword\">throw</span> reason;\n        })\n    );\n  }\n  <span class=\"hljs-comment\">// 静态 resolve 方法</span>\n  <span class=\"hljs-keyword\">static</span> resolve(value) {\n    <span class=\"hljs-comment\">// 如果参数是MyPromise实例，直接返回这个实例</span>\n    <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> MyPromise) <span class=\"hljs-keyword\">return</span> value;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> resolve(value));\n  }\n  <span class=\"hljs-comment\">// 静态 reject 方法</span>\n  <span class=\"hljs-keyword\">static</span> reject(value) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> reject(value));\n  }\n  <span class=\"hljs-comment\">// 静态 all 方法</span>\n  <span class=\"hljs-keyword\">static</span> all(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-comment\">// 返回值的集合</span>\n      <span class=\"hljs-keyword\">let</span> values = [];\n      <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [i, p] <span class=\"hljs-keyword\">of</span> list.entries()) {\n        <span class=\"hljs-comment\">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            values[i] = res;\n            count++;\n            <span class=\"hljs-comment\">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span>\n            <span class=\"hljs-keyword\">if</span> (count === list.length) resolve(values);\n          },\n          err => {\n            <span class=\"hljs-comment\">// 有一个被rejected时返回的MyPromise状态就变成rejected</span>\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// 添加静态race方法</span>\n  <span class=\"hljs-keyword\">static</span> race(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> list) {\n        <span class=\"hljs-comment\">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            resolve(res);\n          },\n          err => {\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n}\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-14\">防抖/节流</h2>\n<blockquote>\n<p><code>防抖函数</code> onscroll 结束时触发一次，延迟执行</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-023\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">func, wait</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> timeout;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> context = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-keyword\">if</span> (timeout) clearTimeout(timeout);\n    timeout = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      func.apply(context, args);\n    }, wait);\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-built_in\">window</span>.onscroll = debounce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'debounce'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><blockquote>\n<p><code>节流函数</code> onscroll 时，每隔一段时间触发一次，像水滴一样</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-024\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">fn, delay</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> prevTime = <span class=\"hljs-built_in\">Date</span>.now();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> curTime = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-keyword\">if</span> (curTime - prevTime > delay) {\n      fn.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n      prevTime = curTime;\n    }\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">var</span> throtteScroll = throttle(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'throtte'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-built_in\">window</span>.onscroll = throtteScroll;\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-15\">函数柯里化实现</h2>\n<blockquote>\n<p>其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。</p>\n</blockquote>\n<p>实际应用中：</p>\n<ul>\n<li>延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）</li>\n<li>动态创建函数 （参数不够时会返回接受剩下参数的函数）</li>\n<li>参数复用（每个参数可以多次复用）</li>\n</ul>\n<pre><code class=\"hljs js copyable code-025\" lang=\"js\"><span class=\"hljs-keyword\">const</span> curry = <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =></span>\n  (judge = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =></span>\n    args.length >= fn.length\n      ? fn(...args)\n      : <span class=\"hljs-function\">(<span class=\"hljs-params\">...arg</span>) =></span> judge(...args, ...arg));\n\n<span class=\"hljs-keyword\">const</span> sum = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c, d</span>) =></span> a + b + c + d;\n<span class=\"hljs-keyword\">const</span> currySum = curry(sum);\n\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-16\">手写一个深拷贝</h2>\n<blockquote>\n<p>浅拷贝只复制地址值，实际上还是指向同一堆内存中的数据，深拷贝则是重新创建了一个相同的数据，二者指向的堆内存的地址值是不同的。这个时候修改赋值前的变量数据不会影响赋值后的变量。</p>\n</blockquote>\n<p>要实现一个完美的神拷贝太复杂了，这里简单介绍一下吧，可以应用于大部分场景了</p>\n<p>判断类型函数</p>\n<pre><code class=\"hljs js copyable code-026\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getType</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n  <span class=\"hljs-keyword\">const</span> map = {\n    <span class=\"hljs-string\">'[object Boolean]'</span>: <span class=\"hljs-string\">'boolean'</span>,\n    <span class=\"hljs-string\">'[object Number]'</span>: <span class=\"hljs-string\">'number'</span>,\n    <span class=\"hljs-string\">'[object String]'</span>: <span class=\"hljs-string\">'string'</span>,\n    <span class=\"hljs-string\">'[object Function]'</span>: <span class=\"hljs-string\">'function'</span>,\n    <span class=\"hljs-string\">'[object Array]'</span>: <span class=\"hljs-string\">'array'</span>,\n    <span class=\"hljs-string\">'[object Date]'</span>: <span class=\"hljs-string\">'date'</span>,\n    <span class=\"hljs-string\">'[object RegExp]'</span>: <span class=\"hljs-string\">'regExp'</span>,\n    <span class=\"hljs-string\">'[object Undefined]'</span>: <span class=\"hljs-string\">'undefined'</span>,\n    <span class=\"hljs-string\">'[object Null]'</span>: <span class=\"hljs-string\">'null'</span>,\n    <span class=\"hljs-string\">'[object Object]'</span>: <span class=\"hljs-string\">'object'</span>\n  };\n  <span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> Element) {\n    <span class=\"hljs-comment\">// 判断是否是dom元素，如div等</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'element'</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> map[str];\n}\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><p>简单版深拷贝，列举三个例子 <code>array</code> <code>object</code> <code>function</code>，可以自行扩展。主要是引发大家的思考</p>\n<pre><code class=\"hljs js copyable code-027\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepCopy</span>(<span class=\"hljs-params\">ori</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> type = getType(ori);\n  <span class=\"hljs-keyword\">let</span> copy;\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'array'</span>:\n      <span class=\"hljs-keyword\">return</span> copyArray(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'object'</span>:\n      <span class=\"hljs-keyword\">return</span> copyObject(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'function'</span>:\n      <span class=\"hljs-keyword\">return</span> copyFunction(ori, type, copy);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> ori;\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyArray</span>(<span class=\"hljs-params\">ori, type, copy = []</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [index, value] <span class=\"hljs-keyword\">of</span> ori.entries()) {\n    copy[index] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyObject</span>(<span class=\"hljs-params\">ori, type, copy = {}</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.entries(ori)) {\n    copy[key] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyFunction</span>(<span class=\"hljs-params\">ori, type, copy = (</span>) => </span>{}) {\n  <span class=\"hljs-keyword\">const</span> fun = <span class=\"hljs-built_in\">eval</span>(ori.toString());\n  fun.prototype = ori.prototype\n  <span class=\"hljs-keyword\">return</span> fun\n}\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-17\">最后有几件小事</h2>\n<ol>\n<li>有想入群的学习前端进阶的加我微信 <code>luoxue2479</code> 回复加群即可</li>\n<li>有错误的话欢迎在留言区指出，一起讨论，也可以加我微信</li>\n<li>每天在群里会有专题讨论 <a target=\"_blank\" href=\"https://github.com/luoxue-victor/source-code/issues/\" rel=\"nofollow noopener noreferrer\">github.com/luoxue-vict…</a></li>\n<li>鄙人公众号【前端技匠】，一起来学习吧。</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e448312ce00d07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"768\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"768\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>参考文章</p>\n<p><a target=\"_blank\" href=\"https://cloud.tencent.com/developer/article/1431398\" rel=\"nofollow noopener noreferrer\">cloud.tencent.com/developer/a…</a></p>\n<p><a target=\"_blank\" href=\"https://www.jianshu.com/p/b4f0425b22a1\" rel=\"nofollow noopener noreferrer\">www.jianshu.com/p/b4f0425b2…</a></p>\n<p><a target=\"_blank\" href=\"https://blog.csdn.net/LL18781132750/article/details/79700089\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/LL187811327…</a></p>\n",
      "id": "6nv7kf1u4cw0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https://www.zoo.team/article/text-overflow\" rel=\"nofollow noopener noreferrer\">可能是最全的 “文本溢出截断省略” 方案合集</a></p>\n</blockquote>\n<p></p><figure><img alt=\"亚格.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/9/16e50853a4306507?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"200\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">前言</h2>\n<p>在我们的日常开发工作中，文本溢出截断省略是很常见的一种需考虑的业务场景细节。看上去 “稀松平常” ，但在实现上却有不同的区分，是单行截断还是多行截断？多行的截断判断是基于行数还是基于高度？这些问题之下，都有哪些实现方案？他们之间的差异性和场景适应性又是如何？凡事就怕较真，较真必有成长。本文试图通过编码实践，给出一些答案。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">先来点基础的，单行文本溢出省略</h2>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>overflow: hidden；（文字长度超出限定宽度，则隐藏超出的内容）</li>\n<li>white-space: nowrap；（设置文字在一行显示，不能换行）</li>\n<li>text-overflow: ellipsis；（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n<li>省略号位置显示刚好</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>只支持单行文本截断</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于单行文本溢出显示省略号的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-00\" lang=\"javascript\"><style>\n    .demo {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n</style>\n<body>\n\t<div class=\"demo\">这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn copy-06\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c405615623?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\">进阶一下，多行文本溢出省略（按行数）</h2>\n<h3 class=\"heading\" data-id=\"heading-4\">○ 纯 CSS 实现方案</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>-webkit-line-clamp: 2；（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。 为了实现该效果，它需要组合其他的WebKit属性）</li>\n<li>display: -webkit-box；（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li>\n<li>-webkit-box-orient: vertical；（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li>\n<li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li>\n<li>text-overflow: ellipsis；（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n<li>省略号显示位置刚好</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>兼容性一般： -webkit-line-clamp 属性只有  WebKit  内核的浏览器才支持</li>\n</ul>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c406bdaa3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1212\" data-height=\"438\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1212\" height=\"438\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>多适用于移动端页面，因为移动设备浏览器更多是基于 WebKit 内核</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-01\" lang=\"javascript\"><style>\n\t.demo {\n\t\t  display: -webkit-box;\n\t    overflow: hidden;\n\t    -webkit-line-clamp: 2;\n\t    -webkit-box-orient: vertical;\n\t}\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn copy-07\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c40876a945?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-5\">○ 基于 JavaScript 的实现方案</h3>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n<li>文本溢出范围才显示省略号，否则不显示省略号</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>需要 JS 实现，背离展示和行为相分离原则</li>\n<li>文本为中英文混合时，省略号显示位置略有偏差</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于响应式截断，多行文本溢出省略的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<p>当前仅适用于文本为中文，若文本中有英文，可自行修改</p>\n<pre><code class=\"hljs javascript copyable code-02\" lang=\"javascript\"><script type=\"text/javascript\">\n    const text = '这是一段很长的文本';\n    const totalTextLen = text.length;\n    const formatStr = () => {\n        const ele = document.getElementsByClassName('demo')[0];\n        const lineNum = 2;\n        const baseWidth = window.getComputedStyle(ele).width;\n        const baseFontSize = window.getComputedStyle(ele).fontSize;\n        const lineWidth = +baseWidth.slice(0, -2);\n\n        // 所计算的strNum为元素内部一行可容纳的字数(不区分中英文)\n        const strNum = Math.floor(lineWidth / +baseFontSize.slice(0, -2));\n\n        let content = '';\n        \n      \t// 多行可容纳总字数\n        const totalStrNum = Math.floor(strNum * lineNum);\n\n        const lastIndex = totalStrNum - totalTextLen;\n\n        if (totalTextLen > totalStrNum) {\n            content = text.slice(0, lastIndex - 3).concat('...');\n        } else {\n            content = text;\n        }\n        ele.innerHTML = content;\n    }\n    \n    formatStr();\n    \n\t\twindow.onresize = () => {\n        formatStr();\n    };\n</script>\n\n<body>\n\t<div class='demo'></div>\n</body>\n<span class=\"copy-code-btn copy-08\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4099041ae?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">再进阶一步，多行文本溢出省略（按高度）</h2>\n<h3 class=\"heading\" data-id=\"heading-7\">○ 多行文本溢出不显示省略号</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li>\n<li>line-height: 20px；（结合元素高度，高度固定的情况下，设定行高， 控制显示行数）</li>\n<li>max-height: 40px；（设定当前元素最大高度）</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无兼容问题</li>\n<li>响应式截断</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>单纯截断文字, 不展示省略号，观感上较为生硬</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于文本溢出不需要显示省略号的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-03\" lang=\"javascript\"><style>\n\t.demo {\n\t\toverflow: hidden;\n\t\tmax-height: 40px;\n\t\tline-height: 20px;\n\t}\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n\n<span class=\"copy-code-btn copy-09\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4096f17c9?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-8\">○ 伪元素 + 定位实现多行省略</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>\n<p>position: relative; （为伪元素绝对定位）</p>\n</li>\n<li>\n<p>overflow: hidden; （文本溢出限定的宽度就隐藏内容）</p>\n</li>\n<li>\n<p>position: absolute;（给省略号绝对定位）</p>\n</li>\n<li>\n<p>line-height: 20px; （结合元素高度,高度固定的情况下,设定行高, 控制显示行数）</p>\n</li>\n<li>\n<p>height: 40px; （设定当前元素高度）</p>\n</li>\n<li>\n<p>::after {}  （设置省略号样式）</p>\n</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>\n<p>无兼容问题</p>\n</li>\n<li>\n<p>响应式截断</p>\n</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>\n<p>无法识别文字的长短，无论文本是否溢出范围, 一直显示省略号</p>\n</li>\n<li>\n<p>省略号显示可能不会刚刚好，有时会遮住一半文字</p>\n</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于对省略效果要求较低，文本一定会溢出元素的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-04\" lang=\"javascript\"><style>\n    .demo {\n        position: relative;\n        line-height: 20px;\n        height: 40px;\n        overflow: hidden;\n    }\n    .demo::after {\n        content: \"...\";\n        position: absolute;\n        bottom: 0;\n        right: 0;\n        padding: 0 20px 0 10px;\n    }\n</style>\n\n<body>\n\t<div class='demo'>这是一段很长的文本</div>\n</body>\n<span class=\"copy-code-btn copy-010\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c40d1eefac?imageslim\" data-width=\"714\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"714\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-9\">○ 利用 Float 特性，纯 CSS 实现多行省略</h3>\n<p><strong>核心 CSS 语句</strong></p>\n<ul>\n<li>\n<p>line-height: 20px；（结合元素高度,高度固定的情况下,设定行高, 控制显示行数）</p>\n</li>\n<li>\n<p>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</p>\n</li>\n<li>\n<p>float: right/left；（利用元素浮动的特性实现）</p>\n</li>\n<li>\n<p>position: relative；（根据自身位置移动省略号位置, 实现文本溢出显示省略号效果）</p>\n</li>\n<li>\n<p>word-break: break-all；（使一个单词能够在换行时进行拆分）</p>\n</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>\n<p>无兼容问题</p>\n</li>\n<li>\n<p>响应式截断</p>\n</li>\n<li>\n<p>文本溢出范围才显示省略号，否则不显示省略号</p>\n</li>\n</ul>\n<p><strong>短板</strong></p>\n<ul>\n<li>省略号显示可能不会刚刚好，有时会遮住一半文字</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>适用于对省略效果要求较低，多行文本响应式截断的情况</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"hljs javascript copyable code-05\" lang=\"javascript\"><style>\n    .demo {\n        background: #099;\n        max-height: 40px;\n        line-height: 20px;\n        overflow: hidden;\n    }\n    .demo::before{\n        float: left;\n        content:'';\n        width: 20px;\n        height: 40px;\n    }\n\n    .demo .text {\n        float: right;\n        width: 100%;\n        margin-left: -20px;\n        word-break: break-all;\n    }\n    .demo::after{\n        float:right;\n        content:'...';\n        width: 20px;\n        height: 20px;\n        position: relative;\n        left:100%;\n        transform: translate(-100%,-100%);\n    }\n</style>\n\n<body>\n    <div class='demo'>\n    \t<div class=\"text\">这是一段很长的文本</div>\n    </div>\n</body>\n<span class=\"copy-code-btn copy-011\">复制代码</span></code></pre><p><strong>示例图片</strong></p>\n<p></p><figure><img alt=\"avatar\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c4375581cb?imageslim\" data-width=\"730\" data-height=\"494\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"730\" height=\"494\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>原理讲解</strong></p>\n<p>有 A、B、C 三个盒子，A 左浮动，B、C 右浮动。设置 A 盒子的高度与 B 盒子高度（或最大高度）要保持一致</p>\n<ol>\n<li>\n<p>当的 B 盒子高度低于 A 盒子，C 盒子仍会处于 B 盒子右下方。</p>\n</li>\n<li>\n<p>如果 B 盒子文本过多，高度超过了 A 盒子，则 C 盒子不会停留在右下方，而是掉到了 A 盒子下。</p>\n</li>\n<li>\n<p>接下来对 C 盒子进行相对定位，将 C 盒子位置向右侧移动 100%，并向左上方向拉回一个 C 盒子的宽高（不然会看不到哟）。这样在文本未溢出时不会看到 C 盒子，在文本溢出时，显示 C 盒子。</p>\n</li>\n</ol>\n<p></p><figure><img alt=\"yuanli.gif\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c444cf3295?imageslim\" data-width=\"730\" data-height=\"494\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"730\" height=\"494\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">收，大道归简，能力封装</h2>\n<blockquote>\n<p>凡重复的，让它单一；凡复杂的，让它简单。</p>\n</blockquote>\n<p>每次都要搞一坨代码，太麻烦。这时候你需要考虑将文本截断的能力，封装成一个可随时调用的自定义容器组件。市面上很多 UI 组件库，都提供了同类组件的封装，如基于 Vue 的 ViewUI Pro，或面向小程序提供组件化解决能力的 MinUI 。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c44af83125?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1194\" data-height=\"700\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1194\" height=\"700\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3b4c44857bc88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"940\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"940\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-11\">结语</h2>\n<p>本文介绍了几种目前常见的文本截断省略的方案，各有利弊，各位同学可根据实际开发情况及需求选择方案。如果你还知道更好其他实现方案，欢迎在评论区留下宝贵评论。</p>\n<h2 class=\"heading\" data-id=\"heading-12\">参考文章</h2>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/happylindz/blog/issues/12\" rel=\"nofollow noopener noreferrer\">纯 CSS 实现多行文字截断</a></li>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/qq_40072782/article/details/82908581\" rel=\"nofollow noopener noreferrer\">【 CSS / JS 】限制一行和多行文字数量，溢出部分用省略号显示</a></li>\n<li><a target=\"_blank\" href=\"https://baijiahao.baidu.com/s?id=1621362934713048315&wfr=spider&for=pc\" rel=\"nofollow noopener noreferrer\">HTML技巧篇：如何让单行文本以及多行文本溢出显示省略号(…)</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-13\">招贤纳士</h2>\n<p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p>\n<p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/29/16cddbe09f60b388?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">推荐阅读</h2>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5dafa3d35188257b1549bad1\" rel>1024 巨献！！一文看尽前端过去一年的精华沉淀（700 篇好文大汇总）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" rel>前端工程实践之可视化搭建系统（一）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6de51de51d45620771f12c\" rel>自动化 Web 性能优化分析方案</a></p>\n",
      "id": "2mic9jiahsi0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）</p>\n<p>Github: <a target=\"_blank\" href=\"https://github.com/huangwei9527/quark-h5\" rel=\"nofollow noopener noreferrer\">传送门</a><br>\n演示地址：<a target=\"_blank\" href=\"http://47.104.247.183:4000/\" rel=\"nofollow noopener noreferrer\">传送门</a></p>\n<p><strong>编辑器预览：</strong></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\" data-width=\"1280\" data-height=\"602\" src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">技术栈</h2>\n<p><strong>前端：</strong><br>\n<code>vue</code>: 模块化开发少不了angular，react，vue三选一，这里选择了vue。<br>\n<code>vuex</code>: 状态管理<br>\n<code>sass</code>: css预编译器。<br>\n<code>element-ui</code>：不造轮子，有现成的优秀的vue组件库当然要用起来。没有的自己再封装一些就可以了。<br>\n<code>loadsh</code>：工具类<br></p>\n<p><strong>服务端：</strong><br>\n<code>koa</code>：后端语言采用nodejs，koa文档和学习资料也比较多，express原班人马打造，这个正合适。<br>\n<code>mongodb</code>：一个基于分布式文件存储的数据库，比较灵活。<br></p>\n<h2 class=\"heading\" data-id=\"heading-2\">阅读前准备</h2>\n<p>1、了解vue技术栈开发<br>\n2、了解koa<br>\n3、了解mongodb<br></p>\n<h2 class=\"heading\" data-id=\"heading-3\">工程搭建</h2>\n<p><strong>基于vue-cli3环境搭建</strong><br></p>\n<ul>\n<li>如何规划好我们项目的目录结构？首先我们需要有一个目录作为前端项目，一个目录作为后端项目。所以我们要对vue-cli 生成的项目结构做一下改造：</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">···\n·\n|-- client\t\t\t\t// 原 src 目录，改成 client 用作前端项目目录\n|-- server\t\t\t\t// 新增 server 用于服务端项目目录\n|-- engine-template\t\t// 新增 engine-template 用于页面模板库目录\n|-- docs\t\t\t\t// 新增 docs 预留编写项目文档目录\n·\n···\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><ul>\n<li>\n<p>这样的话 我们需要再把我们webpack配置文件稍作一下调整，首先是把原先的编译指向src的目录改成client，其次为了 npm run build 能正常编译 client 我们也需要为 babel-loader 再增加一个编译目录：</p>\n<ul>\n<li>\n<p>根目录新增vue.config.js,目的是为了改造项目入口,改为:client/main.js</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">    module.exports = {    \n      pages: {        \n        index: {            \n          entry: <span class=\"hljs-string\">\"client/main.js\"</span>        \n        }    \n      }\n    }\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre></li>\n<li>\n<p>babel-loader能正常编译 client, engine-template目录， 在vue.config.js新增如下配置</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">// 扩展 webpack 配置\nchainWebpack: config => {\n\tconfig.module\n\t.rule(<span class=\"hljs-string\">'js'</span>)\n\t.include.add(/engine-template/).end()\n\t.include.add(/client/).end()\n\t.use(<span class=\"hljs-string\">'babel'</span>)\n\t.loader(<span class=\"hljs-string\">'babel-loader'</span>)\n\t.tap(options => {\n\t// 修改它的选项...\n\t<span class=\"hljs-built_in\">return</span> options\n\t})\n}\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre></li>\n</ul>\n</li>\n</ul>\n<p>这样我们搭建起来一个简易的项目目录结构。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">工程目录结构</h2>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">|-- client\t\t\t\t\t--------前端项目界面代码\n    |--common\t\t\t\t\t--------前端界面对应静态资源\n    |--components\t\t\t\t--------组件\n    |--config\t\t\t\t\t--------配置文件\n    |--eventBus\t\t\t\t\t--------eventBus\n    |--filter\t\t\t\t\t--------过滤器\n    |--mixins\t\t\t\t\t--------混入\n    |--pages\t\t\t\t\t--------页面\n    |--router\t\t\t\t\t--------路由配置\n    |--store\t\t\t\t\t--------vuex状态管理\n    |--service\t\t\t\t\t--------axios封装\n    |--App.vue\t\t\t\t\t--------App\n    |--main.js\t\t\t\t\t--------入口文件\n    |--permission.js\t\t\t--------权限控制\n|-- server\t\t\t\t\t--------服务器端项目代码\n    |--confog\t\t\t\t\t--------数据库链接相关\n    |--middleware\t\t\t\t--------中间件\n    |--models\t\t\t\t\t--------Schema和Model\n    |--routes\t\t\t\t\t--------路由\n    |--views\t\t\t\t\t--------ejs页面模板\n    |--public\t\t\t\t\t--------静态资源\n    |--utils\t\t\t\t\t--------工具方法\n    |--app.js\t\t\t\t\t--------服务端入口\n|-- common\t\t\t\t\t--------前后端公用代码模块（如加解密）\n|-- engine-template\t\t\t--------页面模板引擎，使用webpack打包成js提供页面引用\n|-- docs\t\t\t\t\t--------预留编写项目文档目录\n|-- config.json\t\t\t\t--------配置文件\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">前端编辑器实现</h2>\n<p>编辑器的实现思路是：编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e582f5b9c69601?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"747\" data-height=\"435\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"747\" height=\"435\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">数据结构</h2>\n<p>确认了实现逻辑，数据结构也是非常重要的，把一个页面定义成一个JSON数据，数据结构大致是这样的：</p>\n<p><strong>页面工程数据接口</strong></p>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">{\n\ttitle: <span class=\"hljs-string\">''</span>, // 标题\n\tdescription: <span class=\"hljs-string\">''</span>, //描述\n\tcoverImage: <span class=\"hljs-string\">''</span>, // 封面\n\tauther: <span class=\"hljs-string\">''</span>, // 作者\n\tscript: <span class=\"hljs-string\">''</span>, // 页面插入脚本\n\twidth: 375, // 高\n\theight: 644, // 宽\n\tpages: [], // 多页页面\n\tshareConfig: {}, // 微信分享配置\n\tpageMode: 0, // 渲染模式，用于扩展多种模式渲染，翻页h5/长页/PC页面等等\n}\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><p><strong>多页页面pages其中一页数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">{\n\tname: <span class=\"hljs-string\">''</span>,\n\telements: [], // 页面元素\n\tcommonStyle: {\n\t\tbackgroundColor: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundImage: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundSize: <span class=\"hljs-string\">'cover'</span>\n\t},\n\tconfig: {}\n}\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><p><strong>元素数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">{\n\telName: <span class=\"hljs-string\">''</span>, // 组件名\n\tanimations: [], // 图层的动画,可以支持多个动画\n\tcommonStyle: {}, // 公共样式，默认样式\n\tevents: [], // 事件配置数据，每个图层可以添加多个事件\n\tpropsValue: {}, // 属性参数\n\tvalue: <span class=\"hljs-string\">''</span>, // 绑定值\n\tvalueType: <span class=\"hljs-string\">'String'</span>, // 值类型\n\tisForm: <span class=\"hljs-literal\">false</span> // 是否是表单控件，用于表单提交时获取表单数据\n}\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">编辑器整体设计</h3>\n<ul>\n<li>一个组件选择区，提供使用者选择需要的组件</li>\n<li>一个编辑预览画板，提供使用者拖拽排序页面预览的功能</li>\n<li>一个组件属性编辑，提供给使用者编辑组件内部props、公共样式和动画的功能\n<strong>如图：</strong></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e58647221d6942?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"602\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"602\"></svg>\"><figcaption></figcaption></figure>\n用户在左侧组件区域选择组件添加到页面上，编辑区域通过动态组件特性渲染出每个元素组件。<p></p>\n<p><code>最后，点击保存将页面数据提交到数据库。至于数据怎么转成静态 HTML方法有很多。还有页面数据我们全部都有，我们可以做页面的预渲染，骨架屏，ssr，编译时优化等等。而且我们也可以对产出的活动页做数据分析~有很多想象的空间。</code></p>\n<h3 class=\"heading\" data-id=\"heading-8\">核心代码</h3>\n<p>编辑器核心代码，基于 Vue 动态组件特性实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e586d0f77fe59a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1120\" data-height=\"340\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1120\" height=\"340\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>为大家附上 Vue 官方文档：<a target=\"_blank\" title=\"cn.vuejs.org/v2/api/#is\" href=\"https://cn.vuejs.org/v2/api/#is\" rel=\"nofollow noopener noreferrer\">cn.vuejs.org/v2/api/#is</a></p>\n<h3 class=\"heading\" data-id=\"heading-9\">画板元素渲染</h3>\n<p>编辑画板只需要循环遍历pages[i].elements数组，将里面的元素组件JSON数据取出，通过动态组件渲染出各个组件，支持拖拽改变位置尺寸.</p>\n<h3 class=\"heading\" data-id=\"heading-10\">元素组件管理</h3>\n<p>在client目录新建plugins来管理组件库。也可以将该组件库发到npm上工程中通过npm管理</p>\n<h4 class=\"heading\" data-id=\"heading-11\">组件库</h4>\n<p>编写组件，考虑的是组件库，所以我们竟可能让我们的组件支持全局引入和按需引入，如果全局引入，那么所有的组件需要要注册到Vue component 上，并导出：</p>\n<p><strong>client/plugins下新建index.js入口文件</strong></p>\n<pre><code class=\"copyable code-07\">```\n/**\n * 组件库入口\n * */\nimport Text from './text'\n// 所有组件列表\nconst components = [\n\tText\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n\t// 判断是否安装，安装过就不继续往下执行\n\tif (install.installed) return\n\tinstall.installed = true\n\t// 遍历注册所有组件\n\tcomponents.map(component => Vue.component(component.name, component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n\tinstall(window.Vue)\n}\n\nexport default {\n\tinstall,\n\t// 所有组件，必须具有 install，才能使用 Vue.use()\n\tText\n}\n```\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-12\">组件开发</h4>\n<p>示例： text文本组件</p>\n<p><strong>client/plugins下新建text组件目录</strong></p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">|-- text                --------text组件\n    |--src              --------资源\n    \t|--index.vue    --------组件\n    |--index.js         --------入口\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><p>text/index.js</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">// 为组件提供 install 方法，供组件对外按需引入\nimport Component from <span class=\"hljs-string\">'./src/index'</span>\nComponent.install = Vue => {\n\tVue.component(Component.name, Component)\n}\n<span class=\"hljs-built_in\">export</span> default Component\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><p>text/src/index.vue</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\"><!--text.vue-->\n<template>\n  <div class=<span class=\"hljs-string\">\"qk-text\"</span>>\n    {{text}}\n  </div>\n</template>\n\n<script>\n\t<span class=\"hljs-built_in\">export</span> default {\n\t\tname: <span class=\"hljs-string\">'QkText'</span>, // 这个名字很重要，它就是未来的标签名<qk-text></qk-text>\n\t\tprops: {\n\t\t\ttext: {\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: String,\n\t\t\t\tdefault: <span class=\"hljs-string\">'这是一段文字'</span>\n      \t\t}\n\t\t}\n\t}\n</script>\n\n<style lang=<span class=\"hljs-string\">\"scss\"</span> scoped>\n</style>\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p><strong>编辑器里使用组件库：</strong></p>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\">// 引入组件库\nimport QKUI from <span class=\"hljs-string\">'client/plugins/index'</span>\n// 注册组件库\nVue.use(QKUI)\n\n// 使用：\n<qk-text text=<span class=\"hljs-string\">\"这是一段文字\"</span>></qk-text>\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><p>按照这个组件开发方式我们可以扩展任意多的组件，来丰富组件库</p>\n<p><code>需要注意的是这里的组件最外层宽高都要求是100%</code></p>\n<h4 class=\"heading\" data-id=\"heading-13\">配置文件</h4>\n<p>Quark-h5编辑器左侧选择组件区域可以通过一个配置文件定义可选组件\n新建一个ele-config.js配置文件：</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default [\n\t{\n\t\ttitle: <span class=\"hljs-string\">'基础组件'</span>,\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\telName: <span class=\"hljs-string\">'qk-text'</span>, // 组件名，与组件库名称一致\n\t\t\t\ttitle: <span class=\"hljs-string\">'文字'</span>,\n\t\t\t\ticon: <span class=\"hljs-string\">'iconfont iconwenben'</span>,\n\t\t\t\t// 给每个组件配置默认显示样式\n\t\t\t\tdefaultStyle: {\n\t\t\t\t\theight: 40\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'表单组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'功能组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'业务组件'</span>,\n\t\tcomponents: []\n\t}\n]\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>公共方法中提供一个function 通过组件名和默认样式获取元素组件JSON，getElementConfigJson(elName, defaultStyle)方法</p>\n<h3 class=\"heading\" data-id=\"heading-14\">元素属性编辑</h3>\n<h4 class=\"heading\" data-id=\"heading-15\">公共属性样式编辑</h4>\n<p>公共样式属性编辑比较简单就是对元素JSON对象commonStyles字段进行编辑操作</p>\n<h4 class=\"heading\" data-id=\"heading-16\">props属性编辑</h4>\n<p>1.为组件的每一个prop属性开发一个属性编辑组件. 例如：QkText组件需要text属性，新增一个attr-qk-text组件来操作该属性\n2.获取组件prop对象\n3.遍历prop对象key, 通过key判断显示哪些属性编辑组件</p>\n<h3 class=\"heading\" data-id=\"heading-17\">元素添加动画实现</h3>\n<p>动画效果引入Animate.css动画库。元素组件动画,可以支持多个动画。数据存在元素JSON对象animations数组里。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">选择面板hover预览动画</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e596162029891d?imageslim\" data-width=\"457\" data-height=\"452\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"457\" height=\"452\"></svg>\"><figcaption></figcaption></figure>\n监听mouseover和mouseleave，当鼠标移入时将动画className添加入到元素上，鼠标移出时去掉动画lassName。这样就实现了hover预览动画<p></p>\n<h4 class=\"heading\" data-id=\"heading-19\">编辑预览动画</h4>\n<p>组件编辑时支持动画预览和单个动画预览。\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e5965a19adb15e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"448\" data-height=\"170\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"448\" height=\"170\"></svg>\"><figcaption></figcaption></figure>\n封装一个动画执行方法<p></p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">/**\n * 动画方法， 将动画css加入到元素上，返回promise提供执行后续操作（将动画重置）\n * @param <span class=\"hljs-variable\">$el</span> 当前被执行动画的元素\n * @param animationList 动画列表\n * @param isDebugger 动画列表\n * @returns {Promise<void>}\n */\n<span class=\"hljs-built_in\">export</span> default async <span class=\"hljs-keyword\">function</span> runAnimation(<span class=\"hljs-variable\">$el</span>, animationList = [], isDebug , callback){\n\t<span class=\"hljs-built_in\">let</span> playFn = <span class=\"hljs-keyword\">function</span> (animation) {\n\t\t<span class=\"hljs-built_in\">return</span> new Promise(resolve => {\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationName =  animation.type\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDuration =  `<span class=\"hljs-variable\">${animation.duration}</span>s`\n\t\t\t// 如果是循环播放就将循环次数置为1，这样有效避免编辑时因为预览循环播放组件播放动画无法触发animationend来暂停组件动画\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationIterationCount =  animation.infinite ? (isDebug ? 1 : <span class=\"hljs-string\">'infinite'</span>) : animation.interationCount\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDelay =  `<span class=\"hljs-variable\">${animation.delay}</span>s`\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationFillMode =  <span class=\"hljs-string\">'both'</span>\n\t\t\t<span class=\"hljs-built_in\">let</span> resolveFn = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>(){\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.removeEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\tresolve()\n\t\t\t}\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>)\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t})\n\t}\n\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> i = 0, len = animationList.length; i < len; i++){\n\t\tawait playFn(animationList[i])\n\t}\n\t<span class=\"hljs-keyword\">if</span>(callback){\n\t\tcallback()\n\t}\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p><code>animationIterationCount 如果是编辑模式的化动画只执行一次，不然无法监听到动画结束animationend事件</code></p>\n<p>执行动画前先将元素样式style缓存起来，当动画执行完再将原样式赋值给元素</p>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> cssText = this.<span class=\"hljs-variable\">$el</span>.style.cssText;\nrunAnimations(this.<span class=\"hljs-variable\">$el</span>, animations, <span class=\"hljs-literal\">true</span>, () => {\n\tthis.<span class=\"hljs-variable\">$el</span>.style.cssText = cssText\n})\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">元素添加事件</h3>\n<p>提供事件mixins混入到组件，每个事件方法返回promise，元素被点击时按顺序执行事件方法</p>\n<h3 class=\"heading\" data-id=\"heading-21\">页面插入js脚本</h3>\n<p>参考百度H5，将脚本以script标签形式嵌入。页面加载后执行。\n这里也可以考虑mixins方式混入到页面或者组件，可根据业务需求自行扩展，都是可以实现的。</p>\n<h3 class=\"heading\" data-id=\"heading-22\">redo/undo历史操作纪录</h3>\n<ol>\n<li>历史操作纪录存在状态机store.state.editor.historyCache数组中。</li>\n<li>每次修改编辑操作都把整个pageDataJson字段push到historyCache</li>\n<li>点击redo/undo时根据index获取到pageDataJson重新渲染页面</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-23\">psd设计图导入生成h5页面</h3>\n<p>将psd每个设计图中的每个图层导出成图片保存到静态资源服务器中，</p>\n<p><strong>服务端安装psd依赖</strong></p>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\">cnpm install psd --save\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><p><strong>加入psd.js依赖，并且提供接口来处理数据</strong></p>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\">var PSD = require(<span class=\"hljs-string\">'psd'</span>);\nrouter.post(<span class=\"hljs-string\">'/psdPpload'</span>,async ctx=>{\n\tconst file = ctx.request.files.file; // 获取上传文件\n\t<span class=\"hljs-built_in\">let</span> psd = await PSD.open(file.path)\n\tvar timeStr = + new Date();\n\t<span class=\"hljs-built_in\">let</span> descendantsList = psd.tree().descendants();\n\tdescendantsList.reverse();\n\t<span class=\"hljs-built_in\">let</span> psdSourceList = []\n\t<span class=\"hljs-built_in\">let</span> currentPathDir = `public/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>`\n\t<span class=\"hljs-keyword\">for</span> (var i = 0; i < descendantsList.length; i++){\n\t\t<span class=\"hljs-keyword\">if</span> (descendantsList[i].isGroup()) <span class=\"hljs-built_in\">continue</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (!descendantsList[i].visible) <span class=\"hljs-built_in\">continue</span>;\n\t\ttry{\n\t\t\tawait descendantsList[i].saveAsPng(path.join(ctx.state.SERVER_PATH, currentPathDir + `/<span class=\"hljs-variable\">${i}</span>.png`))\n\t\t\tpsdSourceList.push({\n\t\t\t\t...descendantsList[i].export(),\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'picture'</span>,\n\t\t\t\timageSrc: ctx.state.BASE_URL + `/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>/<span class=\"hljs-variable\">${i}</span>.png`,\n\t\t\t})\n\t\t}catch (e) {\n\t\t\t// 转换不出来的图层先忽略\n\t\t\t<span class=\"hljs-built_in\">continue</span>;\n\t\t}\n\t}\n\tctx.body = {\n\t\telements: psdSourceList,\n\t\tdocument: psd.tree().export().document\n\t};\n})\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><p><strong>最后把获取的数据转义并返回给前端，前端获取到数据后使用系统统一方法，遍历添加统一图片组件</strong></p>\n<ul>\n<li>psd源文件大小最好不要超过30M，过大会导致浏览器卡顿甚至卡死</li>\n<li>尽可能合并图层，并栅格化所有图层</li>\n<li>较复杂的图层样式，如滤镜、图层样式等无法读取</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-24\">html2canvas生成缩略图</h3>\n<p>这里只需要注意下图片跨域问题，官方提供html2canvas: proxy解决方案。它将图片转化为base64格式，结合使用设置(proxy: theProxyURL), 绘制到跨域图片时，会去访问theProxyURL下转化好格式的图片，由此解决了画布污染问题。\n提供一个跨域接口</p>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\">/**\n * html2canvas 跨域接口设置\n */\nrouter.get(<span class=\"hljs-string\">'/html2canvas/corsproxy'</span>, async ctx => {\n\tctx.body =  await request(ctx.query.url)\n})\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-25\">渲染模板</h2>\n<h3 class=\"heading\" data-id=\"heading-26\">实现逻辑</h3>\n<p>在engine-template目录下新建swiper-h5-engine页面组件，这个组件接收到页面JSON数据就可以把页面渲染出来。跟编辑预览画板实现逻辑差不多。</p>\n<p>然后使用vue-cli库打包命令将组件打包成engine.js库文件。ejs模板引入该页面组件配合json数据渲染出页面</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59c83f8b1c456?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"799\" data-height=\"496\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"799\" height=\"496\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-27\">适配方案</h3>\n<p>提供两种方案解决屏幕适配\n1、等比例缩放\n在将json元素转换为dom元素的时候，对所有的px单位做比例转换，转换公式为 new = old * windows.x / pageJson.width，这里的pageJson.width是页面的一个初始值，也是编辑时候的默认宽度，同时viewport使用device-width。\n2.全屏背景， 页面垂直居中\n因为会存在上下或者左右有间隙的情况，这时候我们把背景颜色做全屏处理</p>\n<p><code>页面垂直居中只适用于全屏h5, 以后扩展长页和PC页就不需要垂直居中处理。</code></p>\n<h3 class=\"heading\" data-id=\"heading-28\">模板打包</h3>\n<p>package.json中新增打包命令</p>\n<p><code>\"lib:h5-swiper\": \"vue-cli-service build --target lib --name h5-swiper --dest server/public/engine_libs/h5-swiper engine-template/engine-h5-swiper/index.js\"</code></p>\n<p>执行npm run lib:h5-swiper 生成引擎模板js如图</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59d256c29c46c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"464\" data-height=\"185\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"464\" height=\"185\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-29\">页面渲染</h3>\n<p>ejs中引入模板</p>\n<p><code><script src=\"/third-libs/swiper.min.js\"></script></code></p>\n<p>使用组件</p>\n<p><code><engine-h5-swiper :pageData=\"pageData\" /></code></p>\n<h2 class=\"heading\" data-id=\"heading-30\">后端服务</h2>\n<h3 class=\"heading\" data-id=\"heading-31\">初始化项目</h3>\n<p>工程目录上文已给出，也可以使用 koa-generator 脚手架工具生成</p>\n<h3 class=\"heading\" data-id=\"heading-32\">ejs-template 模板引擎配置</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\">//配置ejs-template 模板引擎\nrender(app, {\n\troot: path.join(__dirname, <span class=\"hljs-string\">'views'</span>),\n\tlayout: <span class=\"hljs-literal\">false</span>,\n\tviewExt: <span class=\"hljs-string\">'html'</span>,\n\tcache: <span class=\"hljs-literal\">false</span>,\n\tdebug: <span class=\"hljs-literal\">false</span>\n});\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-33\">koa-static静态资源服务</h3>\n<p>因为html2canvas需要图片允许跨域，所以在静态资源服务中所有资源请求设置'Access-Control-Allow-Origin':'*'</p>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">//配置静态web\napp.use(koaStatic(__dirname + <span class=\"hljs-string\">'/public'</span>), { gzip: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-built_in\">set</span>Headers: <span class=\"hljs-keyword\">function</span>(res){\n\tres.header( <span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>)\n}});\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-34\">修改路由的注册方式，通过遍历routes文件夹读取文件</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\">const fs =  require(<span class=\"hljs-string\">'fs'</span>)\nfs.readdirSync(<span class=\"hljs-string\">'./routes'</span>).forEach(route=> {\n    <span class=\"hljs-built_in\">let</span> api = require(`./routes/<span class=\"hljs-variable\">${route}</span>`)\n    app.use(api.routes(), api.allowedMethods())\n})\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-35\">添加jwt认证，同时过滤不需要认证的路由，如获取token</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\">const jwt = require(<span class=\"hljs-string\">'koa-jwt'</span>)\napp.use(jwt({ secret: <span class=\"hljs-string\">'yourstr'</span> }).unless({\n    path: [\n        /^\\/$/, /\\/token/, /\\/wechat/,\n        { url: /\\/papers/, methods: [<span class=\"hljs-string\">'GET'</span>] }\n    ]\n}));\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-36\">中间件实现统一接口返回数据格式，全局错误捕获并响应</h3>\n<p>middleware/formatresponse.js</p>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\">module.exports = async (ctx, next) => {\n\tawait next().then(() => {\n\t\t<span class=\"hljs-keyword\">if</span> (ctx.status === 200) {\n\t\t\tctx.body = {\n\t\t\t\tmessage: <span class=\"hljs-string\">'成功'</span>,\n\t\t\t\tcode: 200,\n\t\t\t\tbody: ctx.body,\n\t\t\t\tstatus: <span class=\"hljs-literal\">true</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ctx.status === 201) { // 201处理模板引擎渲染\n\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tctx.body = {\n\t\t\t\tmessage: ctx.body || <span class=\"hljs-string\">'接口异常，请重试'</span>,\n\t\t\t\tcode: ctx.status,\n\t\t\t\tbody: <span class=\"hljs-string\">'接口请求失败'</span>,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>\n\t\t\t}\n\t\t}\n\t}).catch((err) => {\n\t\t<span class=\"hljs-keyword\">if</span> (err.status === 401) {\n\t\t\tctx.status = 401;\n\t\t\tctx.body = {\n\t\t\t\tcode: 401,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>,\n\t\t\t\tmessage: <span class=\"hljs-string\">'登录过期，请重新登录'</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tthrow err\n\t\t}\n\t})\n}\n\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-37\">koa2-cors跨域处理</h3>\n<p>当接口发布到线上，前端通过ajax请求时，会报跨域的错误。koa2使用koa2-cors这个库非常方便的实现了跨域配置，使用起来也很简单</p>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\">const cors = require(<span class=\"hljs-string\">'koa2-cors'</span>);\napp.use(cors());\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-38\">连接数据库</h3>\n<p>我们使用mongodb数据库，在koa2中使用mongoose这个库来管理整个数据库的操作。</p>\n<ul>\n<li>创建配置文件</li>\n</ul>\n<p>根目录下新建config文件夹，新建mongo.js</p>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\">// config/mongo.js\nconst mongoose = require(<span class=\"hljs-string\">'mongoose'</span>).set(<span class=\"hljs-string\">'debug'</span>, <span class=\"hljs-literal\">true</span>);\nconst options = {\n    autoReconnect: <span class=\"hljs-literal\">true</span>\n}\n\n// username 数据库用户名\n// password 数据库密码\n// localhost 数据库ip\n// dbname 数据库名称\nconst url = <span class=\"hljs-string\">'mongodb://username:password@localhost:27017/dbname'</span>\n\nmodule.exports = {\n    connect: ()=> {            \n        mongoose.connect(url,options)\n        <span class=\"hljs-built_in\">let</span> db = mongoose.connection\n        db.on(<span class=\"hljs-string\">'error'</span>, console.error.bind(console, <span class=\"hljs-string\">'连接错误:'</span>));\n        db.once(<span class=\"hljs-string\">'open'</span>, ()=> {\n            console.log(<span class=\"hljs-string\">'mongodb connect suucess'</span>);\n        })\n    }\n}\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><p>把mongodb配置信息放到config.json中统一管理</p>\n<ul>\n<li>然后在app.js中引入</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\">const mongoConf = require(<span class=\"hljs-string\">'./config/mongo'</span>);\nmongoConf.connect();\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><p>...\n<strong>服务端具体接口实现就不详细介绍了，就是对页面的增删改查，和用户的登录注册难度不大</strong></p>\n<h2 class=\"heading\" data-id=\"heading-39\">启动运行</h2>\n<h3 class=\"heading\" data-id=\"heading-40\">启动前端</h3>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\">npm run dev-client\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-41\">启动服务端</h3>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\">npm run dev-server\n<span class=\"copy-code-btn copy-056\">复制代码</span></code></pre><p>注意：\n如果没有生成过引擎模板js文件的，需要先编辑引擎模板，否则预览页面加载页面引擎.js 404报错</p>\n<h5 class=\"heading\" data-id=\"heading-42\">编译engine.js模板引擎</h5>\n<pre><code class=\"hljs bash copyable code-028\" lang=\"bash\">npm run lib:h5-swiper\n<span class=\"copy-code-btn copy-057\">复制代码</span></code></pre>",
      "id": "13kzil3x8osg",
      "author": "围的围",
      "title": "Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>作者：Alex</p>\n<p>译者：前端小智</p>\n<p>来源：dev.to</p>\n</blockquote>\n<hr>\n<p><strong><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">阿里云最近在做活动，低至2折，真心觉得很划算了，可以点击本条内容或者链接进行参与</a>：</strong>\n<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<hr>\n<p>ECMAScript 6（以下简称ES6）是 JS 语言的下一代标准，已经在<code>2015</code>年<code>6</code>月正式发布了。它的目标，是使得 JS 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。接下来咱们来看看 20 道棘手的面试题，通过做题，顺带提升一下咱们的 JS 的技能。</p>\n<h4 class=\"heading\" data-id=\"heading-0\">问题1：可以解释一下 <code>ES5</code> 和<code>ES6</code>的区别吗?</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版，于2009年标准化，该标准已在所有现代浏览器中完全支持。</p>\n<p><strong>ECMAScript 6 (ES6)/ ECMAScript 2015 (ES2015)</strong>:ECMAscript 第 6 版，2015 年标准化。这个标准已经在大多数现代浏览器中部分实现。</p>\n<p>以下是ES5和ES6之间的一些主要区别：</p>\n<p><strong>箭头函数和字符串插值</strong></p>\n<pre><code class=\"copyable code-00\">const greetings = (name) => {\n  return `hello ${name}`;\n}\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre>\n<p>也可以这样写：</p>\n<pre><code class=\"copyable code-01\">const greetings = name => `hello ${name}`;    \n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre>\n<p><strong>const</strong>：<code>const</code> 表示无法修改变量的原始值。需要注意的是，<code>const</code>表示对值的常量引用，咱们可以改变被引用的对象的属性值，但不能改变引用本身。</p>\n<pre><code class=\"copyable code-02\">const NAMES = [];\nNAMES.push(\"Jim\");\nconsole.log(NAMES.length === 1); // true\nNAMES = [\"Steve\", \"John\"]; // error    \n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre>\n<p><strong>块作用域</strong>：ES6 中 <code>let</code>, <code>const</code> 会创建块级作用域，不会像 <code>var</code> 声明变量一样会被提升。</p>\n<p><strong>默认参数</strong>：默认参数使咱们可以使用默认值初始化函数。当参数省略或 <code>undefined</code> 时使用默认参数值。</p>\n<pre><code class=\"copyable code-03\">function multiply (a, b = 2) {\n   return a * b;\n}\nmultiply(5); // 10    \n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre>\n<p><strong>类定义与继承</strong></p>\n<p>ES6 引入了对类(<code>class</code>关键字)、构造函数(<code>constructor</code>关键字)和 <code>extend</code> 关键字(用于继承)的语言支持。</p>\n<p><strong>for-of 运算符</strong></p>\n<p><code>for...of</code> 语句创建一个遍历可迭代对象的循环。</p>\n<p><strong>展开操作符</strong></p>\n<pre><code class=\"copyable code-04\">const obj1 = { a: 1, b: 2 }\nconst obj2 = { a: 2, c: 3, d: 4}\nconst obj3 = {...obj1, ...obj2}    \n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre>\n<p><strong>Promises</strong>: Promises 提供了一种机制来处理异步操作的结果和错误。可以使用回调来完成相同的事情，但是<code>Promises</code> 通过方法链接和简洁的错误处理来提高可读性。</p>\n<pre><code class=\"copyable code-05\">const isGreater = (a, b) => {\n  return new Promise ((resolve, reject) => {\n    if(a > b) {\n      resolve(true)\n    } else {\n      reject(false)\n    }\n    })\n}\nisGreater(1, 2)\n  .then(result => {\n    console.log('greater')\n  })\n .catch(result => {\n    console.log('smaller')\n })    \n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre>\n<p><strong>模块导出</strong></p>\n<pre><code class=\"copyable code-06\">const myModule = { x: 1, y: () => { console.log('This is ES5') }}\nexport default myModule;   \n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre>\n<p><strong>和导入</strong></p>\n<pre><code class=\"copyable code-07\">import myModule from './myModule';\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-1\">问题 2：什么是 IIFE (立即调用的函数表达式)</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p><code>IIFE</code>是一个立即调用的函数表达式，它在创建后立即执行</p>\n<pre><code class=\"copyable code-08\">(function IIFE(){\n    console.log( \"Hello!\" );\n})();\n// \"Hello!\"\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre>\n<p>常常使用此模式来避免污染全局命名空间，因为在<code>IIFE</code>中使用的所有变量(与任何其他普通函数一样)在其作用域之外都是不可见的。</p>\n<h4 class=\"heading\" data-id=\"heading-2\">问题 3：何时在 ES6 中使用箭头函数？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p>以下是一些经验分享：</p>\n<ul>\n<li>\n<p>在全局作用域内和<code>Object.prototype</code>属性中使用 <code>function</code> 。</p>\n</li>\n<li>\n<p>为对象构造函数使用 <code>class</code>。</p>\n</li>\n<li>\n<p>其它情况使用箭头函数。</p>\n</li>\n</ul>\n<p>为啥大多数情况都使用<strong>箭头函数</strong>？</p>\n<ul>\n<li>\n<p><strong>作用域安全性</strong>:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的<code>thisObject</code>。如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。</p>\n</li>\n<li>\n<p><strong>紧凑性</strong>:箭头函数更容易读写。</p>\n</li>\n<li>\n<p>清晰度:使用箭头函数可明确知道当前 <code>this</code> 指向。</p>\n</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-3\">问题 4:将 Symbol 引入ES6 的目的是什么？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p><code>Symbol</code> 是一种新的、特殊的对象，可以用作对象中惟一的属性名。使用 <code>Symbol</code> 替换<code>string</code> 可以避免不同的模块属性的冲突。还可以将<code>Symbol</code>设置为私有，以便尚无直接访问<code>Symbol</code>权限的任何人都不能访问它们的属性。</p>\n<p><code>Symbol</code> 是JS新的基本数据类型。与<code>number</code>、<code>string</code>和<code>boolean</code> 原始类型一样，<code>Symbol</code> 也有一个用于创建它们的函数。与其他原始类型不同，<code>Symbol</code>没有字面量语法。创建它们的唯一方法是使用以下方法中的<code>Symbol</code>构造函数</p>\n<pre><code class=\"copyable code-09\">let symbol = Symbol();    \n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-4\">问题 5: 在 ES6 中使用展开(spread)语法有什么好处? 它与剩余(rest)语法有什么不同?</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p>ES6 的展开语法在以函数形式进行编码时非常有用，因为咱们可以轻松地创建数组或对象的副本，而无需求助于<code>Object.create，slice</code>或库函数。<code>Redux</code> 和<code>rx.js</code>项目中经常使用此特性。</p>\n<pre><code class=\"copyable code-010\">function putDookieInAnyArray(arr) {\n  return [...arr, 'dookie'];\n}\n\nconst result = putDookieInAnyArray(['I', 'really', \"don't\", 'like']); \n// [\"I\", \"really\", \"don't\", \"like\", \"dookie\"]\n\nconst person = {\n  name: 'Todd',\n  age: 29,\n};\n\nconst copyOfTodd = { ...person };  \n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre>\n<p>ES6 的 rest 语法提供了一种捷径，其中包括要传递给函数的任意数量的参数。</p>\n<p>就像展开语法的逆过程一样，它将数据放入并填充到数组中而不是展开数组，并且它在函数变量以及数组和对象解构分中也经常用到。</p>\n<pre><code class=\"copyable code-011\"> function addFiveToABunchOfNumbers(...numbers) {\n  return numbers.map(x => x + 5);\n}\n\nconst result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); \n// [9, 10, 11, 12, 13, 14, 15]\n\nconst [a, b, ...rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]\n\nconst { e, f, ...others } = {\n  e: 1,\n  f: 2,\n  g: 3,\n  h: 4,\n}; // e: 1, f: 2, others: { g: 3, h: 4 }   \n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-5\">问题 6: ES6 类和 ES5 函数构造函数有什么区别？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<pre><code class=\"copyable code-012\">// ES5 Function Constructor\nfunction Person(name) {\n  this.name = name;\n}\n\n// ES6 Class\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}  \n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre>\n<p>对于简单的构造函数，它们看起来非常相似。</p>\n<p>构造函数的主要区别在于使用继承。如果咱们创建一个继承<code>Person</code>类的<code>Student</code>子类并添加一个<code>studentId</code>字段，以下是两种方式的使用：</p>\n<pre><code class=\"copyable code-013\">// ES5 Function Constructor\nfunction Student(name, studentID) {\n  // 调用你类的构造函数以初始化你类派生的成员。\n  Person.call(this. name)\n  // 初始化子类的成员。\n  this.studentId = studentId\n}\n\nStudent.prototype = Object.create(Person.prototype)\nStudent.prototype.constructor = Student\n\n// ES6 Class\nclass Student extends Person {\n  constructor(name, studentId) {\n    super(name)\n    this.studentId = studentId\n  }\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre>\n<p>在 ES5 中使用继承要复杂得多，而且 ES6 版本更容易理解和记住。</p>\n<h4 class=\"heading\" data-id=\"heading-6\">问题 7: <code>.call</code> 和 <code>.apply</code> 区别是啥？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p><code>.call</code>和<code>.apply</code>均用于调用函数，并且第一个参数将用作函数中<code>this</code>的值。但是，<code>.call</code>将逗号分隔的参数作为下一个参数，而<code>.apply</code>将参数数组作为下一个参数。简单记忆法：<strong>C</strong>用于<code>call</code>和逗号分隔，<strong>A</strong>用于<code>apply</code>和参数数组。</p>\n<pre><code class=\"copyable code-014\"> function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add.call(null, 1, 2)); // 3\nconsole.log(add.apply(null, [1, 2])); // 3   \n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-7\">问题 8: 为什么要使用 ES6 类？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p>选择使用类的一些原因：</p>\n<ul>\n<li>\n<p>语法更简单，更不容易出错。</p>\n</li>\n<li>\n<p>使用新语法比使用旧语法更容易(而且更不易出错)地设置继承层次结构。</p>\n</li>\n<li>\n<p><code>class</code>可以避免构造函数中使用new的常见错误（如果构造函数不是有效的对象，则使构造函数抛出异常）。</p>\n</li>\n<li>\n<p>用新语法调用父原型方法的版本比旧语法要简单得多，用<code>super.method()</code>代替<code>ParentConstructor.prototype.method.call(this)</code> 或<code>Object.getPrototypeOf(Object.getPrototypeOf(this)).method.call(this)</code></p>\n</li>\n</ul>\n<p>考虑下面代码：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e57ba14be021fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"603\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"603\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>使用 ES6 实现上述功能：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e57ba288475156?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"619\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"619\" height=\"800\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-8\">问题 9: 在 JS 中定义枚举的首选语法是什么</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p>可以 <code>Object.freeze</code> 来实现枚举</p>\n<pre><code class=\"copyable code-015\">var DaysEnum = Object.freeze({\n    \"monday\": 1,\n    \"tuesday\": 2,\n    \"wednesday\": 3,\n    ...\n})\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre>\n<p>或者</p>\n<pre><code class=\"copyable code-016\">var DaysEnum = {\n    \"monday\": 1,\n    \"tuesday\": 2,\n    \"wednesday\": 3,\n    ...\n}\nObject.freeze(DaysEnum)\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre>\n<p>但是，这阻止咱们把值分配给变量：</p>\n<pre><code class=\"copyable code-017\">let day = DaysEnum.tuesday\nday = 298832342 // 不会报错\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-9\">问题 10: 解释一下 <code>Object.freeze()</code> 和 <code>const</code> 的区别</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐</p>\n</blockquote>\n<p><code>const</code>和<code>Object.freeze</code>是两个完全不同的概念。</p>\n<p><code>const</code> 声明一个只读的变量，一旦声明，常量的值就不可改变：</p>\n<pre><code class=\"copyable code-018\">const person = {\n    name: \"Leonardo\"\n};\nlet animal = {\n    species: \"snake\"\n};\nperson = animal; // ERROR \"person\" is read-only    \n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre>\n<p><code>Object.freeze</code>适用于值，更具体地说，适用于对象值，它使对象不可变，即不能更改其属性。</p>\n<pre><code class=\"copyable code-019\">let person = {\n    name: \"Leonardo\"\n};\nlet animal = {\n    species: \"snake\"\n};\nObject.freeze(person);\nperson.name = \"Lima\"; //TypeError: Cannot assign to read only property 'name' of object\nconsole.log(person); \n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-10\">问题 11: JS 的提升是什么</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>提升是指 JS 解释器将所有变量和函数声明移动到当前作用域顶部的操作，提升有两种类型</p>\n<ul>\n<li>变量提升</li>\n<li>函数提升</li>\n</ul>\n<p>只要一个<code>var</code>(或函数声明)出现在一个作用域内，这个声明就被认为属于整个作用域，并且可以在任何地方访问。</p>\n<pre><code class=\"copyable code-020\">var a = 2\nfoo() // 正常运行, foo 已被提升\n\nfunction foo() {\n  a = 3\n  console.log(a)   // 3\n  var a                        \n}\n\nconsole.log( a )   // 2\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-11\">问题 12: 解释一下原型设计模式(Prototype Pattern)</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>原型模式会创建新的对象，而不是创建未初始化的对象，它会返回使用从原型或样本对象复制的值进行初始化的对象。原型模式也称为属性模式。</p>\n<p>原型模式有用的一个例子是使用与数据库中的默认值匹配的值初始化业务对象。原型对象保留默认值，这些默认值将被复制到新创建的业务对象中。</p>\n<p>传统语言很少使用原型模式，但是JavaScript作为一种原型语言，在构建新对象及其原型时使用这种模式。</p>\n<h4 class=\"heading\" data-id=\"heading-12\">问题 13: ES6 中的临时死区是什么</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>在 ES6 中，<code>let</code> 和<code>const</code> 跟 <code>var</code>、<code>class</code>和<code>function</code>一样也会被提升，只是在进入作用域和被声明之间有一段时间不能访问它们，这段时间是<strong>临时死区(TDZ)</strong>。</p>\n<pre><code class=\"copyable code-021\">//console.log(aLet)  // would throw ReferenceError\n\nlet aLet;\nconsole.log(aLet); // undefined\naLet = 10;\nconsole.log(aLet); // 10\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-13\">问题 14: 什么时候不使用箭头函数? 说出三个或更多的例子</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>不应该使用箭头函数一些情况：</p>\n<ul>\n<li>\n<p>当想要函数被提升时(箭头函数是匿名的)</p>\n</li>\n<li>\n<p>要在函数中使用<code>this/arguments</code>时，由于箭头函数本身不具有<code>this/arguments</code>，因此它们取决于外部上下文</p>\n</li>\n<li>\n<p>使用命名函数(箭头函数是匿名的)</p>\n</li>\n<li>\n<p>使用函数作为构造函数时(箭头函数没有构造函数)</p>\n</li>\n<li>\n<p>当想在对象字面是以将函数作为属性添加并在其中使用对象时，因为咱们无法访问 <code>this</code> 即对象本身。</p>\n</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-14\">问题 15: ES6 中的 WeakMa p的实际用途是什么？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p><strong>WeakMaps</strong> 提供了一种从外部扩展对象而不影响垃圾收集的方法。当咱们想要扩展一个对象，但是因为它是封闭的或者来自外部源而不能扩展时，可以应用<code>WeakMap</code>。</p>\n<p><strong>WeakMap</strong>只适用于 ES6 或以上版本。<strong>WeakMap</strong>是键和值对的集合，其中键<strong>必须是对象</strong>。</p>\n<pre><code class=\"copyable code-022\">var map = new WeakMap();\nvar pavloHero = {\n    first: \"Pavlo\",\n    last: \"Hero\"\n};\nvar gabrielFranco = {\n    first: \"Gabriel\",\n    last: \"Franco\"\n};\nmap.set(pavloHero, \"This is Hero\");\nmap.set(gabrielFranco, \"This is Franco\");\nconsole.log(map.get(pavloHero)); //This is Hero\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre>\n<p><strong>WeakMaps</strong>的有趣之处在于，它包含了对<code>map</code>内部键的弱引用。弱引用意味着如果对象被销毁，垃圾收集器将从<code>WeakMap</code>中删除整个条目，从而释放内存。</p>\n<h4 class=\"heading\" data-id=\"heading-15\">问题 16: 说明下列方法为何不能用作 IIFE，要使其成为 IIFE，需要进行哪些更改？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<pre><code class=\"copyable code-023\">function foo(){ }();\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre>\n<p><code>IIFE</code> 代表立即调用的函数表达式。JS解析器读取函数<code>foo(){}();</code>作为函数<code>foo(){}</code>和<code>();</code>，前者是一个函数声明，后者(一对括号)是尝试调用一个函数，但没有指定名称，因此它抛出<code>Uncaught SyntaxError: Unexpected token</code> 异常。</p>\n<p>咱们可以使用<code>void</code>操作符:<code>void function foo(){ }();</code>。不幸的是，这种方法有一个问题。给定表达式的求值总是<code>undefined</code>的，所以如果IIFE 函数有返回值，则不能使用它，如下所示：</p>\n<pre><code class=\"copyable code-024\">const foo = void\nfunction bar() {\n    console.log('前端小智')\n    return 'foo';\n}();\n\nconsole.log(foo); // undefined\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-16\">问题 17: 能否比较模块模式与构造函数/原型模式的用法？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐</p>\n</blockquote>\n<p>模块模式通常用于命名空间，在该模式中，使用单个实例作为存储来对相关函数和对象进行分组。这是一个不同于原型设计的用例,它们并不是相互排斥,咱们可以同时使用它们(例如，将一个构造函数放在一个模块中，并使用<code>new MyNamespace.MyModule.MyClass(arguments)</code> )。</p>\n<p>构造函数和原型是实现类和实例的合理方法之一。它们与模型并不完全对应，因此通常需要选择一个特定的<code>scheme</code>或辅助方法来实现原型中的类。</p>\n<h4 class=\"heading\" data-id=\"heading-17\">问题 18: ES6 Map 和 WeakMap 有什么区别？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>当它们的键/值引用的对象被删除时，它们的行为都不同，以下面的代码为例:</p>\n<pre><code class=\"copyable code-025\">var map = new Map()\nvar weakmap = new WeakMap()\n\n(function() {\n    var a = {\n        x: 12\n    };\n    var b = {\n        y: 12\n    };\n\n    map.set(a, 1);\n    weakmap.set(b, 2);\n})()\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre>\n<p>执行上面的 IIFE，就无法再引用<code>{x：12}</code>和<code>{y：12}</code>。垃圾收集器继续运行，并从 <code>WeakMa</code>中删除<code>键b</code>指针，还从内存中删除了<code>{y：12}</code>。</p>\n<p>但在使用 <code>Map</code>的情况下，垃圾收集器不会从<code>Map</code>中删除指针，也不会从内存中删除<code>{x：12}</code>。</p>\n<p><code>WeakMap</code> 允许垃圾收集器执行其回收任务，但<code>Map</code>不允许。对于手动编写的 <code>Map</code>，数组将保留对键对象的引用，以防止被垃圾回收。但在<code>WeakMap</code>中，对键对象的引用被“弱”保留，这意味着在没有其他对象引用的情况下，它们不会阻止垃圾回收。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">问题 19: 举一个柯里化函数的例子，并说明柯里化的好处？</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>柯里化是一种模式，其中一个具有多个参数的函数被分解成多个函数，当被串联调用时，这些函数将一次累加一个所需的所有参数。这种技术有助于使用函数式编写的代码更容易阅读和编写。需要注意的是，要实现一个函数，它需要从一个函数开始，然后分解成一系列函数，每个函数接受一个参数。</p>\n<pre><code class=\"copyable code-026\">function curry(fn) {\n  if (fn.length === 0) {\n    return fn;\n  }\n\n  function _curried(depth, args) {\n    return function(newArgument) {\n      if (depth - 1 === 0) {\n        return fn(...args, newArgument);\n      }\n      return _curried(depth - 1, [...args, newArgument]);\n    };\n  }\n\n  return _curried(fn.length, []);\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\nvar curriedAdd = curry(add);\nvar addFive = curriedAdd(5);\n\nvar result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-19\">问题 20: 如何在 JS 中“深冻结”对象</h4>\n<blockquote>\n<p>主题: JavaScript\n难度: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<p>如果咱们想要确保对象被深冻结，就必须创建一个递归函数来冻结对象类型的每个属性：</p>\n<p><strong>没有深冻结</strong></p>\n<pre><code class=\"copyable code-027\">let person = {\n    name: \"Leonardo\",\n    profession: {\n        name: \"developer\"\n    }\n};\nObject.freeze(person); \nperson.profession.name = \"doctor\";\nconsole.log(person); //output { name: 'Leonardo', profession: { name: 'doctor' } }\n<span class=\"copy-code-btn copy-056\">复制代码</span></code></pre>\n<p><strong>深冻结</strong></p>\n<pre><code class=\"copyable code-028\">function deepFreeze(object) {\n    let propNames = Object.getOwnPropertyNames(object);\n    for (let name of propNames) {\n        let value = object[name];\n        object[name] = value && typeof value === \"object\" ?\n            deepFreeze(value) : value;\n    }\n    return Object.freeze(object);\n}\nlet person = {\n    name: \"Leonardo\",\n    profession: {\n        name: \"developer\"\n    }\n};\ndeepFreeze(person);\nperson.profession.name = \"doctor\"; // TypeError: Cannot assign to read only property 'name' of object\n<span class=\"copy-code-btn copy-057\">复制代码</span></code></pre>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a target=\"_blank\" href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noopener noreferrer\">Fundebug</a>。</strong></p>\n<p>原文：<a target=\"_blank\" href=\"https://dev.to/fullstackcafe/20-tricky-es6-interview-questions-to-revamp-your-javascript-skills-5a4o\" rel=\"nofollow noopener noreferrer\">dev.to/fullstackca…</a></p>\n<h4 class=\"heading\" data-id=\"heading-20\">交流（欢迎加入群，群工作日都会发红包，互动讨论技术）</h4>\n<p>阿里云最近在做活动，低至2折，有兴趣可以看看：<a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=pxuujn3r\" rel=\"nofollow noopener noreferrer\">promotion.aliyun.com/ntms/yunpar…</a></p>\n<p>干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noopener noreferrer\">github.com/qq449245884…</a></p>\n</blockquote>\n<p>因为篇幅的限制，今天的分享只到这里。如果大家想了解更多的内容的话，可以去扫一扫每篇文章最下面的二维码，然后关注咱们的微信公众号，了解更多的资讯和有价值的内容。</p>\n<p></p><figure><img alt=\"clipboard.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e4331de95a38b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>每次整理文章，一般都到2点才睡觉，一周4次左右，挺苦的，还望支持，给点鼓励</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/29/16d7c9e2a5bfb741?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"200\" data-height=\"260\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"200\" height=\"260\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2terjxhz7540",
      "author": "前端小智",
      "title": "通过 20 个棘手的ES6面试问题来提高咱们的 JS 技能",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https://www.zoo.team/article/picture\" rel=\"nofollow noopener noreferrer\">为你重新系统梳理下， Web 体验优化中和图有关的那些事（ 万字长文）</a></p>\n</blockquote>\n<p></p><figure><img alt=\"联合作者-1.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e553e730b30321?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"200\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>Web 页面性能优化，解决了图片相关，问题就解决了大半。本文从 Web 常见的图片格式入手，引出与图片优化相关的有效方案，期望对大家能有一点帮助。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">先来点背景知识</h2>\n<blockquote>\n<p>注：如下说明整理于网络公开信息。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-2\">◎ 名词解释</h3>\n<ul>\n<li>\n<p><strong>有损压缩</strong>：借由将次要的信息数据舍弃，牺牲一些质量来减少数据量、提高压缩比。这个过程是不可逆的。图片常见的有损压缩手段是合并相近的像素点。</p>\n</li>\n<li>\n<p><strong>无损压缩</strong>：数据经过压缩后，信息不受损失，还可以完全恢复到压缩前的样子。无损压缩技术一般是通过两个步骤来完成：</p>\n<ul>\n<li>\n<p>产生输入数据的统计模型。</p>\n</li>\n<li>\n<p>利用这个统计模型将较常出现的数据用较短的比特序列表示，较不常出现的数据用较长的比特序列表示。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>索引色</strong>（Indexed Color）：一个字节 2^8 表示一个颜色，也就是最多支持 256 种颜色。</p>\n</li>\n<li>\n<p><strong>直接色</strong>（Direct Color）：4 个数字表示一个颜色，分别表示红、黄、蓝以及透明度，所以最多可以表达 2^32 种颜色。</p>\n</li>\n<li>\n<p><strong>位图</strong>（Bitmap）：又叫栅格图、点阵图，使用像素阵列来表示图像。位图就是由象素阵列的排列来实现其显示效果的，每个象素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个象素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。位图根据位深度，有 1、4、8、16、24、32 位图像等。位图放大会失真变模糊。</p>\n</li>\n<li>\n<p><strong>矢量图</strong>：计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。相比较位图，矢量图保存最少的信息，体积更小，缩放不会失真。</p>\n</li>\n<li>\n<p><strong>通道</strong>：RGB 三种颜色信息称为红通道、绿通道、蓝通道，透明度是 Alpha 通道。</p>\n</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-3\">◎ Web 中常用图格式说明</h3>\n<ul>\n<li>\n<p><strong>JPEG/JPG</strong>：使用 JPEG 格式压缩的图片文件，是目前应用最广泛的图片格式之一。最普遍被使用的扩展名格式为.jpg，其他常用的扩展名还包括 .jpeg、.jpe、.jfif 以及 .jif。联合图像专家小组（Joint Photographic Experts Group）1992 年发布 JPEG 压缩标准，1994 年获得 ISO10918-1 认证。其特点是有损压缩，直接色，位图，体积最小，常用于颜色较丰富、无透明要求的图片。</p>\n</li>\n<li>\n<p><strong>PNG</strong>：PNG 是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。PNG 的开发目标是改善并取代 GIF 作为适合网络传输的格式而不需专利许可。名称由来一个是 Portable Network Graphics（便携式网络图形），还有一个非正式的由来是 \"Png is Not Gif\"。使用场景是带有透明、半透明背景的图片，需要在网络传输中显示预览效果后展示全貌。上古时期的 IE6 不支持 PNG 半透明，需要用 hack 方法解决。PNG 体积比较大，非必须可用 JPG 替代。PNG 有 png8、png24、png32 之分。</p>\n<ul>\n<li>png8: 最多支持 256 色的 PNG，无损、索引色的位图。非动图可以替代 GIF，体积更小，透明度支持也更好。</li>\n<li>png24： 最多支持 2^24 色的 PNG，不支持透明，无损、直接色的位图。目标是替换 JPG，但一般来说，相同显示效果，PNG 图片是 JPG 体积的数倍。</li>\n<li>png32： 加上 8 位 Alpha 通道的 png24。（注：PS 中导出图片时选择 png24，勾选透明度，导出的是png32）。</li>\n</ul>\n</li>\n<li>\n<p><strong>GIF</strong>：图像互换格式（Graphics Interchange Format）是一种位图图形文件格式，无损压缩、索引色。原始版本为 87a，1989 年发布 89a 版本，支持多帧动画和透明色。1995 年 Netscape Navigator 2.0 发布，定义了动画循环多少次或是否无限次播放，现在聊天的动图都是基于该版本的 GIF。GIF 的特性如下：</p>\n<ul>\n<li>优秀的 LZW 算法在保证质量的同时将体积变的更小。</li>\n<li>可插入多帧实现动画效果。</li>\n<li>可实现透明效果。</li>\n<li>最多支持 256 色，故不适用于真彩色图片。</li>\n</ul>\n</li>\n<li>\n<p><strong>WebP</strong>：Google 2010 年发布的同时支持有损和无损压缩的图片文件格式。有损用来替换 JPG，无损用来替换PNG，动态用来替换 GIF。根据 Google 较早的测试，WebP 的无损压缩比网络上找到的 PNG 档少了 45％ 的文件大小，即使这些 PNG 档在使用 <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Pngcrush\" rel=\"nofollow noopener noreferrer\">Pngcrush</a> 和 <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/PNGOUT\" rel=\"nofollow noopener noreferrer\">PNGOUT</a> 处理过，WebP 还是可以减少近 30％ 的文件体积。WebP 目前还不能全平台兼容，相关兼容性可点<a target=\"_blank\" href=\"https://caniuse.com/#feat=webp\" rel=\"nofollow noopener noreferrer\">此链接</a>查看。</p>\n</li>\n<li>\n<p><strong>SVG</strong>：可缩放矢量图形（Scalable Vector Graphics）是一种基于可扩展编辑语言（XML），用于描述二维矢量图形的图形格式。SVG 由 W3C 制定，是一个开放标准。SVG 的优点是文件可读，易于修改编辑。支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图中类似文字阴影的效果，还可以生成动态图形。</p>\n</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-4\">图优化之请求优化</h2>\n<h3 class=\"heading\" data-id=\"heading-5\">◎ 拥抱 HTTP2</h3>\n<p>更快、更简单、更稳定是我们每一个前端工程师的追求，HTTP/2 的出现让这些美好的词汇都汇聚在一起。首先来一个 demo 感受一下牛逼哄哄的 HTTP/2，<a target=\"_blank\" href=\"https://http2.akamai.com/demo\" rel=\"nofollow noopener noreferrer\">HTTP/1.1 vs HTTP/2</a></p>\n<h4 class=\"heading\" data-id=\"heading-6\">二进制分帧层</h4>\n<p>HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p>\n<p></p><figure><img alt=\"HTTP/2 二进制分帧层\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7e91154f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"341\" data-height=\"175\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"341\" height=\"175\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>从这张图比较清晰地看出 HTTP/1.x 和 HTTP/2的区别。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。</p>\n<h4 class=\"heading\" data-id=\"heading-7\">服务器端推送</h4>\n<p>一般情况下，客户端需要啥东西会告诉服务端，然后服务端返回对应的资源到客户端。HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。换句话说，服务端可以先于客户端检测到将要请求的资源，提前推送到客户端，不发送所有资源的实体，只发送资源的 URL。客户端接到后会进行验证缓存，如果发现需要这些资源，则正式发起请求。</p>\n<h4 class=\"heading\" data-id=\"heading-8\">标头压缩</h4>\n<p>每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。在 HTTP/1.x 中，这些元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：</p>\n<ul>\n<li>\n<p>支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。</p>\n</li>\n<li>\n<p>客户端和服务端之间同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），对相同请求而言不需要再次发送和相应，比如 User-Agent。</p>\n</li>\n</ul>\n<p>在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p>\n<p></p><figure><img alt=\"HPACK：HTTP/2 的标头压缩\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7e8a72ce3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"215\" data-height=\"181\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"215\" height=\"181\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-9\">◎ 多路复用</h3>\n<p>每个 TCP 连接只能发送一个请求， HTTP/1.x 在前面的请求没有完成前，后面的请求将会阻塞。</p>\n<p>其实在 HTTP/2 之前，我们在写代码的时候也用过类似的思想，比如</p>\n<ul>\n<li>\n<p>合并 CSS 和 JS 代码</p>\n</li>\n<li>\n<p>雪碧图</p>\n</li>\n<li>\n<p>Iconfont</p>\n</li>\n</ul>\n<p></p><figure><img alt=\"HTTP/2 Multiplexing\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7e8982135?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1268\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1268\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>HTTP/2 的出现又可以让我们省掉不少麻烦。多路复用允许同时通过单一的HTTP请求多个响应。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">◎ 少不了的懒加载</h3>\n<h4 class=\"heading\" data-id=\"heading-11\">什么是懒加载？</h4>\n<p>只加载可视区的内容，当页面向下滚动时，再继续加载后面的内容。</p>\n<p>图片懒加载的原理其实非常简单，我们先不设置图片的 src 属性，将图片的真实路径放到一个浏览器不认识的属性中（比如 data-src），然后我们去监听 scroll 事件。当页面的 scrollTop 与浏览器的高度之和大于图片距页面顶端的 Y (注意是整个页面不是浏览器窗口)时，说明图片已经进入可视区域，这是把 data-src 的值放到 src 中即可。 </p>\n<h4 class=\"heading\" data-id=\"heading-12\">为什么要使用懒加载？</h4>\n<ul>\n<li>对于大多数用户，特别是移动端和网速比较的用户，如果首屏加载过多的图片，页面将会加载得很慢而且浪费用户的流量。</li>\n<li>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。</li>\n<li>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-13\">怎么实现？</h4>\n<p>关于如何实现本文不做过多阐述，成熟的方案社区比比皆是。这边推荐几个比较好用的轮子。</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/ApoorvSaxena/lozad.js\" rel=\"nofollow noopener noreferrer\">Lozad.js</a></li>\n</ul>\n<p>安装</p>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">npm install --save lozad\n<span class=\"copy-code-btn copy-018\">复制代码</span></code></pre><p>使用</p>\n<pre><code class=\"hljs html copyable code-01\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"lozad\"</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">\"image.png\"</span> /></span>\n<span class=\"copy-code-btn copy-019\">复制代码</span></code></pre><pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-keyword\">const</span> observer = lozad(); <span class=\"hljs-comment\">// 默认会去找 .lozad 这个class</span>\nobserver.observe();\n<span class=\"copy-code-btn copy-020\">复制代码</span></code></pre><ul>\n<li><a target=\"_blank\" href=\"https://github.com/hilongjw/vue-lazyload\" rel=\"nofollow noopener noreferrer\">vue-lazyload</a></li>\n</ul>\n<p>安装</p>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">npm i vue-lazyload -S\n<span class=\"copy-code-btn copy-021\">复制代码</span></code></pre><p>使用</p>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\">Vue.use(VueLazyload)\n<span class=\"copy-code-btn copy-022\">复制代码</span></code></pre><ul>\n<li><a target=\"_blank\" href=\"https://github.com/twobin/react-lazyload\" rel=\"nofollow noopener noreferrer\">react-lazyload</a></li>\n</ul>\n<p>用高阶组件去包裹</p>\n<p>安装</p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">npm install --save react-lazyload\n<span class=\"copy-code-btn copy-023\">复制代码</span></code></pre><p>使用</p>\n<pre><code class=\"hljs jsx copyable code-06\" lang=\"jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n<span class=\"hljs-keyword\">import</span> LazyLoad <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-lazyload'</span>;\n<span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent'</span>;\n\n<span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"list\"</span>></span>\n      <span class=\"hljs-tag\"><<span class=\"hljs-name\">LazyLoad</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{200}</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"tiger.jpg\"</span> /></span>\n      <span class=\"hljs-tag\"></<span class=\"hljs-name\">LazyLoad</span>></span>\n      <span class=\"hljs-tag\"><<span class=\"hljs-name\">LazyLoad</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">MyComponent</span> /></span>\n      <span class=\"hljs-tag\"></<span class=\"hljs-name\">LazyLoad</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n  );\n};\n\nReactDOM.render(<span class=\"hljs-tag\"><<span class=\"hljs-name\">App</span> /></span>, document.body);\n</span><span class=\"copy-code-btn copy-024\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-14\">◎ 正确使用缓存</h3>\n<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，因此使用HTTP缓存是WEB性能优化中必不可少的，也是每位前端开发工程师的必修课。</p>\n<p></p><figure><img alt=\"HTTP 请求\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7eec20474?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"349\" data-height=\"253\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"349\" height=\"253\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>浏览器和服务器之间使用的缓存策略可以分为<strong>强缓存、协商缓存</strong>两种：</p>\n<ul>\n<li>强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互</li>\n<li>协商缓存：需要与服务端校验是否使用缓存</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-15\">ETag</h4>\n<p>有这样一种场景，浏览器检查本地缓存找到之前响应的文件发现已经过期，只能去服务端请求，但是服务器的资源没有发生变化，可以说是浪费了一次请求。</p>\n<p>Etag 的出现很好地解决了这个问题，服务器生成并返回的随机令牌通常是文件内容的哈希值或某个其他指纹。</p>\n<p>客户端不需要了解指纹是如何生成的，只需在下一次请求时将其发送至服务器。 如果指纹仍然相同，则表示资源未发生变化，您就可以跳过下载</p>\n<p></p><figure><img alt=\"HTTP Cache-Control 示例\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7eed046db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"474\" data-height=\"215\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"474\" height=\"215\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>浏览器自动在 <code>If-None-Match</code>  HTTP 请求头内提供 ETag。 服务器根据当前资源核对令牌，如果它未发生变化，服务器将返回 <code>304 Not Modified</code> 响应。这样一个来回避免了浏览器再次去请求资源，即省钱又省时间。</p>\n<h4 class=\"heading\" data-id=\"heading-16\">Cache-Control</h4>\n<p>Cache-Control是强缓存的一种，每个资源都可通过 Cache-Control 定义其缓存策略，Cache-Control来控制谁可以缓存、缓存多久。</p>\n<p>无需和服务端通信的请求是最佳的，通过本地副本消除所有网络延迟、节省流量。</p>\n<p>Cache-Control 是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的头部（例如 Expires）。 所有现代浏览器都支持 Cache-Control，因此，用他就足够了。</p>\n<p></p><figure><img alt=\"HTTP Cache-Control 示例\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e7f11fa95b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"356\" data-height=\"259\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"356\" height=\"259\"></svg>\"><figcaption></figcaption></figure><p></p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>max-age</td>\n<td>指令指定从请求的时间开始，允许提取的响应被重用的最长时间（单位：秒</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只为单个用户缓存，不允许任何中间缓存对其进行缓存</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>先与服务器确认返回的响应是否发生了变化，走协商缓存</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>禁止浏览器以及所有中间缓存存储任何版本的返回响应</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-17\">缓存 CheckList</h4>\n<p>实际开发中往往不存在什么固定的最优解，我们需要根据不同的业务场景制定相应的策略。</p>\n<ul>\n<li><strong>变与不变</strong> 一些不变的部分，如第三方库的代码，可以考虑和业务代码分离，这样一来可以减少下载资源的大小</li>\n<li><strong>最佳的缓存周期</strong> 不同的资源可能有不同的更新要求，设置合适的max-age</li>\n<li><strong>Etag</strong> 当服务器上的资源未发生变动时不需要请求</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-18\">◎ 雪碧图</h3>\n<p>雪碧图，CSS Sprites，国内也叫 CSS 精灵，是一种 CSS 图像合成技术，主要用于小图片显示。</p>\n<h4 class=\"heading\" data-id=\"heading-19\">使用场景</h4>\n<p>在网页中，为了更好的展现效果，经常会采用一些小图标来替代文字。常用的方式包括 Icon Fonts、SVG Icons、小图片，其中 Icon Fonts 只支持单色，SVG Icons 需 IE9+。</p>\n<blockquote>\n<p><em>注：如不考虑低版本浏览器兼容性，推荐使用 SVG Icons，有兴趣可以阅读 <a target=\"_blank\" href=\"http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology\" rel=\"nofollow noopener noreferrer\">张鑫旭-SVG Sprites技术介绍</a></em></p>\n</blockquote>\n<p>如果采用小图片，需要考虑一个问题：每张小图片独立请求，加载时都会产生一个 HTTP 请求，而小图片体积（1 ~ 2 kb）就比较小，对比上 HTTP 请求连接、请求头内容、响应等的开销，就显得非常没必要了，那有没有可能将多张小图片合并成一张图？</p>\n<h4 class=\"heading\" data-id=\"heading-20\">实现原理</h4>\n<p>将小图标合并成一张图片，利用 <code>backround-position</code> 属性值来确定图片呈现的位置即可。如下图所示不同尺寸、位置：</p>\n<p></p><figure><img alt=\"图片\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e810166dd6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"291\" data-height=\"204\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"291\" height=\"204\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>通过 CSS 定位，可以展现对应的图标。</p>\n<pre><code class=\"hljs css copyable code-07\" lang=\"css\"><span class=\"hljs-selector-class\">.icon-alipay</span> {\n  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(sprite.png);\n  <span class=\"hljs-attribute\">background-position</span>: <span class=\"hljs-number\">0px</span> -<span class=\"hljs-number\">131px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">81px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">73px</span>;\n}\n<span class=\"hljs-selector-class\">.icon-taobao</span> {\n  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(sprite.png);\n  <span class=\"hljs-attribute\">background-position</span>: -<span class=\"hljs-number\">177px</span> <span class=\"hljs-number\">0px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">114px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">114px</span>;\n}\n<span class=\"hljs-selector-class\">.icon-wechat</span> {\n  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(sprite.png);\n  <span class=\"hljs-attribute\">background-position</span>: <span class=\"hljs-number\">0px</span> <span class=\"hljs-number\">0px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">177px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">131px</span>;\n}\n<span class=\"hljs-selector-class\">.icon-xinlang</span> {\n  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(sprite.png);\n  <span class=\"hljs-attribute\">background-position</span>: -<span class=\"hljs-number\">81px</span> -<span class=\"hljs-number\">131px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">72px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">72px</span>;\n}\n<span class=\"copy-code-btn copy-025\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-21\">自动生成</h4>\n<p>每次修改或者新增图片时，都需要对雪碧图进行修改，如果依靠人工维护，成本太高，能否自动生成雪碧图和样式呢？可以使用 <a target=\"_blank\" href=\"https://github.com/twolfson/spritesmith\" rel=\"nofollow noopener noreferrer\">spritesmith</a>，该工具可自动合并图片，并得到图片在合并之后的相对位置。简单使用示例代码如下：</p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>)\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> Spritesmith = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'spritesmith'</span>);\n\n<span class=\"hljs-keyword\">const</span> baseDir = <span class=\"hljs-string\">'./images'</span>;\n<span class=\"hljs-keyword\">const</span> files = fs.readdirSync(baseDir)\n<span class=\"hljs-keyword\">const</span> sprites = files.map(<span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =></span> path.join(baseDir, file))\n\nSpritesmith.run({<span class=\"hljs-attr\">src</span>: sprites}, (err, result) => {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    <span class=\"hljs-built_in\">console</span>.error(err)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">console</span>.info(result);\n  }\n})\n<span class=\"copy-code-btn copy-026\">复制代码</span></code></pre><p>运行的输出结果如下：</p>\n<pre><code class=\"hljs json copyable code-09\" lang=\"json\">{\n  coordinates: {\n    'images/alipay.png': { x: 0, y: 131, width: 81, height: 73 },\n    'images/taobao.png': { x: 177, y: 0, width: 114, height: 114 },\n    'images/wechat.png': { x: 0, y: 0, width: 177, height: 131 },\n    'images/xinlang.png': { x: 81, y: 131, width: 72, height: 72 }\n  },\n  properties: { width: 291, height: 204 },\n  image: <Buffer 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 01 23 00 00 00 cc 08 06 00 00 00 38 45 c5 ce 00 00 40 06 49 44 41 54 78 01 ec c1 0b 98 e6 05 61 ... 22705 more bytes>\n}\n<span class=\"copy-code-btn copy-027\">复制代码</span></code></pre><p>其中</p>\n<ul>\n<li>\n<p><code>coordinates</code>：每张图片对应的尺寸和位置</p>\n</li>\n<li>\n<p><code>properties</code>：生成的图片尺寸</p>\n</li>\n<li>\n<p><code>image</code>：文件的Buffer，可用于生成图片</p>\n</li>\n</ul>\n<p>对于现有的常用的构建工具，已有现成的插件可直接使用：</p>\n<ol>\n<li>\n<p><a target=\"_blank\" href=\"https://github.com/mixtur/webpack-spritesmith\" rel=\"nofollow noopener noreferrer\">webpack-spritesmith</a></p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://github.com/twolfson/gulp.spritesmith\" rel=\"nofollow noopener noreferrer\">gulp.spritesmith</a></p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://github.com/twolfson/grunt-spritesmith\" rel=\"nofollow noopener noreferrer\">grunt-spritesmith</a></p>\n</li>\n</ol>\n<p>以下为 <code>gulp</code> 配合 <code>gulp.spritesmith</code> 的示例代码：</p>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\"><span class=\"hljs-keyword\">const</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'gulp'</span>);\n<span class=\"hljs-keyword\">const</span> spritesmith = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'gulp.spritesmith'</span>);\n\n<span class=\"hljs-comment\">// gulp任务定义</span>\ngulp.task(<span class=\"hljs-string\">'sprite'</span>, () => {\n  <span class=\"hljs-keyword\">return</span> gulp.src(<span class=\"hljs-string\">'images/*.png'</span>)\n    .pipe(spritesmith({\n        <span class=\"hljs-attr\">imgName</span>: <span class=\"hljs-string\">'sprite.png'</span>,\n        <span class=\"hljs-attr\">cssName</span>: <span class=\"hljs-string\">'sprite.css'</span>\n      })\n    ).pipe(gulp.dest(<span class=\"hljs-string\">'./'</span>));\n});\n<span class=\"copy-code-btn copy-028\">复制代码</span></code></pre><p>运行后会得到<code>sprite.png</code>、<code>sprite.css</code> 两个文件，最后打包的时候将文件对应打包进去即可。</p>\n<h4 class=\"heading\" data-id=\"heading-22\">注意事项</h4>\n<ol>\n<li>如果要适配高清屏，需要配置高清屏的图片，并且通过设置<code>background-size</code>属性来使得最终显示正常，可参考以上插件的<code>retina</code>相关配置参数；</li>\n<li>由于 HTTP/2 的支持多路复用特性，使得单个图片的请求的开销很小，不推荐使用雪碧图了，但为了兼容 HTTP1.1，现阶段多版本HTTP 协议并存期间还是建议保留；</li>\n<li>雪碧图好用，可不要滥用。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-23\">◎ 使用 iconfont</h3>\n<p>iconfont 译为字体图标，即通过字体的方式展示图标，多用于渲染图标、简单图形、特殊字体等。</p>\n<p>使用 iconfont 时，由于只需要引入对应的字体文件，针对加载图片张数较多的情况，可有效减少 HTTP 请求次数，而且一般字体体积较小，所以请求传输数据量较少。与直接引入图片不同，iconfont 可以像使用字体一样，设置大小和颜色，还可以通过 CSS 设置特殊样式，且因为其是矢量图，不存在失真的情况。</p>\n<p>那么，怎么使用 iconfont 呢？请参照以下 demo：</p>\n<blockquote>\n<p>根据开发需求，按需引入不同格式的字体文件（eot / ttf / woff / svg）</p>\n</blockquote>\n<pre><code class=\"hljs javascript copyable code-011\" lang=\"javascript\"><style>\n  @font-face {\n    font-family: \"iconfont\";\n    src: url('iconfont.eot'); /* IE9*/\n    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n         url('iconfont.woff') format('woff'),\n         url('iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari,  Android, iOS 4.2+*/\n         url('iconfont.svg?#iconfont') format('svg'); /* iOS 4.1- */\n  }\n\n  .iconfont {\n    font-family: \"iconfont\";\n  }\n</style>\n\n<body>\n  // &#xe609 是一个字符的 unicode 码，在该 iconfont 字体文件中对应某个图标\n  <i class=\"iconfont\">&#xe609</i> \n</body>\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><p>关于 @font-face 的说明可参考 mozilla <a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face\" rel=\"nofollow noopener noreferrer\">官方文档</a>。</p>\n<p>在平时开发工作中，可使用以下常用图标字体库：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.14&helptype=code\" rel=\"nofollow noopener noreferrer\">IconFont 阿里巴巴矢量图标库</a>   使用方法详见 IconFont 图标库<a target=\"_blank\" href=\"https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.14&helptype=code\" rel=\"nofollow noopener noreferrer\">官方文档</a>。</li>\n<li><a target=\"_blank\" href=\"https://icomoon.io/app/#/select\" rel=\"nofollow noopener noreferrer\">IcoMoon</a>   使用方法详见 IcoMoon<a target=\"_blank\" href=\"https://icomoon.io/#docs\" rel=\"nofollow noopener noreferrer\">官方文档</a>。</li>\n<li><a target=\"_blank\" href=\"http://fontello.com/\" rel=\"nofollow noopener noreferrer\">fontello</a>  使用方法：选中并下载字体文件，引入项目使用即可。</li>\n<li><a target=\"_blank\" href=\"https://www.bootcss.com/p/font-awesome/\" rel=\"nofollow noopener noreferrer\">Font Awesome</a>  多与 bootstrap 结合使用，使用方法详见 Font Awesome <a target=\"_blank\" href=\"https://www.bootcss.com/p/font-awesome/#integration\" rel=\"nofollow noopener noreferrer\">官方文档</a>。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-24\">◎ 使用 Base64</h3>\n<p>Base64 是网络上最常见的用于传输 8Bit 字节码的编码方式之一，可将图片编码为特定的字符串，由 52 个大小字母和 10 个数字，以及 +、/、= 三个字符组成，详见 <a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/Base64\" rel=\"nofollow noopener noreferrer\">wiki</a>.</p>\n<p>使用 Base64 编码渲染图片有以下优点：</p>\n<ul>\n<li>有效减少 HTTP 请求次数</li>\n<li>可对数据进行简单加密，无法肉眼获取信息</li>\n<li>没有跨域问题，无需考虑图片缓存</li>\n</ul>\n<p>凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：</p>\n<ul>\n<li>编码后文件体积增大，仅适用于小体积图片编码</li>\n<li>增加了编码和解码的工作量</li>\n<li>不支持 IE 8.0 以下版本</li>\n</ul>\n<p>如需将图片转换为 Base64 编码，可以使用 JavaScript API <code>FileReader.readAsDataURL</code> ，详细可参考<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" rel=\"nofollow noopener noreferrer\">文档</a>。</p>\n<h2 class=\"heading\" data-id=\"heading-25\">图优化之体积优化</h2>\n<p>图片体积压缩就是在图片保持在可接受的清晰度范围内同时减少文件大小，图片体积压缩可以借助工具实现。</p>\n<h3 class=\"heading\" data-id=\"heading-26\">◎ 在线工具</h3>\n<ul>\n<li><a target=\"_blank\" href=\"https://tinypng.com/\" rel=\"nofollow noopener noreferrer\">TinyPNG</a>：免费，TinyPng  使用智能有损压缩技术减小 PNG 文件的文件大小，原理是将图片中相似的颜色组合起来（量化），通过减少颜色的数量，可以将 24 位 PNG 文件转为更小的 8 位索引图片，同时所有不必要的元数据被剥离。</li>\n<li><a target=\"_blank\" href=\"http://ppduck.com/\" rel=\"nofollow noopener noreferrer\">PP鸭</a>：￥69.9，很好用，根据图片的特点，选择比较兼顾大小和质量的压缩方案。</li>\n<li><a target=\"_blank\" href=\"https://zhitu.isux.us/\" rel=\"nofollow noopener noreferrer\">智图</a>：免费，可以选择压缩质量，生成 Webp。</li>\n<li><a target=\"_blank\" href=\"http://www.iloveimg.com/zh_cn\" rel=\"nofollow noopener noreferrer\">Iloveimg</a>：免费，支持压缩 JPG，PNG， GIF， 能保持最佳文件质量和压缩程度, 并且 Iloveimg 不仅仅是一款图片压缩工具，还支持图片的裁剪、图片的格式转换以及大小调整等功能。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-27\">◎ 客户端工具</h3>\n<ul>\n<li>PhotoShop：只适用 JPG，导出时选择 JPG，选择压缩质量。</li>\n<li>Sketch：只适用 JPG，导出时选择 JPG，选择压缩质量。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-28\">◎ 阿里云 OSS</h3>\n<p>阿里云 OSS 可以通过配置参数形式对图片进行处理，支持缩放、裁剪、旋转、效果、格式转换、水印等操作，详细信息点此 <a target=\"_blank\" href=\"https://help.aliyun.com/document_detail/44688.html\" rel=\"nofollow noopener noreferrer\">文档</a> 查看。</p>\n<p>示例：将图强制缩略成宽度为 100，高度为 100。</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\">http://image-demo.oss-cn-hangzhou.aliyuncs.com/example.jpg?x-oss-process=image/resize,m_fixed,h_100,w_100\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre><p>本文作者之一@明明 亦做过一个小工具，通过配置缩放参数、压缩质量、格式等属性后自动生成 OSS 后缀地址，具体如何使用参考<a target=\"_blank\" href=\"https://npm.taobao.org/package/vue-img-url-suffix-for-alioss\" rel=\"nofollow noopener noreferrer\">文档</a>。</p>\n<h3 class=\"heading\" data-id=\"heading-29\">◎ 七牛云</h3>\n<p>七牛云的图片处理服务和阿里云 OSS 功能类似，也可以对图片进行缩放、裁剪、旋转、缩略等操作，详细<a target=\"_blank\" href=\"https://developer.qiniu.com/dora/api/3683/img-directions-for-use\" rel=\"nofollow noopener noreferrer\">文档</a></p>\n<p>示例：将图强制缩略成宽度为 100，高度为 100。</p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">https://odum9helk.qnssl.com/resource/Ship.jpg?imageView2/2/w/100/h/100\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-30\">图优化之格式、尺寸优化</h2>\n<h3 class=\"heading\" data-id=\"heading-31\">◎ 图片格式</h3>\n<p>Web 开发中常见的图片包括 JPG，PNG，GIF，webP，选择合适的格式以及压缩质量可以在保证视觉效果的情况下，加速网站的呈现。下面针对不同图片格式的特性来做一下对比：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>动画</th>\n<th>压缩类型</th>\n<th>浏览器支持</th>\n<th style=\"text-align:left\">透明度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GIF</td>\n<td>支持</td>\n<td>无损压缩</td>\n<td>所有</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td>PNG</td>\n<td>不支持</td>\n<td>无损压缩</td>\n<td>所有</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td>JPEG</td>\n<td>不支持</td>\n<td>有损压缩</td>\n<td>所有</td>\n<td style=\"text-align:left\">不支持</td>\n</tr>\n<tr>\n<td>webP</td>\n<td>不支持</td>\n<td>无损压缩或有损压缩</td>\n<td>Chrome、Opera、Firefox、Edge、Android</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n</tbody>\n</table>\n<p>回忆本文开头介绍的不同图片格式的特点，大家可以参考下图选择合适的使用场景：</p>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e821433148?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"502\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"502\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-32\">◎ 多倍图</h3>\n<p>在 Retina 视网膜屏幕面世之前人们很少关注像素密度与设备像素比，随着 Retina 屏在移动设备中越来越广泛地应用，为了保证图片在不同 DPR（设备像素比）的设备上显示足够清晰，开发者需要针对不同设备适配不同倍数的图片。</p>\n<h4 class=\"heading\" data-id=\"heading-33\">像素相关概念</h4>\n<ul>\n<li><strong>DP</strong> 设备像素，又名物理像素，即设备屏幕上真实的物理像素，以矩阵的形式排列，如 iphone X 屏幕分辨率为 2436*1125，即屏幕每行包含 1125 个物理像素，每列包含 2436 个物理像素。</li>\n<li><strong>DIP</strong> 设备无关像素，是一种基于屏幕坐标的抽象像素，应用程序以抽象像素为单位，如我们 CSS 中使用的 px，实际渲染时通过底层程序转换为物理像素。</li>\n<li><strong>DPR</strong> 设备像素比，设备像素 / 设备无关像素的值即为设备像素比，在 Javascript 中可以通过 <code>window.devicePixelRatio</code> 来获取。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-34\">多倍图概念</h4>\n<p>了解以上的概念，我们不难理解：</p>\n<ul>\n<li>\n<p>在 DPR 为 1 的设备（一倍屏）上，使用 1 * 1 个物理像素展示一个 CSS 像素。</p>\n</li>\n<li>\n<p>在 DPR 为 2 的设备（二倍屏）上，使用 2 * 2 个物理像素展示一个 CSS 像素。</p>\n</li>\n<li>\n<p>在 DPR 为 3 的设备（三倍屏）上，使用 3 * 3 个物理像素展示一个 CSS 像素。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e552e81ef1a805?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"619\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"619\"></svg>\"><figcaption></figcaption></figure><p></p>\n</li>\n</ul>\n<p>针对一张 30px * 30px 的图片，在 1 倍屏上，按照 1 : 1 平铺，图片质量并不损失。但是在 2 倍屏、3 倍屏上，分别通过 60 * 60 与 90 * 90 个物理像素渲染这张图片就会出现模糊、失真的现象，从而影响用户体验。所以，我们需要根据不同 DPR 去加载不同倍数的图片：</p>\n<ul>\n<li>一倍屏上加载 30px * 30px 的图片，我们称之为一倍图。</li>\n<li>二倍屏上加载 60px * 60px 的图片，图片名一般加上 @2x 标识，我们称之为二倍图。</li>\n<li>三倍屏上加载 90px * 90px 的图片，图片名一般加上 @3x 标识，我们称之为三倍图。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-35\">自适应 DPR 加载图片</h4>\n<p>在高分辨率显示屏如 2x 上，在页面中使用二倍图可以保证清晰度，但是当此页面在低 DPR 设备打开时，我们只需要 50% 长宽的图片就能保证显示效果，而此时带宽开销却是一样的。所以为了节约传输流量，我们需要告诉浏览器，根于不同的 DPR 加载不同尺寸的图片，通常有以下三种方法：</p>\n<ol>\n<li>使用 picture 标签，除了 IE，现有主浏览器均已支持该标签，兼容性参考[文档]([<a target=\"_blank\" href=\"https://caniuse.com/#search=Picture%20element\" rel=\"nofollow noopener noreferrer\">caniuse.com/#search=Pic…</a>](<a target=\"_blank\" href=\"https://caniuse.com/#search=Picture\" rel=\"nofollow noopener noreferrer\">caniuse.com/#search=Pic…</a> element))。</li>\n</ol>\n<pre><code class=\"hljs html copyable code-014\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">picture</span>></span>  \n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">source</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">\"photo@3x.jpg\"</span> <span class=\"hljs-attr\">media</span>=<span class=\"hljs-string\">\"(min-width: 800px)\"</span>></span>  \n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">source</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">\"photo@2x.jpg\"</span> <span class=\"hljs-attr\">media</span>=<span class=\"hljs-string\">\"(min-width: 600px)\"</span>></span>  \n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">\"photo.jpg\"</span>></span>  \n<span class=\"hljs-tag\"></<span class=\"hljs-name\">picture</span>></span>\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><ol start=\"2\">\n<li>使用 img srcset 属性，除了 IE，现有主浏览器均已支持该属性，兼容性参考<a target=\"_blank\" href=\"https://caniuse.com/#search=srcset\" rel=\"nofollow noopener noreferrer\">文档</a>。</li>\n</ol>\n<pre><code class=\"hljs html copyable code-015\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"photo.png\"</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">\"photo@2x.png 2x, photo@3x.png 3x\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"photo\"</span> /></span>\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><ol start=\"3\">\n<li>使用 CSS3 img-set 函数，兼容性相较于前两者较差，参考<a target=\"_blank\" href=\"https://caniuse.com/#search=image-set()\" rel=\"nofollow noopener noreferrer\">文档</a>。</li>\n</ol>\n<pre><code class=\"hljs css copyable code-016\" lang=\"css\"><span class=\"hljs-selector-tag\">background-image</span>: <span class=\"hljs-selector-tag\">image-set</span>(\"<span class=\"hljs-selector-tag\">photo</span><span class=\"hljs-selector-class\">.png</span>\" 1<span class=\"hljs-selector-tag\">x</span>,\n                            \"<span class=\"hljs-selector-tag\">photo</span>@<span class=\"hljs-keyword\">2x</span>.<span class=\"hljs-keyword\">png</span>\" <span class=\"hljs-number\">2</span>x,\n                            <span class=\"hljs-string\">\"photo@3x.png\"</span> <span class=\"hljs-number\">3</span>x);\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-36\">勿忘无障碍，关怀弱视力群体</h2>\n<p>根据世界健康组织的统计，全球约有 2.85 亿视力障碍人士，仅美国就有 810 万网民患视力障碍，而在中国，这个数字要被乘以 2。不同于我们浏览网页的方式是看，视力障碍人员浏览互联网信息主要是靠听 —— 靠屏幕阅读器读出网页的有效信息，通过听这些信息来获知内容。对于前端工程师而言，关注到一些细节的优化，能更好的服务于这些视力障碍人士。</p>\n<h3 class=\"heading\" data-id=\"heading-37\">◎ 设置 Alt 属性</h3>\n<p>最基础的方式，是装饰性图片归类到背景图，通过 CSS 背景图进行设置；功能性图片放到 HTML 中，通过 <code>img</code> 标签引入，且要设置 <code>alt</code> 属性，以便被屏幕阅读器识别并阅读。图片 <code>alt</code> 信息应简短，介绍图片信息即可，避免内容冗余。图片的长信息介绍应被放到 <code>longdesc</code> 属性中：</p>\n<pre><code class=\"hljs html copyable code-017\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"图片说明\"</span> /></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">longdesc</span>=<span class=\"hljs-string\">\"一段很长的文字一段很长的文字一段很长的文字一段很长的文字\"</span> /></span>\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><ul>\n<li>宽或高不到 8px 或者没有 alt 的图片（特别是装饰性的图片）应该被移除，CSS 技术可以用来控制样式</li>\n<li>alt 是用来描述图片的，而非单纯的新闻标题或者名词</li>\n<li>alt 属性不应包含图片的文件名</li>\n<li>alt 值不应包含冗长的信息（如果很长可以使用<img>）</li>\n<li>每个 img 标签要应该设置 alt 属性</li>\n<li>不能只依赖图片上的文字信息</li>\n<li>Banner、头图上的文字信息必须在代码中有所体现</li>\n</ul>\n<p>更多无障碍相关，可参考《<a target=\"_blank\" href=\"https://www.qq.com/accessibility/\" rel=\"nofollow noopener noreferrer\">腾讯网无障碍说明</a>》。</p>\n<h3 class=\"heading\" data-id=\"heading-38\">◎ 考虑 IMG Sprite</h3>\n<p>“高对比度模式” 是一种 Windows 系统的设置主题，其用意是为了保证视力受损的用户，在查看 Web 信息时提供方便。它通过使用对比鲜明的色彩和字号来提高文本的可读性，高对比度模式下网页的背景默认会变成全黑。</p>\n<p>CSS Image Sprites（CSS 雪碧图）是一项用来减少网页中图片 HTTP 请求数的技术，但其会导致在 Windows 高对比度模式下背景图片消失，其服务的 Web 应用性能的提升和对无障碍体验被破坏之间的矛盾，已经引起了 Web 开发者的关注。Sprite 技术的使用的确为更多网站的优化加载速度的体验贡献甚大，但我们要承认，这个过程中我们忽略并损害了使用高对比度模式用户的体验。由于 <code><img></code> 元素可以在高对比度模式下显示，故而在此场景下，使用基于  <code><img></code>  标签的 Sprite 技术，可以得到比基于 CSS 背景图的 Sprite 更多的收益。</p>\n<p>关于 IMG Sprite 技术的应用，可以在此文中学习到 《<a target=\"_blank\" href=\"https://www.artzstudio.com/2010/04/img-sprites-high-contrast/\" rel=\"nofollow noopener noreferrer\">Foreground Sprites – High Contrast Mode Optimization</a>》</p>\n<h2 class=\"heading\" data-id=\"heading-39\">总结</h2>\n<p>就前端性能优化而言，图片优化可谓是其必不可少的环节。但是与其说是在做优化，不如说是在做“权衡”。一些操作是以牺牲一部分成像质量为代价的。我们的主要任务，是尽可能的去寻求一个质量与性能之间的平衡点，并在不同业务场景下，做好图片方案的选型工作。</p>\n<h2 class=\"heading\" data-id=\"heading-40\">更多阅读：</h2>\n<ul>\n<li>\n<p><a target=\"_blank\" href=\"https://www.artzstudio.com/2010/04/img-sprites-high-contrast/\" rel=\"nofollow noopener noreferrer\">Foreground Sprites – High Contrast Mode Optimization</a></p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position\" rel=\"nofollow noopener noreferrer\">background-position - CSS（层叠样式表）</a></p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/CSS_Image_Sprites\" rel=\"nofollow noopener noreferrer\">在 CSS 中实现图像合并 </a></p>\n</li>\n</ul>\n",
      "id": "3fq4sm1ztpc0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "6nv7kf1u4cw0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。call、apply、bind实现new实现class实现继承async/await实现reduce实现实现一个双向数据绑定instanceof实现Array.isArray实现Object.create的基本实现原理getOwnPropertyNames实现promise实现手写一个防抖/节流函数柯里化函数的实现手写一个深拷贝call、ap..."
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "2mic9jiahsi0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "原创不易，希望能关注下我们，再顺手点个赞~~本文首发于政采云前端团队博客：可能是最全的“文本溢出截断省略”方案合集\">前言在我们的日常开发工作中，文本溢出截断省略是很常见的一种需考虑的业务场景细节。看上去“稀松平常”，但在实现上却有不同的区分，是单行截断还是多行截断？多行的截断判断是基于行数还是基于高度？这些问题之下，都有哪些实现方案？他们之间的差异性和场景适应性又是如何？凡事就怕较真，较真必有成长。本文试图通过编码实践，给出一些答案。先来点基础的，单行文本溢出省略核心CSS语句overflow..."
    },
    {
      "url": "https://juejin.im/post/5dc81428e51d4523632ee793",
      "k": "juejin",
      "id": "13kzil3x8osg",
      "author": "围的围",
      "title": "Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "前言想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）Github:传送门演示地址：传送门编辑器预览：技术栈前端：vue:模块化开发少不了angular，react，vue三选一，这里选择了vue。vuex:状态管理sass:css预编译器。elem..."
    },
    {
      "url": "https://juejin.im/post/5dc8a231f265da4d40712f8a",
      "k": "juejin",
      "id": "2terjxhz7540",
      "author": "前端小智",
      "title": "通过 20 个棘手的ES6面试问题来提高咱们的 JS 技能",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "作者：Alex译者：前端小智来源：dev.to阿里云最近在做活动，低至2折，真心觉得很划算了，可以点击本条内容或者链接进行参与：promotion.aliyun.com/ntms/yunpar…ECMAScript6（以下简称ES6）是JS语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JS语言可以用来编写复杂的大型应用程序，成为企业级开发语言。接下来咱们来看看20道棘手的面试题，通过做题，顺带提升一下咱们的JS的技能。问题1：可以解释一下ES5和ES6的区别吗?主题:Java..."
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "3fq4sm1ztpc0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "2天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "原创不易，希望能关注下我们，再顺手点个赞~~本文首发于政采云前端团队博客：为你重新系统梳理下，Web体验优化中和图有关的那些事（万字长文）\">Web页面性能优化，解决了图片相关，问题就解决了大半。本文从Web常见的图片格式入手，引出与图片优化相关的有效方案，期望对大家能有一点帮助。先来点背景知识注：如下说明整理于网络公开信息。◎名词解释有损压缩：借由将次要的信息数据舍弃，牺牲一些质量来减少数据量、提高压缩比。这个过程是不可逆的。图片常见的有损压缩手段是合并相近的像素点。无损压缩：数据经过压缩后，..."
    }
  ]
}