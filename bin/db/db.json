{
  "searchResList": [],
  "hotArticleDetailList": [
    {
      "content": "<p>原文链接：<a target=\"_blank\" href=\"https://dev.to/simonholdorf/9-projects-you-can-do-to-become-a-frontend-master-in-2020-n2h\" rel=\"nofollow noopener noreferrer\">dev.to/simonholdor…</a></p>\n<p>DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。</p>\n<p>本篇文章一共涉及了9个流行的框架/库，没有具体的介绍使用方法，而是给了一些非常棒的实战教程。</p>\n<p>初学者(也许一些有经验的开发者也是一样)在读完官方文档，想写一个项目练手的时候不知道做什么项目好，或是有想法，但是无从下手。那么这篇文章将会给你带来很大的帮助。</p>\n<blockquote>\n<p>本篇翻译已征得原作者同意：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3e822a7f3ea92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"580\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"580\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p><strong>更多文章可戳:</strong> <a target=\"_blank\" href=\"https://github.com/YvetteLau/Blog\" rel=\"nofollow noopener noreferrer\">github.com/YvetteLau/B…</a></p>\n<h3 class=\"heading\" data-id=\"heading-0\">导读</h3>\n<p>无论你是编程新手还是经验丰富的开发人员。在这个行业中，我们不得不一直学习新概念和新语言或是框架，才能跟上快速变化。以React为例 —— FaceBook 四年前开源，现在它已经成为了全球JS开发者的首选。但是与此同时，Vue 和 Angular 也有自己的追求者。然后是 Svelte，Next 和 Nuxt.js，Gatsby，Gridsome,quasar 等等，如果你想成为专业的 JavaScript 开发人员，你在使用自己熟悉的框架进行开发的同时，还需要对不同的框架和库有一些了解。</p>\n<p>为了帮助你在2020年成为一个前端大神，我收集了9个使用了不同JS框架/库的项目，你可以去构建或者将他们加入到自己未来的开发计划中。记住，没什么比实际开发一个项目更有帮助。所以，不要犹豫，试着去开发一下。</p>\n<h3 class=\"heading\" data-id=\"heading-1\">1. 使用React(with hooks)构建一个电影搜索应用</h3>\n<p>首先，你可以使用React构建一个电影搜索应用。展示如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36e1e7cd8ab0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"473\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"473\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-2\">你将学到什么？</h4>\n<p>构建这个项目，你可以使用较新的 Hook API 来提升你的 React 技能。示例项目使用了React组件，很多 hooks 以及一些外部的 API，当然还有一些CSS样式。</p>\n<h4 class=\"heading\" data-id=\"heading-3\">技术栈/点</h4>\n<ol>\n<li>React(Hooks)</li>\n<li>create-react-app</li>\n<li>JSX</li>\n<li>CSS</li>\n</ol>\n<p>你可以在这里看到这个示例项目：<a target=\"_blank\" href=\"https://www.freecodecamp.org/news/how-to-build-a-movie-search-app-using-react-hooks-24eb72ddfaf7/\" rel=\"nofollow noopener noreferrer\">www.freecodecamp.org/news/how-to…</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">2.使用Vue构建一个聊天应用</h3>\n<p>另外一个要介绍给你的很棒的项目是使用Vue构建的聊天应用程序。展示如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36ef6e6862c45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"581\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"581\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-5\">你将学到什么？</h4>\n<p>您将学习到如何从头开始设置Vue应用，创建组件，处理状态，创建路由，连接到第三方服务，甚至是处理身份验证。</p>\n<h4 class=\"heading\" data-id=\"heading-6\">技术栈/点</h4>\n<ol>\n<li>Vue</li>\n<li>Vuex</li>\n<li>Vue Router</li>\n<li>Vue CLI</li>\n<li>Pusher</li>\n<li>CSS</li>\n</ol>\n<p>这真的是一个非常棒的项目，不管是用来学习Vue或者是提升现有的技能，以应对2020年的发展。你可以查看这个教程： <a target=\"_blank\" href=\"https://www.sitepoint.com/pusher-vue-real-time-chat-app/\" rel=\"nofollow noopener noreferrer\">www.sitepoint.com/pusher-vue-…</a></p>\n<h3 class=\"heading\" data-id=\"heading-7\">3. 使用Augular8构建一款漂亮的天气应用</h3>\n<p>此示例将帮助你使用 Google 的 Angular 8 来构建一块漂亮的天气应用程序：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36f7497c75a37?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"495\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"495\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-8\">你将学到什么？</h4>\n<p>该项目将教你一些宝贵的技能，例如从头开始创建应用，从设计到开发，一直到生产就绪部署。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">技术栈/点</h4>\n<ol>\n<li>Angular 8</li>\n<li>Firebase</li>\n<li>SSR</li>\n<li>网络布局和Flexbox</li>\n<li>移动端友好 && 响应式布局</li>\n<li>深色模式</li>\n<li>漂亮的用户界面</li>\n</ol>\n<p>对于这个综合项目，我真正喜欢的是，不是孤立地学习东西，而是从设计到最终部署的整个开发过程。</p>\n<p><a target=\"_blank\" href=\"https://medium.com/@hamedbaatour/build-a-real-world-beautiful-web-app-with-angular-6-a-to-z-ultimate-guide-2018-part-i-e121dd1d55e\" rel=\"nofollow noopener noreferrer\">medium.com/@hamedbaato…</a></p>\n<h3 class=\"heading\" data-id=\"heading-10\">4. 使用 Svelte 构建一个 To-Do 应用</h3>\n<p>与React，Vue和Angular相比，Svelte 还很新，但仍是热门之一。好的，To-Do应用不一定是那里最热门的项目，但这确实可以帮助你提高Svelte技能，如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e36ff0d5669eca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"680\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"680\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">你将学到什么？</h4>\n<p>本教程将向你展示如何从头到尾使用Svelte3制作应用。 它利用了组件，样式和事件处理程序。</p>\n<h4 class=\"heading\" data-id=\"heading-12\">技术栈/点</h4>\n<ol>\n<li>Svelte 3</li>\n<li>Components</li>\n<li>CSS</li>\n<li>ES6语法</li>\n</ol>\n<p>Svelte 没有太多优秀的入门项目，这个是我觉得不错的一个上手项目：<a target=\"_blank\" href=\"https://medium.com/codingthesmartway-com-blog/building-a-svelte-3-todo-app-from-start-to-deployment-1737f72c23a6\" rel=\"nofollow noopener noreferrer\">medium.com/codingthesm…</a></p>\n<h3 class=\"heading\" data-id=\"heading-13\">5. 使用 Next.js 构建购物车</h3>\n<p>Next.js 是一个轻量级的 React 服务端渲染应用框架，该项目将向你展示如何构建一个如下所示的购物车：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e372177dcab8bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"727\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"727\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-14\">你将学到什么？</h4>\n<p>在这个项目中，你将学习如何设置 Next.js 的开发环境，创建新页面和组件，获取数据，设置样式并部署一个 next 应用。</p>\n<h4 class=\"heading\" data-id=\"heading-15\">技术栈/点</h4>\n<ol>\n<li>Next.js</li>\n<li>组件和页面</li>\n<li>数据获取</li>\n<li>样式</li>\n<li>部署</li>\n<li>SSR和SPA</li>\n</ol>\n<p>你可以在此处找到该教程：<a target=\"_blank\" href=\"https://snipcart.com/blog/next-js-ecommerce-tutorial\" rel=\"nofollow noopener noreferrer\">snipcart.com/blog/next-j…</a></p>\n<h3 class=\"heading\" data-id=\"heading-16\">6. 使用 Nuxt.js 构建一个多语言博客网站</h3>\n<p>Nuxt.js 是 Vue 服务端渲染应用框架。你可以创建一个如下所示的应用程序：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/4/16e37208490b64ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"840\" data-height=\"458\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"840\" height=\"458\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-17\">你将学到什么？</h4>\n<p>这个示例项目从初始设置到最终部署一步一步教你如何使用 Nuxt.js 构建一个完整的网站。它使用了 Nuxt 提供的许多出色功能，如页面和组件以及SCSS样式。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">技术栈/点</h4>\n<ul>\n<li>Nuxt.js</li>\n<li>组件和页面</li>\n<li>Storyblok模块</li>\n<li>Mixins</li>\n<li>Vuex</li>\n<li>SCSS</li>\n<li>Nuxt中间件</li>\n</ul>\n<p>这个项目包含了涵盖了 Nuxt.js 的许多出色功能。我个人很喜欢使用 Nuxt 进行开发，你应该尝试使用它，这将使你成为更好的 Vue 开发人员！<a target=\"_blank\" href=\"https://www.storyblok.com/tp/nuxt-js-multilanguage-website-tutorial\" rel=\"nofollow noopener noreferrer\">www.storyblok.com/tp/nuxt-js-…</a></p>\n<p>除此之外，我还找到了一个B站的视频：<a target=\"_blank\" href=\"https://www.bilibili.com/video/av21130191/\" rel=\"nofollow noopener noreferrer\">www.bilibili.com/video/av211…</a></p>\n<h3 class=\"heading\" data-id=\"heading-19\">7. 使用 Gatsby 构建一个博客</h3>\n<p>Gatsby是一个出色的静态站点生成器，它允许使用React作为渲染引擎引擎来搭建一个静态站点，它真正具有现代web应用程序所期望的所有优点。该项目如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e372de5456f4c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"426\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"426\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-20\">你将学到什么？</h4>\n<p>在本教程中，你将学习如何利用 Gatsby 构建出色的博客。</p>\n<h4 class=\"heading\" data-id=\"heading-21\">技术栈/点</h4>\n<ol>\n<li>Gatsby</li>\n<li>React</li>\n<li>GraphQL</li>\n<li>Plugins & Themes</li>\n<li>MDX / Markdown</li>\n<li>Bootstrap CSS</li>\n<li>Templates</li>\n</ol>\n<p>如果你想创建博客，这个示例教你如何利用 React 和 GraphQL 来搭建。并不是说 Wordpress 是一个不好的选择，但是有了 Gatsby ，你可以在使用 React 的同时创建高性能站点！</p>\n<p><a target=\"_blank\" href=\"https://blog.bitsrc.io/how-to-build-a-blog-with-gatsby-and-boostrap-d1270212b3dc\" rel=\"nofollow noopener noreferrer\">blog.bitsrc.io/how-to-buil…</a></p>\n<h3 class=\"heading\" data-id=\"heading-22\">8. 使用 Gridsome 构建一个博客</h3>\n<p>Gridsome 和 Vue的关系与 Gatsby 和 React 的关系一样。Gridsome 和 Gatsby 都使用 GraphQL 作为数据层，但是 Gridsome 使用的是 VueJS。这也是一个很棒的静态站点生成器，它将帮助您创建出色的博客：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3735054979c7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"442\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"442\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-23\">你将学到什么？</h4>\n<p>该项目将教你如何使用 Gridsome，GraphQL 和 Markdown 构建一个简单的博客，它还介绍了如何通过Netlify 部署应用程序。</p>\n<h4 class=\"heading\" data-id=\"heading-24\">技术栈/点</h4>\n<ol>\n<li>Gridsome</li>\n<li>Vue</li>\n<li>GraphQL</li>\n<li>Markdown</li>\n<li>Netlify</li>\n</ol>\n<p>当然，这不是最全面的教程，但涵盖了 Gridsome 和 Markdown 的基本概念，可能是一个很好的起点。</p>\n<p><a target=\"_blank\" href=\"https://www.telerik.com/blogs/building-a-blog-with-vue-and-markdown-using-gridsome\" rel=\"nofollow noopener noreferrer\">www.telerik.com/blogs/build…</a></p>\n<h3 class=\"heading\" data-id=\"heading-25\">9.使用 Quasar 构建一个类似 SoundCloud 的音频播放器</h3>\n<p>Quasar 是另一个 Vue 框架，也可以用于构建移动应用程序。 在这个项目中，你将创建一个音频播放器应用程序，如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/5/16e3738a9976f631?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"880\" data-height=\"597\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"880\" height=\"597\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-26\">你将学到什么？</h4>\n<p>不少项目主要关注Web应用程序，但这个项目展示了如何通过 Quasar 框架创建移动应用程序。你应该已经配置了可工作的 Cordova 设置，并配置了 android studio / xcode。 如果没有，在教程中有一个指向quasar 网站的链接，在那里你可以学习如何进行设置。</p>\n<h4 class=\"heading\" data-id=\"heading-27\">技术栈/点</h4>\n<ul>\n<li>Quasar</li>\n<li>Vue</li>\n<li>Cordova</li>\n<li>Wavesurfer</li>\n<li>UI Components</li>\n</ul>\n<p>一个展示了Quasar在构建移动应用程序方面的强大功能的小项目：<a target=\"_blank\" href=\"https://www.learningsomethingnew.com/how-to-build-a-sound-cloud-like-audio-player-app-with-vue-js-quasar-and-wave-surfer\" rel=\"nofollow noopener noreferrer\">www.learningsomethingnew.com/how-to-buil…</a></p>\n<h3 class=\"heading\" data-id=\"heading-28\">总结</h3>\n<p>本文展示了你可以构建的9个项目，每个项目专注于一个JavaScript框架或库。现在，你可以自行决定：使用以前未使用的框架来尝试一些新的东西或是通过做一个项目来提升已有的技能，或者在2020年完成所有项目？</p>\n<hr>\n<h3 class=\"heading\" data-id=\"heading-29\">关注公众号，加入技术交流群</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/9/8/16d1120a80282ab5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"900\" data-height=\"383\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"383\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "fopfp5tn2lk",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。</p>\n</blockquote>\n<ul>\n<li>call、apply、bind 实现</li>\n<li>new 实现</li>\n<li>class 实现继承</li>\n<li>async/await 实现</li>\n<li>reduce 实现</li>\n<li>实现一个双向数据绑定</li>\n<li>instanceof 实现</li>\n<li>Array.isArray 实现</li>\n<li>Object.create 的基本实现原理</li>\n<li>getOwnPropertyNames 实现</li>\n<li>promise 实现</li>\n<li>手写一个防抖/节流函数</li>\n<li>柯里化函数的实现</li>\n<li>手写一个深拷贝</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-0\">call、apply、bind 实现</h2>\n<blockquote>\n<p><code>call、apply、bind</code> 本质都是改变 <code>this</code> 的指向，不同点 <code>call、apply</code> 是直接调用函数，<code>bind</code> 是返回一个新的函数。<code>call</code> 跟 <code>apply</code> 就只有参数上不同。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-1\">bind 实现</h3>\n<ul>\n<li>箭头函数的 <code>this</code> 永远指向它所在的作用域</li>\n<li>函数作为构造函数用 <code>new</code> 关键字调用时，不应该改变其 <code>this</code> 指向，因为 <code>new绑定</code> 的优先级高于 <code>显示绑定</code> 和 <code>硬绑定</code></li>\n</ul>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mybind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Bind must be called on a function\"</span>);\n    }\n    <span class=\"hljs-comment\">// 拿到参数，为了传给调用者</span>\n    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>),\n      <span class=\"hljs-comment\">// 保存 this</span>\n      self = <span class=\"hljs-keyword\">this</span>,\n      <span class=\"hljs-comment\">// 构建一个干净的函数，用于保存原函数的原型</span>\n      nop = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{},\n      <span class=\"hljs-comment\">// 绑定的函数</span>\n      bound = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-comment\">// this instanceof nop, 判断是否使用 new 来调用 bound</span>\n        <span class=\"hljs-comment\">// 如果是 new 来调用的话，this的指向就是其实例，</span>\n        <span class=\"hljs-comment\">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span>\n        <span class=\"hljs-keyword\">return</span> self.apply(\n          <span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> nop ? <span class=\"hljs-keyword\">this</span> : thisArg,\n          args.concat(<span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>))\n        );\n      };\n\n    <span class=\"hljs-comment\">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.prototype) {\n      nop.prototype = <span class=\"hljs-keyword\">this</span>.prototype;\n    }\n    <span class=\"hljs-comment\">// 修改绑定函数的原型指向</span>\n    bound.prototype = <span class=\"hljs-keyword\">new</span> nop();\n\n    <span class=\"hljs-keyword\">return</span> bound;\n  }\n}\n<span class=\"copy-code-btn copy-028\">复制代码</span></code></pre><ol start=\"3\">\n<li><code>测试 mybind</code></li>\n</ol>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\n<span class=\"hljs-keyword\">const</span> bound = bar.mybind(foo, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">44</span>);\n<span class=\"hljs-keyword\">new</span> bound(); <span class=\"hljs-comment\">// bar, [22, 33, 44]</span>\nbound(); <span class=\"hljs-comment\">// foo, [22, 33, 44]</span>\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-2\">call 实现</h3>\n<blockquote>\n<p><code>bind</code> 是封装了 <code>call</code> 的方法改变了 <code>this</code> 的指向并返回一个新的函数，那么 <code>call</code> 是如何做到改变 <code>this</code> 的指向呢？原理很简单，在方法调用模式下，<code>this</code> 总是指向调用它所在方法的对象，<code>this</code> 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）。先写一个小 <code>demo</code> 来理解一下下。</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><span class=\"hljs-keyword\">const</span> foo = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span> };\n\nfoo.fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 这里的 this 指向了 foo</span>\n  <span class=\"hljs-comment\">// 因为 foo 调用了 fn，</span>\n  <span class=\"hljs-comment\">// fn 的 this 就指向了调用它所在方法的对象 foo 上</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// foo</span>\n};\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre><p>利用 <code>this</code> 的机制来实现 <code>call</code></p>\n<pre><code class=\"hljs js copyable code-03\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.mycall = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n    <span class=\"hljs-comment\">// this指向调用call的对象</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n      <span class=\"hljs-comment\">// 调用call的若不是函数则报错</span>\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Error'</span>);\n    }\n    <span class=\"hljs-comment\">// 声明一个 Symbol 属性，防止 fn 被占用</span>\n    <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n    <span class=\"hljs-keyword\">const</span> args = [...arguments].slice(<span class=\"hljs-number\">1</span>);\n    thisArg = thisArg || <span class=\"hljs-built_in\">window</span>;\n    <span class=\"hljs-comment\">// 将调用call函数的对象添加到thisArg的属性中</span>\n    thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 执行该属性</span>\n    <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...args);\n    <span class=\"hljs-comment\">// 删除该属性</span>\n    <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n    <span class=\"hljs-comment\">// 返回函数执行结果</span>\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-3\">apply 实现</h3>\n<pre><code class=\"hljs js copyable code-04\" lang=\"js\"><span class=\"hljs-built_in\">Function</span>.prototype.myapply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">thisArg</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span> !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">' is not a function'</span>;\n  }\n\n  <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">'fn'</span>)\n  thisArg[fn] = <span class=\"hljs-keyword\">this</span>;\n\n  <span class=\"hljs-keyword\">const</span> result = thisArg[fn](...arg);\n\n  <span class=\"hljs-keyword\">delete</span> thisArg[fn];\n\n  <span class=\"hljs-keyword\">return</span> result;\n};\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><p><code>测试 mycall myapply</code></p>\n<pre><code class=\"hljs js copyable code-05\" lang=\"js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name, <span class=\"hljs-built_in\">arguments</span>);\n};\n\nbar.prototype.name = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> foo = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>\n};\n\nbar.mycall(foo, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\nbar.myapply(foo, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// foo [1, 2, 3]</span>\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-4\">reduce 实现原理</h2>\n<blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-06\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.prototype.myreduce = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reduce</span>(<span class=\"hljs-params\">callbackfn</span>) </span>{\n  <span class=\"hljs-comment\">// 拿到数组</span>\n  <span class=\"hljs-keyword\">const</span> O = <span class=\"hljs-keyword\">this</span>,\n    len = O.length;\n  <span class=\"hljs-comment\">// 下标值</span>\n  <span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-comment\">// 累加器</span>\n    accumulator = <span class=\"hljs-literal\">undefined</span>,\n    <span class=\"hljs-comment\">// k下标对应的值是否存在</span>\n    kPresent = <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-comment\">// 初始值</span>\n    initialValue = <span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span> ? <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">1</span>] : <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callbackfn !== <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(callbackfn + <span class=\"hljs-string\">' is not a function'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 数组为空，并且有初始值，报错</span>\n  <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span> && <span class=\"hljs-built_in\">arguments</span>.length < <span class=\"hljs-number\">2</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Reduce of empty array with no initial value'</span>);\n  }\n\n  <span class=\"hljs-comment\">// 如果初始值存在</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length > <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// 设置累加器为初始值</span>\n    accumulator = initialValue;\n    <span class=\"hljs-comment\">// 初始值不存在</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    accumulator = O[k];\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">while</span> (k < len) {\n    <span class=\"hljs-comment\">// 判断是否为 empty [,,,]</span>\n    kPresent = O.hasOwnProperty(k);\n\n    <span class=\"hljs-keyword\">if</span> (kPresent) {\n      <span class=\"hljs-keyword\">const</span> kValue = O[k];\n      <span class=\"hljs-comment\">// 调用 callbackfn</span>\n      accumulator = callbackfn.apply(<span class=\"hljs-literal\">undefined</span>, [accumulator, kValue, k, O]);\n    }\n    ++k;\n  }\n\n  <span class=\"hljs-keyword\">return</span> accumulator;\n};\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><p><code>测试</code></p>\n<pre><code class=\"hljs js copyable code-07\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> mReduce = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, , <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>].myreduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a + b, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(rReduce, mReduce);\n<span class=\"hljs-comment\">// 31nullundefined34 31nullundefined34</span>\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">new 实现</h2>\n<blockquote>\n<p>我们需要知道当 <code>new</code> 的时候做了什么事情</p>\n</blockquote>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）</li>\n<li>返回新对象。</li>\n</ol>\n<p>因为 new 没办法重写，我们使用 <code>myNew</code> 函数来模拟 <code>new</code></p>\n<pre><code class=\"hljs js copyable code-08\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// 创建一个实例对象</span>\n  <span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n  <span class=\"hljs-comment\">// 取得外部传入的构造器</span>\n  <span class=\"hljs-keyword\">var</span> Constructor = <span class=\"hljs-built_in\">Array</span>.prototype.shift.call(<span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 实现继承，实例可以访问构造器的属性</span>\n  obj.__proto__ = Constructor.prototype;\n  <span class=\"hljs-comment\">// 调用构造器，并改变其 this 指向到实例</span>\n  <span class=\"hljs-keyword\">var</span> ret = Constructor.apply(obj, <span class=\"hljs-built_in\">arguments</span>);\n  <span class=\"hljs-comment\">// 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> ret === <span class=\"hljs-string\">'object'</span> && ret !== <span class=\"hljs-literal\">null</span> ? ret : obj;\n}\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre><p><code>测试 myNew</code></p>\n<pre><code class=\"hljs js copyable code-09\" lang=\"js\"><span class=\"hljs-comment\">// ========= 无返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// { name: \"foo\" }</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// ========= 有返回值 =============</span>\n<span class=\"hljs-keyword\">const</span> testNewFun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n  <span class=\"hljs-keyword\">return</span> {};\n};\n\n<span class=\"hljs-keyword\">const</span> newObj = myNew(testNewFun, <span class=\"hljs-string\">'foo'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(newObj); <span class=\"hljs-comment\">// {}</span>\n<span class=\"hljs-built_in\">console</span>.log(newObj <span class=\"hljs-keyword\">instanceof</span> testNewFun); <span class=\"hljs-comment\">// false</span>\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-6\">class 实现继承</h2>\n<blockquote>\n<p>主要使用 <code>es5</code> 跟 <code>es6</code> 对比看下 <code>class</code> 继承的原理</p>\n</blockquote>\n<p>实现继承 <code>A extends B</code></p>\n<p>使用 <code>es6</code> 语法</p>\n<pre><code class=\"hljs js copyable code-010\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(opt) {\n    <span class=\"hljs-keyword\">this</span>.BName = opt.name;\n  }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-comment\">// 向父类传参</span>\n    <span class=\"hljs-keyword\">super</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> });\n    <span class=\"hljs-comment\">// this 必须在 super() 下面使用</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n  }\n}\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><p>使用 <code>es5</code> 语法</p>\n<p>使用寄生组合继承的方式</p>\n<ol>\n<li>原型链继承，使子类可以调用父类原型上的方法和属性</li>\n<li>借用构造函数继承，可以实现向父类传参</li>\n<li>寄生继承，创造干净的没有构造方法的函数，用来寄生父类的 prototype</li>\n</ol>\n<pre><code class=\"hljs js copyable code-011\" lang=\"js\"><span class=\"hljs-comment\">// 实现继承，通过继承父类 prototype</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__extends</span>(<span class=\"hljs-params\">child, parent</span>) </span>{\n  <span class=\"hljs-comment\">// 修改对象原型</span>\n  <span class=\"hljs-built_in\">Object</span>.setPrototypeOf(child, parent);\n  <span class=\"hljs-comment\">// 寄生继承，创建一个干净的构造函数，用于继承父类的 prototype</span>\n  <span class=\"hljs-comment\">// 这样做的好处是，修改子类的 prototype 不会影响父类的 prototype</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 修正 constructor 指向子类</span>\n    <span class=\"hljs-keyword\">this</span>.constructor = child;\n  }\n  <span class=\"hljs-comment\">// 原型继承，继承父类原型属性，但是无法向父类构造函数传参</span>\n  child.prototype =\n    parent === <span class=\"hljs-literal\">null</span>\n      ? <span class=\"hljs-built_in\">Object</span>.create(parent)\n      : ((__.prototype = parent.prototype), <span class=\"hljs-keyword\">new</span> __());\n}\n\n<span class=\"hljs-keyword\">var</span> B = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\">opt</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = opt.name;\n  }\n  <span class=\"hljs-keyword\">return</span> B;\n})();\n\n<span class=\"hljs-keyword\">var</span> A = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_super</span>) </span>{\n  __extends(A, _super);\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 借用继承，可以实现向父类传参, 使用 super 可以向父类传参</span>\n    <span class=\"hljs-keyword\">return</span> (_super !== <span class=\"hljs-literal\">null</span> && _super.apply(<span class=\"hljs-keyword\">this</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'B'</span> })) || <span class=\"hljs-keyword\">this</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> A;\n})(B);\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p><code>测试 class</code></p>\n<pre><code class=\"hljs js copyable code-012\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">new</span> A();\n\n<span class=\"hljs-built_in\">console</span>.log(a.BName, a.constructor); <span class=\"hljs-comment\">// B ,ƒ A() {}</span>\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-7\">async/await 实现</h2>\n<blockquote>\n<p>原理就是利用 <code>generator</code>（生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个<code>yield</code> 用 <code>promise</code> 包裹起来。执行下一步的时机由 <code>promise</code> 来控制</p>\n</blockquote>\n<p><code>async/await</code> 是关键字，不能重写它的方法，我们使用函数来模拟</p>\n<p>异步迭代，模拟异步函数</p>\n<pre><code class=\"hljs js copyable code-013\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_asyncToGenerator</span>(<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>,\n      args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-comment\">// 将返回值promise化</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n      <span class=\"hljs-comment\">// 获取迭代器实例</span>\n      <span class=\"hljs-keyword\">var</span> gen = fn.apply(self, args);\n      <span class=\"hljs-comment\">// 执行下一步</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_next</span>(<span class=\"hljs-params\">value</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'next'</span>, value);\n      }\n      <span class=\"hljs-comment\">// 抛出异常</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_throw</span>(<span class=\"hljs-params\">err</span>) </span>{\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class=\"hljs-string\">'throw'</span>, err);\n      }\n      <span class=\"hljs-comment\">// 第一次触发</span>\n      _next(<span class=\"hljs-literal\">undefined</span>);\n    });\n  };\n}\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>执行迭代步骤，处理下次迭代结果</p>\n<pre><code class=\"hljs js copyable code-014\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGeneratorStep</span>(<span class=\"hljs-params\">gen, resolve, reject, _next, _throw, key, arg</span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">var</span> info = gen[key](arg);\n    <span class=\"hljs-keyword\">var</span> value = info.value;\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    reject(error);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (info.done) {\n    <span class=\"hljs-comment\">// 迭代器完成</span>\n    resolve(value);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// -- 这行代码就是精髓 --</span>\n    <span class=\"hljs-comment\">// 将所有值promise化</span>\n    <span class=\"hljs-comment\">// 比如 yield 1</span>\n    <span class=\"hljs-comment\">// const a = Promise.resolve(1) a 是一个 promise</span>\n    <span class=\"hljs-comment\">// const b = Promise.resolve(a) b 是一个 promise</span>\n    <span class=\"hljs-comment\">// 可以做到统一 promise 输出</span>\n    <span class=\"hljs-comment\">// 当 promise 执行完之后再执行下一步</span>\n    <span class=\"hljs-comment\">// 递归调用 next 函数，直到 done == true</span>\n    <span class=\"hljs-built_in\">Promise</span>.resolve(value).then(_next, _throw);\n  }\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p><code>测试 _asyncToGenerator</code></p>\n<pre><code class=\"hljs js copyable code-015\" lang=\"js\"><span class=\"hljs-keyword\">const</span> asyncFunc = _asyncToGenerator(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> e = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      resolve(<span class=\"hljs-string\">'e'</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n  });\n  <span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'a'</span>);\n  <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'d'</span>;\n  <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'b'</span>);\n  <span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'c'</span>);\n  <span class=\"hljs-keyword\">return</span> [a, b, c, d, e];\n});\n\nasyncFunc().then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(res); <span class=\"hljs-comment\">// ['a', 'b', 'c', 'd', 'e']</span>\n});\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-8\">实现一个双向绑定</h2>\n<p><code>defineProperty</code> 版本</p>\n<pre><code class=\"hljs js copyable code-016\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-built_in\">Object</span>.defineProperty(data, <span class=\"hljs-string\">'text'</span>, {\n  <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n  set(newVal) {\n    input.value = newVal;\n    span.innerHTML = newVal;\n  }\n});\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  data.text = e.target.value;\n});\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><p><code>proxy</code> 版本</p>\n<pre><code class=\"hljs js copyable code-017\" lang=\"js\"><span class=\"hljs-comment\">// 数据</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'default'</span>\n};\n<span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'input'</span>);\n<span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'span'</span>);\n<span class=\"hljs-comment\">// 数据劫持</span>\n<span class=\"hljs-keyword\">const</span> handler = {\n  set(target, key, value) {\n    target[key] = value;\n    <span class=\"hljs-comment\">// 数据变化 --> 修改视图</span>\n    input.value = value;\n    span.innerHTML = value;\n    <span class=\"hljs-keyword\">return</span> value;\n  }\n};\n<span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(data, handler);\n\n<span class=\"hljs-comment\">// 视图更改 --> 数据变化</span>\ninput.addEventListener(<span class=\"hljs-string\">'keyup'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n  proxy.text = e.target.value;\n});\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-9\">Object.create 的基本实现原理</h2>\n<pre><code class=\"hljs js copyable code-018\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.create !== <span class=\"hljs-string\">\"function\"</span>) {\n  <span class=\"hljs-built_in\">Object</span>.create = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">prototype, properties</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> prototype !== <span class=\"hljs-string\">\"object\"</span>) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ctor</span>(<span class=\"hljs-params\"></span>) </span>{}\n    Ctor.prototype = prototype;\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> Ctor();\n    <span class=\"hljs-keyword\">if</span> (prototype) { o.constructor = Ctor; }\n    <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-literal\">undefined</span>) {\n      <span class=\"hljs-keyword\">if</span> (properties !== <span class=\"hljs-built_in\">Object</span>(properties)) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(); }\n      <span class=\"hljs-built_in\">Object</span>.defineProperties(o, properties);\n    }\n    <span class=\"hljs-keyword\">return</span> o;\n  };\n}\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-10\">instanceof 实现</h2>\n<blockquote>\n<p>原理： <code>L</code> 的 <code>__proto__</code> 是不是等于 <code>R.prototype</code>，不等于再找 <code>L.__proto__.__proto__</code> 直到 <code>__proto__</code> 为 <code>null</code></p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-019\" lang=\"js\"><span class=\"hljs-comment\">// L 表示左表达式，R 表示右表达式</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">instance_of</span>(<span class=\"hljs-params\">L, R</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> O = R.prototype;\n  L = L.__proto__;\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-comment\">// 这里重点：当 O 严格等于 L 时，返回 true</span>\n    <span class=\"hljs-keyword\">if</span> (O === L) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    L = L.__proto__;\n  }\n}\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-11\">Array.isArray 实现</h2>\n<pre><code class=\"hljs js copyable code-020\" lang=\"js\"><span class=\"hljs-built_in\">Array</span>.myIsArray = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(<span class=\"hljs-built_in\">Object</span>(o)) === <span class=\"hljs-string\">'[object Array]'</span>;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Array</span>.myIsArray([])); <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-12\">getOwnPropertyNames 实现</h2>\n<p>备注：不能拿到不可枚举的属性</p>\n<pre><code class=\"hljs js copyable code-021\" lang=\"js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames !== <span class=\"hljs-string\">'function'</span>) {\n  <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">o</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (o !== <span class=\"hljs-built_in\">Object</span>(o)) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Object.getOwnPropertyNames called on non-object'</span>);\n    }\n    <span class=\"hljs-keyword\">var</span> props = [],\n      p;\n    <span class=\"hljs-keyword\">for</span> (p <span class=\"hljs-keyword\">in</span> o) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(o, p)) {\n        props.push(p);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> props;\n  };\n}\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-13\">Promise 实现</h2>\n<blockquote>\n<p>实现原理：其实就是一个发布订阅者模式</p>\n</blockquote>\n<ol>\n<li>构造函数接收一个 <code>executor</code> 函数，并会在 <code>new Promise()</code> 时立即执行该函数</li>\n<li><code>then</code> 时收集依赖，将回调函数收集到 <code>成功/失败队列</code></li>\n<li><code>executor</code> 函数中调用 <code>resolve/reject</code> 函数</li>\n<li><code>resolve/reject</code> 函数被调用时会通知触发队列中的回调</li>\n</ol>\n<p>先看一下整体代码，有一个大致的概念</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e43d1799b13cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"758\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"758\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>完整代码</p>\n<pre><code class=\"hljs js copyable code-022\" lang=\"js\"><span class=\"hljs-keyword\">const</span> isFunction = <span class=\"hljs-function\"><span class=\"hljs-params\">variable</span> =></span> <span class=\"hljs-keyword\">typeof</span> variable === <span class=\"hljs-string\">'function'</span>;\n\n<span class=\"hljs-comment\">// 定义Promise的三种状态常量</span>\n<span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">'pending'</span>;\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">'fulfilled'</span>;\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">'rejected'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyPromise</span> </span>{\n  <span class=\"hljs-comment\">// 构造函数，new 时触发</span>\n  <span class=\"hljs-keyword\">constructor</span>(handle: Function) {\n    <span class=\"hljs-keyword\">try</span> {\n      handle(<span class=\"hljs-keyword\">this</span>._resolve, <span class=\"hljs-keyword\">this</span>._reject);\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      <span class=\"hljs-keyword\">this</span>._reject(err);\n    }\n  }\n  <span class=\"hljs-comment\">// 状态 pending fulfilled rejected</span>\n  private _status: string = PENDING;\n  <span class=\"hljs-comment\">// 储存 value，用于 then 返回</span>\n  private _value: string | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-comment\">// 失败队列，在 then 时注入，resolve 时触发</span>\n  private _rejectedQueues: any = [];\n  <span class=\"hljs-comment\">// 成功队列，在 then 时注入，resolve 时触发</span>\n  private _fulfilledQueues: any = [];\n  <span class=\"hljs-comment\">// resovle 时执行的函数</span>\n  private _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">this</span>._status = FULFILLED;\n      <span class=\"hljs-comment\">// 依次执行成功队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runFulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._fulfilledQueues.shift())) {\n          cb(value);\n        }\n      };\n      <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n      <span class=\"hljs-keyword\">const</span> runRejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">let</span> cb;\n        <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n          cb(error);\n        }\n      };\n      <span class=\"hljs-comment\">/*\n       * 如果resolve的参数为Promise对象，\n       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变\n       * 且状态取决于参数Promsie对象的状态\n       */</span>\n      <span class=\"hljs-keyword\">if</span> (val <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n        val.then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n            <span class=\"hljs-keyword\">this</span>._value = value;\n            runFulfilled(value);\n          },\n          err => {\n            <span class=\"hljs-keyword\">this</span>._value = err;\n            runRejected(err);\n          }\n        );\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>._value = val;\n        runFulfilled(val);\n      }\n    };\n    <span class=\"hljs-comment\">// 异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// reject 时执行的函数</span>\n  private _reject = <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-comment\">// 依次执行失败队列中的函数，并清空队列</span>\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">this</span>._status = REJECTED;\n      <span class=\"hljs-keyword\">this</span>._value = err;\n      <span class=\"hljs-keyword\">let</span> cb;\n      <span class=\"hljs-keyword\">while</span> ((cb = <span class=\"hljs-keyword\">this</span>._rejectedQueues.shift())) {\n        cb(err);\n      }\n    };\n    <span class=\"hljs-comment\">// 为了支持同步的Promise，这里采用异步调用</span>\n    setTimeout(run);\n  };\n  <span class=\"hljs-comment\">// then 方法</span>\n  then(onFulfilled?, onRejected?) {\n    <span class=\"hljs-keyword\">const</span> { _value, _status } = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-comment\">// 返回一个新的Promise对象</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">onFulfilledNext, onRejectedNext</span>) =></span> {\n      <span class=\"hljs-comment\">// 封装一个成功时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> fulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onFulfilled)) {\n            onFulfilledNext(value);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onFulfilled(value);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-comment\">// 封装一个失败时执行的函数</span>\n      <span class=\"hljs-keyword\">const</span> rejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">if</span> (!isFunction(onRejected)) {\n            onRejectedNext(error);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> res = onRejected(error);\n            <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) {\n              <span class=\"hljs-comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span>\n              res.then(onFulfilledNext, onRejectedNext);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span>\n              onFulfilledNext(res);\n            }\n          }\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span>\n          onRejectedNext(err);\n        }\n      };\n\n      <span class=\"hljs-keyword\">switch</span> (_status) {\n        <span class=\"hljs-comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span>\n        <span class=\"hljs-keyword\">case</span> PENDING:\n          <span class=\"hljs-keyword\">this</span>._fulfilledQueues.push(fulfilled);\n          <span class=\"hljs-keyword\">this</span>._rejectedQueues.push(rejected);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-comment\">// 当状态已经改变时，立即执行对应的回调函数</span>\n        <span class=\"hljs-keyword\">case</span> FULFILLED:\n          fulfilled(_value);\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> REJECTED:\n          rejected(_value);\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// catch 方法</span>\n  <span class=\"hljs-keyword\">catch</span>(onRejected) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(<span class=\"hljs-literal\">undefined</span>, onRejected);\n  }\n  <span class=\"hljs-comment\">// finally 方法</span>\n  <span class=\"hljs-keyword\">finally</span>(cb) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> value),\n      reason =>\n        MyPromise.resolve(cb()).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n          <span class=\"hljs-keyword\">throw</span> reason;\n        })\n    );\n  }\n  <span class=\"hljs-comment\">// 静态 resolve 方法</span>\n  <span class=\"hljs-keyword\">static</span> resolve(value) {\n    <span class=\"hljs-comment\">// 如果参数是MyPromise实例，直接返回这个实例</span>\n    <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> MyPromise) <span class=\"hljs-keyword\">return</span> value;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> resolve(value));\n  }\n  <span class=\"hljs-comment\">// 静态 reject 方法</span>\n  <span class=\"hljs-keyword\">static</span> reject(value) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> reject(value));\n  }\n  <span class=\"hljs-comment\">// 静态 all 方法</span>\n  <span class=\"hljs-keyword\">static</span> all(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-comment\">// 返回值的集合</span>\n      <span class=\"hljs-keyword\">let</span> values = [];\n      <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [i, p] <span class=\"hljs-keyword\">of</span> list.entries()) {\n        <span class=\"hljs-comment\">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            values[i] = res;\n            count++;\n            <span class=\"hljs-comment\">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span>\n            <span class=\"hljs-keyword\">if</span> (count === list.length) resolve(values);\n          },\n          err => {\n            <span class=\"hljs-comment\">// 有一个被rejected时返回的MyPromise状态就变成rejected</span>\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n  <span class=\"hljs-comment\">// 添加静态race方法</span>\n  <span class=\"hljs-keyword\">static</span> race(list) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> list) {\n        <span class=\"hljs-comment\">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span>\n        <span class=\"hljs-keyword\">this</span>.resolve(p).then(\n          <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n            resolve(res);\n          },\n          err => {\n            reject(err);\n          }\n        );\n      }\n    });\n  }\n}\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-14\">防抖/节流</h2>\n<blockquote>\n<p><code>防抖函数</code> onscroll 结束时触发一次，延迟执行</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-023\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">func, wait</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> timeout;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> context = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">arguments</span>;\n    <span class=\"hljs-keyword\">if</span> (timeout) clearTimeout(timeout);\n    timeout = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      func.apply(context, args);\n    }, wait);\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-built_in\">window</span>.onscroll = debounce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'debounce'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><blockquote>\n<p><code>节流函数</code> onscroll 时，每隔一段时间触发一次，像水滴一样</p>\n</blockquote>\n<pre><code class=\"hljs js copyable code-024\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">fn, delay</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> prevTime = <span class=\"hljs-built_in\">Date</span>.now();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> curTime = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-keyword\">if</span> (curTime - prevTime > delay) {\n      fn.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n      prevTime = curTime;\n    }\n  };\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">var</span> throtteScroll = throttle(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'throtte'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-built_in\">window</span>.onscroll = throtteScroll;\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-15\">函数柯里化实现</h2>\n<blockquote>\n<p>其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。</p>\n</blockquote>\n<p>实际应用中：</p>\n<ul>\n<li>延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）</li>\n<li>动态创建函数 （参数不够时会返回接受剩下参数的函数）</li>\n<li>参数复用（每个参数可以多次复用）</li>\n</ul>\n<pre><code class=\"hljs js copyable code-025\" lang=\"js\"><span class=\"hljs-keyword\">const</span> curry = <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =></span>\n  (judge = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =></span>\n    args.length >= fn.length\n      ? fn(...args)\n      : <span class=\"hljs-function\">(<span class=\"hljs-params\">...arg</span>) =></span> judge(...args, ...arg));\n\n<span class=\"hljs-keyword\">const</span> sum = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b, c, d</span>) =></span> a + b + c + d;\n<span class=\"hljs-keyword\">const</span> currySum = curry(sum);\n\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\ncurrySum(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 10</span>\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-16\">手写一个深拷贝</h2>\n<blockquote>\n<p>浅拷贝只复制地址值，实际上还是指向同一堆内存中的数据，深拷贝则是重新创建了一个相同的数据，二者指向的堆内存的地址值是不同的。这个时候修改赋值前的变量数据不会影响赋值后的变量。</p>\n</blockquote>\n<p>要实现一个完美的神拷贝太复杂了，这里简单介绍一下吧，可以应用于大部分场景了</p>\n<p>判断类型函数</p>\n<pre><code class=\"hljs js copyable code-026\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getType</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);\n  <span class=\"hljs-keyword\">const</span> map = {\n    <span class=\"hljs-string\">'[object Boolean]'</span>: <span class=\"hljs-string\">'boolean'</span>,\n    <span class=\"hljs-string\">'[object Number]'</span>: <span class=\"hljs-string\">'number'</span>,\n    <span class=\"hljs-string\">'[object String]'</span>: <span class=\"hljs-string\">'string'</span>,\n    <span class=\"hljs-string\">'[object Function]'</span>: <span class=\"hljs-string\">'function'</span>,\n    <span class=\"hljs-string\">'[object Array]'</span>: <span class=\"hljs-string\">'array'</span>,\n    <span class=\"hljs-string\">'[object Date]'</span>: <span class=\"hljs-string\">'date'</span>,\n    <span class=\"hljs-string\">'[object RegExp]'</span>: <span class=\"hljs-string\">'regExp'</span>,\n    <span class=\"hljs-string\">'[object Undefined]'</span>: <span class=\"hljs-string\">'undefined'</span>,\n    <span class=\"hljs-string\">'[object Null]'</span>: <span class=\"hljs-string\">'null'</span>,\n    <span class=\"hljs-string\">'[object Object]'</span>: <span class=\"hljs-string\">'object'</span>\n  };\n  <span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> Element) {\n    <span class=\"hljs-comment\">// 判断是否是dom元素，如div等</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'element'</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> map[str];\n}\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><p>简单版深拷贝，列举三个例子 <code>array</code> <code>object</code> <code>function</code>，可以自行扩展。主要是引发大家的思考</p>\n<pre><code class=\"hljs js copyable code-027\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepCopy</span>(<span class=\"hljs-params\">ori</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> type = getType(ori);\n  <span class=\"hljs-keyword\">let</span> copy;\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'array'</span>:\n      <span class=\"hljs-keyword\">return</span> copyArray(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'object'</span>:\n      <span class=\"hljs-keyword\">return</span> copyObject(ori, type, copy);\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'function'</span>:\n      <span class=\"hljs-keyword\">return</span> copyFunction(ori, type, copy);\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> ori;\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyArray</span>(<span class=\"hljs-params\">ori, type, copy = []</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [index, value] <span class=\"hljs-keyword\">of</span> ori.entries()) {\n    copy[index] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyObject</span>(<span class=\"hljs-params\">ori, type, copy = {}</span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.entries(ori)) {\n    copy[key] = deepCopy(value);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyFunction</span>(<span class=\"hljs-params\">ori, type, copy = (</span>) => </span>{}) {\n  <span class=\"hljs-keyword\">const</span> fun = <span class=\"hljs-built_in\">eval</span>(ori.toString());\n  fun.prototype = ori.prototype\n  <span class=\"hljs-keyword\">return</span> fun\n}\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-17\">最后有几件小事</h2>\n<ol>\n<li>有想入群的学习前端进阶的加我微信 <code>luoxue2479</code> 回复加群即可</li>\n<li>有错误的话欢迎在留言区指出，一起讨论，也可以加我微信</li>\n<li>每天在群里会有专题讨论 <a target=\"_blank\" href=\"https://github.com/luoxue-victor/source-code/issues/\" rel=\"nofollow noopener noreferrer\">github.com/luoxue-vict…</a></li>\n<li>鄙人公众号【前端技匠】，一起来学习吧。</li>\n</ol>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/7/16e448312ce00d07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1024\" data-height=\"768\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1024\" height=\"768\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>参考文章</p>\n<p><a target=\"_blank\" href=\"https://cloud.tencent.com/developer/article/1431398\" rel=\"nofollow noopener noreferrer\">cloud.tencent.com/developer/a…</a></p>\n<p><a target=\"_blank\" href=\"https://www.jianshu.com/p/b4f0425b22a1\" rel=\"nofollow noopener noreferrer\">www.jianshu.com/p/b4f0425b2…</a></p>\n<p><a target=\"_blank\" href=\"https://blog.csdn.net/LL18781132750/article/details/79700089\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/LL187811327…</a></p>\n",
      "id": "cc6pusd2q5k",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "5hr27njhq8k0",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<p>原文链接：<a target=\"_blank\" href=\"https://dev.to/simonholdorf/9-projects-you-can-do-to-become-a-frontend-master-in-2020-n2h\" rel=\"nofollow noopener noreferrer\">dev.to/simonholdor…</a></p>\n<p>DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。</p..."
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "3scu8l4pdpe0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "4天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<blockquote>\n<p>阅读源码的好处，不用说都知道，首先进大厂必备，还可以提升自己的能力，学习前人的经验。源码往往是前人留下的最佳实践，我们跟着前人的脚步去学习会让我们事半功倍。</p>\n</blockquote>\n<ul>\n<li>call、apply、bind 实现</li>\n<li>new 实现</li>\n<li>class 实现继承</li>\n<li>async/await 实现</li>\n<li>reduce 实现</li>\n<li>实现一个双向数据绑定</li>\n<li>i..."
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "4apad8mjye0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https:/..."
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "m5yu8wzxucg",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https:/..."
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "67mmnpivx140",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "<h2 class=\"heading\" data-id=\"heading-0\">1. 内容概要</h2>\n<p>本文主要讨论以下两个问题：</p>\n<ul>\n<li>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</li>\n<li>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-1\">2. JavaScript 位运算</h2>\n<h..."
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "3bv04lm7yzc0",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "54tytu08bz4",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "jmsfzn6l9rc",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "289cctvizlq8",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "1yzqwcqqnzq8",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "4fcfh633a8o0",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "p5akfsevhqo",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "6dipy8x26yc0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "3yt471iu83g0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "62w6rxazguk0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "6junxw3myss0",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "6x02vn6e5jk0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "7cgi02sh6vw0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "l3v1fgl18w0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "586543pa6jw0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "1g4qma358lvk",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "2qrqwwndb3y0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "obr5mtcnmio",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "65vwojx945k0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "22uhdxdts6o0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "4pdg5sglpvy",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "3byna59r1080",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "6yajz98rf2o0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "9fip4788388",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "78zuen2wrao0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "1qrdc7mxtv0g",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "47vfcfckwym0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "4zn16jic6w00",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "2h3vh2pmxmq0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "16g9wsj40odc",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "4edh3ulmdi00",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "axyx34ojqug",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "57g1rmibwew0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "19110ssfhy8w",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "489ls67tw140",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "2lunsfmui80",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "3owrwt1h5tk0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "39hmvalpmgg0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "4pbmk2qaf8c0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "jfb1ogq3f80",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "4f426dh6oys0",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "41i3q91ztjq0",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "d2yvljadu60",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "6ptt4bj1olk0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "618tbhjqiho0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "1c8mi6c2faio",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "1fecmz329fkw",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "1b8s8df4ftwg",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "5i3v0vaqv9s0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "18l6bp017km8",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "f0dw6tpedls",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "4i4dcnprqb20",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "6hhe870v5rk0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "5735estfyz40",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "38pv9ghkpwo0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "3ftkuxsbfj00",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "si7gpwslbe8",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "dfdidjn0dtk",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "4xjt0zyoxl40",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc36f39e51d4529ed292910",
      "k": "juejin",
      "id": "3vdn4x1xcnw0",
      "author": "云音乐前端技术团队",
      "title": "JavaScript 中的位运算和权限设计",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc0c744e51d456e7e41f5ac",
      "k": "juejin",
      "id": "fopfp5tn2lk",
      "author": "刘小夕",
      "title": "9个项目助你在2020年成为前端大神！",
      "time": "7天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc3894051882517a652dbd7",
      "k": "juejin",
      "id": "cc6pusd2q5k",
      "author": "前端技匠",
      "title": "各种源码实现，你想要的这里都有",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc15b35f265da4d432a3d10",
      "k": "juejin",
      "id": "5pvw5uxlpko0",
      "author": "政采云前端团队",
      "title": "可能是最全的 “文本溢出截断省略” 方案合集",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc7fb87e51d454b4213c934",
      "k": "juejin",
      "id": "6lo8ppv68eo0",
      "author": "政采云前端团队",
      "title": "为你重新系统梳理下， Web 体验优化中和图有关的那些事（万字长文）",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    },
    {
      "url": "https://juejin.im/post/5dc8a231f265da4d40712f8a",
      "k": "juejin",
      "id": "62wkyd1y4p40",
      "author": "前端小智",
      "title": "通过 20 个棘手的ES6面试问题来提高咱们的 JS 技能",
      "time": "1天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty"
    }
  ]
}