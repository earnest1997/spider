{
  "ashley":[{
    "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）</p>\n<p>Github: <a target=\"_blank\" href=\"https://github.com/huangwei9527/quark-h5\" rel=\"nofollow noopener noreferrer\">传送门</a><br>\n演示地址：<a target=\"_blank\" href=\"http://47.104.247.183:4000/\" rel=\"nofollow noopener noreferrer\">传送门</a></p>\n<p><strong>编辑器预览：</strong></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\" data-width=\"1280\" data-height=\"602\" src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">技术栈</h2>\n<p><strong>前端：</strong><br>\n<code>vue</code>: 模块化开发少不了angular，react，vue三选一，这里选择了vue。<br>\n<code>vuex</code>: 状态管理<br>\n<code>sass</code>: css预编译器。<br>\n<code>element-ui</code>：不造轮子，有现成的优秀的vue组件库当然要用起来。没有的自己再封装一些就可以了。<br>\n<code>loadsh</code>：工具类<br></p>\n<p><strong>服务端：</strong><br>\n<code>koa</code>：后端语言采用nodejs，koa文档和学习资料也比较多，express原班人马打造，这个正合适。<br>\n<code>mongodb</code>：一个基于分布式文件存储的数据库，比较灵活。<br></p>\n<h2 class=\"heading\" data-id=\"heading-2\">阅读前准备</h2>\n<p>1、了解vue技术栈开发<br>\n2、了解koa<br>\n3、了解mongodb<br></p>\n<h2 class=\"heading\" data-id=\"heading-3\">工程搭建</h2>\n<p><strong>基于vue-cli3环境搭建</strong><br></p>\n<ul>\n<li>如何规划好我们项目的目录结构？首先我们需要有一个目录作为前端项目，一个目录作为后端项目。所以我们要对vue-cli 生成的项目结构做一下改造：</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">···\n·\n|-- client\t\t\t\t// 原 src 目录，改成 client 用作前端项目目录\n|-- server\t\t\t\t// 新增 server 用于服务端项目目录\n|-- engine-template\t\t// 新增 engine-template 用于页面模板库目录\n|-- docs\t\t\t\t// 新增 docs 预留编写项目文档目录\n·\n···\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><ul>\n<li>\n<p>这样的话 我们需要再把我们webpack配置文件稍作一下调整，首先是把原先的编译指向src的目录改成client，其次为了 npm run build 能正常编译 client 我们也需要为 babel-loader 再增加一个编译目录：</p>\n<ul>\n<li>\n<p>根目录新增vue.config.js,目的是为了改造项目入口,改为:client/main.js</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">    module.exports = {    \n      pages: {        \n        index: {            \n          entry: <span class=\"hljs-string\">\"client/main.js\"</span>        \n        }    \n      }\n    }\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre></li>\n<li>\n<p>babel-loader能正常编译 client, engine-template目录， 在vue.config.js新增如下配置</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">// 扩展 webpack 配置\nchainWebpack: config => {\n\tconfig.module\n\t.rule(<span class=\"hljs-string\">'js'</span>)\n\t.include.add(/engine-template/).end()\n\t.include.add(/client/).end()\n\t.use(<span class=\"hljs-string\">'babel'</span>)\n\t.loader(<span class=\"hljs-string\">'babel-loader'</span>)\n\t.tap(options => {\n\t// 修改它的选项...\n\t<span class=\"hljs-built_in\">return</span> options\n\t})\n}\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre></li>\n</ul>\n</li>\n</ul>\n<p>这样我们搭建起来一个简易的项目目录结构。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">工程目录结构</h2>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">|-- client\t\t\t\t\t--------前端项目界面代码\n    |--common\t\t\t\t\t--------前端界面对应静态资源\n    |--components\t\t\t\t--------组件\n    |--config\t\t\t\t\t--------配置文件\n    |--eventBus\t\t\t\t\t--------eventBus\n    |--filter\t\t\t\t\t--------过滤器\n    |--mixins\t\t\t\t\t--------混入\n    |--pages\t\t\t\t\t--------页面\n    |--router\t\t\t\t\t--------路由配置\n    |--store\t\t\t\t\t--------vuex状态管理\n    |--service\t\t\t\t\t--------axios封装\n    |--App.vue\t\t\t\t\t--------App\n    |--main.js\t\t\t\t\t--------入口文件\n    |--permission.js\t\t\t--------权限控制\n|-- server\t\t\t\t\t--------服务器端项目代码\n    |--confog\t\t\t\t\t--------数据库链接相关\n    |--middleware\t\t\t\t--------中间件\n    |--models\t\t\t\t\t--------Schema和Model\n    |--routes\t\t\t\t\t--------路由\n    |--views\t\t\t\t\t--------ejs页面模板\n    |--public\t\t\t\t\t--------静态资源\n    |--utils\t\t\t\t\t--------工具方法\n    |--app.js\t\t\t\t\t--------服务端入口\n|-- common\t\t\t\t\t--------前后端公用代码模块（如加解密）\n|-- engine-template\t\t\t--------页面模板引擎，使用webpack打包成js提供页面引用\n|-- docs\t\t\t\t\t--------预留编写项目文档目录\n|-- config.json\t\t\t\t--------配置文件\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">前端编辑器实现</h2>\n<p>编辑器的实现思路是：编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e582f5b9c69601?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"747\" data-height=\"435\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"747\" height=\"435\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">数据结构</h2>\n<p>确认了实现逻辑，数据结构也是非常重要的，把一个页面定义成一个JSON数据，数据结构大致是这样的：</p>\n<p><strong>页面工程数据接口</strong></p>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">{\n\ttitle: <span class=\"hljs-string\">''</span>, // 标题\n\tdescription: <span class=\"hljs-string\">''</span>, //描述\n\tcoverImage: <span class=\"hljs-string\">''</span>, // 封面\n\tauther: <span class=\"hljs-string\">''</span>, // 作者\n\tscript: <span class=\"hljs-string\">''</span>, // 页面插入脚本\n\twidth: 375, // 高\n\theight: 644, // 宽\n\tpages: [], // 多页页面\n\tshareConfig: {}, // 微信分享配置\n\tpageMode: 0, // 渲染模式，用于扩展多种模式渲染，翻页h5/长页/PC页面等等\n}\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><p><strong>多页页面pages其中一页数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">{\n\tname: <span class=\"hljs-string\">''</span>,\n\telements: [], // 页面元素\n\tcommonStyle: {\n\t\tbackgroundColor: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundImage: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundSize: <span class=\"hljs-string\">'cover'</span>\n\t},\n\tconfig: {}\n}\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><p><strong>元素数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">{\n\telName: <span class=\"hljs-string\">''</span>, // 组件名\n\tanimations: [], // 图层的动画,可以支持多个动画\n\tcommonStyle: {}, // 公共样式，默认样式\n\tevents: [], // 事件配置数据，每个图层可以添加多个事件\n\tpropsValue: {}, // 属性参数\n\tvalue: <span class=\"hljs-string\">''</span>, // 绑定值\n\tvalueType: <span class=\"hljs-string\">'String'</span>, // 值类型\n\tisForm: <span class=\"hljs-literal\">false</span> // 是否是表单控件，用于表单提交时获取表单数据\n}\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">编辑器整体设计</h3>\n<ul>\n<li>一个组件选择区，提供使用者选择需要的组件</li>\n<li>一个编辑预览画板，提供使用者拖拽排序页面预览的功能</li>\n<li>一个组件属性编辑，提供给使用者编辑组件内部props、公共样式和动画的功能\n<strong>如图：</strong></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e58647221d6942?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"602\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"602\"></svg>\"><figcaption></figcaption></figure>\n用户在左侧组件区域选择组件添加到页面上，编辑区域通过动态组件特性渲染出每个元素组件。<p></p>\n<p><code>最后，点击保存将页面数据提交到数据库。至于数据怎么转成静态 HTML方法有很多。还有页面数据我们全部都有，我们可以做页面的预渲染，骨架屏，ssr，编译时优化等等。而且我们也可以对产出的活动页做数据分析~有很多想象的空间。</code></p>\n<h3 class=\"heading\" data-id=\"heading-8\">核心代码</h3>\n<p>编辑器核心代码，基于 Vue 动态组件特性实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e586d0f77fe59a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1120\" data-height=\"340\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1120\" height=\"340\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>为大家附上 Vue 官方文档：<a target=\"_blank\" title=\"cn.vuejs.org/v2/api/#is\" href=\"https://cn.vuejs.org/v2/api/#is\" rel=\"nofollow noopener noreferrer\">cn.vuejs.org/v2/api/#is</a></p>\n<h3 class=\"heading\" data-id=\"heading-9\">画板元素渲染</h3>\n<p>编辑画板只需要循环遍历pages[i].elements数组，将里面的元素组件JSON数据取出，通过动态组件渲染出各个组件，支持拖拽改变位置尺寸.</p>\n<h3 class=\"heading\" data-id=\"heading-10\">元素组件管理</h3>\n<p>在client目录新建plugins来管理组件库。也可以将该组件库发到npm上工程中通过npm管理</p>\n<h4 class=\"heading\" data-id=\"heading-11\">组件库</h4>\n<p>编写组件，考虑的是组件库，所以我们竟可能让我们的组件支持全局引入和按需引入，如果全局引入，那么所有的组件需要要注册到Vue component 上，并导出：</p>\n<p><strong>client/plugins下新建index.js入口文件</strong></p>\n<pre><code class=\"copyable code-07\">```\n/**\n * 组件库入口\n * */\nimport Text from './text'\n// 所有组件列表\nconst components = [\n\tText\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n\t// 判断是否安装，安装过就不继续往下执行\n\tif (install.installed) return\n\tinstall.installed = true\n\t// 遍历注册所有组件\n\tcomponents.map(component => Vue.component(component.name, component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n\tinstall(window.Vue)\n}\n\nexport default {\n\tinstall,\n\t// 所有组件，必须具有 install，才能使用 Vue.use()\n\tText\n}\n```\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-12\">组件开发</h4>\n<p>示例： text文本组件</p>\n<p><strong>client/plugins下新建text组件目录</strong></p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">|-- text                --------text组件\n    |--src              --------资源\n    \t|--index.vue    --------组件\n    |--index.js         --------入口\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><p>text/index.js</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">// 为组件提供 install 方法，供组件对外按需引入\nimport Component from <span class=\"hljs-string\">'./src/index'</span>\nComponent.install = Vue => {\n\tVue.component(Component.name, Component)\n}\n<span class=\"hljs-built_in\">export</span> default Component\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><p>text/src/index.vue</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\"><!--text.vue-->\n<template>\n  <div class=<span class=\"hljs-string\">\"qk-text\"</span>>\n    {{text}}\n  </div>\n</template>\n\n<script>\n\t<span class=\"hljs-built_in\">export</span> default {\n\t\tname: <span class=\"hljs-string\">'QkText'</span>, // 这个名字很重要，它就是未来的标签名<qk-text></qk-text>\n\t\tprops: {\n\t\t\ttext: {\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: String,\n\t\t\t\tdefault: <span class=\"hljs-string\">'这是一段文字'</span>\n      \t\t}\n\t\t}\n\t}\n</script>\n\n<style lang=<span class=\"hljs-string\">\"scss\"</span> scoped>\n</style>\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p><strong>编辑器里使用组件库：</strong></p>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\">// 引入组件库\nimport QKUI from <span class=\"hljs-string\">'client/plugins/index'</span>\n// 注册组件库\nVue.use(QKUI)\n\n// 使用：\n<qk-text text=<span class=\"hljs-string\">\"这是一段文字\"</span>></qk-text>\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><p>按照这个组件开发方式我们可以扩展任意多的组件，来丰富组件库</p>\n<p><code>需要注意的是这里的组件最外层宽高都要求是100%</code></p>\n<h4 class=\"heading\" data-id=\"heading-13\">配置文件</h4>\n<p>Quark-h5编辑器左侧选择组件区域可以通过一个配置文件定义可选组件\n新建一个ele-config.js配置文件：</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default [\n\t{\n\t\ttitle: <span class=\"hljs-string\">'基础组件'</span>,\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\telName: <span class=\"hljs-string\">'qk-text'</span>, // 组件名，与组件库名称一致\n\t\t\t\ttitle: <span class=\"hljs-string\">'文字'</span>,\n\t\t\t\ticon: <span class=\"hljs-string\">'iconfont iconwenben'</span>,\n\t\t\t\t// 给每个组件配置默认显示样式\n\t\t\t\tdefaultStyle: {\n\t\t\t\t\theight: 40\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'表单组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'功能组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'业务组件'</span>,\n\t\tcomponents: []\n\t}\n]\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>公共方法中提供一个function 通过组件名和默认样式获取元素组件JSON，getElementConfigJson(elName, defaultStyle)方法</p>\n<h3 class=\"heading\" data-id=\"heading-14\">元素属性编辑</h3>\n<h4 class=\"heading\" data-id=\"heading-15\">公共属性样式编辑</h4>\n<p>公共样式属性编辑比较简单就是对元素JSON对象commonStyles字段进行编辑操作</p>\n<h4 class=\"heading\" data-id=\"heading-16\">props属性编辑</h4>\n<p>1.为组件的每一个prop属性开发一个属性编辑组件. 例如：QkText组件需要text属性，新增一个attr-qk-text组件来操作该属性\n2.获取组件prop对象\n3.遍历prop对象key, 通过key判断显示哪些属性编辑组件</p>\n<h3 class=\"heading\" data-id=\"heading-17\">元素添加动画实现</h3>\n<p>动画效果引入Animate.css动画库。元素组件动画,可以支持多个动画。数据存在元素JSON对象animations数组里。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">选择面板hover预览动画</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e596162029891d?imageslim\" data-width=\"457\" data-height=\"452\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"457\" height=\"452\"></svg>\"><figcaption></figcaption></figure>\n监听mouseover和mouseleave，当鼠标移入时将动画className添加入到元素上，鼠标移出时去掉动画lassName。这样就实现了hover预览动画<p></p>\n<h4 class=\"heading\" data-id=\"heading-19\">编辑预览动画</h4>\n<p>组件编辑时支持动画预览和单个动画预览。\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e5965a19adb15e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"448\" data-height=\"170\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"448\" height=\"170\"></svg>\"><figcaption></figcaption></figure>\n封装一个动画执行方法<p></p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">/**\n * 动画方法， 将动画css加入到元素上，返回promise提供执行后续操作（将动画重置）\n * @param <span class=\"hljs-variable\">$el</span> 当前被执行动画的元素\n * @param animationList 动画列表\n * @param isDebugger 动画列表\n * @returns {Promise<void>}\n */\n<span class=\"hljs-built_in\">export</span> default async <span class=\"hljs-keyword\">function</span> runAnimation(<span class=\"hljs-variable\">$el</span>, animationList = [], isDebug , callback){\n\t<span class=\"hljs-built_in\">let</span> playFn = <span class=\"hljs-keyword\">function</span> (animation) {\n\t\t<span class=\"hljs-built_in\">return</span> new Promise(resolve => {\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationName =  animation.type\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDuration =  `<span class=\"hljs-variable\">${animation.duration}</span>s`\n\t\t\t// 如果是循环播放就将循环次数置为1，这样有效避免编辑时因为预览循环播放组件播放动画无法触发animationend来暂停组件动画\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationIterationCount =  animation.infinite ? (isDebug ? 1 : <span class=\"hljs-string\">'infinite'</span>) : animation.interationCount\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDelay =  `<span class=\"hljs-variable\">${animation.delay}</span>s`\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationFillMode =  <span class=\"hljs-string\">'both'</span>\n\t\t\t<span class=\"hljs-built_in\">let</span> resolveFn = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>(){\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.removeEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\tresolve()\n\t\t\t}\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>)\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t})\n\t}\n\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> i = 0, len = animationList.length; i < len; i++){\n\t\tawait playFn(animationList[i])\n\t}\n\t<span class=\"hljs-keyword\">if</span>(callback){\n\t\tcallback()\n\t}\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p><code>animationIterationCount 如果是编辑模式的化动画只执行一次，不然无法监听到动画结束animationend事件</code></p>\n<p>执行动画前先将元素样式style缓存起来，当动画执行完再将原样式赋值给元素</p>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> cssText = this.<span class=\"hljs-variable\">$el</span>.style.cssText;\nrunAnimations(this.<span class=\"hljs-variable\">$el</span>, animations, <span class=\"hljs-literal\">true</span>, () => {\n\tthis.<span class=\"hljs-variable\">$el</span>.style.cssText = cssText\n})\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">元素添加事件</h3>\n<p>提供事件mixins混入到组件，每个事件方法返回promise，元素被点击时按顺序执行事件方法</p>\n<h3 class=\"heading\" data-id=\"heading-21\">页面插入js脚本</h3>\n<p>参考百度H5，将脚本以script标签形式嵌入。页面加载后执行。\n这里也可以考虑mixins方式混入到页面或者组件，可根据业务需求自行扩展，都是可以实现的。</p>\n<h3 class=\"heading\" data-id=\"heading-22\">redo/undo历史操作纪录</h3>\n<ol>\n<li>历史操作纪录存在状态机store.state.editor.historyCache数组中。</li>\n<li>每次修改编辑操作都把整个pageDataJson字段push到historyCache</li>\n<li>点击redo/undo时根据index获取到pageDataJson重新渲染页面</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-23\">psd设计图导入生成h5页面</h3>\n<p>将psd每个设计图中的每个图层导出成图片保存到静态资源服务器中，</p>\n<p><strong>服务端安装psd依赖</strong></p>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\">cnpm install psd --save\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><p><strong>加入psd.js依赖，并且提供接口来处理数据</strong></p>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\">var PSD = require(<span class=\"hljs-string\">'psd'</span>);\nrouter.post(<span class=\"hljs-string\">'/psdPpload'</span>,async ctx=>{\n\tconst file = ctx.request.files.file; // 获取上传文件\n\t<span class=\"hljs-built_in\">let</span> psd = await PSD.open(file.path)\n\tvar timeStr = + new Date();\n\t<span class=\"hljs-built_in\">let</span> descendantsList = psd.tree().descendants();\n\tdescendantsList.reverse();\n\t<span class=\"hljs-built_in\">let</span> psdSourceList = []\n\t<span class=\"hljs-built_in\">let</span> currentPathDir = `public/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>`\n\t<span class=\"hljs-keyword\">for</span> (var i = 0; i < descendantsList.length; i++){\n\t\t<span class=\"hljs-keyword\">if</span> (descendantsList[i].isGroup()) <span class=\"hljs-built_in\">continue</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (!descendantsList[i].visible) <span class=\"hljs-built_in\">continue</span>;\n\t\ttry{\n\t\t\tawait descendantsList[i].saveAsPng(path.join(ctx.state.SERVER_PATH, currentPathDir + `/<span class=\"hljs-variable\">${i}</span>.png`))\n\t\t\tpsdSourceList.push({\n\t\t\t\t...descendantsList[i].export(),\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'picture'</span>,\n\t\t\t\timageSrc: ctx.state.BASE_URL + `/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>/<span class=\"hljs-variable\">${i}</span>.png`,\n\t\t\t})\n\t\t}catch (e) {\n\t\t\t// 转换不出来的图层先忽略\n\t\t\t<span class=\"hljs-built_in\">continue</span>;\n\t\t}\n\t}\n\tctx.body = {\n\t\telements: psdSourceList,\n\t\tdocument: psd.tree().export().document\n\t};\n})\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><p><strong>最后把获取的数据转义并返回给前端，前端获取到数据后使用系统统一方法，遍历添加统一图片组件</strong></p>\n<ul>\n<li>psd源文件大小最好不要超过30M，过大会导致浏览器卡顿甚至卡死</li>\n<li>尽可能合并图层，并栅格化所有图层</li>\n<li>较复杂的图层样式，如滤镜、图层样式等无法读取</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-24\">html2canvas生成缩略图</h3>\n<p>这里只需要注意下图片跨域问题，官方提供html2canvas: proxy解决方案。它将图片转化为base64格式，结合使用设置(proxy: theProxyURL), 绘制到跨域图片时，会去访问theProxyURL下转化好格式的图片，由此解决了画布污染问题。\n提供一个跨域接口</p>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\">/**\n * html2canvas 跨域接口设置\n */\nrouter.get(<span class=\"hljs-string\">'/html2canvas/corsproxy'</span>, async ctx => {\n\tctx.body =  await request(ctx.query.url)\n})\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-25\">渲染模板</h2>\n<h3 class=\"heading\" data-id=\"heading-26\">实现逻辑</h3>\n<p>在engine-template目录下新建swiper-h5-engine页面组件，这个组件接收到页面JSON数据就可以把页面渲染出来。跟编辑预览画板实现逻辑差不多。</p>\n<p>然后使用vue-cli库打包命令将组件打包成engine.js库文件。ejs模板引入该页面组件配合json数据渲染出页面</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59c83f8b1c456?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"799\" data-height=\"496\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"799\" height=\"496\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-27\">适配方案</h3>\n<p>提供两种方案解决屏幕适配\n1、等比例缩放\n在将json元素转换为dom元素的时候，对所有的px单位做比例转换，转换公式为 new = old * windows.x / pageJson.width，这里的pageJson.width是页面的一个初始值，也是编辑时候的默认宽度，同时viewport使用device-width。\n2.全屏背景， 页面垂直居中\n因为会存在上下或者左右有间隙的情况，这时候我们把背景颜色做全屏处理</p>\n<p><code>页面垂直居中只适用于全屏h5, 以后扩展长页和PC页就不需要垂直居中处理。</code></p>\n<h3 class=\"heading\" data-id=\"heading-28\">模板打包</h3>\n<p>package.json中新增打包命令</p>\n<p><code>\"lib:h5-swiper\": \"vue-cli-service build --target lib --name h5-swiper --dest server/public/engine_libs/h5-swiper engine-template/engine-h5-swiper/index.js\"</code></p>\n<p>执行npm run lib:h5-swiper 生成引擎模板js如图</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59d256c29c46c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"464\" data-height=\"185\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"464\" height=\"185\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-29\">页面渲染</h3>\n<p>ejs中引入模板</p>\n<p><code><script src=\"/third-libs/swiper.min.js\"></script></code></p>\n<p>使用组件</p>\n<p><code><engine-h5-swiper :pageData=\"pageData\" /></code></p>\n<h2 class=\"heading\" data-id=\"heading-30\">后端服务</h2>\n<h3 class=\"heading\" data-id=\"heading-31\">初始化项目</h3>\n<p>工程目录上文已给出，也可以使用 koa-generator 脚手架工具生成</p>\n<h3 class=\"heading\" data-id=\"heading-32\">ejs-template 模板引擎配置</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\">//配置ejs-template 模板引擎\nrender(app, {\n\troot: path.join(__dirname, <span class=\"hljs-string\">'views'</span>),\n\tlayout: <span class=\"hljs-literal\">false</span>,\n\tviewExt: <span class=\"hljs-string\">'html'</span>,\n\tcache: <span class=\"hljs-literal\">false</span>,\n\tdebug: <span class=\"hljs-literal\">false</span>\n});\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-33\">koa-static静态资源服务</h3>\n<p>因为html2canvas需要图片允许跨域，所以在静态资源服务中所有资源请求设置'Access-Control-Allow-Origin':'*'</p>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">//配置静态web\napp.use(koaStatic(__dirname + <span class=\"hljs-string\">'/public'</span>), { gzip: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-built_in\">set</span>Headers: <span class=\"hljs-keyword\">function</span>(res){\n\tres.header( <span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>)\n}});\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-34\">修改路由的注册方式，通过遍历routes文件夹读取文件</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\">const fs =  require(<span class=\"hljs-string\">'fs'</span>)\nfs.readdirSync(<span class=\"hljs-string\">'./routes'</span>).forEach(route=> {\n    <span class=\"hljs-built_in\">let</span> api = require(`./routes/<span class=\"hljs-variable\">${route}</span>`)\n    app.use(api.routes(), api.allowedMethods())\n})\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-35\">添加jwt认证，同时过滤不需要认证的路由，如获取token</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\">const jwt = require(<span class=\"hljs-string\">'koa-jwt'</span>)\napp.use(jwt({ secret: <span class=\"hljs-string\">'yourstr'</span> }).unless({\n    path: [\n        /^\\/$/, /\\/token/, /\\/wechat/,\n        { url: /\\/papers/, methods: [<span class=\"hljs-string\">'GET'</span>] }\n    ]\n}));\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-36\">中间件实现统一接口返回数据格式，全局错误捕获并响应</h3>\n<p>middleware/formatresponse.js</p>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\">module.exports = async (ctx, next) => {\n\tawait next().then(() => {\n\t\t<span class=\"hljs-keyword\">if</span> (ctx.status === 200) {\n\t\t\tctx.body = {\n\t\t\t\tmessage: <span class=\"hljs-string\">'成功'</span>,\n\t\t\t\tcode: 200,\n\t\t\t\tbody: ctx.body,\n\t\t\t\tstatus: <span class=\"hljs-literal\">true</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ctx.status === 201) { // 201处理模板引擎渲染\n\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tctx.body = {\n\t\t\t\tmessage: ctx.body || <span class=\"hljs-string\">'接口异常，请重试'</span>,\n\t\t\t\tcode: ctx.status,\n\t\t\t\tbody: <span class=\"hljs-string\">'接口请求失败'</span>,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>\n\t\t\t}\n\t\t}\n\t}).catch((err) => {\n\t\t<span class=\"hljs-keyword\">if</span> (err.status === 401) {\n\t\t\tctx.status = 401;\n\t\t\tctx.body = {\n\t\t\t\tcode: 401,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>,\n\t\t\t\tmessage: <span class=\"hljs-string\">'登录过期，请重新登录'</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tthrow err\n\t\t}\n\t})\n}\n\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-37\">koa2-cors跨域处理</h3>\n<p>当接口发布到线上，前端通过ajax请求时，会报跨域的错误。koa2使用koa2-cors这个库非常方便的实现了跨域配置，使用起来也很简单</p>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\">const cors = require(<span class=\"hljs-string\">'koa2-cors'</span>);\napp.use(cors());\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-38\">连接数据库</h3>\n<p>我们使用mongodb数据库，在koa2中使用mongoose这个库来管理整个数据库的操作。</p>\n<ul>\n<li>创建配置文件</li>\n</ul>\n<p>根目录下新建config文件夹，新建mongo.js</p>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\">// config/mongo.js\nconst mongoose = require(<span class=\"hljs-string\">'mongoose'</span>).set(<span class=\"hljs-string\">'debug'</span>, <span class=\"hljs-literal\">true</span>);\nconst options = {\n    autoReconnect: <span class=\"hljs-literal\">true</span>\n}\n\n// username 数据库用户名\n// password 数据库密码\n// localhost 数据库ip\n// dbname 数据库名称\nconst url = <span class=\"hljs-string\">'mongodb://username:password@localhost:27017/dbname'</span>\n\nmodule.exports = {\n    connect: ()=> {            \n        mongoose.connect(url,options)\n        <span class=\"hljs-built_in\">let</span> db = mongoose.connection\n        db.on(<span class=\"hljs-string\">'error'</span>, console.error.bind(console, <span class=\"hljs-string\">'连接错误:'</span>));\n        db.once(<span class=\"hljs-string\">'open'</span>, ()=> {\n            console.log(<span class=\"hljs-string\">'mongodb connect suucess'</span>);\n        })\n    }\n}\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><p>把mongodb配置信息放到config.json中统一管理</p>\n<ul>\n<li>然后在app.js中引入</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\">const mongoConf = require(<span class=\"hljs-string\">'./config/mongo'</span>);\nmongoConf.connect();\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><p>...\n<strong>服务端具体接口实现就不详细介绍了，就是对页面的增删改查，和用户的登录注册难度不大</strong></p>\n<h2 class=\"heading\" data-id=\"heading-39\">启动运行</h2>\n<h3 class=\"heading\" data-id=\"heading-40\">启动前端</h3>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\">npm run dev-client\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-41\">启动服务端</h3>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\">npm run dev-server\n<span class=\"copy-code-btn copy-056\">复制代码</span></code></pre><p>注意：\n如果没有生成过引擎模板js文件的，需要先编辑引擎模板，否则预览页面加载页面引擎.js 404报错</p>\n<h5 class=\"heading\" data-id=\"heading-42\">编译engine.js模板引擎</h5>\n<pre><code class=\"hljs bash copyable code-028\" lang=\"bash\">npm run lib:h5-swiper\n<span class=\"copy-code-btn copy-057\">复制代码</span></code></pre>",
    "id": "33nexc9y7fc0",
    "author": "围的围",
    "title": "Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5",
    "baseClassName": "article-content"
  }]
}