{
  "searchResList": [
    {
      "url": "https://juejin.im/entry/5675217e60b294e7ce8e2a4c",
      "k": "juejin",
      "id": "41calb2g1vi0",
      "author": "sing1ee",
      "title": "Node入门 » 一本全面的Node.js教程",
      "time": "3年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "关于本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“HelloWorld”的教程。状态你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。本书中的代码案例都在Node.js0.6.11版本中测试过，可以正确工作。读者对象本书最适合与我有相似技术背景的读者：至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaS..."
    },
    {
      "url": "https://juejin.im/post/5b0388006fb9a07aa213ae16",
      "k": "juejin",
      "id": "4lm3xszyd2u0",
      "author": "有赞技术",
      "title": "Node 在有赞的实践",
      "time": "1年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "一、概述4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在Node这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。二、Node基础框架的迭代与演进1.从Koa到阿童木（Astroboy）（1）Koa+中间件有赞最早的一个比较完整的Node项目是公司内部的一个管理系统，这个系统是用Node全栈开发的，主要包括一个给H..."
    },
    {
      "url": "https://juejin.im/post/5c1f8e52f265da6170071e43",
      "k": "juejin",
      "id": "24kijtp8gv5s",
      "author": "jsliang",
      "title": "Node - 从0基础到实战企业官网",
      "time": "11月前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "Createbyjsliangon2018-11-813:42:42Recentlyrevisedin2018-12-2321:59:20Hello小伙伴们，如果觉得本文还不错，记得点个赞或者给个star，你们的赞和star是我编写更多更精彩文章的动力！GitHub地址【2019-08-16】Hello小伙伴们，由于jsliang对文档库进行了重构，这篇文章的一些链接可能失效，而jsliang没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的GitHub地址，去文..."
    },
    {
      "url": "https://juejin.im/post/592ed10a2f301e00571966b2",
      "k": "juejin",
      "id": "1zok5x1671kw",
      "author": "小虫巨蟹",
      "title": "Node 爬虫入门",
      "time": "2年前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章为了验证“简书上，经验总结、资料归集类技术文章更容易上热榜”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的..."
    },
    {
      "url": "https://www.jianshu.com/p/f3e10a011381",
      "k": "jianshu",
      "id": "470lupgyxi80",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "time": "\n            5 个月前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。Node.js是名副其实的版本帝，版本更新确实很频繁，时间线如下。2013年，发布了0.10版本。2015年1月，发布了1.0.0版本（io..."
    },
    {
      "url": "https://www.jianshu.com/p/f8b105bb2b13",
      "k": "jianshu",
      "id": "4djqlu0vlo80",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "time": "\n            1 年前\n          ",
      "baseClassName": "empty",
      "baseSelectorToGetClassName": "article",
      "detail": "封面千呼万唤始出来，犹抱琵琶生哪吒。真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。Node.js作为近几年新兴的一种编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++开发Node.js原生扩展的口子，让开发者进行项目开发时有了更多的选择。《Node.js：来一打C++扩展》以ChromeV8的知识作为基础，配合GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写..."
    }
  ],
  "hotArticleDetailList": [
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）</p>\n<p>Github: <a target=\"_blank\" href=\"https://github.com/huangwei9527/quark-h5\" rel=\"nofollow noopener noreferrer\">传送门</a><br>\n演示地址：<a target=\"_blank\" href=\"http://47.104.247.183:4000/\" rel=\"nofollow noopener noreferrer\">传送门</a></p>\n<p><strong>编辑器预览：</strong></p>\n<p></p><figure><img class=\"lazyload inited loaded\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\" data-width=\"1280\" data-height=\"602\" src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e55daeaa08bd25?imageslim\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">技术栈</h2>\n<p><strong>前端：</strong><br>\n<code>vue</code>: 模块化开发少不了angular，react，vue三选一，这里选择了vue。<br>\n<code>vuex</code>: 状态管理<br>\n<code>sass</code>: css预编译器。<br>\n<code>element-ui</code>：不造轮子，有现成的优秀的vue组件库当然要用起来。没有的自己再封装一些就可以了。<br>\n<code>loadsh</code>：工具类<br></p>\n<p><strong>服务端：</strong><br>\n<code>koa</code>：后端语言采用nodejs，koa文档和学习资料也比较多，express原班人马打造，这个正合适。<br>\n<code>mongodb</code>：一个基于分布式文件存储的数据库，比较灵活。<br></p>\n<h2 class=\"heading\" data-id=\"heading-2\">阅读前准备</h2>\n<p>1、了解vue技术栈开发<br>\n2、了解koa<br>\n3、了解mongodb<br></p>\n<h2 class=\"heading\" data-id=\"heading-3\">工程搭建</h2>\n<p><strong>基于vue-cli3环境搭建</strong><br></p>\n<ul>\n<li>如何规划好我们项目的目录结构？首先我们需要有一个目录作为前端项目，一个目录作为后端项目。所以我们要对vue-cli 生成的项目结构做一下改造：</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">···\n·\n|-- client\t\t\t\t// 原 src 目录，改成 client 用作前端项目目录\n|-- server\t\t\t\t// 新增 server 用于服务端项目目录\n|-- engine-template\t\t// 新增 engine-template 用于页面模板库目录\n|-- docs\t\t\t\t// 新增 docs 预留编写项目文档目录\n·\n···\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><ul>\n<li>\n<p>这样的话 我们需要再把我们webpack配置文件稍作一下调整，首先是把原先的编译指向src的目录改成client，其次为了 npm run build 能正常编译 client 我们也需要为 babel-loader 再增加一个编译目录：</p>\n<ul>\n<li>\n<p>根目录新增vue.config.js,目的是为了改造项目入口,改为:client/main.js</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">    module.exports = {    \n      pages: {        \n        index: {            \n          entry: <span class=\"hljs-string\">\"client/main.js\"</span>        \n        }    \n      }\n    }\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre></li>\n<li>\n<p>babel-loader能正常编译 client, engine-template目录， 在vue.config.js新增如下配置</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">// 扩展 webpack 配置\nchainWebpack: config => {\n\tconfig.module\n\t.rule(<span class=\"hljs-string\">'js'</span>)\n\t.include.add(/engine-template/).end()\n\t.include.add(/client/).end()\n\t.use(<span class=\"hljs-string\">'babel'</span>)\n\t.loader(<span class=\"hljs-string\">'babel-loader'</span>)\n\t.tap(options => {\n\t// 修改它的选项...\n\t<span class=\"hljs-built_in\">return</span> options\n\t})\n}\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre></li>\n</ul>\n</li>\n</ul>\n<p>这样我们搭建起来一个简易的项目目录结构。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">工程目录结构</h2>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">|-- client\t\t\t\t\t--------前端项目界面代码\n    |--common\t\t\t\t\t--------前端界面对应静态资源\n    |--components\t\t\t\t--------组件\n    |--config\t\t\t\t\t--------配置文件\n    |--eventBus\t\t\t\t\t--------eventBus\n    |--filter\t\t\t\t\t--------过滤器\n    |--mixins\t\t\t\t\t--------混入\n    |--pages\t\t\t\t\t--------页面\n    |--router\t\t\t\t\t--------路由配置\n    |--store\t\t\t\t\t--------vuex状态管理\n    |--service\t\t\t\t\t--------axios封装\n    |--App.vue\t\t\t\t\t--------App\n    |--main.js\t\t\t\t\t--------入口文件\n    |--permission.js\t\t\t--------权限控制\n|-- server\t\t\t\t\t--------服务器端项目代码\n    |--confog\t\t\t\t\t--------数据库链接相关\n    |--middleware\t\t\t\t--------中间件\n    |--models\t\t\t\t\t--------Schema和Model\n    |--routes\t\t\t\t\t--------路由\n    |--views\t\t\t\t\t--------ejs页面模板\n    |--public\t\t\t\t\t--------静态资源\n    |--utils\t\t\t\t\t--------工具方法\n    |--app.js\t\t\t\t\t--------服务端入口\n|-- common\t\t\t\t\t--------前后端公用代码模块（如加解密）\n|-- engine-template\t\t\t--------页面模板引擎，使用webpack打包成js提供页面引用\n|-- docs\t\t\t\t\t--------预留编写项目文档目录\n|-- config.json\t\t\t\t--------配置文件\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">前端编辑器实现</h2>\n<p>编辑器的实现思路是：编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e582f5b9c69601?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"747\" data-height=\"435\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"747\" height=\"435\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-6\">数据结构</h2>\n<p>确认了实现逻辑，数据结构也是非常重要的，把一个页面定义成一个JSON数据，数据结构大致是这样的：</p>\n<p><strong>页面工程数据接口</strong></p>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">{\n\ttitle: <span class=\"hljs-string\">''</span>, // 标题\n\tdescription: <span class=\"hljs-string\">''</span>, //描述\n\tcoverImage: <span class=\"hljs-string\">''</span>, // 封面\n\tauther: <span class=\"hljs-string\">''</span>, // 作者\n\tscript: <span class=\"hljs-string\">''</span>, // 页面插入脚本\n\twidth: 375, // 高\n\theight: 644, // 宽\n\tpages: [], // 多页页面\n\tshareConfig: {}, // 微信分享配置\n\tpageMode: 0, // 渲染模式，用于扩展多种模式渲染，翻页h5/长页/PC页面等等\n}\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><p><strong>多页页面pages其中一页数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">{\n\tname: <span class=\"hljs-string\">''</span>,\n\telements: [], // 页面元素\n\tcommonStyle: {\n\t\tbackgroundColor: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundImage: <span class=\"hljs-string\">''</span>,\n\t\tbackgroundSize: <span class=\"hljs-string\">'cover'</span>\n\t},\n\tconfig: {}\n}\n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><p><strong>元素数据结构：</strong></p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">{\n\telName: <span class=\"hljs-string\">''</span>, // 组件名\n\tanimations: [], // 图层的动画,可以支持多个动画\n\tcommonStyle: {}, // 公共样式，默认样式\n\tevents: [], // 事件配置数据，每个图层可以添加多个事件\n\tpropsValue: {}, // 属性参数\n\tvalue: <span class=\"hljs-string\">''</span>, // 绑定值\n\tvalueType: <span class=\"hljs-string\">'String'</span>, // 值类型\n\tisForm: <span class=\"hljs-literal\">false</span> // 是否是表单控件，用于表单提交时获取表单数据\n}\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">编辑器整体设计</h3>\n<ul>\n<li>一个组件选择区，提供使用者选择需要的组件</li>\n<li>一个编辑预览画板，提供使用者拖拽排序页面预览的功能</li>\n<li>一个组件属性编辑，提供给使用者编辑组件内部props、公共样式和动画的功能\n<strong>如图：</strong></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e58647221d6942?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"602\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"602\"></svg>\"><figcaption></figcaption></figure>\n用户在左侧组件区域选择组件添加到页面上，编辑区域通过动态组件特性渲染出每个元素组件。<p></p>\n<p><code>最后，点击保存将页面数据提交到数据库。至于数据怎么转成静态 HTML方法有很多。还有页面数据我们全部都有，我们可以做页面的预渲染，骨架屏，ssr，编译时优化等等。而且我们也可以对产出的活动页做数据分析~有很多想象的空间。</code></p>\n<h3 class=\"heading\" data-id=\"heading-8\">核心代码</h3>\n<p>编辑器核心代码，基于 Vue 动态组件特性实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e586d0f77fe59a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1120\" data-height=\"340\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1120\" height=\"340\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>为大家附上 Vue 官方文档：<a target=\"_blank\" title=\"cn.vuejs.org/v2/api/#is\" href=\"https://cn.vuejs.org/v2/api/#is\" rel=\"nofollow noopener noreferrer\">cn.vuejs.org/v2/api/#is</a></p>\n<h3 class=\"heading\" data-id=\"heading-9\">画板元素渲染</h3>\n<p>编辑画板只需要循环遍历pages[i].elements数组，将里面的元素组件JSON数据取出，通过动态组件渲染出各个组件，支持拖拽改变位置尺寸.</p>\n<h3 class=\"heading\" data-id=\"heading-10\">元素组件管理</h3>\n<p>在client目录新建plugins来管理组件库。也可以将该组件库发到npm上工程中通过npm管理</p>\n<h4 class=\"heading\" data-id=\"heading-11\">组件库</h4>\n<p>编写组件，考虑的是组件库，所以我们竟可能让我们的组件支持全局引入和按需引入，如果全局引入，那么所有的组件需要要注册到Vue component 上，并导出：</p>\n<p><strong>client/plugins下新建index.js入口文件</strong></p>\n<pre><code class=\"copyable code-07\">```\n/**\n * 组件库入口\n * */\nimport Text from './text'\n// 所有组件列表\nconst components = [\n\tText\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n\t// 判断是否安装，安装过就不继续往下执行\n\tif (install.installed) return\n\tinstall.installed = true\n\t// 遍历注册所有组件\n\tcomponents.map(component => Vue.component(component.name, component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n\tinstall(window.Vue)\n}\n\nexport default {\n\tinstall,\n\t// 所有组件，必须具有 install，才能使用 Vue.use()\n\tText\n}\n```\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre>\n<h4 class=\"heading\" data-id=\"heading-12\">组件开发</h4>\n<p>示例： text文本组件</p>\n<p><strong>client/plugins下新建text组件目录</strong></p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">|-- text                --------text组件\n    |--src              --------资源\n    \t|--index.vue    --------组件\n    |--index.js         --------入口\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><p>text/index.js</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">// 为组件提供 install 方法，供组件对外按需引入\nimport Component from <span class=\"hljs-string\">'./src/index'</span>\nComponent.install = Vue => {\n\tVue.component(Component.name, Component)\n}\n<span class=\"hljs-built_in\">export</span> default Component\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><p>text/src/index.vue</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\"><!--text.vue-->\n<template>\n  <div class=<span class=\"hljs-string\">\"qk-text\"</span>>\n    {{text}}\n  </div>\n</template>\n\n<script>\n\t<span class=\"hljs-built_in\">export</span> default {\n\t\tname: <span class=\"hljs-string\">'QkText'</span>, // 这个名字很重要，它就是未来的标签名<qk-text></qk-text>\n\t\tprops: {\n\t\t\ttext: {\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: String,\n\t\t\t\tdefault: <span class=\"hljs-string\">'这是一段文字'</span>\n      \t\t}\n\t\t}\n\t}\n</script>\n\n<style lang=<span class=\"hljs-string\">\"scss\"</span> scoped>\n</style>\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p><strong>编辑器里使用组件库：</strong></p>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\">// 引入组件库\nimport QKUI from <span class=\"hljs-string\">'client/plugins/index'</span>\n// 注册组件库\nVue.use(QKUI)\n\n// 使用：\n<qk-text text=<span class=\"hljs-string\">\"这是一段文字\"</span>></qk-text>\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><p>按照这个组件开发方式我们可以扩展任意多的组件，来丰富组件库</p>\n<p><code>需要注意的是这里的组件最外层宽高都要求是100%</code></p>\n<h4 class=\"heading\" data-id=\"heading-13\">配置文件</h4>\n<p>Quark-h5编辑器左侧选择组件区域可以通过一个配置文件定义可选组件\n新建一个ele-config.js配置文件：</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default [\n\t{\n\t\ttitle: <span class=\"hljs-string\">'基础组件'</span>,\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\telName: <span class=\"hljs-string\">'qk-text'</span>, // 组件名，与组件库名称一致\n\t\t\t\ttitle: <span class=\"hljs-string\">'文字'</span>,\n\t\t\t\ticon: <span class=\"hljs-string\">'iconfont iconwenben'</span>,\n\t\t\t\t// 给每个组件配置默认显示样式\n\t\t\t\tdefaultStyle: {\n\t\t\t\t\theight: 40\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'表单组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'功能组件'</span>,\n\t\tcomponents: []\n\t},\n\t{\n\t\ttitle: <span class=\"hljs-string\">'业务组件'</span>,\n\t\tcomponents: []\n\t}\n]\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>公共方法中提供一个function 通过组件名和默认样式获取元素组件JSON，getElementConfigJson(elName, defaultStyle)方法</p>\n<h3 class=\"heading\" data-id=\"heading-14\">元素属性编辑</h3>\n<h4 class=\"heading\" data-id=\"heading-15\">公共属性样式编辑</h4>\n<p>公共样式属性编辑比较简单就是对元素JSON对象commonStyles字段进行编辑操作</p>\n<h4 class=\"heading\" data-id=\"heading-16\">props属性编辑</h4>\n<p>1.为组件的每一个prop属性开发一个属性编辑组件. 例如：QkText组件需要text属性，新增一个attr-qk-text组件来操作该属性\n2.获取组件prop对象\n3.遍历prop对象key, 通过key判断显示哪些属性编辑组件</p>\n<h3 class=\"heading\" data-id=\"heading-17\">元素添加动画实现</h3>\n<p>动画效果引入Animate.css动画库。元素组件动画,可以支持多个动画。数据存在元素JSON对象animations数组里。</p>\n<h4 class=\"heading\" data-id=\"heading-18\">选择面板hover预览动画</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e596162029891d?imageslim\" data-width=\"457\" data-height=\"452\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"457\" height=\"452\"></svg>\"><figcaption></figcaption></figure>\n监听mouseover和mouseleave，当鼠标移入时将动画className添加入到元素上，鼠标移出时去掉动画lassName。这样就实现了hover预览动画<p></p>\n<h4 class=\"heading\" data-id=\"heading-19\">编辑预览动画</h4>\n<p>组件编辑时支持动画预览和单个动画预览。\n</p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e5965a19adb15e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"448\" data-height=\"170\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"448\" height=\"170\"></svg>\"><figcaption></figcaption></figure>\n封装一个动画执行方法<p></p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">/**\n * 动画方法， 将动画css加入到元素上，返回promise提供执行后续操作（将动画重置）\n * @param <span class=\"hljs-variable\">$el</span> 当前被执行动画的元素\n * @param animationList 动画列表\n * @param isDebugger 动画列表\n * @returns {Promise<void>}\n */\n<span class=\"hljs-built_in\">export</span> default async <span class=\"hljs-keyword\">function</span> runAnimation(<span class=\"hljs-variable\">$el</span>, animationList = [], isDebug , callback){\n\t<span class=\"hljs-built_in\">let</span> playFn = <span class=\"hljs-keyword\">function</span> (animation) {\n\t\t<span class=\"hljs-built_in\">return</span> new Promise(resolve => {\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationName =  animation.type\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDuration =  `<span class=\"hljs-variable\">${animation.duration}</span>s`\n\t\t\t// 如果是循环播放就将循环次数置为1，这样有效避免编辑时因为预览循环播放组件播放动画无法触发animationend来暂停组件动画\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationIterationCount =  animation.infinite ? (isDebug ? 1 : <span class=\"hljs-string\">'infinite'</span>) : animation.interationCount\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationDelay =  `<span class=\"hljs-variable\">${animation.delay}</span>s`\n\t\t\t<span class=\"hljs-variable\">$el</span>.style.animationFillMode =  <span class=\"hljs-string\">'both'</span>\n\t\t\t<span class=\"hljs-built_in\">let</span> resolveFn = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>(){\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.removeEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t\t\tresolve()\n\t\t\t}\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationend'</span>, resolveFn, <span class=\"hljs-literal\">false</span>)\n\t\t\t<span class=\"hljs-variable\">$el</span>.addEventListener(<span class=\"hljs-string\">'animationcancel'</span>, resolveFn, <span class=\"hljs-literal\">false</span>);\n\t\t})\n\t}\n\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> i = 0, len = animationList.length; i < len; i++){\n\t\tawait playFn(animationList[i])\n\t}\n\t<span class=\"hljs-keyword\">if</span>(callback){\n\t\tcallback()\n\t}\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p><code>animationIterationCount 如果是编辑模式的化动画只执行一次，不然无法监听到动画结束animationend事件</code></p>\n<p>执行动画前先将元素样式style缓存起来，当动画执行完再将原样式赋值给元素</p>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> cssText = this.<span class=\"hljs-variable\">$el</span>.style.cssText;\nrunAnimations(this.<span class=\"hljs-variable\">$el</span>, animations, <span class=\"hljs-literal\">true</span>, () => {\n\tthis.<span class=\"hljs-variable\">$el</span>.style.cssText = cssText\n})\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">元素添加事件</h3>\n<p>提供事件mixins混入到组件，每个事件方法返回promise，元素被点击时按顺序执行事件方法</p>\n<h3 class=\"heading\" data-id=\"heading-21\">页面插入js脚本</h3>\n<p>参考百度H5，将脚本以script标签形式嵌入。页面加载后执行。\n这里也可以考虑mixins方式混入到页面或者组件，可根据业务需求自行扩展，都是可以实现的。</p>\n<h3 class=\"heading\" data-id=\"heading-22\">redo/undo历史操作纪录</h3>\n<ol>\n<li>历史操作纪录存在状态机store.state.editor.historyCache数组中。</li>\n<li>每次修改编辑操作都把整个pageDataJson字段push到historyCache</li>\n<li>点击redo/undo时根据index获取到pageDataJson重新渲染页面</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-23\">psd设计图导入生成h5页面</h3>\n<p>将psd每个设计图中的每个图层导出成图片保存到静态资源服务器中，</p>\n<p><strong>服务端安装psd依赖</strong></p>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\">cnpm install psd --save\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><p><strong>加入psd.js依赖，并且提供接口来处理数据</strong></p>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\">var PSD = require(<span class=\"hljs-string\">'psd'</span>);\nrouter.post(<span class=\"hljs-string\">'/psdPpload'</span>,async ctx=>{\n\tconst file = ctx.request.files.file; // 获取上传文件\n\t<span class=\"hljs-built_in\">let</span> psd = await PSD.open(file.path)\n\tvar timeStr = + new Date();\n\t<span class=\"hljs-built_in\">let</span> descendantsList = psd.tree().descendants();\n\tdescendantsList.reverse();\n\t<span class=\"hljs-built_in\">let</span> psdSourceList = []\n\t<span class=\"hljs-built_in\">let</span> currentPathDir = `public/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>`\n\t<span class=\"hljs-keyword\">for</span> (var i = 0; i < descendantsList.length; i++){\n\t\t<span class=\"hljs-keyword\">if</span> (descendantsList[i].isGroup()) <span class=\"hljs-built_in\">continue</span>;\n\t\t<span class=\"hljs-keyword\">if</span> (!descendantsList[i].visible) <span class=\"hljs-built_in\">continue</span>;\n\t\ttry{\n\t\t\tawait descendantsList[i].saveAsPng(path.join(ctx.state.SERVER_PATH, currentPathDir + `/<span class=\"hljs-variable\">${i}</span>.png`))\n\t\t\tpsdSourceList.push({\n\t\t\t\t...descendantsList[i].export(),\n\t\t\t\t<span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'picture'</span>,\n\t\t\t\timageSrc: ctx.state.BASE_URL + `/upload_static/psd_image/<span class=\"hljs-variable\">${timeStr}</span>/<span class=\"hljs-variable\">${i}</span>.png`,\n\t\t\t})\n\t\t}catch (e) {\n\t\t\t// 转换不出来的图层先忽略\n\t\t\t<span class=\"hljs-built_in\">continue</span>;\n\t\t}\n\t}\n\tctx.body = {\n\t\telements: psdSourceList,\n\t\tdocument: psd.tree().export().document\n\t};\n})\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><p><strong>最后把获取的数据转义并返回给前端，前端获取到数据后使用系统统一方法，遍历添加统一图片组件</strong></p>\n<ul>\n<li>psd源文件大小最好不要超过30M，过大会导致浏览器卡顿甚至卡死</li>\n<li>尽可能合并图层，并栅格化所有图层</li>\n<li>较复杂的图层样式，如滤镜、图层样式等无法读取</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-24\">html2canvas生成缩略图</h3>\n<p>这里只需要注意下图片跨域问题，官方提供html2canvas: proxy解决方案。它将图片转化为base64格式，结合使用设置(proxy: theProxyURL), 绘制到跨域图片时，会去访问theProxyURL下转化好格式的图片，由此解决了画布污染问题。\n提供一个跨域接口</p>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\">/**\n * html2canvas 跨域接口设置\n */\nrouter.get(<span class=\"hljs-string\">'/html2canvas/corsproxy'</span>, async ctx => {\n\tctx.body =  await request(ctx.query.url)\n})\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-25\">渲染模板</h2>\n<h3 class=\"heading\" data-id=\"heading-26\">实现逻辑</h3>\n<p>在engine-template目录下新建swiper-h5-engine页面组件，这个组件接收到页面JSON数据就可以把页面渲染出来。跟编辑预览画板实现逻辑差不多。</p>\n<p>然后使用vue-cli库打包命令将组件打包成engine.js库文件。ejs模板引入该页面组件配合json数据渲染出页面</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59c83f8b1c456?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"799\" data-height=\"496\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"799\" height=\"496\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-27\">适配方案</h3>\n<p>提供两种方案解决屏幕适配\n1、等比例缩放\n在将json元素转换为dom元素的时候，对所有的px单位做比例转换，转换公式为 new = old * windows.x / pageJson.width，这里的pageJson.width是页面的一个初始值，也是编辑时候的默认宽度，同时viewport使用device-width。\n2.全屏背景， 页面垂直居中\n因为会存在上下或者左右有间隙的情况，这时候我们把背景颜色做全屏处理</p>\n<p><code>页面垂直居中只适用于全屏h5, 以后扩展长页和PC页就不需要垂直居中处理。</code></p>\n<h3 class=\"heading\" data-id=\"heading-28\">模板打包</h3>\n<p>package.json中新增打包命令</p>\n<p><code>\"lib:h5-swiper\": \"vue-cli-service build --target lib --name h5-swiper --dest server/public/engine_libs/h5-swiper engine-template/engine-h5-swiper/index.js\"</code></p>\n<p>执行npm run lib:h5-swiper 生成引擎模板js如图</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/11/16e59d256c29c46c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"464\" data-height=\"185\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"464\" height=\"185\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-29\">页面渲染</h3>\n<p>ejs中引入模板</p>\n<p><code><script src=\"/third-libs/swiper.min.js\"></script></code></p>\n<p>使用组件</p>\n<p><code><engine-h5-swiper :pageData=\"pageData\" /></code></p>\n<h2 class=\"heading\" data-id=\"heading-30\">后端服务</h2>\n<h3 class=\"heading\" data-id=\"heading-31\">初始化项目</h3>\n<p>工程目录上文已给出，也可以使用 koa-generator 脚手架工具生成</p>\n<h3 class=\"heading\" data-id=\"heading-32\">ejs-template 模板引擎配置</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\">//配置ejs-template 模板引擎\nrender(app, {\n\troot: path.join(__dirname, <span class=\"hljs-string\">'views'</span>),\n\tlayout: <span class=\"hljs-literal\">false</span>,\n\tviewExt: <span class=\"hljs-string\">'html'</span>,\n\tcache: <span class=\"hljs-literal\">false</span>,\n\tdebug: <span class=\"hljs-literal\">false</span>\n});\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-33\">koa-static静态资源服务</h3>\n<p>因为html2canvas需要图片允许跨域，所以在静态资源服务中所有资源请求设置'Access-Control-Allow-Origin':'*'</p>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">//配置静态web\napp.use(koaStatic(__dirname + <span class=\"hljs-string\">'/public'</span>), { gzip: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-built_in\">set</span>Headers: <span class=\"hljs-keyword\">function</span>(res){\n\tres.header( <span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>)\n}});\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-34\">修改路由的注册方式，通过遍历routes文件夹读取文件</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\">const fs =  require(<span class=\"hljs-string\">'fs'</span>)\nfs.readdirSync(<span class=\"hljs-string\">'./routes'</span>).forEach(route=> {\n    <span class=\"hljs-built_in\">let</span> api = require(`./routes/<span class=\"hljs-variable\">${route}</span>`)\n    app.use(api.routes(), api.allowedMethods())\n})\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-35\">添加jwt认证，同时过滤不需要认证的路由，如获取token</h3>\n<p>app.js</p>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\">const jwt = require(<span class=\"hljs-string\">'koa-jwt'</span>)\napp.use(jwt({ secret: <span class=\"hljs-string\">'yourstr'</span> }).unless({\n    path: [\n        /^\\/$/, /\\/token/, /\\/wechat/,\n        { url: /\\/papers/, methods: [<span class=\"hljs-string\">'GET'</span>] }\n    ]\n}));\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-36\">中间件实现统一接口返回数据格式，全局错误捕获并响应</h3>\n<p>middleware/formatresponse.js</p>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\">module.exports = async (ctx, next) => {\n\tawait next().then(() => {\n\t\t<span class=\"hljs-keyword\">if</span> (ctx.status === 200) {\n\t\t\tctx.body = {\n\t\t\t\tmessage: <span class=\"hljs-string\">'成功'</span>,\n\t\t\t\tcode: 200,\n\t\t\t\tbody: ctx.body,\n\t\t\t\tstatus: <span class=\"hljs-literal\">true</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ctx.status === 201) { // 201处理模板引擎渲染\n\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tctx.body = {\n\t\t\t\tmessage: ctx.body || <span class=\"hljs-string\">'接口异常，请重试'</span>,\n\t\t\t\tcode: ctx.status,\n\t\t\t\tbody: <span class=\"hljs-string\">'接口请求失败'</span>,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>\n\t\t\t}\n\t\t}\n\t}).catch((err) => {\n\t\t<span class=\"hljs-keyword\">if</span> (err.status === 401) {\n\t\t\tctx.status = 401;\n\t\t\tctx.body = {\n\t\t\t\tcode: 401,\n\t\t\t\tstatus: <span class=\"hljs-literal\">false</span>,\n\t\t\t\tmessage: <span class=\"hljs-string\">'登录过期，请重新登录'</span>\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tthrow err\n\t\t}\n\t})\n}\n\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-37\">koa2-cors跨域处理</h3>\n<p>当接口发布到线上，前端通过ajax请求时，会报跨域的错误。koa2使用koa2-cors这个库非常方便的实现了跨域配置，使用起来也很简单</p>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\">const cors = require(<span class=\"hljs-string\">'koa2-cors'</span>);\napp.use(cors());\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-38\">连接数据库</h3>\n<p>我们使用mongodb数据库，在koa2中使用mongoose这个库来管理整个数据库的操作。</p>\n<ul>\n<li>创建配置文件</li>\n</ul>\n<p>根目录下新建config文件夹，新建mongo.js</p>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\">// config/mongo.js\nconst mongoose = require(<span class=\"hljs-string\">'mongoose'</span>).set(<span class=\"hljs-string\">'debug'</span>, <span class=\"hljs-literal\">true</span>);\nconst options = {\n    autoReconnect: <span class=\"hljs-literal\">true</span>\n}\n\n// username 数据库用户名\n// password 数据库密码\n// localhost 数据库ip\n// dbname 数据库名称\nconst url = <span class=\"hljs-string\">'mongodb://username:password@localhost:27017/dbname'</span>\n\nmodule.exports = {\n    connect: ()=> {            \n        mongoose.connect(url,options)\n        <span class=\"hljs-built_in\">let</span> db = mongoose.connection\n        db.on(<span class=\"hljs-string\">'error'</span>, console.error.bind(console, <span class=\"hljs-string\">'连接错误:'</span>));\n        db.once(<span class=\"hljs-string\">'open'</span>, ()=> {\n            console.log(<span class=\"hljs-string\">'mongodb connect suucess'</span>);\n        })\n    }\n}\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><p>把mongodb配置信息放到config.json中统一管理</p>\n<ul>\n<li>然后在app.js中引入</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\">const mongoConf = require(<span class=\"hljs-string\">'./config/mongo'</span>);\nmongoConf.connect();\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><p>...\n<strong>服务端具体接口实现就不详细介绍了，就是对页面的增删改查，和用户的登录注册难度不大</strong></p>\n<h2 class=\"heading\" data-id=\"heading-39\">启动运行</h2>\n<h3 class=\"heading\" data-id=\"heading-40\">启动前端</h3>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\">npm run dev-client\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-41\">启动服务端</h3>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\">npm run dev-server\n<span class=\"copy-code-btn copy-056\">复制代码</span></code></pre><p>注意：\n如果没有生成过引擎模板js文件的，需要先编辑引擎模板，否则预览页面加载页面引擎.js 404报错</p>\n<h5 class=\"heading\" data-id=\"heading-42\">编译engine.js模板引擎</h5>\n<pre><code class=\"hljs bash copyable code-028\" lang=\"bash\">npm run lib:h5-swiper\n<span class=\"copy-code-btn copy-057\">复制代码</span></code></pre>",
      "id": "33nexc9y7fc0",
      "author": "围的围",
      "title": "Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5",
      "baseClassName": "article-content"
    },
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">前言</h1>\n<p>React 是前端三大框架之一,在开发中也是一项技能;<br>\n本文从实际开发中总结了 React 开发的一些技巧技巧,适合 React 初学或者有一定项目经验的同学<br>\n序列文章:<a target=\"_blank\" href=\"https://juejin.im/post/5d9d386fe51d45784d3f8637\" rel>Vue 开发必须知道的 36 个技巧【近1W字】</a></p>\n<h1 class=\"heading\" data-id=\"heading-1\">源码地址</h1>\n<p><a target=\"_blank\" href=\"https://github.com/lanzhsh/react-vue-koa/tree/master/react-pc-skill\" rel=\"nofollow noopener noreferrer\">请戳</a>， 欢迎 star</p>\n<p>效果图\n</p><figure><img alt=\"react 技巧.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e625a9389867dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"481\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"481\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-2\">1 组件通讯</h1>\n<h2 class=\"heading\" data-id=\"heading-3\">1.1 props</h2>\n<p>子组件</p>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">import React from <span class=\"hljs-string\">\"react\"</span>;\nimport PropTypes from <span class=\"hljs-string\">\"prop-types\"</span>;\nimport { Button } from <span class=\"hljs-string\">\"antd\"</span>;\n\n<span class=\"hljs-built_in\">export</span> default class EightteenChildOne extends React.Component {\n  static propTypes = { //propTypes校验传入类型,详情在技巧11\n    name: PropTypes.string\n  };\n\n  click = () => {\n    // 通过触发方法子传父\n    this.props.eightteenChildOneToFather(<span class=\"hljs-string\">\"这是 props 改变父元素的值\"</span>);\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>这是通过 props 传入的值{this.props.name}</div>\n        <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.click}>\n          点击改变父元素值\n        </Button>\n      </div>\n    );\n  }\n}\n\n<span class=\"copy-code-btn copy-079\">复制代码</span></code></pre><p>父组件</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\"><EightteenChildOne name={<span class=\"hljs-string\">'props 传入的 name 值'</span>} eightteenChildOneToFather={(mode)=>this.eightteenChildOneToFather(mode)}></EightteenChildOne> \n\n// 或者\n<EightteenChildOne name={<span class=\"hljs-string\">'props 传入的 name 值'</span>} eightteenChildOneToFather={this.eightteenChildOneToFather(this)}></EightteenChildOne> \n<span class=\"copy-code-btn copy-080\">复制代码</span></code></pre><p>props 传多个值时:<br>\n传统写法</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">const {dataOne,dataTwo,dataThree} = this.state\n<Com dataOne={dataOne} dataTwo={dataTwo} dataThree={dataThree}>\n<span class=\"copy-code-btn copy-081\">复制代码</span></code></pre><p>升级写法</p>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\"><Com {...{dataOne,dataTwo,dataThree}}>\n<span class=\"copy-code-btn copy-082\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-4\">1.2 props 升级版</h2>\n<p>原理:子组件里面利用 props 获取父组件方法直接调用,从而改变父组件的值<br>\n注意: 此方法和 props 大同小异,都是 props 的应用,所以在源码中没有举例</p>\n<p>调用父组件方法改变该值</p>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">// 父组件\nstate = {\n  count: {}\n}\nchangeParentState = obj => {\n    this.setState(obj);\n}\n// 子组件\nonClick = () => {\n    this.props.changeParentState({ count: 2 });\n}\n<span class=\"copy-code-btn copy-083\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">1.3 Provider,Consumer和Context</h2>\n<p>1.Context在 16.x 之前是定义一个全局的对象,类似 vue 的 eventBus,如果组件要使用到该值直接通过this.context获取</p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">//根组件\nclass MessageList extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span></span>() {\n    <span class=\"hljs-built_in\">return</span> {color: <span class=\"hljs-string\">\"purple\"</span>,text: <span class=\"hljs-string\">\"item text\"</span>};\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const {messages} = this.props || {}\n    const children = messages && messages.map((message) =>\n      <Message text={message.text} />\n    );\n    <span class=\"hljs-built_in\">return</span> <div>{children}</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: React.PropTypes.string\n  text: React.PropTypes.string\n};\n\n//中间组件\nclass Message extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <MessageItem />\n        <Button>Delete</Button>\n      </div>\n    );\n  }\n}\n\n//孙组件(接收组件)\nclass MessageItem extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        {this.context.text}\n      </div>\n    );\n  }\n}\n\nMessageItem.contextTypes = {\n  text: React.PropTypes.string //React.PropTypes在 15.5 版本被废弃,看项目实际的 React 版本\n};\n\nclass Button extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: React.PropTypes.string\n};\n<span class=\"copy-code-btn copy-084\">复制代码</span></code></pre><p>2.16.x 之后的Context使用了Provider和Customer模式,在顶层的Provider中传入value，在子孙级的Consumer中获取该值，并且能够传递函数，用来修改context\n声明一个全局的 context 定义,context.js</p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">import React from <span class=\"hljs-string\">'react'</span>\n<span class=\"hljs-built_in\">let</span> { Consumer, Provider } = React.createContext();//创建 context 并暴露Consumer和Provider模式\n<span class=\"hljs-built_in\">export</span> {\n    Consumer,\n    Provider\n}\n<span class=\"copy-code-btn copy-085\">复制代码</span></code></pre><p>父组件导入</p>\n<pre><code class=\"hljs bash copyable code-07\" lang=\"bash\">// 导入 Provider\nimport {Provider} from <span class=\"hljs-string\">\"../../utils/context\"</span>\n\n<Provider value={name}>\n  <div style={{border:<span class=\"hljs-string\">'1px solid red'</span>,width:<span class=\"hljs-string\">'30%'</span>,margin:<span class=\"hljs-string\">'50px auto'</span>,textAlign:<span class=\"hljs-string\">'center'</span>}}>\n    <p>父组件定义的值:{name}</p>\n    <EightteenChildTwo></EightteenChildTwo>\n  </div>\n</Provider>\n<span class=\"copy-code-btn copy-086\">复制代码</span></code></pre><p>子组件</p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">// 导入Consumer\nimport { Consumer } from <span class=\"hljs-string\">\"../../utils/context\"</span>\n<span class=\"hljs-keyword\">function</span> Son(props) {\n  <span class=\"hljs-built_in\">return</span> (\n    //Consumer容器,可以拿到上文传递下来的name属性,并可以展示对应的值\n    <Consumer>\n      {name => (\n        <div\n          style={{\n            border: <span class=\"hljs-string\">\"1px solid blue\"</span>,\n            width: <span class=\"hljs-string\">\"60%\"</span>,\n            margin: <span class=\"hljs-string\">\"20px auto\"</span>,\n            textAlign: <span class=\"hljs-string\">\"center\"</span>\n          }}\n        >\n        // 在 Consumer 中可以直接通过 name 获取父组件的值\n          <p>子组件。获取父组件的值:{name}</p>\n        </div>\n      )}\n    </Consumer>\n  );\n}\n<span class=\"hljs-built_in\">export</span> default Son;\n<span class=\"copy-code-btn copy-087\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-6\">1.4 EventEmitter</h2>\n<p><a target=\"_blank\" href=\"https://segmentfault.com/a/1190000012361461?utm_source=tag-newest#articleHeader6\" rel=\"nofollow noopener noreferrer\">EventEmiter 传送门</a>\n使用 events 插件定义一个全局的事件机制</p>\n<h2 class=\"heading\" data-id=\"heading-7\">1.5 路由传参</h2>\n<p>1.params</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\"><Route path=<span class=\"hljs-string\">'/path/:name'</span> component={Path}/>\n<link to=<span class=\"hljs-string\">\"/path/2\"</span>>xxx</Link>\nthis.props.history.push({pathname:<span class=\"hljs-string\">\"/path/\"</span> + name});\n读取参数用:this.props.match.params.name\n<span class=\"copy-code-btn copy-088\">复制代码</span></code></pre><p>2.query</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\"><Route path=<span class=\"hljs-string\">'/query'</span> component={Query}/>\n<Link to={{ path : <span class=\"hljs-string\">'/query'</span> , query : { name : <span class=\"hljs-string\">'sunny'</span> }}}>\nthis.props.history.push({pathname:<span class=\"hljs-string\">\"/query\"</span>,query: { name : <span class=\"hljs-string\">'sunny'</span> }});\n读取参数用: this.props.location.query.name\n<span class=\"copy-code-btn copy-089\">复制代码</span></code></pre><p>3.state</p>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\"><Route path=<span class=\"hljs-string\">'/sort '</span> component={Sort}/>\n<Link to={{ path : <span class=\"hljs-string\">'/sort '</span> , state : { name : <span class=\"hljs-string\">'sunny'</span> }}}> \nthis.props.history.push({pathname:<span class=\"hljs-string\">\"/sort \"</span>,state : { name : <span class=\"hljs-string\">'sunny'</span> }});\n读取参数用: this.props.location.query.state \n<span class=\"copy-code-btn copy-090\">复制代码</span></code></pre><p>4.search</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\"><Route path=<span class=\"hljs-string\">'/web/search '</span> component={Search}/>\n<link to=<span class=\"hljs-string\">\"web/search?id=12121212\"</span>>xxx</Link>\nthis.props.history.push({pathname:`/web/search?id <span class=\"hljs-variable\">${row.id}</span>`});\n读取参数用: this.props.location.search\n<span class=\"copy-code-btn copy-091\">复制代码</span></code></pre><p>5.优缺点</p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">1.params和 search 只能传字符串,刷新页面参数不会丢\n2.query和 state 可以传对象,但是刷新页面参数会丢失\n<span class=\"copy-code-btn copy-092\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-8\">1.6 onRef</h2>\n<p>原理:onRef 通讯原理就是通过 props 的事件机制将组件的 this(组件实例)当做参数传到父组件,父组件就可以操作子组件的 state 和方法</p>\n<p>EightteenChildFour.jsx</p>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class EightteenChildFour extends React.Component {\n  state={\n      name:<span class=\"hljs-string\">'这是组件EightteenChildFour的name 值'</span>\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>(){\n    this.props.onRef(this)\n    console.log(this) // ->将EightteenChildFour传递给父组件this.props.onRef()方法\n  }\n\n  click = () => {\n    this.setState({name:<span class=\"hljs-string\">'这是组件click 方法改变EightteenChildFour改变的name 值'</span>})\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>{this.state.name}</div>\n        <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.click}>\n          点击改变组件EightteenChildFour的name 值\n        </Button>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-093\">复制代码</span></code></pre><p>eighteen.jsx</p>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\"><EightteenChildFour onRef={this.eightteenChildFourRef}></EightteenChildFour>\n\neightteenChildFourRef = (ref)=>{\n  console.log(<span class=\"hljs-string\">'eightteenChildFour的Ref值为'</span>)\n  // 获取的 ref 里面包括整个组件实例\n  console.log(ref)\n  // 调用子组件方法\n  ref.click()\n}\n<span class=\"copy-code-btn copy-094\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-9\">1.7 ref</h2>\n<p>原理:就是通过 React 的 ref 属性获取到整个子组件实例,再进行操作</p>\n<p>EightteenChildFive.jsx</p>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\">// 常用的组件定义方法\n<span class=\"hljs-built_in\">export</span> default class EightteenChildFive extends React.Component {\n  state={\n      name:<span class=\"hljs-string\">'这是组件EightteenChildFive的name 值'</span>\n  }\n\n  click = () => {\n    this.setState({name:<span class=\"hljs-string\">'这是组件click 方法改变EightteenChildFive改变的name 值'</span>})\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>{this.state.name}</div>\n        <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.click}>\n          点击改变组件EightteenChildFive的name 值\n        </Button>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-095\">复制代码</span></code></pre><p>eighteen.jsx</p>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\">// 钩子获取实例\n<span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>(){\n    console.log(<span class=\"hljs-string\">'eightteenChildFive的Ref值为'</span>)\n      // 获取的 ref 里面包括整个组件实例,同样可以拿到子组件的实例\n    console.log(this.refs[<span class=\"hljs-string\">\"eightteenChildFiveRef\"</span>])\n  }\n\n// 组件定义 ref 属性\n<EightteenChildFive ref=<span class=\"hljs-string\">\"eightteenChildFiveRef\"</span>></EightteenChildFive>\n<span class=\"copy-code-btn copy-096\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-10\">1.8 redux</h2>\n<p>redux 是一个独立的事件通讯插件,这里就不做过多的叙述\n<a target=\"_blank\" href=\"https://www.redux.org.cn/docs/introduction/CoreConcepts.html\" rel=\"nofollow noopener noreferrer\">请戳传送门:</a></p>\n<h2 class=\"heading\" data-id=\"heading-11\">1.9 MobX</h2>\n<p>MobX 也是一个独立的事件通讯插件,这里就不做过多的叙述<br>\n<a target=\"_blank\" href=\"https://cn.mobx.js.org/\" rel=\"nofollow noopener noreferrer\">请戳传送门:</a></p>\n<h2 class=\"heading\" data-id=\"heading-12\">1.10 flux</h2>\n<p>flux 也是一个独立的事件通讯插件,这里就不做过多的叙述<br>\n<a target=\"_blank\" href=\"https://facebook.github.io/flux/docs/flux-utils#!\" rel=\"nofollow noopener noreferrer\">请戳传送门:</a></p>\n<h2 class=\"heading\" data-id=\"heading-13\">1.11 hooks</h2>\n<p>1.hooks 是利用 userReducer 和 context 实现通讯,下面模拟实现一个简单的 redux<br>\n2.核心文件分为 action,reducer,types<br>\naction.js</p>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\">import * as Types from <span class=\"hljs-string\">'./types'</span>;\n\n<span class=\"hljs-built_in\">export</span> const onChangeCount = count => ({\n    <span class=\"hljs-built_in\">type</span>: Types.EXAMPLE_TEST,\n    count: count + 1\n})\n<span class=\"copy-code-btn copy-097\">复制代码</span></code></pre><p>reducer.js</p>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">import * as Types from <span class=\"hljs-string\">\"./types\"</span>;\n<span class=\"hljs-built_in\">export</span> const defaultState = {\n  count: 0\n};\n<span class=\"hljs-built_in\">export</span> default (state, action) => {\n  switch (action.type) {\n    <span class=\"hljs-keyword\">case</span> Types.EXAMPLE_TEST:\n      <span class=\"hljs-built_in\">return</span> {\n        ...state,\n        count: action.count\n      };\n    default: {\n      <span class=\"hljs-built_in\">return</span> state;\n    }\n  }\n};\n<span class=\"copy-code-btn copy-098\">复制代码</span></code></pre><p>types.js</p>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const EXAMPLE_TEST = <span class=\"hljs-string\">'EXAMPLE_TEST'</span>;\n<span class=\"copy-code-btn copy-099\">复制代码</span></code></pre><p>eightteen.jsx</p>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const ExampleContext = React.createContext(null);//创建createContext上下文\n\n// 定义组件\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">ReducerCom</span></span>() {\n  const [exampleState, exampleDispatch] = useReducer(example, defaultState);\n\n  <span class=\"hljs-built_in\">return</span> (\n    <ExampleContext.Provider\n      value={{ exampleState, dispatch: exampleDispatch }}\n    >\n      <EightteenChildThree></EightteenChildThree>\n    </ExampleContext.Provider>\n  );\n}\n<span class=\"copy-code-btn copy-0100\">复制代码</span></code></pre><p>EightteenChildThree.jsx // 组件</p>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\">import React, {  useEffect, useContext } from <span class=\"hljs-string\">'react'</span>;\nimport {Button} from <span class=\"hljs-string\">'antd'</span>\n\nimport {onChangeCount} from <span class=\"hljs-string\">'../../pages/TwoTen/store/action'</span>;\nimport { ExampleContext } from <span class=\"hljs-string\">'../../pages/TwoTen/eighteen'</span>;\n\nconst Example = () => {\n\n    const exampleContext = useContext(ExampleContext);\n\n    useEffect(() => { // 监听变化\n        console.log(<span class=\"hljs-string\">'变化执行啦'</span>)\n    }, [exampleContext.exampleState.count]);\n\n    <span class=\"hljs-built_in\">return</span> (\n        <div>\n            <p>值为{exampleContext.exampleState.count}</p>\n            <Button onClick={() => exampleContext.dispatch(onChangeCount(exampleContext.exampleState.count))}>点击加 1</Button>\n        </div>\n    )\n}\n\n<span class=\"hljs-built_in\">export</span> default Example;\n<span class=\"copy-code-btn copy-0101\">复制代码</span></code></pre><p>3.hooks其实就是对原有React 的 API 进行了封装,暴露比较方便使用的钩子;</p>\n<p>4.钩子有:</p>\n<table>\n<thead>\n<tr>\n<th>钩子名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>useState</td>\n<td>初始化和设置状态</td>\n</tr>\n<tr>\n<td>useEffect</td>\n<td>componentDidMount，componentDidUpdate和componentWillUnmount和结合体,所以可以监听useState定义值的变化</td>\n</tr>\n<tr>\n<td>useContext</td>\n<td>定义一个全局的对象,类似 context</td>\n</tr>\n<tr>\n<td>useReducer</td>\n<td>可以增强函数提供类似 Redux 的功能</td>\n</tr>\n<tr>\n<td>useCallback</td>\n<td>记忆作用,共有两个参数，第一个参数为一个匿名函数，就是我们想要创建的函数体。第二参数为一个数组，里面的每一项是用来判断是否需要重新创建函数体的变量，如果传入的变量值保持不变，返回记忆结果。如果任何一项改变，则返回新的结果</td>\n</tr>\n<tr>\n<td>useMemo</td>\n<td>作用和传入参数与 useCallback 一致,useCallback返回函数,useDemo 返回值</td>\n</tr>\n<tr>\n<td>useRef</td>\n<td>获取 ref 属性对应的 dom</td>\n</tr>\n<tr>\n<td>useImperativeMethods</td>\n<td>自定义使用ref时公开给父组件的实例值</td>\n</tr>\n<tr>\n<td>useMutationEffect</td>\n<td>作用与useEffect相同，但在更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</td>\n</tr>\n<tr>\n<td>useLayoutEffect</td>\n<td>作用与useEffect相同，但在所有DOM改变后同步触发</td>\n</tr>\n</tbody>\n</table>\n<p>5.useImperativeMethods</p>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeMethods(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  <span class=\"hljs-built_in\">return</span> <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n<span class=\"copy-code-btn copy-0102\">复制代码</span></code></pre><p>更多hooks 介绍请戳</p>\n<h2 class=\"heading\" data-id=\"heading-14\">1.12 对比</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>props</td>\n<td>不需要引入外部插件</td>\n<td>兄弟组件通讯需要建立共同父级组件,麻烦</td>\n</tr>\n<tr>\n<td>props 升级版</td>\n<td>不需要引入外部插件,子传父,不需要在父组件用方法接收</td>\n<td>同 props</td>\n</tr>\n<tr>\n<td>Provider,Consumer和Context</td>\n<td>不需要引入外部插件,跨多级组件或者兄弟组件通讯利器</td>\n<td>状态数据状态追踪麻烦</td>\n</tr>\n<tr>\n<td>EventEmitter</td>\n<td>可支持兄弟,父子组件通讯</td>\n<td>要引入外部插件</td>\n</tr>\n<tr>\n<td>路由传参</td>\n<td>可支持兄弟组件传值,页面简单数据传递非常方便</td>\n<td>父子组件通讯无能为力</td>\n</tr>\n<tr>\n<td>onRef</td>\n<td>可以在获取整个子组件实例,使用简单</td>\n<td>兄弟组件通讯麻烦,官方不建议使用</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>同 onRef</td>\n<td>同 onRef</td>\n</tr>\n<tr>\n<td>redux</td>\n<td>建立了全局的状态管理器,兄弟父子通讯都可解决</td>\n<td>引入了外部插件</td>\n</tr>\n<tr>\n<td>mobx</td>\n<td>建立了全局的状态管理器,兄弟父子通讯都可解决</td>\n<td>引入了外部插件</td>\n</tr>\n<tr>\n<td>flux</td>\n<td>建立了全局的状态管理器,兄弟父子通讯都可解决</td>\n<td>引入了外部插件</td>\n</tr>\n<tr>\n<td>hooks</td>\n<td>16.x 新的属性,可支持兄弟,父子组件通讯</td>\n<td>需要结合 context 一起使用</td>\n</tr>\n</tbody>\n</table>\n<p>redux , mobx和flux对比</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redux</td>\n<td>1.核心模块:Action,Reducer,Store;2. Store 和更改逻辑是分开的;3. 只有一个 Store;4. 带有分层 reducer 的单一 Store;5. 没有调度器的概念;6. 容器组件是有联系的;7. 状态是不可改变的;8.更多的是遵循函数式编程思想</td>\n</tr>\n<tr>\n<td>mobx</td>\n<td>1.核心模块:Action,Reducer,Derivation;2.有多个 store;3.设计更多偏向于面向对象编程和响应式编程，通常将状态包装成可观察对象，一旦状态对象变更，就能自动获得更新</td>\n</tr>\n<tr>\n<td>flux</td>\n<td>1.核心模块:Store,ReduceStore,Container;2.有多个 store;</td>\n</tr>\n</tbody>\n</table>\n<h1 class=\"heading\" data-id=\"heading-15\">2.require.context()</h1>\n<p>这个是 webpack 的 api,这个在 vue 技巧中有介绍,因为 Vue 和 React 工程都是基于 webpack打包,所以在 react 也可以使用</p>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\">const path = require(<span class=\"hljs-string\">'path'</span>)\nconst files = require.context(<span class=\"hljs-string\">'@/components/home'</span>, <span class=\"hljs-literal\">false</span>, /\\.vue$/)\nconst modules = {}\nfiles.keys().forEach(key => {\n  const name = path.basename(key, <span class=\"hljs-string\">'.vue'</span>)\n  modules[name] = files(key).default || files(key)\n})\n\n<span class=\"copy-code-btn copy-0103\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-16\">3.Decorator</h1>\n<p>定义:decorator是ES7的一个新特性，可以修改class的属性</p>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\">import React from <span class=\"hljs-string\">'react'</span>\nimport Test from <span class=\"hljs-string\">'../../utils/decorators'</span>\n\n@Test\n//只要Decorator后面是Class，默认就已经把Class当成参数隐形传进Decorator了。\nclass TwentyNine extends React.Component{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>(){\n        console.log(this,<span class=\"hljs-string\">'decorator.js'</span>) // 这里的this是类的一个实例\n        console.log(this.testable)\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n        <span class=\"hljs-built_in\">return</span> (\n            <div>这是技巧23</div>\n        )\n    }\n}\n\n<span class=\"hljs-built_in\">export</span> default TwentyNine\n<span class=\"copy-code-btn copy-0104\">复制代码</span></code></pre><p>decorators.js</p>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> testable(target) {\n  console.log(target)\n  target.isTestable = <span class=\"hljs-literal\">true</span>;\n  target.prototype.getDate = ()=>{\n    console.log( new Date() )\n  }\n}\n\n<span class=\"hljs-built_in\">export</span> default testable\n<span class=\"copy-code-btn copy-0105\">复制代码</span></code></pre><p>很多中间件,像 redux 里面就封装了Decorator的使用</p>\n<h1 class=\"heading\" data-id=\"heading-17\">4.使用 if...else</h1>\n<p>场景:有些时候需要根据不同状态值页面显示不同内容</p>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\">import React from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-built_in\">export</span> default class Four extends React.Component {\n  state = {\n    count: 1\n  };\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">let</span> info\n    <span class=\"hljs-keyword\">if</span>(this.state.count===0){\n      info=(\n        <span>这是数量为 0 显示</span>\n      )\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(this.state.count===1){\n      info=(\n        <span>这是数量为 1 显示</span>\n      )\n    }\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        {info}\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0106\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-18\">5.state 值改变的五种方式</h1>\n<p>方式 1</p>\n<pre><code class=\"hljs bash copyable code-028\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> {count} = this.state\nthis.setState({count:2})\n<span class=\"copy-code-btn copy-0107\">复制代码</span></code></pre><p>方式 2:callBack</p>\n<pre><code class=\"hljs bash copyable code-029\" lang=\"bash\">this.setState(({count})=>({count:count+2}))\n<span class=\"copy-code-btn copy-0108\">复制代码</span></code></pre><p>方式 3:接收 state 和 props 参数</p>\n<pre><code class=\"hljs bash copyable code-030\" lang=\"bash\">this.setState((state, props) => {\n    <span class=\"hljs-built_in\">return</span> { count: state.count + props.step };\n});\n<span class=\"copy-code-btn copy-0109\">复制代码</span></code></pre><p>方式 4:hooks</p>\n<pre><code class=\"hljs bash copyable code-031\" lang=\"bash\">const [count, <span class=\"hljs-built_in\">set</span>Count] = useState(0)\n// 设置值\n<span class=\"hljs-built_in\">set</span>Count(count+2)\n<span class=\"copy-code-btn copy-0110\">复制代码</span></code></pre><p>方式 5:state 值改变后调用</p>\n<pre><code class=\"hljs bash copyable code-032\" lang=\"bash\">this.setState(\n    {count:3},()=>{\n        //得到结果做某种事\n    }\n)\n<span class=\"copy-code-btn copy-0111\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-19\">6.监听states 变化</h1>\n<p>1.16.x 之前使用componentWillReveiveProps</p>\n<pre><code class=\"hljs bash copyable code-033\" lang=\"bash\">componentWillReceiveProps (nextProps){\n  <span class=\"hljs-keyword\">if</span>(this.props.visible !== nextProps.visible){\n      //props 值改变做的事\n  }\n}\n<span class=\"copy-code-btn copy-0112\">复制代码</span></code></pre><p>注意:有些时候componentWillReceiveProps在 props 值未变化也会触发,因为在生命周期的第一次render后不会被调用，但是会在之后的每次render中被调用 = 当父组件再次传送props</p>\n<p>2.16.x 之后使用getDerivedStateFromProps,16.x 以后componentWillReveiveProps也未移除</p>\n<pre><code class=\"hljs bash copyable code-034\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Six extends React.Component {\n  state = {\n    countOne:1,\n    changeFlag:<span class=\"hljs-string\">''</span>\n  };\n  <span class=\"hljs-function\"><span class=\"hljs-title\">clickOne</span></span>(){\n    <span class=\"hljs-built_in\">let</span> {countOne} = this.state\n    this.setState({countOne:countOne+1})\n  };\n  static getDerivedStateFromProps (nextProps){\n    console.log(<span class=\"hljs-string\">'变化执行'</span>)\n    <span class=\"hljs-built_in\">return</span>{\n      changeFlag:<span class=\"hljs-string\">'state 值变化执行'</span>\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const {countOne,changeFlag} = this.state\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>\n         <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.clickOne.bind(this)}>点击加 1</Button><span>countOne 值为{countOne}</span>\n        <div>{changeFlag}</div>\n        </div>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0113\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-20\">7.组件定义方法</h1>\n<p>方式 1:ES5 的Function 定义</p>\n<pre><code class=\"hljs bash copyable code-035\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> FunCom(props){\n  <span class=\"hljs-built_in\">return</span> <div>这是Function 定义的组件</div>\n}\nReactDOM.render(<FunCom name=<span class=\"hljs-string\">\"Sebastian\"</span> />, mountNode)\n\n// 在 hooks 未出来之前,这个是定义无状态组件的方法,现在有了 hooks 也可以处理状态\n<span class=\"copy-code-btn copy-0114\">复制代码</span></code></pre><p>方式 2: ES5的 createClass 定义</p>\n<pre><code class=\"hljs bash copyable code-036\" lang=\"bash\">const CreateClassCom = React.createClass({\n  render: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n  <span class=\"hljs-built_in\">return</span> <div>这是React.createClass定义的组件</div>\n  }\n});\n<span class=\"copy-code-btn copy-0115\">复制代码</span></code></pre><p>方式 3:ES6 的 extends</p>\n<pre><code class=\"hljs bash copyable code-037\" lang=\"bash\">class Com extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n    <span class=\"hljs-built_in\">return</span>(<div>这是React.Component定义的组件</div>)\n  }\n}\n<span class=\"copy-code-btn copy-0116\">复制代码</span></code></pre><p>调用</p>\n<pre><code class=\"hljs bash copyable code-038\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Seven extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <FunCom></FunCom>\n        <Com></Com>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0117\">复制代码</span></code></pre><p>区别: ES5的 createClass是利用function模拟class的写法做出来的es6;\n通过es6新增class的属性创建的组件此组件创建简单.</p>\n<h1 class=\"heading\" data-id=\"heading-21\">8.通过 ref 属性获取 component</h1>\n<p>方式 1:也是最早的用法,通过 this.refs[属性名获取]\n也可以作用到组件上,从而拿到组件实例</p>\n<pre><code class=\"hljs bash copyable code-039\" lang=\"bash\">class RefOne extends React.Component{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>() {\n    this.refs[<span class=\"hljs-string\">'box'</span>].innerHTML=<span class=\"hljs-string\">'这是 div 盒子,通过 ref 获取'</span>\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n    <span class=\"hljs-built_in\">return</span>(\n      <div ref=<span class=\"hljs-string\">\"box\"</span>></div>\n    )\n  }\n}\n<span class=\"copy-code-btn copy-0118\">复制代码</span></code></pre><p>方式 2:回调函数,在dom节点或组件上挂载函数，函数的入参是dom节点或组件实例，达到的效果与字符串形式是一样的，都是获取其引用</p>\n<pre><code class=\"hljs bash copyable code-040\" lang=\"bash\">class RefTwo extends React.Component{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>() {\n    this.input.value=<span class=\"hljs-string\">'这是输入框默认值'</span>;\n    this.input.focus();\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n    <span class=\"hljs-built_in\">return</span>(\n      <input ref={comp => { this.input = comp; }}/>\n    )\n  }\n}\n<span class=\"copy-code-btn copy-0119\">复制代码</span></code></pre><p>方式 3:React.createRef()\nReact 16.3版本后，使用此方法来创建ref。将其赋值给一个变量，通过ref挂载在dom节点或组件上，该ref的current属性,将能拿到dom节点或组件的实例</p>\n<pre><code class=\"hljs bash copyable code-041\" lang=\"bash\">class RefThree extends React.Component{\n  constructor(props){\n    super(props);\n    this.myRef=React.createRef();\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>(){\n    console.log(this.myRef.current);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n    <span class=\"hljs-built_in\">return</span> <input ref={this.myRef}/>\n  }\n}\n<span class=\"copy-code-btn copy-0120\">复制代码</span></code></pre><p>方式 4:React.forwardRef<br>\nReact 16.3版本后提供的，可以用来创建子组件，以传递ref</p>\n<pre><code class=\"hljs bash copyable code-042\" lang=\"bash\">class RefFour extends React.Component{\n  constructor(props){\n    super(props);\n    this.myFourRef=React.createRef();\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>(){\n    console.log(this.myFourRef.current);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n    <span class=\"hljs-built_in\">return</span> <Child ref={this.myFourRef}/>\n  }\n}\n<span class=\"copy-code-btn copy-0121\">复制代码</span></code></pre><p>子组件通过React.forwardRef来创建，可以将ref传递到内部的节点或组件，进而实现跨层级的引用。forwardRef在高阶组件中可以获取到原始组件的实例.这个功能在技巧 18 会着重讲</p>\n<h1 class=\"heading\" data-id=\"heading-22\">9.static 使用</h1>\n<p>场景:声明静态方法的关键字,静态方法是指即使没有组件实例也可以直接调用</p>\n<pre><code class=\"hljs bash copyable code-043\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Nine extends React.Component {\n  static update(data) {\n    console.log(<span class=\"hljs-string\">'静态方法调用执行啦'</span>)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        这是 static 关键字技能\n      </div>\n    );\n  }\n}\n\nNine.update(<span class=\"hljs-string\">'2'</span>)\n<span class=\"copy-code-btn copy-0122\">复制代码</span></code></pre><p>注意:\n1.ES6的class，我们定义一个组件的时候通常是定义了一个类，而static则是创建了一个属于这个类的属性或者方法<br>\n2.组件则是这个类的一个实例，component的props和state是属于这个实例的，所以实例还未创建<br>\n3.所以static并不是react定义的，而加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用,所以也是无法访问到 this<br>\n4.getDerivedStateFromProps也是通过静态方法监听值,详情请见技巧 6</p>\n<h1 class=\"heading\" data-id=\"heading-23\">10.constructor和super</h1>\n<p>回顾:<br>\n1.谈这两个属性之前,先回顾一下ES6 函数定义方法<br>\n2.每一个使用class方式定义的类默认都有一个constructor函数， 这个函数是构造函数的主函数， 该函数体内部的this指向生成的实例<br>\n3.super关键字用于访问和调用一个对象的父对象上的函数</p>\n<pre><code class=\"hljs bash copyable code-044\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Ten extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span></span>() { // class 的主函数\n    super() // React.Component.prototype.constructor.call(this),其实就是拿到父类的属性和方法\n    this.state = {\n      arr:[]\n    }\n  }  \n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        这是技巧 10\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0123\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-24\">11.PropTypes</h1>\n<p>场景:检测传入子组件的数据类型<br>\n类型检查PropTypes自React v15.5起已弃用，请使用prop-types<br>\n方式 1:旧的写法</p>\n<pre><code class=\"hljs bash copyable code-045\" lang=\"bash\">class PropTypeOne extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>{this.props.email}</div>\n        <div>{this.props.name}</div>\n      </div>\n    );\n  }\n}\n\nPropTypeOne.propTypes = {\n  name: PropTypes.string, //值可为array,bool,func,number,object,symbol\n  email: <span class=\"hljs-keyword\">function</span>(props, propName, componentName) { //自定义校验\n    <span class=\"hljs-keyword\">if</span> (\n      !/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/.test(\n        props[propName]\n      )\n    ) {\n      <span class=\"hljs-built_in\">return</span> new Error(\n        <span class=\"hljs-string\">\"组件\"</span> + componentName + <span class=\"hljs-string\">\"里的属性\"</span> + propName + <span class=\"hljs-string\">\"不符合邮箱的格式\"</span>\n      );\n    }\n  },\n};\n<span class=\"copy-code-btn copy-0124\">复制代码</span></code></pre><p>方法 2:利用 ES7 的静态属性关键字 static</p>\n<pre><code class=\"hljs bash copyable code-046\" lang=\"bash\">class PropTypeTwo extends React.Component {\n  static propTypes = {\n      name:PropTypes.string\n  };\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div>{this.props.name}</div>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0125\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-25\">12.使用类字段声明语法</h1>\n<p>场景:可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定</p>\n<pre><code class=\"hljs bash copyable code-047\" lang=\"bash\">class Counter extends Component {\n  state = { value: 0 };\n\n  handleIncrement = () => {\n    this.setState(prevState => ({\n      value: prevState.value + 1\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState(prevState => ({\n      value: prevState.value - 1\n    }));\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        {this.state.value}\n\n        <button onClick={this.handleIncrement}>+</button>\n        <button onClick={this.handleDecrement}>-</button>\n      </div>\n    )\n  }\n}\n<span class=\"copy-code-btn copy-0126\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-26\">13.异步组件</h1>\n<p>1.场景:路由切换,如果同步加载多个页面路由会导致缓慢</p>\n<p>2.核心 API:<br>\nloader:需要加载的组件<br>\nloading:未加载出来的页面展示组件<br>\ndelay:延迟加载时间<br>\ntimeout:超时时间</p>\n<p>3.使用方法:<br>\n安装 react-loadable ,babel插件安装 syntax-dynamic-import. react-loadable是通过webpack的异步import实现的</p>\n<pre><code class=\"hljs bash copyable code-048\" lang=\"bash\">const Loading = () => {\n  <span class=\"hljs-built_in\">return</span> <div>loading</div>;\n};\n\nconst LoadableComponent = Loadable({\n  loader: () => import(<span class=\"hljs-string\">\"../../components/TwoTen/thirteen\"</span>),\n  loading: Loading\n});\n\n<span class=\"hljs-built_in\">export</span> default class Thirteen extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> <LoadableComponent></LoadableComponent>;\n  }\n}\n<span class=\"copy-code-btn copy-0127\">复制代码</span></code></pre><p>4.Loadable.Map()<br>\n并行加载多个资源的高阶组件</p>\n<h1 class=\"heading\" data-id=\"heading-27\">14.动态组件</h1>\n<p>场景:做一个 tab 切换时就会涉及到组件动态加载<br>\n实质上是利用三元表达式判断组件是否显示</p>\n<pre><code class=\"hljs bash copyable code-049\" lang=\"bash\">class FourteenChildOne extends React.Component {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n        <span class=\"hljs-built_in\">return</span> <div>这是动态组件 1</div>;\n    }\n}\n\nclass FourteenChildTwo extends React.Component {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n        <span class=\"hljs-built_in\">return</span> <div>这是动态组件 2</div>;\n    }\n}\n\n<span class=\"hljs-built_in\">export</span> default class Fourteen extends React.Component {\n  state={\n      oneShowFlag:<span class=\"hljs-literal\">true</span>\n  }\n  tab=()=>{\n      this.setState({oneShowFlag:!this.state.oneShowFlag})\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const {oneShowFlag} = this.state\n    <span class=\"hljs-built_in\">return</span> (<div>\n        <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.tab}>显示组件{oneShowFlag?2:1}</Button>\n        {oneShowFlag?<FourteenChildOne></FourteenChildOne>:<FourteenChildTwo></FourteenChildTwo>}\n    </div>);\n  }\n}\n<span class=\"copy-code-btn copy-0128\">复制代码</span></code></pre><p>如果是单个组件是否显示可以用短路运算</p>\n<pre><code class=\"hljs bash copyable code-050\" lang=\"bash\">oneShowFlag&&<FourteenChildOne></FourteenChildOne>\n<span class=\"copy-code-btn copy-0129\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-28\">15.递归组件</h1>\n<p>场景:tree组件<br>\n利用React.Fragment或者 div 包裹循环</p>\n<pre><code class=\"hljs bash copyable code-051\" lang=\"bash\">class Item extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const list = this.props.children || [];\n    <span class=\"hljs-built_in\">return</span> (\n      <div className=<span class=\"hljs-string\">\"item\"</span>>\n        {list.map((item, index) => {\n          <span class=\"hljs-built_in\">return</span> (\n            <React.Fragment key={index}>\n              <h3>{item.name}</h3>\n              {// 当该节点还有children时，则递归调用本身\n              item.children && item.children.length ? (\n                <Item>{item.children}</Item>\n              ) : null}\n            </React.Fragment>\n          );\n        })}\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0130\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-29\">16.受控组件和不受控组件</h1>\n<p>受控组件:组件拥有自己的状态</p>\n<pre><code class=\"hljs bash copyable code-052\" lang=\"bash\">class Controll extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span></span>() {\n    super();\n    this.state = { value: <span class=\"hljs-string\">\"这是受控组件默认值\"</span> };\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> <div>{this.state.value}</div>;\n  }\n}\n<span class=\"copy-code-btn copy-0131\">复制代码</span></code></pre><p>不受控组件:组件无自己的状态,在父组件通过 ref 来控制或者通过 props 传值</p>\n<pre><code class=\"hljs bash copyable code-053\" lang=\"bash\">class NoControll extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> <div>{this.props.value}</div>;\n  }\n}\n<span class=\"copy-code-btn copy-0132\">复制代码</span></code></pre><p>导入代码:</p>\n<pre><code class=\"hljs bash copyable code-054\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Sixteen extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>() {\n    console.log(<span class=\"hljs-string\">\"ref 获取的不受控组件值为\"</span>, this.refs[<span class=\"hljs-string\">\"noControll\"</span>]);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <Controll></Controll>\n        <NoControll\n          value={<span class=\"hljs-string\">\"这是不受控组件传入值\"</span>}\n          ref=<span class=\"hljs-string\">\"noControll\"</span>\n        ></NoControll>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0133\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-30\">17.高阶组件</h1>\n<h2 class=\"heading\" data-id=\"heading-31\">17.1 定义</h2>\n<p>就是类似高阶函数的定义,将组件作为参数或者返回一个组件的组件</p>\n<h2 class=\"heading\" data-id=\"heading-32\">17.2 实现方法</h2>\n<p>1.属性代理</p>\n<pre><code class=\"hljs bash copyable code-055\" lang=\"bash\">import React,{Component} from <span class=\"hljs-string\">'react'</span>;\n\nconst Seventeen = WrappedComponent =>\n  class extends React.Component {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n      const props = {\n        ...this.props,\n        name: <span class=\"hljs-string\">\"这是高阶组件\"</span>\n      };\n      <span class=\"hljs-built_in\">return</span> <WrappedComponent {...props} />;\n    }\n  };\n\nclass WrappedComponent extends React.Component {\n  state={\n     baseName:<span class=\"hljs-string\">'这是基础组件'</span> \n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const {baseName} = this.state\n    const {name} = this.props\n    <span class=\"hljs-built_in\">return</span> <div>\n        <div>基础组件值为{baseName}</div>\n        <div>通过高阶组件属性代理的得到的值为{name}</div>\n    </div>\n  }\n}\n\n<span class=\"hljs-built_in\">export</span> default Seventeen(WrappedComponent)\n<span class=\"copy-code-btn copy-0134\">复制代码</span></code></pre><p>2.反向继承<br>\n原理就是利用 super 改变改组件的 this 方向,继而就可以在该组件处理容器组件的一些值</p>\n<pre><code class=\"hljs bash copyable code-056\" lang=\"bash\">  const Seventeen = (WrappedComponent)=>{\n    <span class=\"hljs-built_in\">return</span> class extends WrappedComponent {\n        <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>() {\n            this.setState({baseName:<span class=\"hljs-string\">'这是通过反向继承修改后的基础组件名称'</span>})\n        }\n        <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n            <span class=\"hljs-built_in\">return</span> super.render();\n        }\n    }\n}\n\nclass WrappedComponent extends React.Component {\n  state={\n     baseName:<span class=\"hljs-string\">'这是基础组件'</span> \n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const {baseName} = this.state\n    <span class=\"hljs-built_in\">return</span> <div>\n        <div>基础组件值为{baseName}</div>\n    </div>\n  }\n}\n\n<span class=\"hljs-built_in\">export</span> default Seventeen(WrappedComponent);\n<span class=\"copy-code-btn copy-0135\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-33\">18.元素是否显示</h1>\n<p>一般用三元表达式</p>\n<pre><code class=\"hljs bash copyable code-057\" lang=\"bash\"> flag?<div>显示内容</div>:<span class=\"hljs-string\">''</span>\n flag&&<div>显示内容</div>\n<span class=\"copy-code-btn copy-0136\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-34\">19.Dialog 组件创建</h1>\n<p>Dialog 应该是用的比较多的组件,下面有三种不同的创建方法\n方式 1:通过 state 控制组件是否显示</p>\n<pre><code class=\"hljs bash copyable code-058\" lang=\"bash\"> class NineteenChildOne extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const Dialog = () => <div>这是弹层1</div>;\n\n    <span class=\"hljs-built_in\">return</span> this.props.dialogOneFlag && <Dialog />;\n  }\n}\n<span class=\"copy-code-btn copy-0137\">复制代码</span></code></pre><p>方式 2:通过ReactDom.render创建弹层-挂载根节点外层<br>\n通过原生的createElement,appendChild, removeChild和react 的ReactDOM.render,ReactDOM.unmountComponentAtNode来控制元素的显示和隐藏</p>\n<p>NineteenChild.jsx</p>\n<pre><code class=\"hljs bash copyable code-059\" lang=\"bash\">import ReactDOM from <span class=\"hljs-string\">\"react-dom\"</span>;\n\nclass Dialog {\n  constructor(name) {\n    this.div = document.createElement(<span class=\"hljs-string\">\"div\"</span>);\n    this.div.style.width = <span class=\"hljs-string\">\"200px\"</span>;\n    this.div.style.height = <span class=\"hljs-string\">\"200px\"</span>;\n    this.div.style.backgroundColor = <span class=\"hljs-string\">\"green\"</span>;\n    this.div.style.position = <span class=\"hljs-string\">\"absolute\"</span>;\n    this.div.style.top = <span class=\"hljs-string\">\"200px\"</span>;\n    this.div.style.left = <span class=\"hljs-string\">\"400px\"</span>;\n    this.div.id = <span class=\"hljs-string\">\"dialog-box\"</span>;\n  }\n  show(children) {\n    // 销毁\n    const dom = document.querySelector(<span class=\"hljs-string\">\"#dialog-box\"</span>);\n    <span class=\"hljs-keyword\">if</span>(!dom){ //兼容多次点击\n      // 显示\n      document.body.appendChild(this.div);\n      ReactDOM.render(children, this.div);\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">destroy</span></span>() {\n    // 销毁\n    const dom = document.querySelector(<span class=\"hljs-string\">\"#dialog-box\"</span>);\n    <span class=\"hljs-keyword\">if</span>(dom){//兼容多次点击\n      ReactDOM.unmountComponentAtNode(this.div);\n      dom.parentNode.removeChild(dom);\n    }\n  }\n}\n<span class=\"hljs-built_in\">export</span> default {\n  show: <span class=\"hljs-keyword\">function</span>(children) {\n    new Dialog().show(children);\n  },\n  hide: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n    new Dialog().destroy();\n  }\n};\n<span class=\"copy-code-btn copy-0138\">复制代码</span></code></pre><p>nineteen.jsx</p>\n<pre><code class=\"hljs bash copyable code-060\" lang=\"bash\">twoSubmit=()=>{\n    Dialog.show(<span class=\"hljs-string\">'这是弹层2'</span>)\n  }\n\n  twoCancel=()=>{\n    Dialog.hide()\n  }\n<span class=\"copy-code-btn copy-0139\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-35\">20.React.memo</h1>\n<p>作用:当类组件的输入属性相同时，可以使用 pureComponent 或 shouldComponentUpdate 来避免组件的渲染。现在，你可以通过把函数组件包装在 React.memo 中来实现相同的功能</p>\n<pre><code class=\"hljs bash copyable code-061\" lang=\"bash\">import React from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">function</span> areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 <span class=\"hljs-literal\">true</span>，\n  否则返回 <span class=\"hljs-literal\">false</span>\n  */\n  <span class=\"hljs-keyword\">if</span> (prevProps.val === nextProps.val) {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">true</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n}\n\n// React.memo()两个参数,第一个是纯函数,第二个是比较函数\n<span class=\"hljs-built_in\">export</span> default React.memo(<span class=\"hljs-keyword\">function</span> twentyChild(props) {\n  console.log(<span class=\"hljs-string\">\"MemoSon rendered : \"</span> + Date.now());\n  <span class=\"hljs-built_in\">return</span> <div>{props.val}</div>;\n}, areEqual);\n<span class=\"copy-code-btn copy-0140\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-36\">21.React.PureComponent</h1>\n<p>作用:<br>\n1.React.PureComponent 和 React.Component类似，都是定义一个组件类。<br>\n2.不同是React.Component没有实现shouldComponentUpdate()，而 React.PureComponent通过props和state的浅比较实现了。<br>\n3.React.PureComponent是作用在类中,而React.memo是作用在函数中。<br>\n4.如果组件的props和state相同时，render的内容也一致，那么就可以使用React.PureComponent了,这样可以提高组件的性能</p>\n<pre><code class=\"hljs bash copyable code-062\" lang=\"bash\">class TwentyOneChild extends React.PureComponent{  //组件直接继承React.PureComponent\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> <div>{this.props.name}</div>\n  }\n}\n\n<span class=\"hljs-built_in\">export</span> default class TwentyOne extends React.Component{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n        <span class=\"hljs-built_in\">return</span> (\n            <div>\n              <TwentyOneChild name={<span class=\"hljs-string\">'这是React.PureComponent的使用方法'</span>}></TwentyOneChild>\n            </div>\n        )\n    }\n}\n<span class=\"copy-code-btn copy-0141\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-37\">22.React.Component</h1>\n<p>作用:是基于ES6 class的React组件,React允许定义一个class或者function作为组件，那么定义一个组件类，就需要继承React.Component</p>\n<pre><code class=\"hljs bash copyable code-063\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class TwentyTwo extends React.Component{ //组件定义方法\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n        <span class=\"hljs-built_in\">return</span> (\n            <div>这是技巧22</div>\n        )\n    }\n}\n<span class=\"copy-code-btn copy-0142\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-38\">23.在 JSX 打印 falsy 值</h1>\n<p>定义:<br>\n1.falsy 值 (虚值) 是在 Boolean 上下文中认定为 false 的值;<br>\n2.值有 0,\"\",'',``,null,undefined,NaN</p>\n<pre><code class=\"hljs bash copyable code-064\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class TwentyThree extends React.Component{\n    state={myVariable:null}\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n        <span class=\"hljs-built_in\">return</span> (\n            <div>{String(this.state.myVariable)}</div>\n        )\n    }\n}\n<span class=\"copy-code-btn copy-0143\">复制代码</span></code></pre><p>虚值如果直接展示,会发生隐式转换,为 false,所以页面不显示</p>\n<h1 class=\"heading\" data-id=\"heading-39\">24.ReactDOM.createPortal</h1>\n<p>作用:组件的render函数返回的元素会被挂载在它的父级组件上,createPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</p>\n<pre><code class=\"hljs bash copyable code-065\" lang=\"bash\">import React from <span class=\"hljs-string\">\"react\"</span>;\nimport ReactDOM from <span class=\"hljs-string\">\"react-dom\"</span>;\nimport {Button} from <span class=\"hljs-string\">\"antd\"</span>\n\nconst modalRoot = document.body;\n\nclass Modal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.el = document.createElement(<span class=\"hljs-string\">\"div\"</span>);\n    this.el.style.width = <span class=\"hljs-string\">\"200px\"</span>;\n    this.el.style.height = <span class=\"hljs-string\">\"200px\"</span>;\n    this.el.style.backgroundColor = <span class=\"hljs-string\">\"green\"</span>;\n    this.el.style.position = <span class=\"hljs-string\">\"absolute\"</span>;\n    this.el.style.top = <span class=\"hljs-string\">\"200px\"</span>;\n    this.el.style.left = <span class=\"hljs-string\">\"400px\"</span>;\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span></span>() {\n    modalRoot.appendChild(this.el);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span></span>() {\n    modalRoot.removeChild(this.el);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> ReactDOM.createPortal(this.props.children, this.el);\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Child</span></span>() {\n  <span class=\"hljs-built_in\">return</span> (\n    <div className=<span class=\"hljs-string\">\"modal\"</span>>\n      这个是通过ReactDOM.createPortal创建的内容\n    </div>\n  );\n}\n\n<span class=\"hljs-built_in\">export</span> default class TwentyFour extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clicks: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleClick</span></span>() {\n    this.setState(prevState => ({\n      clicks: prevState.clicks + 1\n    }));\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n          <Button onClick={this.handleClick}>点击加1</Button>\n        <p>点击次数: {this.state.clicks}</p>\n        <Modal>\n          <Child />\n        </Modal>\n      </div>\n    );\n  }\n}\n\n<span class=\"copy-code-btn copy-0144\">复制代码</span></code></pre><p>这样元素就追加到指定的元素下面啦</p>\n<h1 class=\"heading\" data-id=\"heading-40\">25.在 React 使用innerHTML</h1>\n<p>场景:有些后台返回是 html 格式字段,就需要用到 innerHTML 属性</p>\n<pre><code class=\"hljs bash copyable code-066\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class TwentyFive extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div dangerouslySetInnerHTML={{ __html: <span class=\"hljs-string\">\"<span>这是渲染的 HTML 内容</span>\"</span> }}></div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0145\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-41\">26.React.createElement</h1>\n<p>语法:<br>\nReact.createElement(\ntype,\n[props],\n[...children]\n)</p>\n<p>源码:</p>\n<pre><code class=\"hljs bash copyable code-067\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class TwentySix extends React.Component {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        {React.createElement(\n          <span class=\"hljs-string\">\"div\"</span>,\n          { id: <span class=\"hljs-string\">\"one\"</span>, className: <span class=\"hljs-string\">\"two\"</span> },\n          React.createElement(<span class=\"hljs-string\">\"span\"</span>, { id: <span class=\"hljs-string\">\"spanOne\"</span> }, <span class=\"hljs-string\">\"这是第一个 span 标签\"</span>),\n          React.createElement(<span class=\"hljs-string\">\"br\"</span>),\n          React.createElement(<span class=\"hljs-string\">\"span\"</span>, { id: <span class=\"hljs-string\">\"spanTwo\"</span> }, <span class=\"hljs-string\">\"这是第二个 span 标签\"</span>)\n        )}\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0146\">复制代码</span></code></pre><p>原理:实质上 JSX 的 dom 最后转化为 js 都是React.createElement</p>\n<pre><code class=\"hljs bash copyable code-068\" lang=\"bash\">// jsx 语法\n<div id=<span class=\"hljs-string\">'one'</span> class=<span class=\"hljs-string\">'two'</span>>\n    <span id=<span class=\"hljs-string\">\"spanOne\"</span>>this is spanOne</span>\n    <span id=<span class=\"hljs-string\">\"spanTwo\"</span>>this is spanTwo</span>\n</div>\n\n// 转化为 js\nReact.createElement(\n  <span class=\"hljs-string\">\"div\"</span>,\n { id: <span class=\"hljs-string\">\"one\"</span>, class: <span class=\"hljs-string\">\"two\"</span> },\n React.createElement( <span class=\"hljs-string\">\"span\"</span>, { id: <span class=\"hljs-string\">\"spanOne\"</span> }, <span class=\"hljs-string\">\"this is spanOne\"</span>), \n React.createElement(<span class=\"hljs-string\">\"span\"</span>, { id: <span class=\"hljs-string\">\"spanTwo\"</span> }, <span class=\"hljs-string\">\"this is spanTwo\"</span>)\n);\n<span class=\"copy-code-btn copy-0147\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-42\">27.React.cloneElement</h1>\n<p>语法:</p>\n<pre><code class=\"hljs bash copyable code-069\" lang=\"bash\">React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n<span class=\"copy-code-btn copy-0148\">复制代码</span></code></pre><p>作用:这个方法的作用是复制组件,给组件传值或者添加属性<br>\n核心代码</p>\n<pre><code class=\"hljs bash copyable code-070\" lang=\"bash\">React.Children.map(children, child => {\n  <span class=\"hljs-built_in\">return</span> React.cloneElement(child, {\n    count: _this.state.count\n  });\n});\n<span class=\"copy-code-btn copy-0149\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-43\">28.React.Fragment</h1>\n<p>作用:React.Fragment可以让你聚合一个子元素列表，并且不在DOM中增加额外节点<br>\n核心代码</p>\n<pre><code class=\"hljs bash copyable code-071\" lang=\"bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    const { info } = this.state;\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        {info.map((item, index) => {\n          <span class=\"hljs-built_in\">return</span> (\n            <React.Fragment key={index}>\n              <div>{item.name}</div>\n              <div>{item.age}</div>\n            </React.Fragment>\n          );\n        })}\n      </div>\n    );\n  }\n<span class=\"copy-code-btn copy-0150\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-44\">29.循环元素</h1>\n<p>内部没有封装像 vue 里面 v-for 的指令,而是通过 map 遍历</p>\n<pre><code class=\"hljs bash copyable code-072\" lang=\"bash\">{arr.map((item,index)=>{\n  <span class=\"hljs-built_in\">return</span>(\n    <div key={item.id}>\n      <span>{item.name}</span>\n      <span>{item.age}</span>\n    </div>\n  )\n})}\n<span class=\"copy-code-btn copy-0151\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-45\">30.给 DOM 设置和获取自定义属性</h1>\n<p>作用:有些要通过自定义属性传值</p>\n<pre><code class=\"hljs bash copyable code-073\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default class Thirty extends React.Component {\n  click = e => {\n    console.log(e.target.getAttribute(<span class=\"hljs-string\">\"data-row\"</span>));\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <div data-row={<span class=\"hljs-string\">\"属性1\"</span>} data-col={<span class=\"hljs-string\">\"属性 2\"</span>} onClick={this.click}>\n          点击获取属性\n        </div>\n      </div>\n    );\n  }\n}\n<span class=\"copy-code-btn copy-0152\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-46\">31.绑定事件</h1>\n<p>场景:交互就会涉及到事件点击,然后点击选中值传参也是一个很常见场景</p>\n<pre><code class=\"hljs bash copyable code-074\" lang=\"bash\">import React from <span class=\"hljs-string\">\"react\"</span>;\nimport { Button } from <span class=\"hljs-string\">'antd'</span>\n\n<span class=\"hljs-built_in\">export</span> default class Three extends React.Component {\n  state = {\n    flag: <span class=\"hljs-literal\">true</span>,\n    flagOne: 1\n  };\n  click(data1,data2){\n    console.log(<span class=\"hljs-string\">'data1 值为'</span>,data1)\n    console.log(<span class=\"hljs-string\">'data2 值为'</span>,data2)\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>() {\n    <span class=\"hljs-built_in\">return</span> (\n      <div>\n        <Button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> onClick={this.click.bind(this,<span class=\"hljs-string\">'参数 1'</span>,<span class=\"hljs-string\">'参数 2'</span>)}>点击事件</Button>\n      </div>\n    );\n  }\n}\n\n<span class=\"copy-code-btn copy-0153\">复制代码</span></code></pre><p>使用方法在源码 routes.js 有详细使用</p>\n<h1 class=\"heading\" data-id=\"heading-47\">32.React-Router</h1>\n<h2 class=\"heading\" data-id=\"heading-48\">32.1 V3和 V4的区别</h2>\n<p>1.V3或者说V早期版本是把router 和 layout components 分开;<br>\n2.V4是集中式 router,通过 Route 嵌套，实现 Layout 和 page 嵌套,Layout 和 page 组件 是作为 router 的一部分;<br>\n3.在V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 route;<br>\n4.V4 中的 routes 默认是 inclusive 的，这就意味着多个;   可以同时匹配和呈现.如果只想匹配一个路由，可以使用Switch，在 <switch> 中只有一个  会被渲染，同时可以再在每个路由添加exact，做到精准匹配\nRedirect，浏览器重定向，当多有都不匹配的时候，进行匹配</switch></p>\n<h1 class=\"heading\" data-id=\"heading-49\">32.2 使用</h1>\n<pre><code class=\"hljs bash copyable code-075\" lang=\"bash\">import { HashRouter as Router, Switch  } from <span class=\"hljs-string\">\"react-router-dom\"</span>;\n\nclass App extends React.Component{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n        const authPath = <span class=\"hljs-string\">'/login'</span> // 默认未登录的时候返回的页面，可以自行设置\n        <span class=\"hljs-built_in\">let</span> authed = this.props.state.authed || <span class=\"hljs-built_in\">local</span>Storage.getItem(<span class=\"hljs-string\">'authed'</span>) // 如果登陆之后可以利用redux修改该值\n        <span class=\"hljs-built_in\">return</span> (\n            <Router>\n                <Switch>\n                    {renderRoutes(routes, authed, authPath)}\n                </Switch>\n            </Router>\n        )\n    }\n}\n<span class=\"copy-code-btn copy-0154\">复制代码</span></code></pre><p>V4是通过 Route 嵌套，实现 Layout 和 page 嵌套,Switch切换路由的作用</p>\n<h1 class=\"heading\" data-id=\"heading-50\">33.样式引入方法</h1>\n<p>方式 1:import 导入</p>\n<pre><code class=\"hljs bash copyable code-076\" lang=\"bash\">import <span class=\"hljs-string\">'./App.css'</span>;\n<span class=\"copy-code-btn copy-0155\">复制代码</span></code></pre><p>方式 2:内联方式</p>\n<pre><code class=\"hljs bash copyable code-077\" lang=\"bash\">import React from <span class=\"hljs-string\">'react'</span>;\n\nconst Header = () => {\n\n    const heading = <span class=\"hljs-string\">'头部组件'</span>\n\n    <span class=\"hljs-built_in\">return</span>(\n        <div style={{backgroundColor:<span class=\"hljs-string\">'orange'</span>}}>\n            <h1>{heading}</h1>\n        </div>\n    )\n}\n\n或者\nimport React from <span class=\"hljs-string\">'react'</span>;\n\nconst footerStyle = {\n    width: <span class=\"hljs-string\">'100%'</span>,\n    backgroundColor: <span class=\"hljs-string\">'green'</span>,\n    padding: <span class=\"hljs-string\">'50px'</span>,\n    font: <span class=\"hljs-string\">'30px'</span>,\n    color: <span class=\"hljs-string\">'white'</span>,\n    fontWeight: <span class=\"hljs-string\">'bold'</span>\n}\n\n<span class=\"hljs-built_in\">export</span> const Footer = () => {\n    <span class=\"hljs-built_in\">return</span>(\n        <div style={footerStyle}>\n            底部组件\n        </div>\n    )\n}\n<span class=\"copy-code-btn copy-0156\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-51\">34.动态绑定 className</h1>\n<p>原理:通过三元表达式控制 className 值</p>\n<pre><code class=\"hljs bash copyable code-078\" lang=\"bash\"><span class=\"hljs-function\"><span class=\"hljs-title\">render</span></span>(){\n  const flag=<span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-built_in\">return</span> (\n    <div className={flag?<span class=\"hljs-string\">\"active\"</span>:<span class=\"hljs-string\">\"no-active\"</span>}>这是技巧 34</div>\n  )\n}\n<span class=\"copy-code-btn copy-0157\">复制代码</span></code></pre><h1 class=\"heading\" data-id=\"heading-52\">总结</h1>\n<p>这就是从实际项目开发总结的 React的 34 个技巧;<br>\n源码地址，<a target=\"_blank\" href=\"https://github.com/lanzhsh/react-vue-koa/tree/master/react-pc-skill\" rel=\"nofollow noopener noreferrer\">请戳</a> 欢迎 star</p>\n",
      "id": "3oeglh3wuu00",
      "author": "火狼1",
      "title": "React 开发必须知道的 34 个技巧【近1W字】",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前提</h2>\n<blockquote>\n<p>在 vue开发中，难免遇到各种表单校验，这里整理了网络上和自己平时高频率用到的一些校验方法。如果错误欢迎指出，后期不断补充更新。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">Git地址</h2>\n<p><a target=\"_blank\" href=\"http://toc.lieme.cn/2019/08/07/%E5%B8%B8%E7%94%A8%E7%9A%84JS%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F.html\" rel=\"nofollow noopener noreferrer\">前端常用的正则校验</a></p>\n<p><a target=\"_blank\" href=\"https://github.com/jiaopianjun/JsCode/blob/master/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8rule%E6%A0%A1%E9%AA%8C.js\" rel=\"nofollow noopener noreferrer\">git地址</a></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/10/25/16e01aa629901533?imageslim\" data-width=\"900\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"900\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p style=\"font-size:30px;color:#1c8a95\" align=\"center\"> 欢迎关注 前端公众号【小夭同学】 </p>\n<h3 class=\"heading\" data-id=\"heading-2\">1、是否合法IP地址</h3>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateIP(rule, value,callback) {\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  }<span class=\"hljs-keyword\">else</span> {\n    const reg = /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/;\n    <span class=\"hljs-keyword\">if</span> ((!reg.test(value)) && value != <span class=\"hljs-string\">''</span>) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的IP地址'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-028\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-3\">2、是否手机号码或者固话</h3>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validatePhoneTwo(rule, value, callback) {\n  const reg = /^((0\\d{2,3}-\\d{7,8})|(1[34578]\\d{9}))$/;;\n  <span class=\"hljs-keyword\">if</span> (value == <span class=\"hljs-string\">''</span> || value == undefined || value == null) {\n    callback();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> ((!reg.test(value)) && value != <span class=\"hljs-string\">''</span>) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的电话号码或者固话号码'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-4\">3、是否固话</h3>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateTelphone(rule, value,callback) {\n  const reg =/0\\d{2,3}-\\d{7,8}/;\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  }<span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> ((!reg.test(value)) && value != <span class=\"hljs-string\">''</span>) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的固定电话）'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">4、是否手机号码</h3>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validatePhone(rule, value,callback) {\n  const reg =/^[1][3-9][0-9]{9}$/;\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  }<span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> ((!reg.test(value)) && value != <span class=\"hljs-string\">''</span>) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的电话号码'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">5、是否身份证号码</h3>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateIdNo(rule, value,callback) {\n  const reg = /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/;\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  }<span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> ((!reg.test(value)) && value != <span class=\"hljs-string\">''</span>) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的身份证号码'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-7\">6、是否邮箱</h3>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateEMail(rule, value,callback) {\n  const reg =/^([a-zA-Z0-9]+[-_\\.]?)+@[a-zA-Z0-9]+\\.[a-z]+$/;\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  }<span class=\"hljs-keyword\">else</span>{\n    <span class=\"hljs-keyword\">if</span> (!reg.test(value)){\n      callback(new Error(<span class=\"hljs-string\">'请输入正确的邮箱'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-8\">7、合法url</h3>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateURL(url) {\n  const urlregex = /^(https?|ftp):\\/\\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+\\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\\/($|[a-zA-Z0-9.,?<span class=\"hljs-string\">'\\\\+&%$#=~_-]+))*$/;\n  return urlregex.test(url);\n}\n</span><span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-9\">8、验证内容是否包含英文数字以及下划线</h3>\n<pre><code class=\"hljs bash copyable code-07\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isPassword(rule, value, callback) {\n  const reg =/^[_a-zA-Z0-9]+$/;\n  <span class=\"hljs-keyword\">if</span>(value==<span class=\"hljs-string\">''</span>||value==undefined||value==null){\n    callback();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> (!reg.test(value)){\n      callback(new Error(<span class=\"hljs-string\">'仅由英文字母，数字以及下划线组成'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      callback();\n    }\n  }\n}\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-10\">9、自动检验数值的范围</h3>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> checkMax20000(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (value == <span class=\"hljs-string\">''</span> || value == undefined || value == null) {\n    callback();\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n    callback(new Error(<span class=\"hljs-string\">'请输入[1,20000]之间的数字'</span>));\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value < 1 || value > 20000) {\n    callback(new Error(<span class=\"hljs-string\">'请输入[1,20000]之间的数字'</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    callback();\n  }\n}\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-11\">10、验证数字输入框最大数值</h3>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> checkMaxVal(rule, value,callback) {\n  <span class=\"hljs-keyword\">if</span> (value < 0 || value > 最大值) {\n    callback(new Error(<span class=\"hljs-string\">'请输入[0,最大值]之间的数字'</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    callback();\n  }\n}\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-12\">11、验证是否1-99之间</h3>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isOneToNinetyNine(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正整数'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      const re = /^[1-9][0-9]{0,1}$/;\n      const rsCheck = re.test(value);\n      <span class=\"hljs-keyword\">if</span> (!rsCheck) {\n        callback(new Error(<span class=\"hljs-string\">'请输入正整数，值为【1,99】'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 0);\n}\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-13\">12、验证是否整数</h3>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isInteger(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正整数'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      const re = /^[0-9]*[1-9][0-9]*$/;\n      const rsCheck = re.test(value);\n      <span class=\"hljs-keyword\">if</span> (!rsCheck) {\n        callback(new Error(<span class=\"hljs-string\">'请输入正整数'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 0);\n}\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-14\">13、验证是否整数,非必填</h3>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isIntegerNotMust(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    callback();\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正整数'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      const re = /^[0-9]*[1-9][0-9]*$/;\n      const rsCheck = re.test(value);\n      <span class=\"hljs-keyword\">if</span> (!rsCheck) {\n        callback(new Error(<span class=\"hljs-string\">'请输入正整数'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 1000);\n}\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-15\">14、 验证是否是[0-1]的小数</h3>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isDecimal(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入[0,1]之间的数字'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (value < 0 || value > 1) {\n        callback(new Error(<span class=\"hljs-string\">'请输入[0,1]之间的数字'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-16\">15、 验证是否是[1-10]的小数,即不可以等于0</h3>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isBtnOneToTen(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (typeof value == <span class=\"hljs-string\">'undefined'</span>) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入正整数，值为[1,10]'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (!(value == <span class=\"hljs-string\">'1'</span> || value == <span class=\"hljs-string\">'2'</span> || value == <span class=\"hljs-string\">'3'</span> || value == <span class=\"hljs-string\">'4'</span> || value == <span class=\"hljs-string\">'5'</span> || value == <span class=\"hljs-string\">'6'</span> || value == <span class=\"hljs-string\">'7'</span> || value == <span class=\"hljs-string\">'8'</span> || value == <span class=\"hljs-string\">'9'</span> || value == <span class=\"hljs-string\">'10'</span>)) {\n        callback(new Error(<span class=\"hljs-string\">'请输入正整数，值为[1,10]'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-17\">16、验证是否是[1-100]的小数,即不可以等于0</h3>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isBtnOneToHundred(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入整数，值为[1,100]'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (value < 1 || value > 100) {\n        callback(new Error(<span class=\"hljs-string\">'请输入整数，值为[1,100]'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-18\">17、验证是否是[0-100]的小数</h3>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isBtnZeroToHundred(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (!Number(value)) {\n      callback(new Error(<span class=\"hljs-string\">'请输入[1,100]之间的数字'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (value < 0 || value > 100) {\n        callback(new Error(<span class=\"hljs-string\">'请输入[1,100]之间的数字'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-044\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-19\">18、验证端口是否在[0,65535]之间</h3>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isPort(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'输入不可以为空'</span>));\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (value == <span class=\"hljs-string\">''</span> || typeof(value) == undefined) {\n      callback(new Error(<span class=\"hljs-string\">'请输入端口值'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      const re = /^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$/;\n      const rsCheck = re.test(value);\n      <span class=\"hljs-keyword\">if</span> (!rsCheck) {\n        callback(new Error(<span class=\"hljs-string\">'请输入在[0-65535]之间的端口值'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-045\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">19、验证端口是否在[0,65535]之间，非必填,isMust表示是否必填</h3>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> isCheckPort(rule, value, callback) {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    callback();\n  }\n  <span class=\"hljs-built_in\">set</span>Timeout(() => {\n    <span class=\"hljs-keyword\">if</span> (value == <span class=\"hljs-string\">''</span> || typeof(value) == undefined) {\n      //callback(new Error(<span class=\"hljs-string\">'请输入端口值'</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      const re = /^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$/;\n      const rsCheck = re.test(value);\n      <span class=\"hljs-keyword\">if</span> (!rsCheck) {\n        callback(new Error(<span class=\"hljs-string\">'请输入在[0-65535]之间的端口值'</span>));\n      } <span class=\"hljs-keyword\">else</span> {\n        callback();\n      }\n    }\n  }, 100);\n}\n<span class=\"copy-code-btn copy-046\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-21\">20、小写字母</h3>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateLowerCase(val) {\n  const reg = /^[a-z]+$/;\n  <span class=\"hljs-built_in\">return</span> reg.test(val);\n}\n<span class=\"copy-code-btn copy-047\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-22\">22、两位小数验证</h3>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\">const validateValidity = (rule, value, callback) => {\n  <span class=\"hljs-keyword\">if</span> (!/(^[1-9]([0-9]+)?(\\.[0-9]{1,2})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9])?$)/.test(value)) {\n    callback(new Error(<span class=\"hljs-string\">'最多两位小数！！！'</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    callback();\n  }\n};\n<span class=\"copy-code-btn copy-048\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-23\">23、是否大写字母</h3>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validateUpperCase(val) {\n  const reg = /^[A-Z]+$/;\n  <span class=\"hljs-built_in\">return</span> reg.test(val);\n}\n<span class=\"copy-code-btn copy-049\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-24\">24、是否大小写字母</h3>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-keyword\">function</span> validatAlphabets(val) {\n  const reg = /^[A-Za-z]+$/;\n  <span class=\"hljs-built_in\">return</span> reg.test(val);\n}\n<span class=\"copy-code-btn copy-050\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-25\">25、密码校验</h3>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const validatePsdReg = (rule, value, callback) => {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'请输入密码'</span>))\n  }\n  <span class=\"hljs-keyword\">if</span> (!/^(?![\\d]+$)(?![a-zA-Z]+$)(?![^\\da-zA-Z]+$)([^\\u4e00-\\u9fa5\\s]){6,20}$/.test(value)) {\n    callback(new Error(<span class=\"hljs-string\">'请输入6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种'</span>))\n  } <span class=\"hljs-keyword\">else</span> {\n    callback()\n  }\n}\n<span class=\"copy-code-btn copy-051\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-26\">26、中文校验</h3>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const validateContacts = (rule, value, callback) => {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'请输入中文'</span>))\n  }\n  <span class=\"hljs-keyword\">if</span> (!/^[\\u0391-\\uFFE5A-Za-z]+$/.test(value)) {\n    callback(new Error(<span class=\"hljs-string\">'不可输入特殊字符'</span>))\n  } <span class=\"hljs-keyword\">else</span> {\n    callback()\n  }\n}\n<span class=\"copy-code-btn copy-052\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-27\">27、 账号校验</h3>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const validateCode = (rule, value, callback) => {\n  <span class=\"hljs-keyword\">if</span> (!value) {\n    <span class=\"hljs-built_in\">return</span> callback(new Error(<span class=\"hljs-string\">'请输入账号'</span>))\n  }\n  <span class=\"hljs-keyword\">if</span> (!/^(?![0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]{6,20}$/.test(value)) {\n    callback(new Error(<span class=\"hljs-string\">'账号必须为6-20位字母和数字组合'</span>))\n  } <span class=\"hljs-keyword\">else</span> {\n    callback()\n  }\n}\n<span class=\"copy-code-btn copy-053\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-28\">28 、纯数字校验</h3>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> const validateNumber = (rule, value, callback) => {\n    <span class=\"hljs-built_in\">let</span> numberReg = /^\\d+$|^\\d+[.]?\\d+$/\n    <span class=\"hljs-keyword\">if</span> (value !== <span class=\"hljs-string\">''</span>) {\n        <span class=\"hljs-keyword\">if</span> (!numberReg.test(value)) {\n            callback(new Error(<span class=\"hljs-string\">'请输入数字'</span>))\n        } <span class=\"hljs-keyword\">else</span> {\n            callback()\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        callback(new Error(<span class=\"hljs-string\">'请输入值'</span>))\n    }\n}\n<span class=\"copy-code-btn copy-054\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-29\">29、最多一位小数</h3>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\">const onePoint = (rule, value, callback) => {\n  <span class=\"hljs-keyword\">if</span> (!/^[0-9]+([.]{1}[0-9]{1})?$/.test(value)) {\n    callback(new Error(<span class=\"hljs-string\">'最多一位小数！！！'</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    callback();\n  }\n};\n<span class=\"copy-code-btn copy-055\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-30\">使用方法：</h2>\n<blockquote>\n<p>在使用地方直接 import 引入，然后在 rules 校验中加入即可。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-31\">前端交流群</h2>\n<h4 class=\"heading\" data-id=\"heading-32\">添加直接机器人，通过后，回复  暗号 string 拉你进群</h4>\n<p></p><figure><img alt=\"添加直接回复  暗号 string 拉你进群\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e683ff6116abc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"901\" data-height=\"1198\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"901\" height=\"1198\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2lsn3ia5ux20",
      "author": "故事胶片",
      "title": "前端Vue中常用rules校验规则",
      "baseClassName": "article-content"
    },
    {
      "content": "<h3 class=\"heading\" data-id=\"heading-0\">目录</h3>\n<p>本文简单介绍几种常见的 web 安全问题：</p>\n<ul>\n<li>同源策略</li>\n<li>XSS</li>\n<li>CSRF</li>\n<li>SQL注入</li>\n<li>点击劫持</li>\n<li>window.opener 安全问题</li>\n<li>文件上传漏洞</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">同源策略</h3>\n<p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</p>\n<ul>\n<li>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li>\n<li>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</li>\n<li>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>\n</ul>\n<p>解决同源策略的方法：</p>\n<ul>\n<li><code>跨文档消息机制</code>:可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</li>\n<li><code>跨域资源共享（CORS）</code>:跨域资源在服务端设置允许跨域，就可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</li>\n<li><code>内容安全策略（CSP）</code>:主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等等），而非白名单的内容无法正常执行。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">XSS，跨站脚本攻击(Cross Site Scripting)</h3>\n<h4 class=\"heading\" data-id=\"heading-3\">存储型 XSS 攻击</h4>\n<p>利用漏洞提交恶意 JavaScript 代码，比如在input, textarea等所有可能输入文本信息的区域，输入<code><script src=\"http://恶意网站\"></script></code>等，提交后信息会存在服务器中，当用户再次打开网站请求到相应的数据，打开页面，恶意脚本就会将用户的 Cookie 信息等数据上传到黑客服务器。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">反射型 XSS 攻击</h4>\n<p>用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。\n在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p>\n<p><code>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</code></p>\n<h4 class=\"heading\" data-id=\"heading-5\">基于 DOM 的 XSS 攻击</h4>\n<p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。它的特点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。比如利用工具(如Burpsuite)扫描目标网站所有的网页并自动测试写好的注入脚本等。</p>\n<p>预防策略：</p>\n<ol>\n<li>将cookie等敏感信息设置为httponly，禁止Javascript通过<code>document.cookie</code>获得</li>\n<li>对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式.</li>\n<li>净化和过滤掉不必要的html标签，比如：<code><iframe>, alt,<script></code> ;净化和过滤掉不必要的Javascript的事件标签，比如：<code>onclick, onfocus</code>等</li>\n<li>转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符</li>\n<li>CSP,CSP 全称为 Content Security Policy，即内容安全策略。主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等等），而非白名单的内容无法正常执行，从而减少跨站脚本攻击（XSS），当然，也能够减少运营商劫持的内容注入攻击。\n配置方式：</li>\n</ol>\n<pre><code class=\"hljs js copyable code-00\" lang=\"js\"><span class=\"hljs-comment\">//1、meta</span>\n\n<meta http-equiv=<span class=\"hljs-string\">\"Content-Security-Policy\"</span> content=<span class=\"hljs-string\">\"script-src 'self'\"</span>>\n\n<span class=\"hljs-comment\">//2、Http 头部</span>\n\nContent-Security-Policy:\nscript-src <span class=\"hljs-string\">'unsafe-inline'</span> <span class=\"hljs-string\">'unsafe-eval'</span> <span class=\"hljs-string\">'self'</span> *<span class=\"hljs-number\">.54</span>php.cn *.yunetidc.com *.baidu.com *.cnzz.com *.duoshuo.com *.jiathis.com;report-uri /error/csp\n<span class=\"copy-code-btn copy-03\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-6\">CSRF,跨站请求伪造（Cross-site request forgery）</h3>\n<p>引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p>\n<p>发起 CSRF 攻击的三个必要条件：</p>\n<ol>\n<li>目标站点一定要有 CSRF 漏洞；</li>\n<li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>需要用户打开一个第三方站点，如黑客的站点等。</li>\n</ol>\n<p>预防策略：</p>\n<ol>\n<li>充分利用好 Cookie 的 SameSite 属性。</li>\n</ol>\n<p>SameSite 选项通常有 Strict、Lax 和 None 三个值。</p>\n<ul>\n<li>SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</li>\n<li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li>\n<li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。\n如：</li>\n</ul>\n<pre><code class=\"hljs js copyable code-01\" lang=\"js\">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none\n<span class=\"copy-code-btn copy-04\">复制代码</span></code></pre><ol start=\"2\">\n<li>验证请求的来源站点</li>\n</ol>\n<p>在服务器端验证请求来源的站点，就是验证 HTTP 请求头中的 <code>Origin</code> 和 <code>Referer</code> 属性。Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，而O rigin 属性只包含了域名信息，并没有包含具体的 URL 路径。这是 Origin 和 Referer 的一个主要区别。</p>\n<p>服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p>\n<ol start=\"3\">\n<li>在请求地址中添加 token 并验证</li>\n</ol>\n<p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。因此要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>\n<ol start=\"4\">\n<li>在 HTTP 头中自定义属性并验证</li>\n</ol>\n<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>\n<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">SQL注入</h3>\n<p>拼接 SQL 时未仔细过滤，黑客可提交畸形数据改变语义。比如查某个文章，提交了这样的数据<code>id=-1 or 1=1</code>等。1=1 永远是true，导致where语句永远是ture.那么查询的结果相当于整张表的内容，攻击者就达到了目的。或者，通过屏幕上的报错提示推测 SQL 语句等。</p>\n<p>预防策略：</p>\n<ol>\n<li>禁止目标网站利用动态拼接字符串的方式访问数据库</li>\n<li>减少不必要的数据库抛出的错误信息</li>\n<li>对数据库的操作赋予严格的权限控制</li>\n<li>净化和过滤掉不必要的SQL保留字，比如：where, or, exec 等</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-8\">点击劫持</h3>\n<ul>\n<li>诱使用户点击看似无害的按钮（实则点击了透明 iframe 中的按钮）.</li>\n<li>监听鼠标移动事件，让危险按钮始终在鼠标下方.</li>\n<li>使用 HTML5 拖拽技术执行敏感操作（例如 deploy key）.</li>\n</ul>\n<p>预防策略：</p>\n<ol>\n<li>服务端添加 X-Frame-Options 响应头,这个 HTTP 响应头是为了防御用 iframe 嵌套的点击劫持攻击。 这样浏览器就会阻止嵌入网页的渲染。</li>\n<li>JS 判断顶层视口的域名是不是和本页面的域名一致，不一致则不允许操作，<code>top.location.hostname === self.location.hostname</code>；</li>\n<li>敏感操作使用更复杂的步骤（验证码、输入项目名称以删除）。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-9\">window.opener 安全问题</h3>\n<p>window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=\"_blank\" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。</p>\n<p>一般来说，打开同源(域名相同)的页面，不会有什么问题。但对于跨域的外部链接来说，存在一个被钓鱼的风险。比如你正在浏览购物网站，从当前网页打开了某个外部链接，在打开的外部页面，可以通过 window.opener.location 改写来源站点的地址。利用这一点，将来源站点改写到钓鱼站点页面上，例如跳转到伪造的高仿购物页面，当再回到购物页面的时候，是很难发现购物网站的地址已经被修改了的，这个时候你的账号就存在被钓鱼的可能了。</p>\n<p>预防策略：</p>\n<ol>\n<li>设置 rel 属性</li>\n</ol>\n<pre><code class=\"hljs js copyable code-02\" lang=\"js\"><a href=<span class=\"hljs-string\">\"https://xxxx\"</span> rel=<span class=\"hljs-string\">\"noopener noreferrer\"</span>> 外链 <a>\n<span class=\"copy-code-btn copy-05\">复制代码</span></code></pre><p>rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。\n2. 将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，再由服务器 redirect 到外链。\n3. 可以由 widow.open 打开外链。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">文件上传漏洞</h3>\n<p>服务器未校验上传的文件，致使黑客可以上传恶意脚本等方式。</p>\n<p>预防策略：</p>\n<ol>\n<li>用文件头来检测文件类型，使用白名单过滤(有些文件可以从其中一部分执行，只检查文件头无效，例如 PHP 等脚本语言)；</li>\n<li>上传后将文件彻底重命名并移动到不可执行的目录下；</li>\n<li>升级服务器软件以避免路径解析漏洞；</li>\n<li>升级用到的开源编辑器；</li>\n<li>管理后台设置强密码。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-11\">参考资料</h3>\n<ul>\n<li>极客时间《浏览器工作原理与实践》</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-12\">最后</h3>\n<ul>\n<li>欢迎加我微信(winty230)，拉你进技术群，长期交流学习...</li>\n<li>欢迎关注「前端Q」,认真学前端，做个有专业的技术人...</li>\n</ul>\n<p></p><figure><img alt=\"GitHub\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/8/16e49372b7d39717?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"480\" data-height=\"480\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"480\" height=\"480\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "dtgeiqwbt0g",
      "author": "winty",
      "title": "Web 安全总结(面试必备良药)",
      "baseClassName": "article-content"
    },
    {
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">写在前面</h1>\n<p>现在面试文章已很多，更不觉得新鲜，本文可能有点不同，正因为“多”也就才有了本文的输出。</p>\n<p>相信很多前端小伙伴也包括我在内，面试前都要做一些准备，而做做面试题是最平常不过的事儿了，然而每次面试前都要现找面试题，而且答案也不是现成的，其实这样重复的事情在不知不觉中浪费你很多时间。</p>\n<p>也就因为发现了这个问题，才有了把面试题进行整理的想法，希望能对一些人有所帮助，节省一点时间吧。</p>\n<h1 class=\"heading\" data-id=\"heading-1\">题目整理</h1>\n<p>这1个多月来一直在整理前端领域相关的面试题，阅读查看了将近100多篇的面试文章，文章大多来自技术社区，如掘金、思否等，由于很多文章的题目重复性较大，所以整理起来比较费事。</p>\n<p>到目前为止已经收集了将近500道，包含问答题、代码题、高频基础、大厂题目等。</p>\n<p>下面是部分问题，由于时间精力问题解析还没来得及写，目前指向了原文。</p>\n<p><strong>第1题 谈谈变量提升？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第2题 说说bind、call、apply的 区别？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-3\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第3题 如何实现一个 bind 函数？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-4\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第4题 请实现一个 call 函数</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-5\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第5题 如何实现一个 apply 函数？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-6\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第6题 简单说下原型链？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-7\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第7题 怎么判断对象类型？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-8\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第8题 说说箭头函数的特点</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-9\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第9题 如何确定This指向</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-10\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第10题 async、await 的优缺点</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-11\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第11题 generator 原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-12\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第12题 对Promise的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-13\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第13题 == 和 ===区别，什么情况用 ==</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-15\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第14题 垃圾回收 新生代算法，老生代算法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-16\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第15题 说说你对闭包的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-19\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第16题 基本数据类型和引⽤类型在存储上的差别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-20\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第17题 浏览器 Eventloop 和 Node 中的有什么区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-21\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第18题 怎样理解setTimeout 执行误差</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-23\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第19题 说说函数节流和防抖</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://zhuanlan.zhihu.com/p/38313717\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第20题 数组降维</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"http://foreverz.cn/2016/11/01/JavaScript之数组降维/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第21题 请实现一个深拷贝</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/148 https://juejin.im/post/5ba34e54e51d450e5162789b#heading-26 https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第22题 typeof 于 instanceof 区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-27\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第23题 cookie和localSrorage、session、indexDB 的区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-29\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第24题 怎么判断页面是否加载完成？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-30\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第25题 说说 jsonp 原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-32\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第26题 说说你对Service worker的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-37\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第27题 说说浏览器缓存机制</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-38\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第28题 怎样选择合适的缓存策略</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-43\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第29题 说说重绘（Repaint）和回流（Reflow）</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-45\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第30题 如何优化图片</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-47\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第31题 页面首屏渲染性能优化方案有哪些</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-44\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第32题 浏览器性能问题-使用 Webpack 优化项目</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-52\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第33题 Babel 原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-55\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第34题 介绍下React 生命周期</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-58\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第35题  react setState 机制</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-60\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第36题 Vue的 nextTick 原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-61\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第37题 Vue 生命周期</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-62\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第38题 Vue 双向绑定</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-63\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第39题 v-model原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-64\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第40题 watch 和 computed 的区别和运用的场景</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-65\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第41题 Vue 的父子通信</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-66\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第42题 简述路由原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-67\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第43题 MVVM-脏数据检测</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-69\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第44题 MVVM-数据劫持</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-70\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第45题 React V16 生命周期函数用法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-59\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第46题 Vue 和 React 区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-74\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第47题 介绍下虚拟 DOM，对虚拟 DOM 的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b10dd36e51d4506e04cf802 https://juejin.im/post/5d3f3bf36fb9a06af824b3e2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第48题 路由鉴权</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d6352116fb9a06ae8361932 https://juejin.im/post/5caeb3756fb9a068967791b3\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第49题 TCP 3次握手</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-76\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第50题 TCP 拥塞控制</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-77\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第51题 慢开始算法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-78\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第52题 拥塞避免算法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-79\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第53题 tcp 快速重传</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-80\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第54题 TCP New Ren 改进后的快恢复</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-81\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第55题 HTTPS 握手</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-82\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第56题 从输入 URL 到页面加载全过程</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-84\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第57题 HTTP 常用状态码 301 302 304 403</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5a276865f265da432c23b8d2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第58题 常见排序-冒泡排序</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-88\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第59题 常见排序-插入排序</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-89\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第60题 常见排序-选择排序</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-90\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第61题 常见排序-归并排序</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-91\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第62题 常见排序-快排</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-92\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第63题 常见排序-堆排序</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-94\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第64题 常见排序-系统自带排序实现</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-95\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第65题 介绍下设计模式-工厂模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-99\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第66题 介绍下设计模式-单例模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-100\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第67题 介绍下设计模式-适配器模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-101\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第68题 介绍下设计模式-装饰模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-102\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第69题 介绍下设计模式-代理模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-103\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第70题 介绍下设计模式-发布-订阅模式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-104\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第71题 Vue 响应式原理</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b5eb69a5188251af86bfe00\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第72题 实现一个new操作符</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-0\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第73题 实现一个JSON.stringify</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-1\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第74题 实现一个JSON.parse</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ba34e54e51d450e5162789b#heading-2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第75题 手写一个继承</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-11\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第76题 实现一个JS函数柯里化</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-12\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第77题 请手写一个Promise(中高级必考)</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-15\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第78题 手写防抖(Debouncing)和节流(Throttling)</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-19\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第79题 实现一个instanceOf</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-26\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第80题 实现一个私有变量</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-1\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第81题 使用setTimeout代替setInterval进行间歇调用</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-0\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第82题 数组中的forEach和map的区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第83题 for in和for of的区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-3\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第84题 写一个发布订阅 EventEmitter方法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-4\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第85题 let、var、const区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-5\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第86题 typeof和instanceof 区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-7\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第87题 常见的继承的几种方法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ceaaaf0e51d45508c2fb7c0#heading-8\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第88题 常见的浏览器内核有哪些?</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-1\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第89题 浏览器的主要组成部分是什么？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-2\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第90题 浏览器是如何渲染UI的？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-3\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第91题 浏览器如何解析css选择器？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-4\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第92题 DOM Tree是如何构建的？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-5\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第93题 重绘与重排的区别？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-6\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第94题 如何触发重排和重绘？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-7\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第95题 如何避免重绘或者重排？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-8\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第96题 前端如何实现即时通讯？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-12\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第97题 什么是浏览器同源策略？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-19\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第98题 怎样解决跨域问题？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-20 https://juejin.im/post/5ba34e54e51d450e5162789b#heading-31\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第99题 时间格式化</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5d7659c76fb9a06b307068ed#heading-1\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第100题 说说对html 语义化的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-3\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第101题 说说常用的 meta 标签</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第102题 说说两种盒模型以及区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-8\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第103题 css reset 和 normalize.css 有什么区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-9\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第104题 怎样让元素水平垂直居中</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-9\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第105题 说说选择器的权重计算方式</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-11\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第106题 清除浮动的方法</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第107题 说说你对 BFC 的理解</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第108题 import 和 link 区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ab36d99f265da23866fccd1\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第109题 说下 [1, 2, 3].map(parseInt) 结果</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://mp.weixin.qq.com/s/CT0ae6C1_pr8ELzffO0IEA\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第110题 介绍下浏览器事件委托</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://zhuanlan.zhihu.com/p/26536815\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第111题 10w 条记录的数组，一次性渲染到页面上，如何处理可以不冻结UI？</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5ae17a386fb9a07abc299cdd\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第112题 如何实现一个左右固定，中间自适应的三栏布局</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/599970f4518825243a78b9d5#heading-52\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第113题 如何实现一个自适应的正方形</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5da32d43e51d45781d5e4bdf#heading-10\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第114题 如何用css实现一个三角形</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5da32d43e51d45781d5e4bdf#heading-11\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第115题 介绍下 positon 属性</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/5da32d43e51d45781d5e4bdf#heading-9\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第116题 说说渐进增强和优雅降级</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://juejin.im/post/58eda95261ff4b005819faf9\" target=\"_blank\" rel>参考解析</a></p>\n</details>\n<p><strong>第117题 defer和async区别</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://segmentfault.com/a/1190000006778717\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第118题 实现sleep函数</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://www.cnblogs.com/pompey/p/6644977.html https://juejin.im/post/5cc7ddaf6fb9a032106bda07\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第119题 实现 lazyMan</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://www.jianshu.com/p/f1b7cb456d37 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p><strong>第120题 获取元素的最终background-color</strong></p>\n<details><summary><b>参考解析</b></summary>\n        <p><a href=\"https://www.jianshu.com/p/e94b5779f998\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参考解析</a></p>\n</details>\n<p>由于篇幅问题我就不全部列出了。请继续往下看。</p>\n<h1 class=\"heading\" data-id=\"heading-2\">碎片时间系统刷题</h1>\n<p>为了方便管理和维护这些题目，同时为前端小伙伴儿提供更好看题体验，我简单做了一个题库网站-大前端面试题库，宗旨是充分利用大家的碎片时间，在上下班，地铁公交上刷刷题，日积月累，尽量避免临时抱佛脚的局面。</p>\n<p>另外对面试题做了一个简单的类型划分，进行分类划分的重要性不言而喻，碎片化的信息会极大的消耗我们精力，同时也不利于我们记忆，人脑自然的更喜欢结构化的，有规则的信息，通过系统的只处理同一种类型的问题来降低大脑的损耗，加强我们对知识的理解和记忆。</p>\n<p>分类大概为js、经典高频、编程题、大厂题、html、css、布局、浏览器、性能、前端框架、react、vue、web 安全、数据结构和算法、http、tcp、node、设计模式等。</p>\n<p>这个网站是用的我自己的 <a target=\"_blank\" href=\"https://github.com/Bigerfe/koa-react-ssr\" rel=\"nofollow noopener noreferrer\">react ssr</a> 开发骨架做的，目前支持 pc 和移动端浏览。</p>\n<p>看下页面效果</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e607e880d9cee3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1009\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1009\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e607eb89043f90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1013\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1013\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e607f187bad460?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"952\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"952\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e607f61ee2bb75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"1016\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1016\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-3\">解析/答案</h1>\n<p>由于个人精力有限，一时无法写完所有的问题解析。目前仍在继续完善中，这个过程也是对自己一种提升和沉淀，我觉得这个价值很大。</p>\n<p>不过为了方便大家校对答案，大部分问题的解析我单独做了链接跳转，指向了原文，可直接跳转到来源文章查看解析。</p>\n<h1 class=\"heading\" data-id=\"heading-4\">一点心得</h1>\n<p>这个题库的价值不只是用来刷题，他的价值在于问题本身，问题本身比答案更重要。</p>\n<p>通过问题来验证自己的知识技能，核对自己对知识的掌握程度，这完全可以当做一种学习方法来执行。</p>\n<p>当我们遇到的问题越多，理解和解决的问题越多，相对的我们的能力就会越强。\n这500+看上去确实挺多的了，覆盖面也挺广了，但是前端技术日新月异，新技术新思路层出不穷，相关的问题也会不断的更新迭代，所以这个题库还要继续更新，后面继续把更有针对性的问题收集进来。</p>\n<p>以上一些观点有些属于本人自嗨，现在回归初心，收集题库并创建题库站的最终目的是希望帮一些人提升一点效率，节约一点时间，利用碎片时间，上下班地铁上刷个题，如果还能帮你提升技能，提升搞定面试的几率，那就最好不过了。</p>\n<h1 class=\"heading\" data-id=\"heading-5\">题库入口1</h1>\n<p>为了方便大家找到入口不迷路，题库入口绑定到了公众号的独立菜单。</p>\n<p>我的公众号是-《前端技术江湖》，主要是个人的原创和一些工作心得的输出，可以及时的获得题库的更新通知，另外还有很多优质文章和前端学习资料，希望大家多多关注。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e60729ba402e0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"680\" data-height=\"176\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"680\" height=\"176\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e6072bd208844b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"254\" data-height=\"252\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"254\" height=\"252\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-6\">题库入口2</h1>\n<p>网站入口 - <a target=\"_blank\" href=\"http://bigerfe.com/\" rel=\"nofollow noopener noreferrer\">大前端面试刷题- http://bigerfe.com/</a>，内有福利哦。</p>\n<h1 class=\"heading\" data-id=\"heading-7\">最后一件事</h1>\n<p>我正在打造一个纯技术交流群，面向初中级前端开发者，以学习、交流、思考、提升能力为目标，因为一个人学不如大家一起学，有了更多的交流才会进步的更快。</p>\n<p>我理想的模式是，每期让一个人深入学习一个技术，然后自己再转述给大家听，类似一个分享课堂，这样可以成倍的提升学习效率。</p>\n<p>或者可以按照题库的顺序依次进行，每人每天对对一个问题进行思考和总结性的输出，锻炼技术的同时提升表达能力。</p>\n<p>在这个群里不用担心自己的能力不足，不用担心问题是否太小白而不敢说，大胆的说出问题， 让更多的人一起来分析，说错了也没关系。</p>\n<p><strong>有想加入请的关注公众号《前端技术江湖》，回复‘进群’，我拉你进群。</strong></p>\n<hr>\n<p>希望本文可以给你带了一些帮助和便利，文中如有错误，欢迎在评论区指。\n如果这篇文章帮助到了你，欢迎点赞和关注。</p>\n",
      "id": "5veaqpetfv00",
      "author": "zz_jesse",
      "title": "【前方高能】新手到高级前端攻城狮都用的上的前端面试题库，备战明年金三银四",
      "baseClassName": "article-content"
    },
    {
      "content": "<p>下面是我在开发大型 Vue 项目时的最佳实践。这些技巧将帮助你开发更高效、更易于维护和共享的代码。</p>\n<p>今年做自由职业的时候，我有机会开发了一些大型 Vue 应用程序。我所说的这些项目，Vuex store 超过十个，包含大量的组件（有时候几百个）和视图页面。对我来说这是个很有益的经验，因为我发现了很多有意思的模式，可以让代码拥有更好的伸缩性。我还必须修正一些导致著名的意大利面条式代码困境的错误实践。</p>\n<p>因此，今天我将与你分享10个最佳实践，如果你正在处理大型代码库，我建议你参考这些方法。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">1. 使用 slot, 让组件更强大，也更容易理解</h2>\n<p>最近我写了篇关于 Vue.js slot 的文章，它强调了 slot 如何使组件更易于重用和维护，以及为什么应该使用它们。</p>\n<p>🧐 但是这与 Vue.js 大型项目有什么关系呢？一张图片通常胜过千言万语，所以我要给你描绘一幅关于我第一次后悔没有使用它们的画面。</p>\n<p>有一天，我要创建一个 popup。乍一看并没有什么复杂的东西，只是包含了一个标题，一个描述和一些按钮。所以我所做的就是把一切配置一股脑当做 props 传进去。最终我定义了三个 prop，用于自定义组件，当用户单击按钮时将发送一个事件。So easy !</p>\n<p>但是，随着项目的发展，团队要求我们在其中展示更多其他的新内容：表单字段、不同的按钮(取决于它显示在哪个页面上)、卡片、页脚，以及列表。我以为，如果继续使用 prop 来迭代这个组件也没啥问题。但是我滴个神哪，我是大错特错！组件很快变得非常复杂，难以理解，因为它包含了无数的子组件，用了太多的 prop，并发送了一堆的事件。我开始体验到了可怕的情况，当你做出一点改动，其他页面的某个地方就会崩溃！我仿佛造了一个 Frankenstein 怪人，而不是一个可维护的组件!🤖</p>\n<p>然而，如果我从一开始就依赖 slot，情况可能会好多了。最后我重构了所有东西，得到了这个小组件：更容易维护，理解起来更快，更好扩展！</p>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\"><template>\n  <div class=<span class=\"hljs-string\">\"c-base-popup\"</span>>\n    <div v-if=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$slot</span>.header\"</span> class=<span class=\"hljs-string\">\"c-base-popup__header\"</span>>\n      <slot name=<span class=\"hljs-string\">\"header\"</span>>\n    </div>\n    <div v-if=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$slot</span>.subheader\"</span> class=<span class=\"hljs-string\">\"c-base-popup__subheader\"</span>>\n      <slot name=<span class=\"hljs-string\">\"subheader\"</span>>\n    </div>\n    <div class=<span class=\"hljs-string\">\"c-base-popup__body\"</span>>\n      <h1>{{ title }}</h1>\n      <p v-if=<span class=\"hljs-string\">\"description\"</span>>{{ description }}</p>\n    </div>\n    <div v-if=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$slot</span>.actions\"</span> class=<span class=\"hljs-string\">\"c-base-popup__actions\"</span>>\n      <slot name=<span class=\"hljs-string\">\"actions\"</span>>\n    </div>\n    <div v-if=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$slot</span>.footer\"</span> class=<span class=\"hljs-string\">\"c-base-popup__footer\"</span>>\n      <slot name=<span class=\"hljs-string\">\"footer\"</span>>\n    </div>\n  </div>\n</template>\n\n<script>\n<span class=\"hljs-built_in\">export</span> default {\n  props: {\n    description: {\n      <span class=\"hljs-built_in\">type</span>: String,\n      default: null\n    },\n    title: {\n      <span class=\"hljs-built_in\">type</span>: String,\n      required: <span class=\"hljs-literal\">true</span>\n    }\n  }\n}\n</script>\n\n<span class=\"copy-code-btn copy-014\">复制代码</span></code></pre><p>我的观点是，从经验来看，那些知道何时使用 slot 的开发人员所构建的项目确实会对其未来的可维护性产生很大的影响。由于发送的事件更少，代码更容易理解，而且提供了更大的灵活性，可以在其中显示任何组件。</p>\n<blockquote>\n<p>️ 敲黑板：根据经验，当你开始在父组件中复制子组件的 prop 时，你就应该考虑使用 slot 了。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">2. 合理组织 Vuex Store</h2>\n<p>通常，Vue.js 新手开始了解Vuex，因为他们刚好碰到了这两个问题：</p>\n<ul>\n<li>组件树结构中相隔太远的组件之间访问数据</li>\n<li>组件销毁后需要持久化数据</li>\n</ul>\n<p>这个时候他们就会创建第一个 Vuex store，学习模块并开始在应用程序中组织它们。</p>\n<p>问题在于，创建模块时没有单一的模式可以遵循。然而，我强烈建议你仔细考虑如何组织它们。据我所见，大多数开发人员更喜欢根据功能来组织它们。例如:</p>\n<ul>\n<li>Auth.</li>\n<li>Blog.</li>\n<li>Inbox.</li>\n<li>Settings.</li>\n</ul>\n<p>就我来说，我发现根据从 API 获取的数据模型来组织它们更容易理解。例如:</p>\n<ul>\n<li>Users</li>\n<li>Teams</li>\n<li>Messages</li>\n<li>Widgets</li>\n<li>Articles</li>\n</ul>\n<p>如何选择取决于你自己。唯一需要记住的是，从长远来看，一个组织良好的 Vuex store 会造就一个更高效的团队。它还将使新人在加入团队时更容易将他们的想法围绕在你的代码基础上。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">3. 使用 action 发起 API 调用和提交数据</h2>\n<p>我的大部分 API 调用（如果不是全部）是在Vuex action 里面完成的。你可能会问：为什么要这么做？ 🤨\n🤷‍♀️ 简单来说，它们中的大多数获取的数据需要提交到 store里去。另外，它们还提供了一层封装和可重用性，我很喜欢用。还有一些原因如下：</p>\n<ul>\n<li>\n<p>如果我需要在两个地方（假设是博客页面和首页）获取文章的第一页，我只需要用正确的参数调用合适的 dispatcher 就行了。除了 dispatcher 调用，无需重复代码就可以完成数据的获取，commit 到 store 和返回。</p>\n</li>\n<li>\n<p>如果我需要写一些避免重复获取第一页的逻辑，我就可以在一个地方完成。这样做除了会减轻服务器负载，还会增强我对代码的信心。</p>\n</li>\n<li>\n<p>我可以跟踪这些操作中的大多数 Mixpanel（一个网站用户行为分析工具） 事件，这使得分析代码非常容易维护。我确实有一些应用程序，其中所有的 Mixpanel 调用都是只在 action 中完成的。我不需要了解哪些数据被跟踪，哪些没有，以及什么时候发送这些信息。以这种工作方式的乐趣简直无法言说。</p>\n</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-3\">4. 用 mapState，mapGetters，mapMutations 和 mapActions 简化代码</h2>\n<p>通常不需要创建多个计算属性或方法，只需在组件内部访问 state/getters 或者调用 actions/mutations 。使用<code>mapState</code>，<code>mapGetters</code>，<code>mapMutations</code> 和 <code>mapActions</code> \n可以帮助你简化代码，把来自 store 模块的数据分组到一起，让代码更容易理解。</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">// NPM\nimport { mapState, mapGetters, mapActions, mapMutations } from <span class=\"hljs-string\">\"vuex\"</span>;\n\n<span class=\"hljs-built_in\">export</span> default {\n  computed: {\n    // Accessing root properties\n    ...mapState(<span class=\"hljs-string\">\"my_module\"</span>, [<span class=\"hljs-string\">\"property\"</span>]),\n    // Accessing getters\n    ...mapGetters(<span class=\"hljs-string\">\"my_module\"</span>, [<span class=\"hljs-string\">\"property\"</span>]),\n    // Accessing non-root properties\n    ...mapState(<span class=\"hljs-string\">\"my_module\"</span>, {\n      property: state => state.object.nested.property\n    })\n  },\n\n  methods: {\n    // Accessing actions\n    ...mapActions(<span class=\"hljs-string\">\"my_module\"</span>, [<span class=\"hljs-string\">\"myAction\"</span>]),\n    // Accessing mutations\n    ...mapMutations(<span class=\"hljs-string\">\"my_module\"</span>, [<span class=\"hljs-string\">\"myMutation\"</span>])\n  }\n};\n\n<span class=\"copy-code-btn copy-015\">复制代码</span></code></pre><p>有关以上工具方法的所有信息都在 <a target=\"_blank\" href=\"https://vuex.vuejs.org/guide/modules.html\" rel=\"nofollow noopener noreferrer\"> Vuex 官方文档</a>。🤩</p>\n<h2 class=\"heading\" data-id=\"heading-4\">5. 使用 API 工厂</h2>\n<p>我通常喜欢写一个<code>this.$api</code> 助手，以便在任何地方调用，获取后台 API 资源。在我的项目根目录有一个<code>api</code> 文件夹，包含了所有相关的类。如下所示（仅部分）：</p>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">api\n├── auth.js\n├── notifications.js\n└── teams.js\n\n<span class=\"copy-code-btn copy-016\">复制代码</span></code></pre><p>每个文件都将其类别下的所有 API 资源分组。下面是我在 Nuxt 应用中使用插件初始化这个模式的方法（在标准的 Vue 应用中的过程也类似）。</p>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">// PROJECT: API\nimport Auth from <span class=\"hljs-string\">\"@/api/auth\"</span>;\nimport Teams from <span class=\"hljs-string\">\"@/api/teams\"</span>;\nimport Notifications from <span class=\"hljs-string\">\"@/api/notifications\"</span>;\n\n<span class=\"hljs-built_in\">export</span> default (context, inject) => {\n  <span class=\"hljs-keyword\">if</span> (process.client) {\n    const token = <span class=\"hljs-built_in\">local</span>Storage.getItem(<span class=\"hljs-string\">\"token\"</span>);\n    // Set token when defined\n    <span class=\"hljs-keyword\">if</span> (token) {\n      context.<span class=\"hljs-variable\">$axios</span>.setToken(token, <span class=\"hljs-string\">\"Bearer\"</span>);\n    }\n  }\n  // Initialize API repositories\n  const repositories = {\n    auth: Auth(context.<span class=\"hljs-variable\">$axios</span>),\n    teams: Teams(context.<span class=\"hljs-variable\">$axios</span>),\n    notifications: Notifications(context.<span class=\"hljs-variable\">$axios</span>)\n  };\n  inject(<span class=\"hljs-string\">\"api\"</span>, repositories);\n};\n\n<span class=\"copy-code-btn copy-017\">复制代码</span></code></pre><pre><code class=\"hljs bash copyable code-04\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default <span class=\"hljs-variable\">$axios</span> => ({\n  forgotPassword(email) {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-variable\">$axios</span>.<span class=\"hljs-variable\">$post</span>(<span class=\"hljs-string\">\"/auth/password/forgot\"</span>, { email });\n  },\n\n  login(email, password) {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-variable\">$axios</span>.<span class=\"hljs-variable\">$post</span>(<span class=\"hljs-string\">\"/auth/login\"</span>, { email, password });\n  },\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">logout</span></span>() {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-variable\">$axios</span>.<span class=\"hljs-variable\">$get</span>(<span class=\"hljs-string\">\"/auth/logout\"</span>);\n  },\n\n  register(payload) {\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-variable\">$axios</span>.<span class=\"hljs-variable\">$post</span>(<span class=\"hljs-string\">\"/auth/register\"</span>, payload);\n  }\n});\n\n<span class=\"copy-code-btn copy-018\">复制代码</span></code></pre><p>现在，我可以简单地在我的组件或 Vuex action 里像这样调用它们：</p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default {\n  methods: {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">onSubmit</span></span>() {\n      try {\n        this.<span class=\"hljs-variable\">$api</span>.auth.login(this.email, this.password);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n};\n\n<span class=\"copy-code-btn copy-019\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-5\">6. 使用 $config 访问环境变量（在模板里特别有用）</h2>\n<p>你的项目可能在一些文件中定义了一些全局配置变量：</p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">config\n├── development.json\n└── production.json\n\n<span class=\"copy-code-btn copy-020\">复制代码</span></code></pre><p>我喜欢通过 <code>this.$config</code> 助手快速访问它们，特别是在模板里。像往常一样，扩展 Vue 对象非常容易：</p>\n<pre><code class=\"hljs bash copyable code-07\" lang=\"bash\">// NPM\nimport Vue from <span class=\"hljs-string\">\"vue\"</span>;\n\n// PROJECT: COMMONS\nimport development from <span class=\"hljs-string\">\"@/config/development.json\"</span>;\nimport production from <span class=\"hljs-string\">\"@/config/production.json\"</span>;\n\n<span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV === <span class=\"hljs-string\">\"production\"</span>) {\n  Vue.prototype.<span class=\"hljs-variable\">$config</span> = Object.freeze(production);\n} <span class=\"hljs-keyword\">else</span> {\n  Vue.prototype.<span class=\"hljs-variable\">$config</span> = Object.freeze(development);\n}\n\n<span class=\"copy-code-btn copy-021\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-6\">7.  按照某个约定来给代码提交命名</h2>\n<p>随着项目的增长，你可能需要定期浏览组件的历史记录。如果你的团队没有遵循相同的约定来命名他们的提交，那么理解每个提交将会变得更加困难。</p>\n<p>我一直推荐使用 <a target=\"_blank\" href=\"https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines\" rel=\"nofollow noopener noreferrer\">Angular 提交信息指南</a>。我在每个项目中都遵循它，在很多情况下，其他团队成员很快就会发现遵循它带来的好处。</p>\n<p>遵循这些指导原则可以得到更具可读性的信息，这使得在查看项目历史记录时更容易跟踪提交。简而言之，它是这样工作的：</p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">git commit -am <span class=\"hljs-string\">\"<type>(<scope>): <subject>\"</span>\n\n<span class=\"hljs-comment\"># 举例</span>\ngit commit -am <span class=\"hljs-string\">\"docs(changelog): update changelog to beta.5\"</span>\ngit commit -am <span class=\"hljs-string\">\"fix(release): need to depend on latest rxjs and zone.js\"</span>\n\n<span class=\"copy-code-btn copy-022\">复制代码</span></code></pre><p>看下他们的 <a target=\"_blank\" href=\"https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines\" rel=\"nofollow noopener noreferrer\">README 文件</a> 了解更多了解更多关于它和相关约定。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">8. 项目上线后固定 package 版本</h2>\n<p>我知道，所有 package 都应该遵循<a target=\"_blank\" href=\"https://semver.org/\" rel=\"nofollow noopener noreferrer\">语义化版本规则</a>。但现实情况是，有些根本没有遵守。</p>\n<p>为了避免因为某个依赖项破坏了整个项目而不得不在半夜醒来，锁定所有 package 版本可以让你的早晨工作压力更小。</p>\n<p>它的意思很简单：避免使用带 <code>^</code> 前缀的版本号：</p>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">{\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"my project\"</span>,\n\n  <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n\n  <span class=\"hljs-string\">\"private\"</span>: <span class=\"hljs-literal\">true</span>,\n\n  <span class=\"hljs-string\">\"dependencies\"</span>: {\n    <span class=\"hljs-string\">\"axios\"</span>: <span class=\"hljs-string\">\"0.19.0\"</span>,\n    <span class=\"hljs-string\">\"imagemin-mozjpeg\"</span>: <span class=\"hljs-string\">\"8.0.0\"</span>,\n    <span class=\"hljs-string\">\"imagemin-pngquant\"</span>: <span class=\"hljs-string\">\"8.0.0\"</span>,\n    <span class=\"hljs-string\">\"imagemin-svgo\"</span>: <span class=\"hljs-string\">\"7.0.0\"</span>,\n    <span class=\"hljs-string\">\"nuxt\"</span>: <span class=\"hljs-string\">\"2.8.1\"</span>,\n  },\n\n  <span class=\"hljs-string\">\"devDependencies\"</span>: {\n    <span class=\"hljs-string\">\"autoprefixer\"</span>: <span class=\"hljs-string\">\"9.6.1\"</span>,\n    <span class=\"hljs-string\">\"babel-eslint\"</span>: <span class=\"hljs-string\">\"10.0.2\"</span>,\n    <span class=\"hljs-string\">\"eslint\"</span>: <span class=\"hljs-string\">\"6.1.0\"</span>,\n    <span class=\"hljs-string\">\"eslint-friendly-formatter\"</span>: <span class=\"hljs-string\">\"4.0.1\"</span>,\n    <span class=\"hljs-string\">\"eslint-loader\"</span>: <span class=\"hljs-string\">\"2.2.1\"</span>,\n    <span class=\"hljs-string\">\"eslint-plugin-vue\"</span>: <span class=\"hljs-string\">\"5.2.3\"</span>\n  }\n}\n\n<span class=\"copy-code-btn copy-023\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-8\">9. 在显示大量数据时使用 Vue Virtual Scroller</h2>\n<p>当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，你可以使用<a target=\"_blank\" href=\"https://github.com/akryum/vue-virtual-scroller\" rel=\"nofollow noopener noreferrer\">vue-virtual-scoller</a>。</p>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\">npm install vue-virtual-scroller\n\n<span class=\"copy-code-btn copy-024\">复制代码</span></code></pre><p>它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。它真的很容易使用，如丝般顺滑！✨</p>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\"><template>\n  <RecycleScroller\n    class=<span class=\"hljs-string\">\"scroller\"</span>\n    :items=<span class=\"hljs-string\">\"list\"</span>\n    :item-size=<span class=\"hljs-string\">\"32\"</span>\n    key-field=<span class=\"hljs-string\">\"id\"</span>\n    v-slot=<span class=\"hljs-string\">\"{ item }\"</span>\n  >\n    <div class=<span class=\"hljs-string\">\"user\"</span>>\n      {{ item.name }}\n    </div>\n  </RecycleScroller>\n</template>\n\n<span class=\"copy-code-btn copy-025\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-9\">10. 跟踪第三方包的大小</h2>\n<p>当很多人在同一个项目中工作时，如果没人关注安装包的数量，那么很快就会越来越多。为了避免应用程序变慢(特别是在移动网络变慢的情况下)，我在 VS Code 中使用了 <a target=\"_blank\" href=\"https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost\" rel=\"nofollow noopener noreferrer\">import cost 插件</a>。这样，我就可以从我的编辑器中看到导入的模块库有多大，并且可以在它变得太大时检查出问题。</p>\n<p>例如，在最近的一个项目中，整个 lodash 库被导入(大约有24kB的gzipped)。结果只使用了 cloneDeep 方法。通过 import cost 插件定位到这个问题，我们是这样解决的：</p>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\">npm remove lodash\nnpm install lodash.clonedeep\n\n<span class=\"copy-code-btn copy-026\">复制代码</span></code></pre><p>cloneDeep 函数可以在需要的地方引入：</p>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">import <span class=\"hljs-built_in\">clone</span>Deep from <span class=\"hljs-string\">\"lodash.clonedeep\"</span>;\n\n<span class=\"copy-code-btn copy-027\">复制代码</span></code></pre><blockquote>\n<p>️ 要进一步优化，你可以使用 <a target=\"_blank\" href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" rel=\"nofollow noopener noreferrer\">Webpack Bundle Analyzer </a> ，用交互式的可缩放地图可视化文件大小。</p>\n</blockquote>\n<hr>\n<p></p><figure><img alt=\"Webpack Bundle Analyzer\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e643bc4e63d0b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1240\" data-height=\"605\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1240\" height=\"605\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>关于处理大型 Vue 代码库，你还有其他最佳实践可以分享的吗？欢迎在评论区留言。</p>\n<p><a target=\"_blank\" href=\"https://www.telerik.com/blogs/10-good-practices-building-maintaining-large-vuejs-projects\" rel=\"nofollow noopener noreferrer\">原文</a></p>\n<h4 class=\"heading\" data-id=\"heading-10\">交流</h4>\n<p>欢迎关注微信公众号“1024译站”，为你奉上更多技术干货。\n</p><figure><img alt=\"公众号：1024译站\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/10/16e53d941905a70a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"129\" data-height=\"129\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"129\" height=\"129\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "2ufzg9qxnh60",
      "author": "政采云前端团队",
      "title": "构建大型 Vue.js 项目的10条建议",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\"><strong><table><tbody><tr><td bgcolor=\"#FDFFE7\"><font size=\"4\">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table></strong></h2>\n<blockquote>\n<p>本文首发于政采云前端团队博客： <a target=\"_blank\" href=\"https://www.zoo.team/article/slot\" rel=\"nofollow noopener noreferrer\">让你的组件千变万化，Vue slot 剖玄析微</a></p>\n</blockquote>\n<p></p><figure><img alt=\"季节.png\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/9/16e508787bc8e161?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"200\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"200\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-1\">（一）前言</h3>\n<p>Vue 代码中的 slot 是什么，简单来说就是插槽。 <code><slot></code> 元素作为组件模板之中的内容分发插槽，传入内容后 <code><slot></code>  元素自身将被替换。</p>\n<p>看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。</p>\n<p>举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 <code>slot</code> 作为 HTML 结构的传递入口来解决问题。</p>\n<h3 class=\"heading\" data-id=\"heading-2\">（二）v-slot 用法</h3>\n<p>在 2.6.0 版本中，Vue 为具名插槽和作用域插槽引入了一个新的统一的语法 （即 <code><v-slot></code> 指令）。它取代了  <code>slot</code> 和  <code>slot-scope</code> 这两个目前已被废弃、尚未移除，仍在<a target=\"_blank\" href=\"https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95\" rel=\"nofollow noopener noreferrer\">文档中</a>的特性。</p>\n<p>使用方法可以分为三类：<strong>默认插槽</strong>、<strong>具名插槽</strong>以及<strong>作用域插槽</strong>。</p>\n<h4 class=\"heading\" data-id=\"heading-3\"><strong>◎ 默认插槽</strong></h4>\n<p><strong>子组件编写</strong>：在组件中添加  <code><slot></code> 元素，来确定渲染的位置。</p>\n<pre><code class=\"hljs Vue copyable code-00\" lang=\"Vue\">  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的，当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 -->\n        <slot>默认值</slot>\n      </header>\n    </div>\n  </template>\n<span class=\"copy-code-btn copy-08\">复制代码</span></code></pre><p><strong>父组件编写</strong>：任何没有被包裹在带有 v-slot 的 <code><template></code> 中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， <code><v-slot></code> 标签可以直接用在组件上，也就是独占默认插槽的写法</p>\n<pre><code class=\"hljs Vue copyable code-01\" lang=\"Vue\">  // 父组件\n  <template>\n    <div class=\"container\">\n      <!-- 默认插槽-->\n      <child>\n        任意内容\n        <template>内容</template>\n        中间内容\n        <!-- <template v-slot:default>但如果你定义了 default 之后，其他内容就不会出现了，原理同上，不能重复定义</template> -->\n      </child>\n    \n      <!-- 独占默认插槽的缩写 -->\n      <child v-slot=\"slotProps\">\n        当只有默认插槽时，此为独占默认插槽的缩写<br>\n        如果组件中有其他具名插槽，这么写会报错<br>\n        slotProps 取的是，子组件标签 slot 上属性数据的集合\n      </child>\n    </div>\n  </template>\n<span class=\"copy-code-btn copy-09\">复制代码</span></code></pre><p><strong>渲染结果</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63f27fcba905e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1228\" data-height=\"243\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1228\" height=\"243\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-4\"><strong>◎ 具名插槽</strong></h4>\n<p><strong>子组件编写</strong>：当需要使用多个插槽时，为 <code><slot></code> 元素添加 <code>name</code> 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。</p>\n<pre><code class=\"hljs Vue copyable code-02\" lang=\"Vue\">  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      <footer class=\"text\">\n        <slot name=\"footer\"></slot>\n      </footer>\n    </div>\n  </template>\n<span class=\"copy-code-btn copy-010\">复制代码</span></code></pre><p><strong>父组件编写</strong>：<code><template></code> 标签中添加 <code>v-slot:xxx</code> 或者 <code>#xxx</code> 属性的内容， # 代表插槽的缩写。</p>\n<pre><code class=\"hljs Vue copyable code-03\" lang=\"Vue\">  // 父组件\n  <template>\n    <div class=\"container\">\n      <!-- 具名插槽使用 -->\n      <child>\n        <template v-slot:main>\n          <a href=\"https://www.zcygov.cn\" target=\"_blank\">导航</a>\n        </template>\n        <template #footer>页脚（具名插槽的缩写#）</template>\n        <template #footer>\n          <!--  v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 -->\n          v-slot只会添加在一个 template 上面\n        </template>\n      </child>\n    </div>\n  </template>\n<span class=\"copy-code-btn copy-011\">复制代码</span></code></pre><p><strong>渲染结果</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63f27fcfdff39?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1227\" data-height=\"136\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1227\" height=\"136\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-5\"><strong>◎ 作用域插槽</strong></h4>\n<p><strong>子组件编写</strong>：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 <code><slot></code> 元素上的特性称为<strong>插槽 Prop</strong> ，当然也可以传递一些 <code>Function</code>。</p>\n<pre><code class=\"hljs Vue copyable code-04\" lang=\"Vue\">  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    },\n    methods:{\n      testClick(){\n      \t// 子组件通用方法，可传递给父组件复用\n        alert('123');\n      }\n    }\n  };\n  </script>\n<span class=\"copy-code-btn copy-012\">复制代码</span></code></pre><p><strong>父组件编写</strong>：被绑定的属性的集合对象，在父元素中会被 <code>v-slot:xxx=\"slotProps\"</code> 或者 <code>#xxx=\"slotProps\"</code> 接收，xxx 代表具名插槽的 <code>name</code> ，slotProps 为子组件传递的数据对象，可以重命名。</p>\n<pre><code class=\"hljs Vue copyable code-05\" lang=\"Vue\">  // 父组件\n  <template>\n    <div class=\"container\">\n      <!-- 作用域插槽，以及解构插槽 Prop 的写法 -->\n      <child>\n        <template #footer=\"slotProps\">\n          {{slotProps.user.title}}\n          <button @click=\"slotProps.testClick\">点我</button>\n        </template>\n        <template #footer=\"{user,testClick}\">\n          {{user.title}}<br>\n          此为解构插槽prop<br>\n          <!-- 子组件中的通用方法，可传递给父组件复用 -->\n          <button @click=\"testClick\">点我</button>\n        </template>\n      </child>\n    </div>\n  </template>\n\n  <script>\n  import Child from './component/child.vue';\n  export default {\n    name: 'demo',\n    components: {\n      Child\n    },\n  };\n  </script>\n<span class=\"copy-code-btn copy-013\">复制代码</span></code></pre><p><strong>渲染结果</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63f27fde9ecd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1231\" data-height=\"155\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1231\" height=\"155\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">◎ 其他拓展</h4>\n<ul>\n<li>解构插槽 prop 可以重命名，例如：<code>v-slot=\"{ user: person }\"</code>  将 user 对象重命名为 person 使用。</li>\n<li>解构插槽 prop 可以赋值默认值，例如：<code>v-slot=\"{ user = { name: 'Guest' } }\"</code> 给属性添加自定义后备内容。</li>\n<li>动态插槽命名，例如：<code>v-slot:[dynamicSlotName]</code> ，支持命名变量定义。</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-7\">◎ 注意事项</h4>\n<ul>\n<li>\n<p><code>v-slot</code> 只能用在 <code>template</code> 上面，或者是独占默认插槽的写法。</p>\n</li>\n<li>\n<p>父组件引用时 ，重复定义了 <code>v-slot</code> 的 <code>name</code> 后只会加载最后一个定义的插槽内容。</p>\n</li>\n<li>\n<p>当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 <code>template</code> 的语法。</p>\n</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-8\">（三）slot 以及 slot-scope 的用法</h3>\n<p>介绍完 v-slot 的基本用法，这里我们也顺带介绍一下之前的 <code>slot</code> 和 <code>slot-scope</code> 的用法以及区别。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">◎ 子组件编写</h4>\n<p>子组件的编写方式没什么区别，下面是一个集合</p>\n<pre><code class=\"hljs Vue copyable code-06\" lang=\"Vue\">  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <slot>默认值</slot>\n      </header>\n      \n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      \n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    }\n  };\n  </script>\n<span class=\"copy-code-btn copy-014\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-10\">◎ 父组件编写</h4>\n<ul>\n<li>\n<p>具名插槽：直接使用 <code>slot</code> 属性，传值为子组件插槽的 <code>name</code> 属性。</p>\n</li>\n<li>\n<p>作用域插槽：通过 <code>slot-scope</code> 属性来接受子组件传入的属性集合，其他用法一致。</p>\n</li>\n</ul>\n<pre><code class=\"hljs Vue copyable code-07\" lang=\"Vue\">  // 父组件\n <template>\n   <div class=\"container\">\n     <child>\n       <!-- 默认插槽 -->\n       <div>默认插槽</div> \n      \n       <!-- 具名插槽 -->\n       <div slot=\"main\">具名插槽</div>\n       <div slot=\"main\">具名插槽2</div>\n      \n       <!-- 作用域插槽 -->\n       <div slot=\"footer\" slot-scope=\"slotProps\">\n         {{slotProps.user.title}}\n       </div>\n     </child>\n   </div>\n </template>\n\n <script>\n import Child from './component/child.vue';\n export default {\n   name: 'demo',\n   components: {\n     Child\n   },\n };\n </script>\n<span class=\"copy-code-btn copy-015\">复制代码</span></code></pre><p>最终渲染</p>\n<p></p><figure><img alt=\"渲染\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e409724d6d0ad2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1245\" data-height=\"157\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1245\" height=\"157\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-11\">◎ 需要注意</h4>\n<ul>\n<li>\n<p>不同于 <code>v-slot</code> 的是，<code>slot</code> 中同名可以重复定义多次。</p>\n</li>\n<li>\n<p><code>slot</code> 可以直接定义在子组件上。</p>\n</li>\n<li>\n<p>v3.0 版本后不可使用 <code>slot</code> ，建议直接使用 <code>v-slot</code> 。</p>\n</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-12\">（四）总结</h3>\n<ul>\n<li>插槽的 <code><slot></code> 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。</li>\n<li>插槽可以传递属性值或者 <code>function</code> 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-13\">招贤纳士</h2>\n<p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p>\n<p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/8/29/16cddbe09f60b388?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"365\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"365\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">推荐阅读</h2>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5dc15b35f265da4d432a3d10\" rel>可能是最全的 “文本溢出截断省略” 方案合集</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" rel>前端工程实践之可视化搭建系统（一）</a></p>\n<p><a target=\"_blank\" href=\"https://juejin.im/post/5d6de51de51d45620771f12c\" rel>自动化 Web 性能优化分析方案</a></p>\n",
      "id": "4b1ckg8sz840",
      "author": "陈大鱼头",
      "title": "让你的组件千变万化，Vue slot 剖玄析微",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<ul>\n<li>作者：陈大鱼头</li>\n<li>github： <a target=\"_blank\" href=\"https://github.com/KRISACHAN\" rel=\"nofollow noopener noreferrer\">KRISACHAN</a></li>\n</ul>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>最近听说TypeScript3.7添加了对<a target=\"_blank\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining\" rel=\"nofollow noopener noreferrer\">Optional Chaining</a>的支持，然后就想着给鱼头的脚手架<a target=\"_blank\" href=\"https://github.com/KRISACHAN/ying-template\" rel=\"nofollow noopener noreferrer\">ying-template</a>的TS版本升级，然后在命令行发现这样的一句信息：</p>\n<blockquote>\n<p>'postcss-cssnext' 已经被 'postcss-preset-env'代替了。详情请查看 <a target=\"_blank\" href=\"https://moox.io/blog/deprecating-cssnext/\" rel=\"nofollow noopener noreferrer\">moox.io/blog/deprec…</a></p>\n</blockquote>\n<p>其实鱼头的脚手架里早就把<code>postcss-cssnext</code>换成了<code>postcss-preset-env</code>，不过一直没删，但是看到这句话之后，处于好奇，就去翻了翻<strong>PostCSS</strong>的官网，然后又思考了下这些年CSS的发展历程，遂有这篇文章的出炉。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">浅谈现代化的CSS</h2>\n<p>从1997年 <code>CSS1.0</code> 发布到如今，从最开始只支持简单的文字排版到如今已经可以做出酷炫的3D动画，CSS已经走过了22个年头，其发展如图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63593dca434b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1139\" data-height=\"521\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1139\" height=\"521\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>[图片来自<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Archive/CSS3\" rel=\"nofollow noopener noreferrer\">MDN</a>]</p>\n<p>随着互联网的发展，人们对网页的要求已经是从只要展示图文就好变成了各种交互跟视觉效果都需要有着更多的体验要求。CSS为此也是不断的更新着。</p>\n<p>随着web业务日益复杂化和多元化，前端开发也从单纯的web page转变成web app，在此也诞生了“前端工程化”的概念，一个完备的web app往往会很大很复杂，甚至会有很多人共同维护，以往的拼页面，写jQuery已经是不足以支撑现代的需求。同样的，CSS也是如此，不再是内联写几个<code>margin</code>，<code>padding</code>或者HTML一股脑引入几个CSS就足够的，而且由于人员配置的增多，不同的开发，命名习惯，样式是否会冲突也是必须要考虑的。</p>\n<p>除了工程问题，还有就是CSS与浏览器之间的关系也是我们不得不考虑的，虽然CSS发展的很快，但是浏览器对CSS新特性支持的进度确实非常缓慢的。所以虽然某些属性已经推出了很多年，但是也往往因为浏览器的原因而无法进行大规模的使用。</p>\n<p>虽然在实际开发过程中，CSS有着这样那样让人无法忽略的问题，但是“方法总比困难多”，在前端界也有许多热心的大牛们在尝试着解决这些问题。这次让鱼头与大家一起分享下这些与CSS相关的技巧与方法。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">最初的CSS模块化 —— CSS命名规则</h2>\n<blockquote>\n<p>命名一直是开发者比较头疼的问题，在前端里，除了JS各种变量的命名，还有元素class的命名，虽然我们可以随意起名，愿意的话甚至可以使用<code>.a .b .c</code>等无意义的规则来命名，但是如果是一个长期的，大型的或多人协作的项目里这么命名，恐怕容易被人胖揍。这次我们来分享下业界常用的用来防挨揍的命名规则。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-3\">OOCSS(Object-Oriented CSS)</h3>\n<p>OOCSS有两个编写原则：</p>\n<ul>\n<li>结构与样式分离</li>\n<li>容器与内容分离</li>\n</ul>\n<p>我们来看看官网的一个例子：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63593d7625d23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"312\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"312\" height=\"100\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs html copyable code-00\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"mod grab\"</span>></span> \n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"top\"</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"tl\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"tr\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span> \n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"inner\"</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"hd\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">h3</span>></span>grab<span class=\"hljs-tag\"></<span class=\"hljs-name\">h3</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"bd\"</span>></span>\n            <span class=\"hljs-tag\"><<span class=\"hljs-name\">p</span>></span>Body<span class=\"hljs-tag\"></<span class=\"hljs-name\">p</span>></span>\n        <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"bottom\"</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"bl\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span>\n        <span class=\"hljs-tag\"><<span class=\"hljs-name\">b</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"br\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span>\n    <span class=\"hljs-tag\"></<span class=\"hljs-name\">b</span>></span> \n<span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn copy-022\">复制代码</span></code></pre><p>在这里<code>.mod</code>是父类，所有的类都是继承自它，<code>.grab</code>便是子类。</p>\n<p>至于<code>.top</code>、<code>.inner</code>与<code>bottom</code>，顾名思义就是不同位置的子盒子。</p>\n<p>这里是以“容器”为命名法则。</p>\n<h3 class=\"heading\" data-id=\"heading-4\">BEM</h3>\n<p>BEM 是块（Block）、 元素（Element）、修饰符（ Modifier）的单词集合。</p>\n<p>在选择器中，我们用以下三种符号来表示以上内容</p>\n<ul>\n<li><strong><code>-</code></strong> 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</li>\n<li><code>__</code> 双下划线：双下划线用来连接块和块的子元素</li>\n<li><code>_</code> 单下划线：单下划线用来描述一个块或者块的子元素的一种状态</li>\n</ul>\n<p>就像这样：<code>type-block__element_modifier</code></p>\n<p>官网的例子如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63593d7870e2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs html copyable code-01\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n    <span class=\"hljs-selector-class\">.button</span> {\n        <span class=\"hljs-attribute\">display</span>: inline-block;\n        <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">3px</span>;\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">7px</span> <span class=\"hljs-number\">12px</span>;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#D5D5D5</span>;\n        <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(#EEE, #DDD);\n        <span class=\"hljs-attribute\">font</span>: <span class=\"hljs-number\">700</span> <span class=\"hljs-number\">13px</span>/<span class=\"hljs-number\">18px</span> Helvetica, arial;\n    }\n    <span class=\"hljs-selector-class\">.button--state-success</span> {\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#FFF</span>;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#569E3D</span> <span class=\"hljs-built_in\">linear-gradient</span>(#79D858, #569E3D) repeat-x;\n        <span class=\"hljs-attribute\">border-color</span>: <span class=\"hljs-number\">#4A993E</span>;\n    }\n    <span class=\"hljs-selector-class\">.button--state-danger</span> {\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#900</span>;\n    }\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button\"</span>></span>\n\tNormal button\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button--state-success\"</span>></span>\n\tSuccess button\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button--state-danger\"</span>></span>\n\tDanger button\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">button</span>></span>\n<span class=\"copy-code-btn copy-023\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-5\">SMACSS</h3>\n<p>SMACSS，一个长得很像OOCSS的规则。</p>\n<p>核心只有以下6个：</p>\n<ul>\n<li>Base：页面的基本样式命名规则</li>\n<li>Layout：布局命名规则</li>\n<li>Module：模块规命名规则</li>\n<li>State：状态命名规则</li>\n<li>Theme：主题命名规则</li>\n<li>Changing State：可变状态的命名规则</li>\n</ul>\n<p>修饰符是<code>--</code>，子模块是<code>__</code></p>\n<p>官网的例子如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e6359456266278?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"500\" data-height=\"213\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"500\" height=\"213\"></svg>\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs html copyable code-02\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"undefined\">\n    #header { … }\n    #primarynav { … }\n    #maincontent { … }\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"header\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"primarynav\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"maincontent\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"copy-code-btn copy-024\">复制代码</span></code></pre><h2 class=\"heading\" data-id=\"heading-6\">为CSS赋能 —— 预处理器</h2>\n<blockquote>\n<p>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-7\">sass</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63595189d789b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"512\" data-height=\"385\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"512\" height=\"385\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>sass是诞生最早，也是世界上最成熟、最稳定、最强大的专业级CSS扩展语言！（官网说的(O_o)?? ）</p>\n<p>sass可用使用变量，嵌套规则，混合器，继承等编程语言才有的概念，代码例子如下：</p>\n<pre><code class=\"hljs scss copyable code-03\" lang=\"scss\"><span class=\"hljs-variable\">$nav-color</span>: <span class=\"hljs-number\">#F90</span>;\n<span class=\"hljs-selector-tag\">nav</span> {\n  <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-variable\">$width</span>;\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$nav-color</span>;\n}\n\n<span class=\"hljs-comment\">//编译后</span>\n\n<span class=\"hljs-selector-tag\">nav</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#F90</span>;\n}\n<span class=\"copy-code-btn copy-025\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-8\">less</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e6359456bf17b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"528\" data-height=\"234\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"528\" height=\"234\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p>\n<p>代码例子如下：</p>\n<pre><code class=\"hljs less copyable code-04\" lang=\"less\"><span class=\"hljs-variable\">@base:</span> <span class=\"hljs-number\">#f938ab</span>;\n\n<span class=\"hljs-selector-class\">.box-shadow</span>(<span class=\"hljs-variable\">@style</span>, <span class=\"hljs-variable\">@c</span>) <span class=\"hljs-keyword\">when</span> (iscolor(<span class=\"hljs-variable\">@c</span>)) {\n  <span class=\"hljs-attribute\">-webkit-box-shadow</span>: <span class=\"hljs-variable\">@style</span> <span class=\"hljs-variable\">@c</span>;\n  <span class=\"hljs-attribute\">box-shadow</span>:         <span class=\"hljs-variable\">@style</span> <span class=\"hljs-variable\">@c</span>;\n}\n<span class=\"hljs-selector-class\">.box-shadow</span>(<span class=\"hljs-variable\">@style</span>, <span class=\"hljs-variable\">@alpha</span>: <span class=\"hljs-number\">50%</span>) <span class=\"hljs-keyword\">when</span> (isnumber(<span class=\"hljs-variable\">@alpha</span>)) {\n  <span class=\"hljs-selector-class\">.box-shadow</span>(<span class=\"hljs-variable\">@style</span>, rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable\">@alpha</span>));\n}\n<span class=\"hljs-selector-class\">.box</span> {\n  <span class=\"hljs-attribute\">color</span>: saturate(<span class=\"hljs-variable\">@base</span>, <span class=\"hljs-number\">5%</span>);\n  <span class=\"hljs-attribute\">border-color</span>: lighten(<span class=\"hljs-variable\">@base</span>, <span class=\"hljs-number\">30%</span>);\n  <span class=\"hljs-selector-tag\">div</span> { <span class=\"hljs-selector-class\">.box-shadow</span>(<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">5px</span>, <span class=\"hljs-number\">30%</span>) }\n}\n\n<span class=\"hljs-comment\">// 编译后</span>\n<span class=\"hljs-selector-class\">.box</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#fe33ac</span>;\n  <span class=\"hljs-attribute\">border-color</span>: <span class=\"hljs-number\">#fdcdea</span>;\n}\n<span class=\"hljs-selector-class\">.box</span> <span class=\"hljs-selector-tag\">div</span> {\n  <span class=\"hljs-attribute\">-webkit-box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">5px</span> rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.3</span>);\n  <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">5px</span> rgba(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.3</span>);\n}\n<span class=\"copy-code-btn copy-026\">复制代码</span></code></pre><h4 class=\"heading\" data-id=\"heading-9\">stylus</h4>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e636060319d290?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"393\" data-height=\"241\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"393\" height=\"241\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>Stylus，富于表现力、动态的、健壮的 CSS</p>\n<p>代码例子如下：</p>\n<pre><code class=\"hljs stylus copyable code-05\" lang=\"stylus\"><span class=\"hljs-selector-tag\">body</span>\n  <span class=\"hljs-attribute\">font</span> <span class=\"hljs-number\">12px</span> Helvetica, Arial, sans-serif\n\n<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.button</span>\n  <span class=\"hljs-attribute\">border-radius</span> <span class=\"hljs-number\">5px</span>\n<span class=\"copy-code-btn copy-027\">复制代码</span></code></pre><p>完全不需要<code>{} : ;</code>的预处理器，个人是特别不喜欢这种写法，但是对于很多喜欢简洁的开发者来说，这确实非常好的编写方式</p>\n<h2 class=\"heading\" data-id=\"heading-10\">如魔法师一般的存在 —— CSS Houdini</h2>\n<blockquote>\n<p>有点时候眼看CSS出来新的属性，但是因为浏览器兼容的问题，所以往往是只能看而不能用，即便有的属性可以用，但也因为各浏览器的现实情况而存在意想不到的BUG，那么这就意味着一个属性出来之后我们要等到5年甚至更久之后才能使用吗？都9012年了耶？</p>\n<p>当然不是，接下来我们可以了解一下这个如魔法师一般的存在 —— CSS Houdini</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-11\">CSS Houdini是什么？</h3>\n<p>CSS Houdini是一组底层API，它们公开了CSS引擎的各个部分，从而使开发者可以通过这组API来扩展CSS。它让开发者拥有了直接访问CSSOM的能力，开发者可以通过这组API来编写浏览器可解析的CSS代码，这让开发者可以在不需要等待浏览器的实现的前提下实现自己想要的CSS功能。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e635945447ace1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"720\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"720\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>[图片来自：<a target=\"_blank\" href=\"https://www.qed42.com/blog/building-powerful-custom-properties-CSS-houdini\" rel=\"nofollow noopener noreferrer\">www.qed42.com/blog/buildi…</a>]</p>\n<p>如上所示，不同的API所对应的就是浏览器不同的渲染环节，用时下流行的概念来解释就是浏览器加载时不同生命周期的钩子函数。</p>\n<p>简单来说，CSS Houdini就是<strong>JS IN CSS</strong>，niubility ..</p>\n<h3 class=\"heading\" data-id=\"heading-12\">CSS Houdini是怎么工作的？</h3>\n<p>我们可访问的7个API如下：</p>\n<ol>\n<li>Typed OM API</li>\n<li>Properties & Values API</li>\n<li>Paint API</li>\n<li>Layout API</li>\n<li>Animation worklet</li>\n<li>Parser API</li>\n<li>Font Metrics API</li>\n</ol>\n<p>Mmmm，虽然是有7个API（Houdini drafts上还有一些），但浏览器实际的支持情况其实是这样的：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63594c93efe58?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"624\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"624\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>[图片来自：<a target=\"_blank\" href=\"https://ishoudinireadyyet.com/\" rel=\"nofollow noopener noreferrer\">ishoudinireadyyet.com/</a>]</p>\n<p>CSS Houdini的工作流程如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63594a8c66dca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"720\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"720\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>[图片来自：<a target=\"_blank\" href=\"https://www.qed42.com/blog/building-powerful-custom-properties-CSS-houdini\" rel=\"nofollow noopener noreferrer\">www.qed42.com/blog/buildi…</a>]</p>\n<ol>\n<li>钩子进入渲染的进程中</li>\n<li>JS是这个钩子的核心</li>\n<li>使用JS的Typed OM，可以挂载自定义的属性，绘制图形，布局以及动画</li>\n<li>还有其他两个API：Parser API 和 Font Metrics API。它们用于注册CSS相关的新事物</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-13\">一些示例</h3>\n<blockquote>\n<p>本篇不打算细讲CSS Houdini，所以不会画出所有的DEMO，有兴趣的可以查看底部的“资料来源”，从而获取更加详细的信息。</p>\n</blockquote>\n<p><strong>Typed OM</strong></p>\n<pre><code class=\"hljs html copyable code-06\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n    * {\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-selector-class\">.box</span> {\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(to right, #2c3e50, #4ca1af);\n    }\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"box\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"box\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span>></span><span class=\"javascript\"><span class=\"hljs-meta\">\n    'use strict'</span>\n    box.attributeStyleMap.set(<span class=\"hljs-string\">'width'</span>, CSS.px(<span class=\"hljs-number\">200</span>))\n    box.attributeStyleMap.set(<span class=\"hljs-string\">'height'</span>, CSS.px(<span class=\"hljs-number\">200</span>))\n    <span class=\"hljs-keyword\">const</span> [x, y] = <span class=\"hljs-string\">'width,height'</span>\n    .split(<span class=\"hljs-string\">','</span>)\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-built_in\">Number</span>.parseInt(box.computedStyleMap().get(val)))\n    box.attributeStyleMap.set(<span class=\"hljs-string\">'transform'</span>, <span class=\"hljs-keyword\">new</span> CSSTranslate(CSS.px(x), CSS.px(y)))\n    <span class=\"hljs-built_in\">console</span>.log(box.computedStyleMap().get(<span class=\"hljs-string\">'transform'</span>))\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.getComputedStyle(box, <span class=\"hljs-literal\">null</span>)[<span class=\"hljs-string\">'transform'</span>])\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn copy-028\">复制代码</span></code></pre><p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e6359458ab90bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"990\" data-height=\"441\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"990\" height=\"441\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>上面就是Typed OM的示例，这里值得一提的就是，如果我们用<code>getComputedStyle</code>去获取<code>transform</code>的值，最终结果是个矩阵，这其实不太方便我们做二次操作，但是用Typed OM的JS API <code>computedStyleMap</code>，去取的结果就是一个具体属性的集合，这是非常有利于我们进行二次操作的。</p>\n<p><strong>Paint API</strong></p>\n<p>Paint API就是允许你例如Canvas的属性来编写CSS样式，使用方法也很简单，我们可以看看<a target=\"_blank\" href=\"https://slides.iamvdo.me/waq19/#/35\" rel=\"nofollow noopener noreferrer\">slides.iamvdo.me/waq19/#/35</a>上的示例</p>\n<p>首先我们新建个文件叫<code>registerPaint.js</code>，在里面写下以下代码：</p>\n<pre><code class=\"hljs javascript copyable code-07\" lang=\"javascript\">registerPaint(<span class=\"hljs-string\">'circle-ripple'</span>, <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> </span>{\n  <span class=\"hljs-keyword\">static</span> get inputProperties() { <span class=\"hljs-keyword\">return</span> [ <span class=\"hljs-string\">'--circle-color'</span>,\n    <span class=\"hljs-string\">'--circle-radius'</span>, <span class=\"hljs-string\">'--circle-x'</span>, <span class=\"hljs-string\">'--circle-y'</span>\n  ]}\n  paint(ctx, geom, props, args) {\n    <span class=\"hljs-keyword\">const</span> x = props.get(<span class=\"hljs-string\">'--circle-x'</span>).value;\n    <span class=\"hljs-keyword\">const</span> y = props.get(<span class=\"hljs-string\">'--circle-y'</span>).value;\n    <span class=\"hljs-keyword\">const</span> radius = props.get(<span class=\"hljs-string\">'--circle-radius'</span>).value;\n  }\n}\n<span class=\"copy-code-btn copy-029\">复制代码</span></code></pre><p>然后再新建一个<code>index.html</code>，并且在JS代码里注册上面写好的<code>registerPaint.js</code>，方式如下：<code>CSS.paintWorklet.addModule('registerPaint.js');</code></p>\n<p>具体代码如下：</p>\n<pre><code class=\"hljs html copyable code-08\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n    <span class=\"hljs-selector-class\">.el</span> {\n          <span class=\"hljs-attribute\">--circle-radius</span>: <span class=\"hljs-number\">0</span>;\n          <span class=\"hljs-attribute\">--circle-color</span>: deepskyblue;\n          <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">paint</span>(circle-ripple);\n    }\n    <span class=\"hljs-selector-class\">.el</span><span class=\"hljs-selector-class\">.animating</span> {\n          <span class=\"hljs-attribute\">transition</span>: --circle-radius <span class=\"hljs-number\">1s</span>,\n                      --circle-color <span class=\"hljs-number\">1s</span>;\n          <span class=\"hljs-attribute\">--circle-radius</span>: <span class=\"hljs-number\">300</span>;\n          <span class=\"hljs-attribute\">--circle-color</span>: transparent;\n    }\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"el\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"el\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span>></span><span class=\"javascript\"><span class=\"hljs-meta\">\n    'use strict'</span>\n    CSS.paintWorklet.addModule(<span class=\"hljs-string\">'registerPaint.js'</span>);\n    el.addEventListener(<span class=\"hljs-string\">'click'</span>, e => {\n          el.classList.add(<span class=\"hljs-string\">'animating'</span>);\n          el.attributeStyleMap.set(<span class=\"hljs-string\">'--circle-x'</span>, e.offsetX);\n          el.attributeStyleMap.set(<span class=\"hljs-string\">'--circle-y'</span>, e.offsetY);\n    });\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn copy-030\">复制代码</span></code></pre><p>所以我们有以下的效果：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63594d3394a1b?imageslim\" data-width=\"257\" data-height=\"262\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"257\" height=\"262\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">CSS届的Babel —— PostCSS</h2>\n<blockquote>\n<p>说到底CSS Houdini其实也只是JS IN CSS，并不是纯正的CSS，那么对于一些新的CSS属性，我们相用的话，真的还得等5年后吗？还有即便是有各种工具，但是像一些兼容性写法，厂商前缀，循环，原生CSS也没有，我们不是还得需要依赖CSS预处理器吗？</p>\n<p>其实也不是，这时候我们可以利用CSS届的Babel —— PostCSS</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-15\">PostCSS是什么？</h3>\n<p>简单来说PostCSS就是可以让开发者使用JS来处理CSS的处理器，它分了以下5大类功能：</p>\n<h3 class=\"heading\" data-id=\"heading-16\">增强代码的可读性</h3>\n<p>利用从 Can I Use 网站获取的数据为 CSS 规则添加特定厂商的前缀。<a target=\"_blank\" href=\"https://github.com/postcss/autoprefixer\" rel=\"nofollow noopener noreferrer\">Autoprefixer</a> 自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。</p>\n<p>例如我们输入以下代码：</p>\n<pre><code class=\"hljs css copyable code-09\" lang=\"css\"><span class=\"hljs-selector-pseudo\">:fullscreen</span> {\n}\n<span class=\"copy-code-btn copy-031\">复制代码</span></code></pre><p>那么就会输出：</p>\n<pre><code class=\"hljs css copyable code-010\" lang=\"css\"><span class=\"hljs-selector-pseudo\">:-webkit-</span><span class=\"hljs-selector-pseudo\">:full-screen</span> {\n}\n<span class=\"hljs-selector-pseudo\">:-moz-</span><span class=\"hljs-selector-pseudo\">:full-screen</span> {\n}\n<span class=\"hljs-selector-pseudo\">:full-screen</span> {\n}\n<span class=\"copy-code-btn copy-032\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-17\">将未来的 CSS 特性带到今天！</h3>\n<p><a target=\"_blank\" href=\"https://preset-env.cssdb.org/\" rel=\"nofollow noopener noreferrer\">PostCSS Preset Env</a> 帮你将现代 CSS 语法转换成大多数浏览器都能理解的东西，根据你的目标浏览器或运行时环境来确定你需要的 polyfills，基于 <a target=\"_blank\" href=\"https://cssdb.org/\" rel=\"nofollow noopener noreferrer\">cssdb 实现</a>。</p>\n<p>例如我们输入以下代码：</p>\n<pre><code class=\"hljs css copyable code-011\" lang=\"css\">@custom-media --med (width <= 50rem);\n\n@media (--med) {\n  a { \n    &:hover {\n      color: color-mod(black alpha(54%));\n    }\n  }\n}\n<span class=\"copy-code-btn copy-033\">复制代码</span></code></pre><p>就会输出：</p>\n<pre><code class=\"hljs css copyable code-012\" lang=\"css\">@<span class=\"hljs-keyword\">media</span> (max-width: <span class=\"hljs-number\">50rem</span>) {\n  <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span>  { \n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgba</span>(0, 0, 0, 0.54);\n  }\n} \n<span class=\"copy-code-btn copy-034\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-18\">终结全局  CSS</h3>\n<p><a target=\"_blank\" href=\"https://github.com/css-modules/css-modules\" rel=\"nofollow noopener noreferrer\">CSS 模块</a> 就是说你永远不用担心命名太大众化而造成冲突太普通，只要用最有意义的名字就行了。</p>\n<p>例如我们输入以下代码：</p>\n<pre><code class=\"hljs css copyable code-013\" lang=\"css\"><span class=\"hljs-selector-class\">.name</span> {\n  <span class=\"hljs-attribute\">color</span>: gray;\n}\n<span class=\"copy-code-btn copy-035\">复制代码</span></code></pre><p>就会输出：</p>\n<pre><code class=\"hljs css copyable code-014\" lang=\"css\"><span class=\"hljs-selector-class\">.Logo__name__SVK0g</span> {\n  <span class=\"hljs-attribute\">color</span>: gray;\n}\n<span class=\"copy-code-btn copy-036\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-19\">避免  CSS 代码中的错误</h3>\n<p>通过使用 <a target=\"_blank\" href=\"http://stylelint.io/\" rel=\"nofollow noopener noreferrer\">stylelint 强化一致性约定并避免样式表中的错误</a>，stylelint 是一个现代化 CSS 代码检查工具。它支持最新的 CSS 语法，包括类似 CSS 的语法，例如 SCSS 。</p>\n<p>例如我们输入以下代码：</p>\n<pre><code class=\"hljs css copyable code-015\" lang=\"css\"><span class=\"hljs-selector-tag\">a</span> { \n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#d3</span>;\n}\n<span class=\"copy-code-btn copy-037\">复制代码</span></code></pre><p>那么控制台会抛出错误：</p>\n<pre><code class=\"hljs javascript copyable code-016\" lang=\"javascript\">app.css\n<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">10</span> Invalid hex color\n<span class=\"copy-code-btn copy-038\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-20\">强大的网格系统</h3>\n<p><a target=\"_blank\" href=\"https://github.com/peterramsing/lost\" rel=\"nofollow noopener noreferrer\">LostGrid</a> 利用 calc() 和你所定义的分割方式来创建网格系统，无需传递大量参数。</p>\n<p>例如我们输入以下代码：</p>\n<pre><code class=\"hljs css copyable code-017\" lang=\"css\"><span class=\"hljs-selector-tag\">div</span> {\n  <span class=\"hljs-attribute\">lost-column</span>: <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">3</span> \n}\n<span class=\"copy-code-btn copy-039\">复制代码</span></code></pre><p>就会输出：</p>\n<pre><code class=\"hljs css copyable code-018\" lang=\"css\"><span class=\"hljs-selector-tag\">div</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-built_in\">calc</span>(99.9% * 1/3 -  \n  (30px - 30px * 1/3)); \n}\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:nth-child(1n)</span> {\n  <span class=\"hljs-attribute\">float</span>: left; \n  <span class=\"hljs-attribute\">margin-right</span>: <span class=\"hljs-number\">30px</span>; \n  <span class=\"hljs-attribute\">clear</span>: none; \n}\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:last-child</span> {\n  <span class=\"hljs-attribute\">margin-right</span>: <span class=\"hljs-number\">0</span>; \n}\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:nth-child(3n)</span> {\n  <span class=\"hljs-attribute\">margin-right</span>: <span class=\"hljs-number\">0</span>; \n  <span class=\"hljs-attribute\">float</span>: right; \n}\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:nth-child(3n</span> + 1) {\n  <span class=\"hljs-attribute\">clear</span>: both; \n}\n<span class=\"copy-code-btn copy-040\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-21\">可窥探的未来 —— cssdb</h3>\n<blockquote>\n<p>cssdb是postcss-preset-env的实现基准，主要就是CSS的新功能功能及这些功能从提出到成为标准时所在的进程。</p>\n</blockquote>\n<p>cssdb跟ecma一样，对新属性分了不同的进程，具体的进程如下：</p>\n<ol>\n<li>Stage 0：脑袋风暴阶段。高度不稳定，可能会发生变化。</li>\n<li>Stage 1：实验阶段。也非常不稳定，可能会发生变化，但是该提案已得到W3C成员的认可。</li>\n<li>Stage 2：承认阶段。高度不稳定并且可能会发生变化，但是正在积极研究中。</li>\n<li>Stage3：拥抱阶段。稳定且变化不大，此功能可能会成为标准。</li>\n<li>Stage4：标准阶段。最终的解决方案，所有主流浏览器都支持。</li>\n</ol>\n<p>这就是postcss-preset-env依赖的实现基准，那么如果我们想要在我们的代码里使用这些Stage，该怎么做呢？</p>\n<p>以我的脚手架<code>ying-template</code>为例，我们来查看在webpack中的实际配置：</p>\n<p>首先我们先安装postcss以及其相应的插件：</p>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">npm install postcss postcss-loader postcss-preset-env postcss-nesting --save-dev\n<span class=\"copy-code-btn copy-041\">复制代码</span></code></pre><p>然后我们在webpack的config配置module中输入以下配置：</p>\n<pre><code class=\"hljs javascript copyable code-020\" lang=\"javascript\"><span class=\"hljs-built_in\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n        {\n            <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n            include,\n            exclude,\n            <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-comment\">/* 你其它的loader */</span> <span class=\"hljs-string\">'postcss-loader'</span>]\n        }\n    ]\n}\n<span class=\"copy-code-btn copy-042\">复制代码</span></code></pre><p>然后在根目录新建一个<code>postcss.config.js</code></p>\n<pre><code class=\"hljs javascript copyable code-021\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> postcssConfig = {\n    <span class=\"hljs-attr\">plugins</span>: {\n        <span class=\"hljs-attr\">precss</span>: {},\n        <span class=\"hljs-string\">'postcss-preset-env'</span>: {\n            <span class=\"hljs-attr\">browsers</span>: <span class=\"hljs-string\">'last 2 versions'</span>, <span class=\"hljs-comment\">// 浏览器兼容的版本</span>\n            stage: <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">// 你用的属性所在的阶段</span>\n        },\n        <span class=\"hljs-string\">'postcss-nesting'</span>: {} <span class=\"hljs-comment\">// 这里就是你所使用的插件</span>\n    }\n};\n<span class=\"hljs-built_in\">module</span>.exports = postcssConfig\n<span class=\"copy-code-btn copy-043\">复制代码</span></code></pre><p>这样就完成了，如果想看完整的配置，可以clone我的脚手架：<a target=\"_blank\" href=\"https://github.com/KRISACHAN/ying-template\" rel=\"nofollow noopener noreferrer\">github.com/KRISACHAN/y…</a></p>\n<p>（这是个多页面的webpack4脚手架，集成了babel 7，precss 4，typescript3.7，karma以及eslint等现代前端开发所需常用的东西，有兴趣的可以去看看。）</p>\n<p>我们可以通过<a target=\"_blank\" href=\"https://preset-env.cssdb.org/playground\" rel=\"nofollow noopener noreferrer\">preset-env.cssdb.org/playground</a>这个网站来查看具体的编译结果。</p>\n<p>编译结果图如下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e63595000e0f70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"624\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"624\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>是不是非常神奇呢？</p>\n<h2 class=\"heading\" data-id=\"heading-22\">后话</h2>\n<p>随着前端工程的普及，某E浏览器的没落，CSS的发展可谓是一日千里，近日也有一些数学属性的提案在发起，以后会发展成什么样，没人可以知道。只是总的来说，CSS的未来是一片光明的。本文简单分享了一些现代化的CSS知识，通过这些知识，我们很容易就能写出完备且现代化的CSS代码，能够给创造出更多的效益，希望大家可以积极地用起这些知识，并对CSS可以有更多的思考以及想象。</p>\n<p><strong>CSS，未来可期</strong></p>\n<h2 class=\"heading\" data-id=\"heading-23\">资料来源</h2>\n<ol>\n<li><a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Archive/CSS3\" rel=\"nofollow noopener noreferrer\">developer.mozilla.org/zh-CN/docs/…</a></li>\n<li><a target=\"_blank\" href=\"http://oocss.org/\" rel=\"nofollow noopener noreferrer\">oocss.org/</a></li>\n<li><a target=\"_blank\" href=\"http://getbem.com/\" rel=\"nofollow noopener noreferrer\">getbem.com/</a></li>\n<li><a target=\"_blank\" href=\"http://smacss.com/\" rel=\"nofollow noopener noreferrer\">smacss.com/</a></li>\n<li><a target=\"_blank\" href=\"https://sass-lang.com/\" rel=\"nofollow noopener noreferrer\">sass-lang.com/</a></li>\n<li><a target=\"_blank\" href=\"http://lesscss.org/\" rel=\"nofollow noopener noreferrer\">lesscss.org/</a></li>\n<li><a target=\"_blank\" href=\"http://stylus-lang.com/\" rel=\"nofollow noopener noreferrer\">stylus-lang.com/</a></li>\n<li><a target=\"_blank\" href=\"https://blog.techbridge.cc/2017/05/23/css-houdini/\" rel=\"nofollow noopener noreferrer\">blog.techbridge.cc/2017/05/23/…</a></li>\n<li><a target=\"_blank\" href=\"https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/\" rel=\"nofollow noopener noreferrer\">www.smashingmagazine.com/2016/03/hou…</a></li>\n<li><a target=\"_blank\" href=\"https://slides.iamvdo.me/waq19/fr/\" rel=\"nofollow noopener noreferrer\">slides.iamvdo.me/waq19/fr/</a></li>\n<li><a target=\"_blank\" href=\"https://www.qed42.com/blog/building-powerful-custom-properties-CSS-houdini\" rel=\"nofollow noopener noreferrer\">www.qed42.com/blog/buildi…</a></li>\n<li><a target=\"_blank\" href=\"https://www.postcss.com.cn/\" rel=\"nofollow noopener noreferrer\">www.postcss.com.cn/</a></li>\n<li><a target=\"_blank\" href=\"https://cssdb.org/#staging-process\" rel=\"nofollow noopener noreferrer\">cssdb.org/#staging-pr…</a></li>\n<li><a target=\"_blank\" href=\"https://s0dev0to.icopy.site/adrianbdesigns/postcss-preset-env-babel-for-css-12hp\" rel=\"nofollow noopener noreferrer\">s0dev0to.icopy.site/adrianbdesi…</a></li>\n</ol>\n<p>如果你、喜欢探讨技术，或者对本文有任何的意见或建议，你可以扫描下方二维码，关注微信公众号“ <strong>鱼头的Web海洋</strong> ”，随时与鱼头互动。欢迎！衷心希望可以遇见你。</p>\n<p></p><figure><img alt=\"qrcode-base\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/13/16e635953cc1972e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"560\" data-height=\"238\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"560\" height=\"238\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "3xbcscf7zpo0",
      "author": "郑闯",
      "title": "CSS的未来已来",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>首先这篇文章肯定是个标题党了，先给大家说声对不起。</p>\n<p>Angular肯定也有它不适用的场景，但是这一系列的文章是为了讲Angular，所以不管各位兄弟姐妹对自己钟爱的框架有多么热爱。这里也只会讲我自己在使用三种框架的过程中遇到的Angular中比较好解决的场景而React或者Vue中解决起来有些痛苦的场景。</p>\n<p>对不起了。。。。</p>\n<p>下面的场景有些只针对某一种框架，有些针对React和Vue两种框架。如果各位觉得自己用的框架解决起来还不错，请跳过这个场景。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">目录</h2>\n<ul>\n<li>场景一：<a target=\"_blank\" href=\"https://juejin.im/post/5dcc0b40e51d4510b72adf1b\" rel>表单</a></li>\n<li>场景七：<a target=\"_blank\" href=\"https://material.angular.cn/cdk/drag-drop/overview\" rel=\"nofollow noopener noreferrer\">拖拽</a></li>\n<li>场景九：<a target=\"_blank\" href=\"https://juejin.im/post/5dcd12bce51d4507f87d0659\" rel>安全导航操作符 ( ?. ) 和空属性路径 safe-navigation-operator</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">场景一： <a target=\"_blank\" href=\"https://juejin.im/post/5dcc0b40e51d4510b72adf1b\" rel>表单</a></h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e681b61f8dc021?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"897\" data-height=\"502\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"897\" height=\"502\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>Angular的项目就是可以保证所有的技术方案都能够统一。这才是框架存在的意义。</p>\n<h4 class=\"heading\" data-id=\"heading-3\">补充</h4>\n<p>感谢两位指出错误，已修改。关于动态表单的例子在<a target=\"_blank\" href=\"https://juejin.im/post/5dcc0b40e51d4510b72adf1b\" rel>Angular“吊打“React和Vue——表单</a>引用其他作者写的优秀文章进行说明。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e68811871d746b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1032\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1032\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">场景二：路由</h3>\n<ol>\n<li>当用户满足某些条件的时候可以进入某个页面（比如访问权限）</li>\n<li>在一个表单页面，如果用户填写表单之后，没有保存，在离开页面的时候要提示用户保存</li>\n<li>有一些接口或场景可能性能数据获取的比较慢，希望能够获取到数据之后再进行页面跳转（避免页面长时间的白屏）</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-5\">场景三： 环境变量</h3>\n<ol>\n<li>在不同的开发环境上，我们的测试账号也是不同的，如何不做各种逻辑判断让应用能够正确的在不同的环境上使用对应环境的数据</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-6\">场景四： module</h3>\n<ol>\n<li>多个组件使用十分多的其他封装好的公用组件的时候，React和Vue中每使用一个组件都需要重复的import（会出现一个组件文件的开头是大量的import）</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-7\">场景五： “最佳实践”</h3>\n<ol>\n<li>react和vue的用户可能每换一个公司甚至每换一个部门都要重新学习一下新的部门的“最佳实践”</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-8\">场景六： 业务代码的复用</h3>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/16/16e720032f4af17b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1236\" data-height=\"666\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1236\" height=\"666\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-9\">场景七：<a target=\"_blank\" href=\"https://material.angular.cn/cdk/drag-drop/overview\" rel=\"nofollow noopener noreferrer\">拖拽</a></h3>\n<p><a target=\"_blank\" href=\"https://material.angular.cn/cdk/drag-drop/overview\" rel=\"nofollow noopener noreferrer\">拖拽的例子</a></p>\n<h3 class=\"heading\" data-id=\"heading-10\">场景八： 对ts的支持</h3>\n<p>这里的Vue用户先想一想16年大漠穷秋在知乎上发布那些专栏的时候，那么多Vue的用户各种吐槽typescript的话。（真香警告）</p>\n<p>这里可以大言不惭的说，三大框架对ts支持最好的是Angular。</p>\n<p>想想你在React中使用ts的时候定义各种props和state的酸爽</p>\n<p>想想Vue中为了使用ts开发的vue-class-component（这不是学Angular的写法吗？那怎么不直接用Angular？？？？）</p>\n<h3 class=\"heading\" data-id=\"heading-11\">场景九： <a target=\"_blank\" href=\"https://juejin.im/post/5dcd12bce51d4507f87d0659\" rel>安全导航操作符 ( ?. ) 和空属性路径 safe-navigation-operator</a></h3>\n<p>这个特性在新的es版本里有提案<a target=\"_blank\" href=\"https://github.com/tc39/proposal-optional-chaining\" rel=\"nofollow noopener noreferrer\">参考地址</a></p>\n<p>而Angular从Angular2的时候就开始支持了</p>\n<p>安全导航这个特性可以吊打React中渲染多层嵌套的对象的数据的时候各种三元判断的恶心写法。</p>\n<p><a target=\"_blank\" href=\"https://angular.cn/guide/template-syntax#the-safe-navigation-operator----and-null-property-paths\" rel=\"nofollow noopener noreferrer\">安全导航操作符 ( ?. ) 和空属性路径</a></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e65d6938a05797?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"896\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"896\" height=\"1280\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>关于这个老哥的问题，我想在这里详细说一下。</p>\n<p>Angular有自己的设计思想，它不像Vue借鉴完anjularjs又去借鉴React。</p>\n<p>jsx这东西本来就是React强行加上去的。ts也只是为了照顾React的用户出了一个tsx。</p>\n<p>这东西是不是个好东西先不说。但不是说React有的Angular就也去借鉴。</p>\n<p>你可以用tsc生成一个配置文件。默认是不支持tsx的。你需要自己修改。</p>\n<h3 class=\"heading\" data-id=\"heading-12\">场景十： 管道</h3>\n<h3 class=\"heading\" data-id=\"heading-13\">场景十一： i18n</h3>\n<h3 class=\"heading\" data-id=\"heading-14\">十二：学习回报</h3>\n<p>学会了Angular你可以同时学会使用</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://ionicframework.com/docs/angular/your-first-app\" rel=\"nofollow noopener noreferrer\">Ionic</a>  一个Hybird应用开发框架</li>\n<li><a target=\"_blank\" href=\"https://www.nativescript.org/nativescript-is-how-you-build-native-mobile-apps-with-angular\" rel=\"nofollow noopener noreferrer\">NativeScript</a>  类似React Native的框架</li>\n<li><a target=\"_blank\" href=\"https://nestjs.com/\" rel=\"nofollow noopener noreferrer\">nestjs</a>  一个优秀的企业级的node后端框架。</li>\n</ul>\n<p>这里另附一份nestjs官方文档上的一张截图</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e67a5e50155300?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"699\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"699\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>这里并没有列举完全，先发出来后期添加。</p>\n",
      "id": "29zrp5xtuda8",
      "author": "政采云前端团队",
      "title": "说一说Angular“吊打”React和Vue的几个点",
      "baseClassName": "article-content"
    }
  ],
  "searchArticleDetailList": [
    {
      "content": "<div>\n\n\n        \n\n        \n\n        <h2 data-id=\"heading-0\">关于</h2>\n\n        <p>\n            本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-1\">状态</h3>\n\n        <p>\n            你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。\n        </p>\n\n        <p>\n            本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-2\">读者对象</h3>\n\n        <p>\n            本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。\n        </p>\n\n        <p>\n            这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。\n        </p>\n\n        <p>\n            然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-3\">本书结构</h3>\n\n        <p>\n            读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。\n        </p>\n\n        <p>\n            当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。\n        </p>\n\n        <p>\n            本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。\n        </p>\n\n        <p>\n            紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。\n        </p>\n\n        <p>\n            最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。\n        </p>\n\n        <p>\n            可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。\n        </p>\n\n        <p>\n            该应用所有的源代码都可以通过\n            <a href=\"https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">本书Github代码仓库</a>.\n        </p>\n\n        <div>目录</div>\n        <div>\n            <ul>\n\n                <li><a href=\"#about\">关于</a>\n                    <ul>\n                        <li><a href=\"#status\">状态</a></li>\n                        <li><a href=\"#intended-audience\">读者对象</a></li>\n                        <li><a href=\"#structure\">本书结构</a></li>\n                    </ul>\n                </li>\n\n                <li><a href=\"#javascript-and-nodejs\">JavaScript与Node.js</a>\n                    <ul>\n                        <li><a href=\"#javascript-and-you\">JavaScript与你</a></li>\n                        <li><a href=\"#a-word-of-warning\">简短申明</a></li>\n                        <li><a href=\"#server-side-javascript\">服务器端JavaScript</a></li>\n                        <li><a href=\"#hello-world\">“Hello World”</a></li>\n\n                    </ul>\n                </li>\n                <li><a href=\"#a-full-blown-web-application-with-nodejs\">一个完整的基于Node.js的web应用</a>\n                    <ul>\n                        <li><a href=\"#the-use-cases\">用例</a></li>\n                        <li><a href=\"#the-application-stack\">应用不同模块分析</a></li>\n                    </ul>\n\n                </li>\n                <li><a href=\"#building-the-application-stack\">构建应用的模块</a>\n                    <ul>\n                        <li><a href=\"#a-basic-http-server\">一个基础的HTTP服务器</a></li>\n                        <li><a href=\"#analyzing-our-http-server\">分析HTTP服务器</a></li>\n                        <li><a href=\"#passing-functions-around\">进行函数传递</a></li>\n                        <li><a href=\"#how-function-passing-makes-our-http-server-work\">函数传递是如何让HTTP服务器工作的</a></li>\n\n                        <li><a href=\"#event-driven-callbacks\">基于事件驱动的回调</a></li>\n                        <li><a href=\"#how-our-server-handles-requests\">服务器是如何处理请求的</a></li>\n                        <li><a href=\"#finding-a-place-for-our-server-module\">服务端的模块放在哪里</a>\n                        </li>\n                        <li><a href=\"#whats-needed-to-route-requests\">如何来进行请求的“路由”</a></li>\n                        <li><a href=\"#execution-in-the-kongdom-of-verbs\">行为驱动执行</a></li>\n                        <li><a href=\"#routing-to-real-request-handlers\">路由给真正的请求处理程序</a></li>\n\n                        <li><a href=\"#making-the-request-handlers-respond\">让请求处理程序作出响应</a>\n                            <ul>\n                                <li><a href=\"#how-to-not-do-it\">不好的实现方式</a></li>\n                                <li><a href=\"#blocking-and-non-blocking\">阻塞与非阻塞</a></li>\n                                <li><a href=\"#responding-request-handlers-with-non-blocking-operations\">以非阻塞操作进行请求响应</a>\n                                </li>\n                            </ul>\n\n                        </li>\n                        <li><a href=\"#serving-something-useful\">更有用的场景</a>\n                            <ul>\n                                <li><a href=\"#handling-post-requests\">处理POST请求</a></li>\n                                <li><a href=\"#handling-file-uploads\">处理文件上传</a></li>\n                            </ul>\n                        </li>\n\n                        <li><a href=\"#conclusion-and-outlook\">总结与展望</a></li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n\n        <a></a>\n\n        <h2 data-id=\"heading-4\">JavaScript与Node.js</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-5\">JavaScript与你</h3>\n\n        <p>\n            抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。\n        </p>\n\n        <p>\n            如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。\n        </p>\n\n        <p>\n            而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。\n        </p>\n\n        <p>\n            与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是<em>window.open() </em>那么简单。 .\n        </p>\n\n        <p>\n            不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript<em>用户</em>，而非JavaScript<em>开发者</em>。\n        </p>\n\n        <p>\n            然后，出现了Node.js，服务端的JavaScript，这有多酷啊？\n        </p>\n\n        <p>\n            于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。\n        </p>\n\n        <p>\n            问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。\n        </p>\n\n        <p>\n            因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。\n        </p>\n\n        <p>\n            当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。\n        </p>\n\n        <p>\n            本书的目标就是给你提供指导。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-6\">简短申明</h3>\n\n        <p>\n            业界有非常优秀的JavaScript程序员。而我并非其中一员。\n        </p>\n\n        <p>\n            我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。\n        </p>\n\n        <p>\n            因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。\n        </p>\n\n        <p>\n            如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-7\">服务端JavaScript</h3>\n\n        <p>\n            JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\n        </p>\n\n        <p>\n            Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。\n        </p>\n\n        <p>\n            要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。\n        </p>\n\n        <p>\n            除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。\n        </p>\n\n        <p>\n            因此，Node.js事实上既是一个运行时环境，同时又是一个库。\n        </p>\n\n        <p>\n            要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考<a href=\"https://github.com/joyent/node/wiki/Installation\" title=\"Building and Installing Node.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方的安装指南</a>。安装完成后，继续回来阅读本书下面的内容。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-8\">“Hello World”</h3>\n\n        <p>\n            好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。\n        </p>\n\n        <p>\n            打开你最喜欢的编辑器，创建一个<em>helloworld.js</em>文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：\n        </p>\n        <pre>console.log(\"Hello World\");</pre>\n        \n        <p>\n            保存该文件，并通过Node.js来执行：\n        </p>\n\n        <pre>node helloworld.js</pre>\n        <p>\n            正常的话，就会在终端输出<em>Hello World</em> 。\n        </p>\n\n        <p>\n            好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。\n        </p>\n\n\n        <a></a>\n\n        <h2 data-id=\"heading-9\">一个完整的基于Node.js的web应用</h2>\n \n        <a></a> \n \n        <h3 data-id=\"heading-10\">用例</h3> \n \n        <p>我们来把目标设定得简单点，不过也要够实际才行：</p>\n\n        <ul>\n        <li>用户可以通过浏览器使用我们的应用。</li>\n        <li>当用户请求<em>http://domain/start</em>时，可以看到一个欢迎页面，页面上有一个文件上传的表单。</li>\n        <li>用户可以选择一个图片并提交表单，随后文件将被上传到<em>http://domain/upload</em>，该页面完成上传后会把图片显示在页面上。</li>\n        </ul>\n\n        <p>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>\n\n        <p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>\n\n        <h3 data-id=\"heading-11\">应用不同模块分析</h3>\n\n        <p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>\n\n        <ul>\n        <li>我们需要提供Web页面，因此需要一个<em>HTTP服务器</em></li>\n        <li>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个<em>路由</em>，用于把请求对应到请求处理程序（request handler）</li>\n        <li>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的<em>请求处理程序</em></li>\n        <li>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要<em>请求数据处理功能</em></li>\n        <li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些<em>视图逻辑</em>供请求处理程序使用，以便将内容发送给用户的浏览器</li>\n        <li>最后，用户需要上传图片，所以我们需要<em>上传处理功能</em>来处理这方面的细节</li>\n        </ul>\n\n        <p>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>\n\n        <p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n\n        <p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>\n\n        <p>现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。</p>\n\n        <a></a>\n\n        <h2 data-id=\"heading-12\">构建应用的模块</h2>\n\n        <a></a>\n\n        <h3 data-id=\"heading-13\">一个基础的HTTP服务器</h3>\n\n        <p>\n            当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。\n            <br>\n            我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？\n        </p>\n\n        <p>\n\n            实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。\n        </p>\n\n        <p>\n            这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。  \n        </p>\n\n        <p>\n            那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。\n        </p>\n\n        <p>\n\n            在我的印象里，把主文件叫做<em>index.js</em>或多或少是个标准格式。把服务器模块放进叫<em>server.js</em>的文件里则很好理解。\n        </p>\n\n        <p>\n            让我们先从服务器模块开始。在你的项目的根目录下创建一个叫<em>server.js</em>的文件，并写入以下代码：\n        </p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>\n            搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：\n        </p>\n        <pre>node server.js</pre>\n        <p>\n            接下来，打开浏览器访问<a href=\"http://localhost:8888/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a>，你会看到一个写着“Hello World”的网页。 \n        </p>\n\n        <p>\n            这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-14\">分析HTTP服务器</h3>\n\n        <p>\n            那么接下来，让我们分析一下这个HTTP服务器的构成。\n        </p>\n\n        <p>\n            第一行<em>请求（require）</em>Node.js自带的 <em>http</em> 模块，并且把它赋值给 <em>http</em> 变量。\n        </p>\n\n\n        <p>\n            接下来我们调用http模块提供的函数： <em>createServer</em> 。这个函数会返回一个对象，这个对象有一个叫做 <em>listen</em> 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。\n        </p>\n\n        <p>\n            咱们暂时先不管 <em>http.createServer</em> 的括号里的那个函数定义。\n        </p>\n\n        <p>\n            我们本来可以用这样的代码来启动服务器并侦听8888端口：\n        </p>\n        <pre>var http = require(\"http\");var server = http.createServer();server.listen(8888);</pre>\n\n        <p>\n            这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。\n        </p>\n\n        <p>\n            最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 <em>createSever()</em> 的第一个参数，一个函数定义。\n        </p>\n\n        <p>\n            实际上，这个函数定义是 <em>createServer()</em> 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-15\">进行函数传递</h3>\n\n        <p>\n            举例来说，你可以这样做：\n        </p>\n        <pre>function say(word) {  console.log(word);}function execute(someFunction, value) {  someFunction(value);}execute(say, \"Hello\");</pre>\n\n        <p>\n            请仔细阅读这段代码！在这里，我们把 <em>say</em> 函数作为<em>execute</em>函数的第一个变量进行了传递。这里传递的不是 <em>say</em> 的返回值，而是 <em>say</em> 本身！\n        </p>\n\n        <p>\n            这样一来， <em>say</em> 就变成了<em>execute</em> 中的本地变量 <em>someFunction</em> ，execute可以通过调用 <em>someFunction()</em> （带括号的形式）来使用 <em>say</em> 函数。\n        </p>\n\n        <p>\n            当然，因为 <em>say</em> 有一个变量， <em>execute</em> 在调用 <em>someFunction</em> 时可以传递这样一个变量。\n        </p>\n\n        <p>\n            我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n        </p>\n        <pre>function execute(someFunction, value) {  someFunction(value);}execute(function(word){ console.log(word) }, \"Hello\");</pre>\n\n        <p>\n            我们在 <em>execute</em> 接受第一个参数的地方直接定义了我们准备传递给 <em>execute</em> 的函数。\n        </p>\n\n        <p>\n            用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 <em>匿名函数</em> 。\n        </p>\n\n        <p>\n            这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-16\">函数传递是如何让HTTP服务器工作的</h3>\n\n        <p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n        <pre>var http = require(\"http\");http.createServer(function(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}).listen(8888);</pre>\n\n        <p>现在它看上去应该清晰了很多：我们向 <em>createServer</em> 函数传递了一个匿名函数。  </p>\n\n        <p>用这样的代码也可以达到同样的目的：  </p>\n        <pre>var http = require(\"http\");function onRequest(request, response) {  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);</pre>\n\n        <p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-17\">基于事件驱动的回调</h3>\n\n        <p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。  </p>\n\n        <p>你也许会想花点时间读一下Felix Geisendörfer的大作<a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding node.js</a>，它介绍了一些背景知识。  </p>\n\n        <p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。  </p>\n\n        <p>当我们使用 <em>http.createServer</em> 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。  </p>\n\n        <p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。  </p>\n\n        <p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。  </p>\n\n        <p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？  </p>\n\n        <p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。  </p>\n\n        <p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。  </p>\n\n        <p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。  </p>\n\n        <p>这个就是传说中的 <em>回调</em> 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 <em>回调</em> 。  </p>\n\n        <p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。  </p>\n\n        <p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：  </p>\n\n        <pre>var http = require(\"http\");function onRequest(request, response) {  console.log(\"Request received.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello World\");  response.end();}http.createServer(onRequest).listen(8888);console.log(\"Server has started.\");</pre>\n\n        <p>注意：在 <em>onRequest</em> （我们的回调函数）触发的地方，我用 <em>console.log</em> 输出了一段文本。在HTTP服务器开始工作<em>之后</em>，也输出一段文本。  </p>\n\n        <p>\n            当我们与往常一样，运行它<em>node server.js</em>时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href=\"http://localhost:8888/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/</a> ），“Request received.”这条消息就会在命令行中出现。\n        </p>\n\n        <p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>\n\n        <p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /时尝试读取 http://localhost:8888/favicon.ico )</p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-18\">服务器是如何处理请求的</h3>\n\n        <p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 <em>onRequest()</em> 的主体部分。  </p>\n\n        <p>当回调启动，我们的 <em>onRequest()</em> 函数被触发的时候，有两个参数被传入： <em>request</em> 和 <em>response</em> 。  </p>\n\n        <p>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。  </p>\n\n        <p>所以我们的代码就是：当收到请求时，使用 <em>response.writeHead()</em> 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 <em>response.write()</em> 函数在HTTP相应主体中发送文本“Hello World\"。  </p>\n\n        <p>最后，我们调用 <em>response.end()</em> 完成响应。  </p>\n\n        <p>目前来说，我们对请求的细节并不在意，所以我们没有使用 <em>request</em> 对象。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-19\">服务端的模块放在哪里</h3>\n\n        <p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 <em>server.js</em> 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 <em>index.js</em> 的文件去调用应用的其他模块（比如 <em>server.js</em> 中的HTTP服务器模块）来引导和启动应用。  </p>\n\n        <p>我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 <em>index.js</em> 主文件使用。</p>\n\n        <p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：  </p>\n        <pre>var http = require(\"http\");...http.createServer(...);</pre>\n\n        <p>Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。  </p>\n\n        <p>这把我们的本地变量变成了一个拥有所有 <em>http</em> 模块所提供的公共方法的对象。</p>\n\n        <p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：  </p>\n        <pre>var foo = require(\"http\");...foo.createServer(...);</pre>\n\n        <p>很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？  </p>\n\n        <p>等我们把 <em>server.js</em> 变成一个真正的模块，你就能搞明白了。  </p>\n\n        <p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 <em>导出</em> 到请求这个模块的脚本。  </p>\n\n        <p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。  </p>\n\n        <p>我们把我们的服务器脚本放到一个叫做 <em>start</em> 的函数里，然后我们会导出这个函数。  </p>\n        <pre>var http = require(\"http\");function start() {  function onRequest(request, response) {    console.log(\"Request received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>这样，我们现在就可以创建我们的主文件 <em>index.js</em> 并在其中启动我们的HTTP了，虽然服务器的代码还在 <em>server.js</em> 中。  </p>\n\n        <p>创建 <em>index.js</em> 文件并写入以下内容：  </p>\n        <pre>var server = require(\"./server\");server.start();</pre>\n\n        <p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>\n\n        <p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>\n        <pre>node index.js</pre>\n\n        <p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。  </p>\n\n        <p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。  </p>\n\n        <p>对于一个非常简单的应用来说，你可以直接在回调函数 <em>onRequest()</em> 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。  </p>\n\n        <p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 <em>路由</em> 的模块吧。  </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-20\">如何来进行请求的“路由”</h3> \n\n         <p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>\n\n        <p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n\n        <p>我们需要的所有数据都会包含在request对象中，该对象作为<em>onRequest()</em>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<em>url</em>和<em>querystring</em>模块。</p>\n<pre>                               url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n</pre>\n\n        <p>当然我们也可以用<em>querystring</em>模块来解析POST请求体中的参数，稍后会有演示。</p>\n\n        <p>现在我们来给<em>onRequest()</em>函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start() {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>\n\n        <p>在我们所要构建的应用中，这意味着来自<em>/start</em>和<em>/upload</em>的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n\n        <p>现在我们可以来编写路由了，建立一个名为<em>router.js</em>的文件，添加以下内容：</p>\n        <pre>function route(pathname) {  console.log(\"About to route a request for \" + pathname);}exports.route = route;</pre>\n\n        <p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n\n        <p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href=\"http://martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>\n\n        <p>首先，我们来扩展一下服务器的<em>start()</em>函数，以便将路由函数作为参数传递过去：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(pathname);    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>同时，我们会相应扩展<em>index.js</em>，使得路由函数可以被注入到服务器中：</p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");server.start(router.route);</pre>\n\n        <p>在这里，我们传递的函数依旧什么也没做。</p>\n\n        <p>如果现在启动应用（<em>node index.js，始终记得这个命令行</em>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n\n        <pre>bash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo</pre>\n\n        <p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>\n \n        <a></a> \n \n        <h3 data-id=\"heading-21\">行为驱动执行</h3> \n\n        <p>请允许我再次脱离主题，在这里谈一谈函数式编程。</p>\n\n        <p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将<em>router</em>对象传递进去，服务器随后可以调用这个对象的<em>route</em>函数。</p>\n\n        <p>就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？</p>\n\n        <p>但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要<em>名词</em>，你需要<em>动词</em>。</p>\n\n        <p>理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</p>\n\n        <p>我是在读了Steve Yegge的大作<a href=\"http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">名词王国中的死刑</a>之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。</p>\n\n        <a></a> \n \n        <h3 data-id=\"heading-22\">路由给真正的请求处理程序</h3> \n\n         <p>回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。</p>\n\n        <p>当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理<em>/start</em>的“业务逻辑”就应该和处理<em>/upload</em>的不同。</p>\n\n        <p>在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。</p>\n\n        <p>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>\n\n        <p>应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>\n\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");}function upload() {  console.log(\"Request handler 'upload' was called.\");}exports.start = start;exports.upload = upload;</pre>\n\n        <p>这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</p>\n\n        <p>在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</p>\n\n        <p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>\n\n        <p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<em>if request == x then call handler y</em>也使得系统丑陋不堪。</p>\n\n        <p>仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array）能完美胜任。</p>\n\n        <p>不过结果有点令人失望，JavaScript没提供关联数组 -- 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。</p>\n\n        <p>在这方面，<a href=\"http://msdn.microsoft.com/en-us/magazine/cc163419.aspx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">msdn.microsoft.com/en-us/magaz…</a>有一个不错的介绍，我在此摘录一段：</p>\n\n         <blockquote>\n            <p>在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>\n        </blockquote>\n\n        <p>但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！</p>\n\n        <p>好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到<em>route()</em>函数中。</p>\n\n        <p>我们先将这个对象引入到主文件<em>index.js</em>中：</p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = {}handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;server.start(router.route, handle);</pre>\n\n        <p>虽然<em>handle</em>并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。</p>\n\n        <p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为<em>\"/\"</em>的属性，对应<em>requestHandlers.start</em>即可，这样我们就可以干净简洁地配置<em>/start</em>和<em>/</em>的请求都交由<em>start</em>这一处理程序处理。</p>\n\n        <p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将<em>server.js</em>修改如下：</p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname);    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(\"Hello World\");    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>这样我们就在<em>start()</em>函数里添加了<em>handle</em>参数，并且把handle对象作为第一个参数传递给了<em>route()</em>回调函数。</p>\n\n        <p>然后我们相应地在<em>route.js</em>文件中修改<em>route()</em>函数：</p>\n        <pre>function route(handle, pathname) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname]();  } else {    console.log(\"No request handler found for \" + pathname);  }}exports.route = route;</pre>\n\n       <p>通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如<em>handle[pathname]();</em>的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</p>\n\n        <p>有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问<em>http://localhost:8888/start</em>，以下日志可以说明系统调用了正确的请求处理程序：</p>\n\n        <pre>Server has started.\nRequest for /start received.\nAbout to route a request for /start\nRequest handler 'start' was called.</pre>\n\n         <p>并且在浏览器中打开<em>http://localhost:8888/</em>可以看到这个请求同样被<em>start</em>请求处理程序处理了：</p>\n        <pre>Request for / received.\nAbout to route a request for /\nRequest handler 'start' was called.</pre>\n\n        <a></a>\n\n        <h3 data-id=\"heading-23\">让请求处理程序作出响应</h3>\n\n        <p>\n            很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。\n        </p>\n\n        <p>\n            这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们<em>server.js</em>文件中的<em>onRequest</em>函数。\n        </p>\n\n        <p>\n            其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像<em>onRequest</em>函数那样可以和浏览器进行“对话”。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-24\">不好的实现方式</h4>\n\n        <p>\n            对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。\n        </p>\n\n        <p>\n            这里我指的“直截了当的实现方式”意思是：让请求处理程序通过<em>onRequest</em>函数直接返回（<em>return()</em>）他们要展示给用户的信息。\n        </p>\n\n        <p>\n            我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。\n        </p>\n\n        <p>\n            让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将<em>requestHandler.js</em>修改为如下形式：\n        </p>\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");  return \"Hello Start\";}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将<em>router.js</em>修改为如下形式：\n        </p>\n        <pre>function route(handle, pathname) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    return handle[pathname]();  } else {    console.log(\"No request handler found for \" + pathname);    return \"404 Not found\";  }}exports.route = route;</pre>\n        <p>\n            正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。\n        </p>\n\n        <p>\n            最后，我们需要对我们的<em>server.js</em>进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    var content = route(handle, pathname)    response.write(content);    response.end();  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n        <p>\n            如果我们运行重构后的应用，一切都会工作的很好：请求<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>,浏览器会输出“Hello Start”，请求<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>会输出“Hello Upload”,而请求<a href=\"http://localhost:8888/foo\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/foo</a> 会输出“404 Not found”。\n        </p>\n\n        <p>\n            好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。\n        </p>\n\n        <p>\n            没理解？没关系，下面就来详细解释下。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-25\">阻塞与非阻塞</h4>\n\n        <p>\n            正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。\n        </p>\n\n        <p>\n            我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。\n        </p>\n\n        <p>\n            这里，我们来修改下<em>start</em>请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似<em>sleep()</em>这样的操作，所以这里只能够来点小Hack来模拟实现。\n        </p>\n\n        <p>\n            让我们将<em>requestHandlers.js</em>修改成如下形式：\n        </p>\n        <pre>function start() {  console.log(\"Request handler 'start' was called.\");  function sleep(milliSeconds) {    var startTime = new Date().getTime();    while (new Date().getTime() < startTime + milliSeconds);  }  sleep(10000);  return \"Hello Start\";}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            上述代码中，当函数<em>start()</em>被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用<em>upload()</em>的时候，会和此前一样立即返回。\n        </p>\n\n        <p>\n            （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）\n        </p>\n\n        <p>\n            接下来就让我们来看看，我们的改动带来了哪些变化。\n        </p>\n\n        <p>\n            如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>， 但是先不要打开它！\n        </p>\n\n        <p>\n            在第二个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>， 同样的，先不要打开它！\n        </p>\n\n        <p>\n           接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。\n        </p>\n\n        <p>\n            注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然<em>也</em>花了10秒，而它在对应的请求处理程序中并没有类似于<em>sleep()</em>这样的操作！\n        </p>\n\n        <p>\n            这到底是为什么呢？原因就是<em>start()</em>包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。\n        </p>\n\n        <p>\n            这显然是个问题，因为Node一向是这样来标榜自己的：<em>“在node中除了代码，所有一切都是并行执行的”</em>。\n        </p>\n\n        <p>\n            这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。\n        </p>\n\n        <p>\n            然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。\n        </p>\n\n        <p>\n            对于Node.js来说，它是这样处理的：<em>“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</em>\n        </p>\n\n        <p>\n            （如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">理解node.js的事件轮询</a>。）\n        </p>\n\n        <p>\n            接下来，我们会介绍一种错误的使用非阻塞操作的方式。\n        </p>\n\n        <p>\n            和上次一样，我们通过修改我们的应用来暴露问题。\n        </p>\n\n        <p>\n            这次我们还是拿<em>start</em>请求处理程序来“开刀”。将其修改成如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start() {  console.log(\"Request handler 'start' was called.\");  var content = \"empty\";  exec(\"ls -lah\", function (error, stdout, stderr) {    content = stdout;  });  return content;}function upload() {  console.log(\"Request handler 'upload' was called.\");  return \"Hello Upload\";}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            上述代码中，我们引入了一个新的Node.js模块，<em>child_process</em>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<em>exec()</em>。\n        </p>\n\n        <p>\n            <em>exec()</em>做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当<em>/start</em>URL请求的时候将文件信息输出到浏览器中。\n        </p>\n\n        <p>\n            上述代码是非常直观的： 创建了一个新的变量<em>content</em>（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。\n        </p>\n\n        <p>\n            和往常一样，我们启动服务器，然后访问“<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>” 。\n        </p>\n\n        <p>\n            之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？\n        </p>\n\n        <p>\n            这个时候，你可能大致已经猜到了，<em>exec()</em>在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。\n        </p>\n\n        <p>\n            （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。\n        </p>\n\n        <p>\n            然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？\n        </p>\n\n        <p>\n            好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。\n        </p>\n\n        <p>\n            问题就在于，为了进行非阻塞工作，<em>exec()</em>使用了回调函数。\n        </p>\n\n        <p>\n            在我们的例子中，该回调函数就是作为第二个参数传递给<em>exec()</em>的匿名函数：\n        </p>\n        <pre>function (error, stdout, stderr) {  content = stdout;}</pre>\n\n        <p>\n            现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用<em>exec()</em>之后，Node.js会立即执行 <em>return content</em> ；在这个时候，<em>content</em>仍然是“empty”，因为传递给<em>exec()</em>的回调函数还未执行到——因为<em>exec()</em>的操作是异步的。\n        </p>\n\n        <p>\n            我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。\n        </p>\n\n        <p>\n            为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当<em>exec()</em>在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给<em>exec()</em>的回调函数，只会在“find /”命令执行完成之后才会被调用。\n        </p>\n\n        <p>\n            那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？\n        </p>\n\n        <p>\n            好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-26\">以非阻塞操作进行请求响应</h4>\n\n        <p>\n            我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。\n        </p>\n\n        <p>\n            不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。\n        </p>\n\n        <p>\n            到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -> 请求路由 -> 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。\n        </p>\n\n        <p>\n            现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将<em>response</em>对象（从服务器的回调函数<em>onRequest()</em>获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。\n        </p>\n\n        <p>\n            原理就是如此，接下来让我们来一步步实现这种方案。\n        </p>\n\n        <p>\n            先从<em>server.js</em>开始：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname, response);  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            相对此前从<em>route()</em>函数获取返回值的做法，这次我们将response对象作为第三个参数传递给<em>route()</em>函数，并且，我们将<em>onRequest()</em>处理程序中所有有关<em>response</em>的函数调都移除，因为我们希望这部分工作让<em>route()</em>函数来完成。\n        </p>\n\n        <p>\n            下面就来看看我们的<em>router.js</em>:\n        </p>\n        <pre>function route(handle, pathname, response) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/plain\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递<em>response</em>对象。\n        </p>\n\n        <p>\n            如果没有对应的请求处理器处理，我们就直接返回“404”错误。\n        </p>\n\n        <p>\n            最后，我们将<em>requestHandler.js</em>修改为如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start(response) {  console.log(\"Request handler 'start' was called.\");  exec(\"ls -lah\", function (error, stdout, stderr) {    response.writeHead(200, {\"Content-Type\": \"text/plain\"});    response.write(stdout);    response.end();  });}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。\n        </p>\n\n        <p>\n            <em>start</em>处理程序在<em>exec()</em>的匿名回调函数中做请求响应的操作，而<em>upload</em>处理程序仍然是简单的回复“Hello World”，只是这次是使用<em>response</em>对象而已。\n        </p>\n\n        <p>\n            这时再次我们启动应用（<em>node index.js</em>），一切都会工作的很好。\n        </p>\n\n        <p>\n            如果想要证明<em>/start</em>处理程序中耗时的操作不会阻塞对<em>/upload</em>请求作出立即响应的话，可以将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n        <pre>var exec = require(\"child_process\").exec;function start(response) {  console.log(\"Request handler 'start' was called.\");  exec(\"find /\",    { timeout: 10000, maxBuffer: 20000*1024 },    function (error, stdout, stderr) {      response.writeHead(200, {\"Content-Type\": \"text/plain\"});      response.write(stdout);      response.end();    });}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            这样一来，当请求<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>的时候，会花10秒钟的时间才载入，而当请求<a href=\"http://localhost:8888/upload\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/upload</a>的时候，会立即响应，纵然这个时候/start响应还在处理中。\n        </p>\n\n        <a></a>\n\n        <h3 data-id=\"heading-27\">更有用的场景</h3>\n\n        <p>\n            到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。\n        </p>\n\n        <p>\n            服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。\n        </p>\n\n        <p>\n            好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。\n        </p>\n\n        <p>\n            要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。\n        </p>\n\n        <p>\n            第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。\n            <br>\n            第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它<em>不</em>在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-28\">处理POST请求</h4>\n\n        <p>\n            考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。\n        </p>\n        \n        <p>\n            <em>/start</em>请求处理程序用于生成带文本区的表单，因此，我们将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n        <pre>function start(response) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"Hello Upload\");  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问<a href=\"http://localhost:8888/start\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/start</a>就可以看到简单的表单了，要记得重启服务器哦！\n        </p>\n\n        <p>\n            你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。\n        </p>\n\n        <p>\n            余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发<em>/upload</em>请求处理程序处理POST请求的问题。\n        </p>\n\n        <p>\n            现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。\n        </p>\n\n        <p>\n            这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。\n        </p>\n\n        <p>\n            为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有<em>data</em>事件（表示新的小数据块到达了）以及<em>end</em>事件（表示所有的数据都已经接收完毕）。\n        </p>\n\n        <p>\n            我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在<em>request</em>对象上注册<em>监听器</em>（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给<em>onRequest</em>回调函数。\n        </p>\n\n        <p>\n            如下所示：\n        </p>\n        <pre>request.addListener(\"data\", function(chunk) {  // called when a new chunk of data was received});request.addListener(\"end\", function() {  // called when all chunks of data have been received});</pre>\n\n        <p>\n            问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了<em>request</em>对象 —— 我们并没有像之前<em>response</em>对象那样，把 request 对象传递给请求路由和请求处理程序。\n        </p>\n\n        <p>\n            在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。\n        </p>\n\n        <p>\n            因此，实现思路就是： 将<em>data</em>和<em>end</em>事件的回调函数直接放在服务器中，在<em>data</em>事件回调中收集所有的POST数据，当接收到所有数据，触发<em>end</em>事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。\n        </p>\n\n        <p>\n            还等什么，马上来实现。先从<em>server.js</em>开始：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var postData = \"\";    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    request.setEncoding(\"utf8\");    request.addListener(\"data\", function(postDataChunk) {      postData += postDataChunk;      console.log(\"Received POST data chunk '\"+      postDataChunk + \"'.\");    });    request.addListener(\"end\", function() {      route(handle, pathname, response, postData);    });  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给<em>postData</em> 变量，最后，我们将请求路由的调用移到<em>end</em>事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。\n        </p>\n\n        <p>\n            上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。\n        </p>\n\n        <p>\n            我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现<em>data</em>事件会触发多次。\n        </p>\n\n        <p>\n            再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将<em>postData</em>传递给请求处理程序，修改<em>router.js</em>为如下形式：\n        </p>\n\n        <pre>function route(handle, pathname, response, postData) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response, postData);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/plain\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            然后，在<em>requestHandlers.js</em>中，我们将数据包含在对<em>upload</em>请求的响应中：\n        </p>\n        <pre>function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent: \" + postData);  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。\n        </p>\n\n        <p>\n            我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是<em>text</em>字段。\n        </p>\n\n        <p>\n            我们可以使用此前介绍过的<em>querystring</em>模块来实现：\n        </p>\n        <pre>var querystring = require(\"querystring\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}exports.start = start;exports.upload = upload;</pre>\n\n        <p>\n            好了，以上就是关于处理POST数据的全部内容。\n        </p>\n\n        <a></a>\n\n        <h4 data-id=\"heading-29\">处理文件上传</h4>\n\n        <p>\n            最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。\n        </p>\n\n        <p>\n            回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。\n        </p>\n\n        <p>\n            这里我们要用到的外部模块是Felix Geisendörfer开发的<em>node-formidable</em>模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传<em>“就是”</em>处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。\n        </p>\n\n        <p>\n            使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫<em>NPM</em>。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：\n        </p>\n        <pre>npm install formidable</pre>\n\n        <p>\n            如果终端输出如下内容：\n        </p>\n        <pre>npm info build Success: formidable@1.0.9npm ok</pre>\n\n        <p>\n            就说明模块已经安装成功了。\n        </p>\n\n        <p>\n            现在我们就可以用<em>formidable</em>模块了——使用外部模块与内部模块类似，用require语句将其引入即可：\n        </p>\n        <pre>var formidable = require(\"formidable\");</pre>\n\n        <p>\n            这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的<em>IncomingForm</em>，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。\n        </p>\n\n        <p>\n            node-formidable官方的例子展示了这两部分是如何融合在一起工作的：\n        </p>\n        <pre>var formidable = require('formidable'),    http = require('http'),    util = require('util');http.createServer(function(req, res) {  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {    // parse a file upload    var form = new formidable.IncomingForm();    form.parse(req, function(err, fields, files) {      res.writeHead(200, {'content-type': 'text/plain'});      res.write('received upload:\\n\\n');      res.end(util.inspect({fields: fields, files: files}));    });    return;  }  // show a file upload form  res.writeHead(200, {'content-type': 'text/html'});  res.end(    '+    'method=\"post\">'+    '<input type=\"text\" name=\"title\"><br>'+    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+    '<input type=\"submit\" value=\"Upload\">'+    ''  );}).listen(8888);</pre>\n\n        <p>\n            如果我们将上述代码，保存到一个文件中，并通过<em>node</em>来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用<em>form.parse</em>传递给回调函数的<em>files</em>对象的内容，如下所示：\n        </p>\n        <pre>received upload:\n\n{ fields: { title: 'Hello World' },\n  files:\n   { upload:\n      { size: 1558,\n        path: '/tmp/1c747974a27a6292743669e91f29350b',\n        name: 'us-flag.png',\n        type: 'image/png',\n        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,\n        _writeStream: [Object],\n        length: [Getter],\n        filename: [Getter],\n        mime: [Getter] } } }</pre>\n\n        <p>\n            为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在<em>/tmp</em>目录中）显示到浏览器中。\n        </p>\n\n        <p>\n            我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？\n        </p>\n\n        <p>\n            显然，我们需要将该文件读取到我们的服务器中，使用一个叫<em>fs</em>的模块。\n        </p>\n\n        <p>\n            我们来添加<em>/show</em>URL的请求处理程序，该处理程序直接硬编码将文件<em>/tmp/test.png</em>内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。\n        </p>\n\n        <p>\n            将<em>requestHandlers.js</em>修改为如下形式：\n        </p>\n\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'content=\"text/html; charset=UTF-8\" />'+    ''+    ''+    '<form action=\"/upload\" method=\"post\">'</form>+    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+    '<input type=\"submit\" value=\"Submit text\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}function show(response, postData) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            我们还需要将这新的请求处理程序，添加到<em>index.js</em>中的路由映射表中：\n        </p>\n        <pre>var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = {}handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.route, handle);</pre>\n\n        <p>\n            重启服务器之后，通过访问<a href=\"http://localhost:8888/show\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">http://localhost:8888/show</a>，就可以看到保存在<em>/tmp/test.png</em>的图片了。\n        </p>\n\n        <p>\n            好，最后我们要的就是：\n        </p>\n        \n        <p>\n            </p><ul>\n                <li>\n                    在<em>/start</em>表单中添加一个文件上传元素\n                </li>\n                <li>\n                    将node-formidable整合到我们的<em>upload</em>请求处理程序中，用于将上传的图片保存到<em>/tmp/test.png</em>\n                </li>\n        \n                <li>\n                    将上传的图片内嵌到<em>/upload</em>URL输出的HTML中\n                </li>\n            </ul>\n        <p></p>\n\n        <p>\n            第一项很简单。只需要在HTML表单中，添加一个<em>multipart/form-data</em>的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下<em>requestHandler.js</em>所示：\n        </p>\n\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\");function start(response, postData) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'content=\"text/html; charset=UTF-8\" />'+    ''+    ''+    '+    'method=\"post\">'+    '<input type=\"file\" name=\"upload\">'+    '<input type=\"submit\" value=\"Upload file\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, postData) {  console.log(\"Request handler 'upload' was called.\");  response.writeHead(200, {\"Content-Type\": \"text/plain\"});  response.write(\"You've sent the text: \"+  querystring.parse(postData).text);  response.end();}function show(response, postData) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在<em>upload</em>处理程序中对上传的文件进行处理，这样的话，我们就需要将<em>request</em>对象传递给node-formidable的<em>form.parse</em>函数。\n        </p>\n\n        <p>\n            但是，我们有的只是<em>response</em>对象和<em>postData</em>数组。看样子，我们只能不得不将<em>request</em>对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。\n        </p>\n\n        <p>\n            到这里，我们可以将<em>postData</em>从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了<em>request</em>对象中的数据，这意味着，对于<em>form.parse</em>来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）\n        </p>\n\n        <p>\n            我们从<em>server.js</em>开始 —— 移除对postData的处理以及<em>request.setEncoding</em>\n            （这部分node-formidable自身会处理），转而采用将<em>request</em>对象传递给请求路由的方式：\n        </p>\n        <pre>var http = require(\"http\");var url = require(\"url\");function start(route, handle) {  function onRequest(request, response) {    var pathname = url.parse(request.url).pathname;    console.log(\"Request for \" + pathname + \" received.\");    route(handle, pathname, response, request);  }  http.createServer(onRequest).listen(8888);  console.log(\"Server has started.\");}exports.start = start;</pre>\n\n        <p>\n            接下来是 router.js —— 我们不再需要传递<em>postData</em>了，这次要传递<em>request</em>对象：\n        </p>\n        <pre>function route(handle, pathname, response, request) {  console.log(\"About to route a request for \" + pathname);  if (typeof handle[pathname] === 'function') {    handle[pathname](response, request);  } else {    console.log(\"No request handler found for \" + pathname);    response.writeHead(404, {\"Content-Type\": \"text/html\"});    response.write(\"404 Not found\");    response.end();  }}exports.route = route;</pre>\n\n        <p>\n            现在，<em>request</em>对象就可以在我们的<em>upload</em>请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地<em>/tmp</em>目录中，而我们需要做的是确保该文件保存成<em>/tmp/test.png</em>。 没错，我们保持简单，并假设只允许上传PNG图片。\n        </p>\n\n        <p>\n            这里采用<em>fs.renameSync(path1,path2)</em>来实现。要注意的是，正如其名，该方法是同步执行的，\n            也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。\n        </p>\n\n        <p>\n            接下来，我们把处理文件上传以及重命名的操作放到一起，如下<em>requestHandlers.js</em>所示：\n        </p>\n        <pre>var querystring = require(\"querystring\"),    fs = require(\"fs\"),    formidable = require(\"formidable\");function start(response) {  console.log(\"Request handler 'start' was called.\");  var body = ''+    ''+    '+    'charset=UTF-8\" />'+    ''+    ''+    '+    'method=\"post\">'+    '<input type=\"file\" name=\"upload\" multiple=\"multiple\">'+    '<input type=\"submit\" value=\"Upload file\">'+    ''+    ''+    '';    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(body);    response.end();}function upload(response, request) {  console.log(\"Request handler 'upload' was called.\");  var form = new formidable.IncomingForm();  console.log(\"about to parse\");  form.parse(request, function(error, fields, files) {    console.log(\"parsing done\");    fs.renameSync(files.upload.path, \"/tmp/test.png\");    response.writeHead(200, {\"Content-Type\": \"text/html\"});    response.write(\"received image:<br>\");    response.write(\"<img style class=\"lazyload inited\" data-src=\"/show\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\">\");    response.end();  });}function show(response) {  console.log(\"Request handler 'show' was called.\");  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {    if(error) {      response.writeHead(500, {\"Content-Type\": \"text/plain\"});      response.write(error + \"\\n\");      response.end();    } else {      response.writeHead(200, {\"Content-Type\": \"image/png\"});      response.write(file, \"binary\");      response.end();    }  });}exports.start = start;exports.upload = upload;exports.show = show;</pre>\n\n        <p>\n            好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。\n        </p>\n\n        <a></a>\n\n        <h2 data-id=\"heading-30\">总结与展望</h2>\n\n        <p>\n            恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。\n        </p>\n\n        <p>\n            当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。\n        </p>\n\n        <p>\n            但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。\n        </p>\n\n        <p>\n            幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？），\n            这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。\n            其中<a href=\"https://github.com/joyent/node/wiki\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js社区的wiki</a>以及\n            <a href=\"http://www.nodecloud.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NodeCloud</a>就是最好的资源。\n        </p>\n        </div>",
      "id": "41calb2g1vi0",
      "author": "sing1ee",
      "title": "Node入门 » 一本全面的Node.js教程",
      "baseClassName": "article-content"
    },
    {
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">一、概述</h2>\n<blockquote>\n<p>4月21日，有赞举办了第一届“有赞技术开发日”的活动，我作为分享讲师，分享了有赞最近一年在 Node 这一块的实践经验。但由于分享时间有限，我也只能把最重要的内容拿出来和大家分享，所以这个周末就花了几个小时时间，结合那次的分享，并完善了其中的一些内容，写了这篇文章，希望可以给大家带来新的启发。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-1\">二、Node 基础框架的迭代与演进</h2>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 从 Koa 到 阿童木（Astroboy）</h3>\n<h4 class=\"heading\" data-id=\"heading-3\">（1）Koa + 中间件</h4>\n<p>有赞最早的一个比较完整的 Node 项目是公司内部的一个管理系统，这个系统是用 Node 全栈开发的，主要包括一个给 HR 用的员工管理系统和给小伙伴用的 APP。就像大多数公司一样，我们第一个 Node 项目也是直接用 Koa，然后整合一些开源的中间件，这样就快速的把项目搭建起来了。</p>\n<p>这个项目做了半年之后，我们把 Node 该踩的坑基本也都踩了一遍，所以我们就开始尝试在对外产品上使用 Node了，我们第一个尝试改造的项目是公司的官网，这是最简单的一个项目，基本没什么大的风险。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">（2）脚手架项目模板</h4>\n<p>第二个项目我们不可能再按照之前的方式，简单用 Koa 加上一堆中间件的方式来搭建项目了，因为已经有了之前的经验，所以我们就整理了下这一套方案，抽离出了一个项目模板，每个新项目只要把这个模板克隆下来，然后改一下配置，就可以快速搭建出一个新的项目来。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">（3）阿童木 1.0</h4>\n<p>项目多了之后，这种方式弊端很快就显现出来了，因为模板代码和业务代码是耦合在一起，如果要改模板生成的代码，只能每个项目手动更新，而随着时间的推移，越来越难保持同步了，每个项目的目录结构和代码风格可能也会变得非常不一样，所以，<strong>解耦框架代码和业务代码就非常重要了</strong>。所以我们就在脚手架模板的基础上抽离出了一个框架叫 Astroboy（阿童木），这个框架是在  Koa 的基础上封装的，这样，每个项目都基于这个框架开发，如果框架更新了，项目也只需要更改下框架的版本号。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cc9555a2b18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1164\" data-height=\"666\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1164\" height=\"666\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">（4）阿童木 2.0</h4>\n<p>很多项目都开始用 Node 了，新的问题又出现了，因为每个产品的业务场景都不一样，对框架的需求也都不一样。例如某个中间件，产品 A 可能需要，而产品 B 可能根本不需要这个中间件，而这个时候的框架又不支持定制改造。所以对框架来说，又提出了新的挑战，所以在今年年初，对框架做了一次大的重构。</p>\n<p>这次重构在阿童木 1.0 的基础上，加入了很多新特性，主要有以下几点：</p>\n<ul>\n<li>基于 Koa2 开发，性能表现优异</li>\n<li>提供基于 Astroboy 定制上层框架的能力</li>\n<li>高度可扩展的插件机制</li>\n<li>渐进式开发</li>\n</ul>\n<p>首先提供基于 Astroboy 定制上层框架的能力，如下图所示，Youzan Base Framework 是在阿童木的基础上定制的一个有赞最基础的 Node Web 框架，这一层主要集成了一些有赞最基础的服务，像：</p>\n<ul>\n<li>天网系统接入，这是有赞内部的一个日志及业务监控系统</li>\n<li>健康检查，运维监控系统每隔5秒钟，都会检查系统服务可用性</li>\n<li>全链路监控，对于一次 HTTP 请求，一般都会调用多个后端接口，相应的后端接口也会再去调用其他接口，所以整个调用过程实际上是一棵树状的结构，如果碰到性能问题，找出其中性能瓶颈问题就非常重要了，全链路监控就是为了解决这个问题。</li>\n<li>Dubbo 服务调用接入，关于这一点，查看下面关于服务化的介绍。</li>\n</ul>\n<p>有了 Youzan Base Framework 后，我们就需要在上面开发业务了，这个分两种业务场景：对于一些简单单一的业务，直接继承 Youzan Base Framework 开发就可以了；而如果是一些复杂的业务，就可以先在 Youzan Base Framework 的基础上，定制出一个业务框架，像我们有赞原先有一个超大的 PHP 项目（我们叫 Iron），那么服务化拆分后，Node 就承担了原先 PHP 的部分，所以我们新先定制了一个业务级的框架叫 Iron Base Framework，然后再按照业务模块（交易、店铺、用户、营销）拆分成多个子项目。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cd133687115?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"694\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"694\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>其次是支持插件化，关于这一点，可查看下面关于插件的说明。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">2. 框架的几个核心概念</h3>\n<p>以上介绍了有赞 Node 基础框架迭代和演变的过程，下面主要介绍下阿童木2.0 框架的几个核心概念</p>\n<h4 class=\"heading\" data-id=\"heading-8\">（1）应用 Application</h4>\n<p>应用 Application 的概念很好理解，在这里应用就可以理解成一个项目，它是从框架继承下来，并且实例化之后的一个实例，应用也是由一个一个插件构成的。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">（2）框架 Framework</h4>\n<p>Astroboy 框架是在 Koa2 的基础上封装的，关于框架的概念，这里就不再做过多的介绍了。</p>\n<h4 class=\"heading\" data-id=\"heading-10\">（3）插件 Plugin</h4>\n<p>插件化是软件设计中一个很重要的思想，很多软件像 Eclipse 都支持这样的特性，插件化可以让我们的系统解耦，每个模块做到独立开发，而模块之间又不会相互影响，这样的特性对于大型项目来说是非常重要的。</p>\n<p>插件化是 Astroboy 框架中最核心的一个实现，它是服务（Service）、中间件（Middleware）和工具函数库（Lib）等的载体，它本质上还是 NPM 包，只不过是在 NPM 包的基础上，做了更深层次的抽象。基于 Astroboy 的应用，就是由一个一个的 Plugin 组成的，Plugin 就是我们手中的积木，通过 Astroboy 的框架引擎把这些积木组织在一起，就形成了系统。</p>\n<p><strong>那么插件跟普通的 NPM 包有什么区别呢？</strong></p>\n<p>插件约定了目录结构，这样每个插件看起来都是类似的，这对于团队的协作是非常重要，如果每个模块看起来都不一样，那么团队的协作成本就会很高。\n应用启动后，插件的代码是自动注入到整个应用的，只需要在插件的配置文件里面开启这个插件即可。</p>\n<p><strong>一个插件可以包含哪些信息？</strong></p>\n<ul>\n<li>插件元数据，包括插件名称、版本、描述等；</li>\n<li>服务（Service）、中间件（Middleware）以及工具函数库（Lib）等；</li>\n<li>Koa 内置对象的扩展，包括 Context、Application、Request 以及 Response 等；</li>\n</ul>\n<p><strong>插件的管理</strong></p>\n<ul>\n<li>安装插件，通过npm install 命令即可，例如：npm install [<@scope>/]@</li>\n<li>启用插件，安装插件后还需要启用插件，插件才会真正生效。启用插件也很简单，只需要配置 plugin.default.js 即可，如果不同环境插件配置不一样，也只需修改相应* 环境的配置（plugin.${env}.js）即可，这里 env 表示 Node 运行时的环境变量，例如：development、test、production 等。如下代码所示：</li>\n</ul>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    path: path.resolve(__dirname, <span class=\"hljs-string\">'../plugins/astroboy-cookie'</span>)\n}\n<span class=\"copy-code-btn copy-04\">复制代码</span></code></pre><p>enable 设置成 true 就可以开启这个插件，path 表示插件的绝对路径，这种一般适合于还在快速迭代中的插件，如果插件已经很稳定了，你就可以把这个插件打包发布成一个 NPM 包，然后通过 package 声明你的插件即可，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\"><span class=\"hljs-string\">'astroboy-cookie'</span>: {\n    <span class=\"hljs-built_in\">enable</span>: <span class=\"hljs-literal\">true</span>,\n    package: <span class=\"hljs-string\">'astroboy-cookie'</span>\n}\n<span class=\"copy-code-btn copy-05\">复制代码</span></code></pre><ul>\n<li>禁用插件，禁用插件就更加简单了，只需将 enable 设置成 false 即可。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-11\">三、Node 接入有赞服务化体系的历程</h2>\n<h3 class=\"heading\" data-id=\"heading-12\">1. 为什么要做服务化？</h3>\n<p>随着公司业务的发展，网站应用的规模不断扩大，垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键，所以在这个时候，分布式服务架构就势在必行了。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">2. 技术栈的选择</h3>\n<p>在介绍技术栈选择之前，先讲一下公司的一些技术背景。</p>\n<blockquote>\n<p>在公司成立初期，为了能够快速开发，把产品快速做出来推出市场，所以我们选择用 PHP 语言，我想这也是大多数创业公司的选择。而随着业务的发展，PHP 越来越难处理复杂的业务。</p>\n</blockquote>\n<p>所以等到了一定时候，我们开始做服务化拆分，那么首先考虑的就是底层技术的选择，我们从下面几点考虑：</p>\n<ul>\n<li>第一个是这门技术的生态是否足够完善，也就是相关的开源软件、工具是否成熟；</li>\n<li>第二个是否能够快速招到你需要的人才。</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-14\">3. 服务化拆分之后，每一层职责分别是什么？</h3>\n<p>对于 Node 层，我们的定位是一层很薄的中间层，Node 这一层不会过多地处理业务逻辑，业务逻辑全部都交给 Java 来处理，它只负责下面三件事情：</p>\n<ul>\n<li>模板渲染：模板渲染说的就是 HTML 模板的渲染；</li>\n<li>业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node 就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。</li>\n<li>接口转发：Java 的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node 需要承担接口转发的角色。</li>\n</ul>\n<p>而对于 Java 这一层，就需要承担业务逻辑以及缓存等复杂的操作，这里就不做过多的介绍了。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">4. Node 如何调用 Java 接口？</h3>\n<p>那么服务化拆分之后，首先要解决的一个问题是：Node 如何调用 Java 提供的接口。首先，我们想到的就是 HTTP 的方式，这里说明一下，我们公司采用的分布式服务化框架是阿里开源的 Dubbo 框架，而 Dubbo 框架本身是支持通过添加注解的方式生成 Restful API 的，所以在初期，我们就是采用这个现成的方案。</p>\n<p>而随着应用数目的增加，这种方式的弊端也逐渐显现出来，主要有下面几点：</p>\n<ul>\n<li>如果某个接口需要暴露给 Node 使用，就需要手动再去添加额外的注解。</li>\n<li>每增加一个应用，运维都需要针对每个应用配置域名，不同的环境又需要配置不同的域名，所以随着应用数的增加，应用域名的管理越来越难维护。</li>\n<li>相应的，node 也需要维护一份很长的域名配置文件。</li>\n<li>由于 Java 是直接提供 HTTP 接口，所以性能上相对 RPC 的方式会低一点。</li>\n</ul>\n<p>所以，我们就调研了下，看其他公司在使用 Dubbo 框架时，Node 是如何调用 Java 的？如下图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce4fa59a7c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1216\" data-height=\"489\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1216\" height=\"489\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>首先，Java 应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是 ETCD 或者 Zookeeper，然后，Node 应用在启动的时候，会先从服务注册中心拉取服务列表，接着 Node 会跟 Java 服务建立一条TCP长链接，除此之外，Node 还需要负责 Hession 协议解析以及负载均衡等。</p>\n<p>不难发现，这种方式 Node 的职责就比较重，而且对 Node 开发的要求会很高。所以，我们对这种方式做了改进，如下图所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385ce94f18acfa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1029\" data-height=\"481\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1029\" height=\"481\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p>我们在 Node 和 Java 之间添加了一层中间代理层 Tether，Tether 是用 Go 语言写的一个本地代理，Tether 会对外暴露一个 HTTP 的服务，对 Node 来说，只需要通过 HTTP 方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由 Tether 来处理。这样，Node 这一层就非常轻量了，那么，最终实现出来，Node 是怎么调用 Java 服务的呢？如下代码所示：</p>\n<pre><code class=\"hljs javascript copyable code-02\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> Service = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../base/BaseService'</span>);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoodsService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span> </span>{\n  <span class=\"hljs-comment\">/**\n   * 根据商品 alias 获取商品详情\n   * @param  {String} alias 商品 alias\n   */</span>\n  <span class=\"hljs-keyword\">async</span> getGoodsDetailByAlias(alias) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">this</span>.invoke(\n      <span class=\"hljs-string\">'com.youzan.ic.service.GoodsService'</span>,\n      <span class=\"hljs-string\">'getGoodsDetailByAlias'</span>,\n      [alias]\n    );\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n}\n<span class=\"hljs-built_in\">module</span>.exports = GoodsService;\n<span class=\"copy-code-btn copy-06\">复制代码</span></code></pre><p>对 Node 来说，调用 Java 服务它只需要关注三个点：</p>\n<ul>\n<li>服务名：服务名是由 Java 的包名 + 类名组成，例如上面的 com.youzan.ic.service.GoodsService</li>\n<li>方法名：Java 类对外暴露的方法，例如上面代码所示的根据商品 alias 查询商品详情的一个方法 getGoodsDetailByAlias</li>\n<li>参数：参数就是传递给 Java 的参数列表</li>\n</ul>\n<p>最后，总结下这种方式都有哪些优点：</p>\n<ul>\n<li>第一个是使用简单，对前端开发非常友好，只需要通过 HTTP 方式调用本地的 Tether 服务即可；</li>\n<li>第二个是多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像 Node 一样，它们都只需要调用本地 Tether 暴露的 HTTP 服务即可，没有额外的开发成本了。</li>\n<li>第三个是后期更方便做协议层的优化，因为这种方式 Tether 其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化 Tether 的性能就可以了。</li>\n</ul>\n<p>那么，看到这里，有人可能又会想，这里 Node 也是通过 HTTP 方式调用 Java 的，性能上是不是也存在问题呢？所以这里我们就做了一些优化，如下代码所示：</p>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">const Agent = require(<span class=\"hljs-string\">'agentkeepalive'</span>);\n\nmodule.exports = new Agent({\n  maxSockets: 100,\n  maxFreeSockets: 10,\n  timeout: 60000,\n  freeSocketKeepAliveTimeout: 30000,\n});\n<span class=\"copy-code-btn copy-07\">复制代码</span></code></pre><p>这里，我们引用了一个 agentkeepalive 包，在 HTTP 早期，每个 HTTP 请求都要求打开一个 TCP Socket 连接，并且使用一次之后就断开这个 TCP 连接，使用 keep-alive 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。所以通过使用 keep-alive 机制，就可以减少 TCP 连接建立次数。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">四、参考资料</h2>\n<p>https://github.com/apache/incubator-dubbo\nhttps://github.com/QianmiOpen/dubbo2.js\nhttps://github.com/QianmiOpen/dubbo-node-client\nhttps://github.com/p412726700/node-zookeeper-dubbo\nhttps://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/22/16385cf039b468ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"640\" data-height=\"400\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"640\" height=\"400\"></svg>\"><figcaption></figcaption></figure><p></p>\n",
      "id": "4lm3xszyd2u0",
      "author": "有赞技术",
      "title": "Node 在有赞的实践",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>Create by <strong>jsliang</strong> on <strong>2018-11-8 13:42:42</strong><br>\nRecently revised in <strong>2018-12-23 21:59:20</strong></p>\n</blockquote>\n<p>Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<br>\n<p> <span style=\"color:red\">【2019-08-16】Hello 小伙伴们，由于 <strong>jsliang</strong> 对文档库进行了重构，这篇文章的一些链接可能失效，而 <strong>jsliang</strong> 没有精力维护掘金这边的旧文章，对此深感抱歉。请需要获取最新文章的小伙伴，点击上面的 GitHub 地址，去文档库查看调整后的文章。</span></p>\n<br>\n<h3 class=\"heading\" data-id=\"heading-0\">本文重点内容</h3>\n<ul>\n<li>Node 基础 - 通过对 Node 基础的了解学习，打下 Node 基础</li>\n<li>Node API - 开启服务提供 API 给前端调用</li>\n<li>Node 连接 MySQL - 通过 npm 安装 mysql，从而实现数据库的链接</li>\n<li>Node 实战 - 企业官网从 0 开始，打造能注册、登录以及留言的企业官网</li>\n<li>Node 部署 - 如何通过部署云服务器，让小伙伴们可以查看到你的网站</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">本文延伸链接</h3>\n<ul>\n<li>Node 部署项目、云服务器以及域名的使用：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 基础代码下载地址：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n<li>本文 Node 成品代码下载地址：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node\" rel=\"nofollow noopener noreferrer\">链接</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">本文成品演示</h3>\n<ul>\n<li>Node 项目演示：<a target=\"_blank\" href=\"http://company.jsliang.top/\" rel=\"nofollow noopener noreferrer\">jsliang 前端有限公司</a></li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47764ad7e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"726\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"726\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-3\"><a id=\"chapter-one\" name=\"chapter-one\">一 目录</a></h2>\n<p> <strong>不折腾的前端，和咸鱼有什么区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#chapter-one\">一 目录</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-two\" name=\"catalog-chapter-two\"></a><a href=\"#chapter-two\">二 前言</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-three\" name=\"catalog-chapter-three\"></a><a href=\"#chapter-three\">三 基础学习</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-one\" name=\"catalog-chapter-three-one\"></a><a href=\"#chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-two\" name=\"catalog-chapter-three-two\"></a><a href=\"#chapter-three-two\">3.2 URL 模块</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-three\" name=\"catalog-chapter-three-three\"></a><a href=\"#chapter-three-three\">3.3 CommonJS</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-four\" name=\"catalog-chapter-three-four\"></a><a href=\"#chapter-three-four\">3.4 包与 npm</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-five\" name=\"catalog-chapter-three-five\"></a><a href=\"#chapter-three-five\">3.5 fs 文件管理</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-six\" name=\"catalog-chapter-three-six\"></a><a href=\"#chapter-three-six\">3.6 fs 案例</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-seven\" name=\"catalog-chapter-three-seven\"></a><a href=\"#chapter-three-seven\">3.7 fs 流</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eight\" name=\"catalog-chapter-three-eight\"></a><a href=\"#chapter-three-eight\">3.8 创建 Web 服务器</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-night\" name=\"catalog-chapter-three-night\"></a><a href=\"#chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-ten\" name=\"catalog-chapter-three-ten\"></a><a href=\"#chapter-three-ten\">3.10 get 与 post</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-three-eleven\" name=\"catalog-chapter-three-eleven\"></a><a href=\"#chapter-three-eleven\">3.11 Node 连接 MySQL</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-four\" name=\"catalog-chapter-four\"></a><a href=\"#chapter-four\">四 Web 实战 —— 企业官网</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-one\" name=\"catalog-chapter-four-one\"></a><a href=\"#chapter-four-one\">4.1 编程环境</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-two\" name=\"catalog-chapter-four-two\"></a><a href=\"#chapter-four-two\">4.2 后端接口</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-three\" name=\"catalog-chapter-four-three\"></a><a href=\"#chapter-four-three\">4.3 注册功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-four\" name=\"catalog-chapter-four-four\"></a><a href=\"#chapter-four-four\">4.4 登录功能</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-four-five\" name=\"catalog-chapter-four-five\"></a><a href=\"#chapter-four-five\">4.5 留言功能</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-five\" name=\"catalog-chapter-five\"></a><a href=\"#chapter-five\">五 工具整合</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-one\" name=\"catalog-chapter-five-one\"></a><a href=\"#chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></td>\n</tr>\n<tr>\n<td> <a id=\"catalog-chapter-five-two\" name=\"catalog-chapter-five-two\"></a><a href=\"#chapter-five-two\">5.2 PM2 - Node 进程管理</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-six\" name=\"catalog-chapter-six\"></a><a href=\"#chapter-six\">六 参考资料</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-seven\" name=\"catalog-chapter-seven\"></a><a href=\"#chapter-seven\">七 线上部署</a></td>\n</tr>\n<tr>\n<td><a id=\"catalog-chapter-eight\" name=\"catalog-chapter-eight\"></a><a href=\"#chapter-eight\">八 归纳总结</a></td>\n</tr>\n</tbody>\n</table>\n<h2 class=\"heading\" data-id=\"heading-4\"><a id=\"chapter-two\" name=\"chapter-two\">二 前言</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-two\">返回目录</a></p>\n</blockquote>\n<p> 本文主要目的：</p>\n<ol>\n<li>整合 Node 基础，加深 <strong>jsliang</strong> 对 Node 的学习了解，并且方便日后复习。</li>\n<li>整合 Node 工具，方便查找在 Node 开发中，有哪些工具比较有利于开发。</li>\n<li>给初学 Node 的小伙伴做一个参考，如有疑问还请在 QQ 群：<code>798961601</code> 中咨询。</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-5\"><a id=\"chapter-three\" name=\"chapter-three\">三 基础</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-three\">返回目录</a></p>\n</blockquote>\n<p> <strong>万丈高楼平地起，地基还得自己起。</strong></p>\n<h3 class=\"heading\" data-id=\"heading-6\"><a id=\"chapter-three-one\" name=\"chapter-three-one\">3.1 HTTP - 开始 Node 之旅</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-one\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>01_http.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-00\" lang=\"bash\">// 1. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 2. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn copy-059\">复制代码</span></code></pre><p> 那么，上面代码，我们要怎么用呢？</p>\n<p> <strong>首先</strong>，将上面的代码复制粘贴到 <code>01_http.js</code> 中。<br>\n <strong>然后</strong>，启动 VS Code 终端：<code>Ctrl + ~</code>。<br>\n <strong>接着</strong>，输入 <code>node 01_http.js</code> 并回车。<br>\n <strong>最后</strong>，打开 <code>localhost:3000</code>：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db47a578759c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"660\" data-height=\"500\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"660\" height=\"500\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> OK，搞定完事，现在我们一一讲解上面代码：</p>\n<ol>\n<li><strong>首先</strong>，我们需要先开启仙人模式。哦，不是，是 HTTP 模式。我们都知道，像 PHP 这类老牌子的后端语言，需要 Apache 或者 Nginx 开启 HTTP 服务。然而我们的 Node 不需要：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-01\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn copy-060\">复制代码</span></code></pre><ol start=\"2\">\n<li><strong>然后</strong>，开启 HTTP 服务，并设置开启的端口：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-02\" lang=\"bash\">/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 步骤 3 代码\n}).listen(3000); // 监听的端口\n<span class=\"copy-code-btn copy-061\">复制代码</span></code></pre><ol start=\"3\">\n<li><strong>接着</strong>，我们设置 HTTP 头部，并往页面打印值，最后结束响应：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-03\" lang=\"bash\">// 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\nres.writeHead(200, {\n  <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n});\n\n// 往页面打印值\nres.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n// 结束响应 \nres.end();\n<span class=\"copy-code-btn copy-062\">复制代码</span></code></pre><ol start=\"4\">\n<li><strong>最后</strong>，我们往浏览器输入 <code>http://localhost:3000/</code>，将访问到我们开启的 Node 服务，从而往页面渲染页面。</li>\n</ol>\n<p> 至此，小伙伴们是不是也开启了自己的 Node 之旅？</p>\n<h3 class=\"heading\" data-id=\"heading-7\"><a id=\"chapter-three-two\" name=\"chapter-three-two\">3.2 URL 模块</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-two\">返回目录</a></p>\n</blockquote>\n<p> URL 模块是什么呢？<br>\n 我们在控制台（终端）开启 Node 模式，并打印出 <code>url</code> 来看一下：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db481725e04bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"509\" data-height=\"230\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"509\" height=\"230\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，它有 <code>Url</code>、<code>parse</code>、<code>resolve</code>、<code>resolveObject</code>、<code>format</code>、<code>URL</code>、<code>URLSearchParams</code>、<code>domainToASCII</code>、<code>domainToUnicode</code> 这么多模块。<br>\n 那么，这些模块都有什么用呢？</p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>02_url.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-04\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 4. 获取服务器请求\n  /**\n   * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n   * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n   * /  ?userName=jsliang&userAge=23\n   * /  /favicon.ico\n   * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n   */\n  <span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    \n    // 5. 使用 url 的 parse 方法\n    /**\n     * parse 方法需要两个参数：\n     * 第一个参数是地址\n     * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n     */ \n    var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n    console.log(result);\n    /**\n     * Url {\n     *   protocol: null,\n     *   slashes: null,\n     *   auth: null,\n     *   host: null,\n     *   port: null,\n     *   hostname: null,\n     *   <span class=\"hljs-built_in\">hash</span>: null,\n     *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n     *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n     *   pathname: <span class=\"hljs-string\">'/'</span>,\n     *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n     *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n     */\n\n    console.log(result.query.userName); // jsliang\n\n    console.log(result.query.userAge); // 23\n  }\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn copy-063\">复制代码</span></code></pre><p> 在上面的代码中：</p>\n<p> <strong>首先</strong>，我们引入该章节的主角 <code>url</code> 模块：</p>\n<pre><code class=\"hljs bash copyable code-05\" lang=\"bash\">// 1. 引入 url 模块\nvar url = require(<span class=\"hljs-string\">\"url\"</span>);\n<span class=\"copy-code-btn copy-064\">复制代码</span></code></pre><p> <strong>然后</strong>，我们引入 <code>http</code> 模块：</p>\n<pre><code class=\"hljs bash copyable code-06\" lang=\"bash\">// 2. 引入 http 模块\nvar http = require(<span class=\"hljs-string\">\"http\"</span>);\n<span class=\"copy-code-btn copy-065\">复制代码</span></code></pre><p> <strong>接着</strong>，我们创建 <code>http</code> 模块，因为 <code>url</code> 的监听，需要 <code>http</code> 模块的开启：</p>\n<pre><code class=\"hljs bash copyable code-07\" lang=\"bash\">// 3. 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  // ... 第 4 步、第 5 步代码\n\n  // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  // 往页面打印值\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n\n  // 结束响应\n  res.end();\n}).listen(3000);\n<span class=\"copy-code-btn copy-066\">复制代码</span></code></pre><p> <strong>最后</strong>，我们访问我们给出的地址：<code>http://localhost:3000/?userName=jsliang&userAge=23</code>，并通过它查看 <code>url</code> 的 <code>parse</code> 模块怎么用，输出啥：</p>\n<pre><code class=\"hljs bash copyable code-08\" lang=\"bash\">// 4. 获取服务器请求\n/**\n  * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23\n  * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息：\n  * /  ?userName=jsliang&userAge=23\n  * /  /favicon.ico\n  * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况\n  */\n<span class=\"hljs-keyword\">if</span>(req.url != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n  \n  // 5. 使用 url 的 parse 方法\n  /**\n    * parse 方法需要两个参数：\n    * 第一个参数是地址\n    * 第二个参数是 <span class=\"hljs-literal\">true</span> 的话表示把 get 传值转换成对象\n    */ \n  var result = url.parse(req.url, <span class=\"hljs-literal\">true</span>);\n  console.log(result);\n  /**\n    * Url {\n    *   protocol: null,\n    *   slashes: null,\n    *   auth: null,\n    *   host: null,\n    *   port: null,\n    *   hostname: null,\n    *   <span class=\"hljs-built_in\">hash</span>: null,\n    *   search: <span class=\"hljs-string\">'?userName=jsliang&userAge=23'</span>,\n    *   query: { userName: <span class=\"hljs-string\">'jsliang'</span>, userAge: <span class=\"hljs-string\">'23'</span> },\n    *   pathname: <span class=\"hljs-string\">'/'</span>,\n    *   path: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span>,\n    *   href: <span class=\"hljs-string\">'/?userName=jsliang&userAge=23'</span> }\n    */\n\n  console.log(result.query.userName); // jsliang\n\n  console.log(result.query.userAge); // 23\n}\n<span class=\"copy-code-btn copy-067\">复制代码</span></code></pre><p> 从中，我们可以看出，我们可以通过 <code>query</code>，获取到我们想要的路径字段。</p>\n<p> 当然，上面只讲解了 <code>parse</code> 的用法，我们可以将上面代码中 <code>if</code> 语句里面的代码全部清空。然后，输入下面的内容，去学习 <code>url</code> 模块更多的内容：</p>\n<ol>\n<li>url 模块所有内容：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-09\" lang=\"bash\">console.log(url);\n\n/**\n * Console：\n { \n   Url: [Function: Url],\n    parse: [Function: urlParse], // 获取地址信息\n    resolve: [Function: urlResolve], // 追加或者替换地址\n    resolveObject: [Function: urlResolveObject],\n    format: [Function: urlFormat], // 逆向 parse，根据地址信息获取原 url 信息\n    URL: [Function: URL],\n    URLSearchParams: [Function: URLSearchParams],\n    domainToASCII: [Function: domainToASCII],\n    domainToUnicode: [Function: domainToUnicode] \n  }\n */\n<span class=\"copy-code-btn copy-068\">复制代码</span></code></pre><ol start=\"2\">\n<li>parse 如何使用</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-010\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com\"</span>));\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: null,\n    query: null,\n    pathname: <span class=\"hljs-string\">'/'</span>,\n    path: <span class=\"hljs-string\">'/'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/'</span> \n  }\n */\n<span class=\"copy-code-btn copy-069\">复制代码</span></code></pre><ol start=\"3\">\n<li>parse 带参数：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-011\" lang=\"bash\">console.log(url.parse(<span class=\"hljs-string\">\"http://www.baidu.com/new?name=zhangsan\"</span>));\n\n/**\n * Console：\n  Url {\n    protocol: <span class=\"hljs-string\">'http:'</span>,\n    slashes: <span class=\"hljs-literal\">true</span>,\n    auth: null,\n    host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    port: null,\n    hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n    <span class=\"hljs-built_in\">hash</span>: null,\n    search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n    query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n    pathname: <span class=\"hljs-string\">'/new'</span>,\n    path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n    href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n  }\n */\n<span class=\"copy-code-btn copy-070\">复制代码</span></code></pre><ol start=\"4\">\n<li><code>format</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-012\" lang=\"bash\">console.log(url.format({\n  protocol: <span class=\"hljs-string\">'http:'</span>,\n  slashes: <span class=\"hljs-literal\">true</span>,\n  auth: null,\n  host: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  port: null,\n  hostname: <span class=\"hljs-string\">'www.baidu.com'</span>,\n  <span class=\"hljs-built_in\">hash</span>: null,\n  search: <span class=\"hljs-string\">'?name=zhangsan'</span>,\n  query: <span class=\"hljs-string\">'name=zhangsan'</span>,\n  pathname: <span class=\"hljs-string\">'/new'</span>,\n  path: <span class=\"hljs-string\">'/new?name=zhangsan'</span>,\n  href: <span class=\"hljs-string\">'http://www.baidu.com/new?name=zhangsan'</span> \n}))\n\n// Console：\n// http://www.baidu.com/new?name=zhangsan\n<span class=\"copy-code-btn copy-071\">复制代码</span></code></pre><ol start=\"5\">\n<li><code>resolve</code> 的使用：</li>\n</ol>\n<pre><code class=\"hljs bash copyable code-013\" lang=\"bash\">console.log(url.resolve(<span class=\"hljs-string\">\"http://www.baidu.com/jsliang\"</span>, <span class=\"hljs-string\">\"梁峻荣\"</span>));\n\n// Console：\n// http://www.baidu.com/梁峻荣\n<span class=\"copy-code-btn copy-072\">复制代码</span></code></pre><p> 当然，<code>url</code> 这里我们只讲解了个入门，更多的还请看官网 API：<a target=\"_blank\" href=\"http://nodejs.cn/api/url.html#url_class_url\" rel=\"nofollow noopener noreferrer\">url | Node.js v10.14.1 文档</a></p>\n<h3 class=\"heading\" data-id=\"heading-8\"><a id=\"chapter-three-three\" name=\"chapter-three-three\">3.3 CommonJS</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-three\">返回目录</a></p>\n</blockquote>\n<ul>\n<li>什么是 CommonJS？</li>\n</ul>\n<p> CommonJS 就是为 JS 的表现来制定规范，因为 JS 没有模块系统、标准库较少、缺乏包管理工具，所以 CommonJS 应运而生，它希望 JS 可以在任何地方运行，而不只是在浏览器中，从而达到 Java、C#、PHP 这些后端语言具备开发大型应用的能力。</p>\n<ul>\n<li>CommonJS 的应用？</li>\n</ul>\n<ol>\n<li>服务器端 JavaScript 应用程序。（Node.js）</li>\n<li>命令行工具</li>\n<li>桌面图形界面应用程序。</li>\n</ol>\n<ul>\n<li>CommonJS 与 Node.js 的关系？</li>\n</ul>\n<p> CommonJS 就是模块化的标准，Node.js 就是 CommonJS（模块化）的实现。</p>\n<ul>\n<li>Node.js 中的模块化？</li>\n</ul>\n<ol>\n<li>在 Node 中，模块分为两类：一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP 模块、URL 模块、FS 模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。</li>\n<li>我们可以将公共的功能抽离出一个单独的 JS 文件存放，然后在需要的情况下，通过 exports 或者 module.exports 将模块导出，并通过 require 引入这些模块。</li>\n</ol>\n<p> 现在，我们通过三种使用方式，来讲解下 Node 中的模块化及 exports/require 的使用。</p>\n<p> 我们先查看下目录：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4838b82f804?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"227\" data-height=\"381\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"227\" height=\"381\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> <strong>方法一</strong>：</p>\n<p> 首先，我们新建 <code>03_CommonJS.js</code>、<code>03_tool-add.js</code>、<code>node_modules/03_tool-multiply.js</code>、<code>node_modules/jsliang-module/tools.js</code> 这 4 个文件/文件夹。<br>\n 其中 <code>package.json</code> 我们暂且不理会，稍后会讲解它如何自动生成。</p>\n<p> 在 <code>03_tool-add.js</code> 中：</p>\n<blockquote>\n<p>03_tool-add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-014\" lang=\"bash\">// 1. 假设我们文件其中有个工具模块\nvar tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\n/**\n * 2. 暴露模块\n * exports.str = str;\n * module.exports = str;\n * 区别：\n * module.exports 是真正的接口\n * exports 是一个辅助工具\n * 如果 module.exports 为空，那么所有的 exports 收集到的属性和方法，都赋值给了 module.exports\n * 如果 module.exports 具有任何属性和方法，则 exports 会被忽略\n */\n\n// exports 使用方法\n// var str = <span class=\"hljs-string\">\"jsliang is very good!\"</span>;\n// exports.str = str; // { str: <span class=\"hljs-string\">'jsliang is very good!'</span> }\n\n// module.exports 使用方法\nmodule.exports = tools;\n<span class=\"copy-code-btn copy-073\">复制代码</span></code></pre><p> 那么，上面的代码有啥含义呢？<br>\n 第一步，我们定义了个工具库 <code>tools</code>。<br>\n 第二步，我们通过 <code>modules.exports</code> 将 <code>tools</code> 进行了导出。<br>\n 所以，我们在 <code>03_CommonJS.js</code> 可以通过 <code>require</code> 导入使用：</p>\n<pre><code class=\"hljs bash copyable code-015\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  /**\n   * Console：\n   * 6\n   * 6\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn copy-074\">复制代码</span></code></pre><p> 这样，我们就完成了 <code>exports</code> 与 <code>require</code> 的初次使用。</p>\n<p> <strong>方法二</strong>：</p>\n<p> 当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node 就很靠谱，它规范我们可以将这些文件都放在 <code>node_modules</code> 目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。</p>\n<p> 所以，我们在 <code>node_modules</code> 中新建一个 <code>03_tool-multiply.js</code> 文件，其内容如下：</p>\n<blockquote>\n<p>03_tool-multiply.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-016\" lang=\"bash\">var tools = {\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn copy-075\">复制代码</span></code></pre><p> 在引用方面，我们只需要通过：</p>\n<pre><code class=\"hljs bash copyable code-017\" lang=\"bash\">// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\nconsole.log(tools2.multiply(1, 2, 3, 4));\n<span class=\"copy-code-btn copy-076\">复制代码</span></code></pre><p> 这样，就可以成功导入 <code>03_tool-multiply.js</code> 文件了。</p>\n<p> <strong>方法三</strong>：</p>\n<p> 如果全部单个文件丢在 <code>node_modules</code> 上，它会显得杂乱无章，所以我们应该定义个自己的模块：<code>jsliang-module</code>，然后将我们的 <code>tools.js</code> 存放在该目录中：</p>\n<blockquote>\n<p>jsliang-module/tools.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-018\" lang=\"bash\">var tools = {\n  add: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = 0;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum += numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  },\n  multiply: (...numbers) => {\n    <span class=\"hljs-built_in\">let</span> sum = numbers[0];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> number <span class=\"hljs-keyword\">in</span> numbers) {\n      sum = sum * numbers[number];\n    }\n    <span class=\"hljs-built_in\">return</span> sum;\n  }\n}\n\nmodule.exports = tools;\n<span class=\"copy-code-btn copy-077\">复制代码</span></code></pre><p> 这样，我们就定义好了自己的工具库。<br>\n 但是，如果我们通过 <code>var tools3 = require('jsliang-module');</code> 去导入，会发现它报 <code>error</code> 了，所以，我们应该在 <code>jsliang-module</code> 目录下，通过下面命令行生成一个 <code>package.json</code></p>\n<blockquote>\n<p>PS E:\\MyWeb\\node_modules\\jsliang-module> npm init --yes</p>\n</blockquote>\n<p> 这样，在 <code>jsliang-module</code> 中就有了 <code>package.json</code>。<br>\n 而我们在 <code>03_CommonJS.js</code> 就可以引用它了：</p>\n<blockquote>\n<p>03_CommonJS.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-019\" lang=\"bash\">var http = require(<span class=\"hljs-string\">\"http\"</span>);\n\nvar tools1 = require(<span class=\"hljs-string\">'./03_tool-add'</span>);\n\n// 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找\nvar tools2 = require(<span class=\"hljs-string\">'03_tool-multiply'</span>);\n\n/**\n * 通过 package.json 来引用文件\n * 1. 通过在 jsliang-module 中 npm init --yes 来生成 package.json 文件\n * 2. package.json 文件中告诉了程序入口文件为 ：<span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"tools.js\"</span>,\n * 3. Node 通过 require 查找 jsliang-module，发现它有个 package.json\n * 4. Node 执行 tools.js 文件\n */\nvar tools3 = require(<span class=\"hljs-string\">'jsliang-module'</span>);\n\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">Hello NodeJS</h1>'</span>);\n  \n  console.log(tools1.add(1, 2, 3));\n  console.log(tools2.multiply(1, 2, 3, 4));\n  console.log(tools3.add(4, 5, 6));\n  /**\n   * Console：\n   * 6\n   * 24\n   * 15\n   * 6\n   * 24\n   * 15\n   * 这里要记得 Node 运行过程中，它请求了两次，\n   * http://localhost:3000/ 为一次，\n   * http://localhost:3000/favicon.ico 为第二次\n   */\n  \n  res.end();\n\n}).listen(3000);\n<span class=\"copy-code-btn copy-078\">复制代码</span></code></pre><p> 到此，我们就通过三种方法，了解了各种 <code>exports</code> 和 <code>require</code> 的姿势以及 Node 模块化的概念啦~</p>\n<p> 参考文献：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/littlebirdlbw/p/5670633.html\" rel=\"nofollow noopener noreferrer\">CommonJS 规范 | 博客园 - Little Bird</a></li>\n<li><a target=\"_blank\" href=\"http://www.cnblogs.com/chenguangliang/p/5856701.html\" rel=\"nofollow noopener noreferrer\">js模块化编程之彻底弄懂CommonJS和AMD/CMD！ | 博客园 - 方便以后复习</a></li>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/ghostwu/p/7298462.html\" rel=\"nofollow noopener noreferrer\">[js高手之路] es6系列教程 - 不定参数与展开运算符(...) | 博客园 - ghostwu</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-9\"><a id=\"chapter-three-four\" name=\"chapter-three-four\">3.4 包与 npm</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-four\">返回目录</a></p>\n</blockquote>\n<p> Node 中除了它自己提供的核心模块之外，还可以自定义模块，以及使用 <strong>第三方模块</strong>。<br>\n Node 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4863f64fe3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"822\" data-height=\"468\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"822\" height=\"468\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 那么，假如我们需要使用一些第三方模块，应该去哪找呢？</p>\n<ol>\n<li><a target=\"_blank\" href=\"https://www.baidu.com\" rel=\"nofollow noopener noreferrer\">百度</a>。百度查找你需要安装的第三方模块的对应内容。</li>\n<li><a target=\"_blank\" href=\"https://www.npmjs.com/\" rel=\"nofollow noopener noreferrer\">npm 官网</a>。如果你已经知道包的名字或者包的作用。那么，直接在 npm 官网上搜索，想必会更快找到想要安装的包。</li>\n</ol>\n<p> 那么，npm 是啥？<br>\n npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。<br>\n 在我们安装 Node 的时候，它默认会顺带给你安装 npm。</p>\n<ul>\n<li><code>npm -v</code>：查看 npm 版本。</li>\n<li><code>npm list</code>：查看当前目录下都安装了哪些 npm 包。</li>\n<li><code>npm info 模块</code>：查看该模块的版本及内容。</li>\n<li><code>npm i 模块@版本号</code>：安装该模块的指定版本。</li>\n</ul>\n<p> 在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识：</p>\n<ul>\n<li><code>i</code>/<code>install</code>：安装。使用 <code>install</code> 或者它的简写 <code>i</code>，都表明你想要下载这个包。</li>\n<li><code>uninstall</code>：卸载。如果你发现这个模块你已经不使用了，那么可以通过 <code>uninstall</code> 卸载它。</li>\n<li><code>g</code>：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。</li>\n<li><code>--save</code>/<code>-S</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>dependencies</code> 中。<code>dependencies</code> 是需要发布在生成环境的。例如：<code>ElementUI</code> 是部署后还需要的，所以通过 <code>-S</code> 形式来安装。</li>\n<li><code>--save-dev</code>/<code>-D</code>：通过该种方式安装的包的名称及版本号会出现在 <code>package.json</code> 中的 <code>devDependencies</code> 中。<code>devDependencies</code> 只在开发环境使用。例如：<code>gulp</code> 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 <code>-D</code> 形式来安装。</li>\n</ul>\n<p> 例子：</p>\n<ul>\n<li><code>cnpm i webpack-cli -D</code></li>\n<li><code>npm install element-ui -S</code></li>\n</ul>\n<p> 那么，这么多的 npm 包，我们通过什么管理呢？<br>\n 答案是 <code>package.json</code>。<br>\n 如果我们需要创建 <code>package.json</code>，那么我们只需要在指定的包管理目录（例如 <code>node_modules</code>）中通过以下命名进行生成：</p>\n<ul>\n<li><code>npm init</code>：按步骤创建 <code>package.json</code>。</li>\n<li><code>npm init --yes</code>：快速创建 <code>package.json</code></li>\n</ul>\n<p> 当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm</p>\n<ul>\n<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-10\"><a id=\"chapter-three-five\" name=\"chapter-three-five\">3.5 fs 文件管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-five\">返回目录</a></p>\n</blockquote>\n<p> 本章节我们讲解下 fs 文件管理：</p>\n<blockquote>\n<p>如需快速找到下面某个内容，请使用 <code>Ctrl + F</code></p>\n</blockquote>\n<ol>\n<li><code>fs.stat</code> 检测是文件还是目录</li>\n<li><code>fs.mkdir</code> 创建目录</li>\n<li><code>fs.writeFile</code> 创建写入文件</li>\n<li><code>fs.appendFile</code> 追加文件</li>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n<li><code>fs.rename</code> 重命名</li>\n<li><code>fs.rmdir</code> 删除目录</li>\n<li><code>fs.unlink</code> 删除文件</li>\n</ol>\n<blockquote>\n<p>此章节文件目录：</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4943495aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"228\" data-height=\"373\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"228\" height=\"373\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> <strong>首先</strong>，我们通过 <code>fs.stat</code> 检查一个读取的是文件还是目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-020\" lang=\"bash\">//  1. fs.stat\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\nfs.stat(<span class=\"hljs-string\">'index.js'</span>, (error, stats) => {\n  <span class=\"hljs-keyword\">if</span>(error) {\n    console.log(error);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(stats);\n    /**\n     * Console：\n     * Stats {\n     *  dev: 886875,\n     *  mode: 33206,\n     *  nlink: 1,\n     *  uid: 0,\n     *  gid: 0,\n     *  rdev: 0,\n     *  blksize: undefined,\n     *  ino: 844424931461390,\n     *  size: 284,\n     *  blocks: undefined,\n     *  atimeMs: 1542847157494,\n     *  mtimeMs: 1543887546361.2158,\n     *  ctimeMs: 1543887546361.2158,\n     *  birthtimeMs: 1542847157493.663,\n     *  atime: 2018-11-22T00:39:17.494Z,\n     *  mtime: 2018-12-04T01:39:06.361Z,\n     *  ctime: 2018-12-04T01:39:06.361Z,\n     *  birthtime: 2018-11-22T00:39:17.494Z }\n     */\n\n    console.log(`文件：<span class=\"hljs-variable\">${stats.isFile()}</span>`); \n    // Console：文件：<span class=\"hljs-literal\">true</span>\n    \n    console.log(`目录：<span class=\"hljs-variable\">${stats.isDirectory()}</span>`); \n    // Console：目录：<span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n})\n<span class=\"copy-code-btn copy-079\">复制代码</span></code></pre><p> 通过 <code>Console</code> 打印出来的信息，我们基础掌握了 <code>fs.stat</code> 的作用。</p>\n<p> <strong>然后</strong>，我们尝试通过 <code>fs.mkdir</code> 创建目录：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-021\" lang=\"bash\">//  2. fs.mkdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.mkdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn copy-080\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中多了一个 <code>css</code> 文件夹。</p>\n<p> <strong>那么</strong>，有创建就有删除，创建的目录如何删除呢？这里讲解下 <code>fs.rmdir</code>：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-022\" lang=\"bash\">//  8. fs.rmdir\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * 接收参数\n * path - 将创建的目录路径\n * mode - 目录权限（读写权限），默认 0777\n * callback - 回调，传递异常参数 err\n */\nfs.rmdir(<span class=\"hljs-string\">'css'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"创建目录成功！\"</span>);\n    // Console：创建目录成功！\n  }\n})\n<span class=\"copy-code-btn copy-081\">复制代码</span></code></pre><p> 通过 <code>node 05_fs.js</code>，我们发现目录中的 <code>css</code> 文件夹被删除了。</p>\n<p> <strong>接着</strong>，我们通过 <code>fs.writeFile</code> 来创建写入文件：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-023\" lang=\"bash\">//  3. fs.writeFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n/**\n * filename (String) 文件名称\n * data (String | Buffer) 将要写入的内容，可以是字符串或者 buffer 数据。\n * · encoding (String) 可选。默认 <span class=\"hljs-string\">'utf-8'</span>，当 data 是 buffer 时，该值应该为 ignored。\n * · mode (Number) 文件读写权限，默认 438。\n * · flag (String) 默认值 <span class=\"hljs-string\">'w'</span>。\n * callback { Function } 回调，传递一个异常参数 err。\n */\nfs.writeFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'Hello jsliang'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">'写入成功！'</span>);\n  }\n})\n<span class=\"copy-code-btn copy-082\">复制代码</span></code></pre><p> 值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加 <code>Hello jsliang</code> 这句话。即：存在即覆盖，不存在即创建。</p>\n<p> 有创建就有删除，感兴趣的可以使用 <code>fs.unlink</code> 进行文件的删除，再次不做过多讲解。</p>\n<p> <strong>既然</strong>，上面的是覆盖文件，那么有没有追加文件呢？有的，使用 <code>fs.appendFile</code> 吧：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-024\" lang=\"bash\">//  4. fs.appendFile\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\nfs.appendFile(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'这段文本是要追加的内容'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"追加成功\"</span>);\n  }\n})\n<span class=\"copy-code-btn copy-083\">复制代码</span></code></pre><p> 这样，我们就成功往里面追加了一段话，从而使 <code>index.js</code> 变成了：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-025\" lang=\"bash\">Hello jsliang这段文本是要追加的内容\n<span class=\"copy-code-btn copy-084\">复制代码</span></code></pre><p> <strong>在上面</strong>，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了：</p>\n<ul>\n<li><code>fs.readFile</code> 读取文件</li>\n<li><code>fs.readdir</code> 读取目录</li>\n</ul>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-026\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 5. fs.readFile\nfs.readFile(<span class=\"hljs-string\">'index.js'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取文件成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取文件成功！\n    // <Buffer 48 65 6c 6c 6f 20 6a 73 6c 69 61 6e 67 e8 bf 99 e6 ae b5 e6 96 87 e6 9c ac e6 98 af e8 a6 81 e8 bf bd e5 8a a0 e7 9a 84 e5 86 85 e5 ae b9>\n  }\n})\n\n// 6. fs.readdir 读取目录\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, data) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"读取目录成功！\"</span>);\n    console.log(data);\n    // Console：\n    // 读取目录成功！\n    // [ <span class=\"hljs-string\">'03_tool-multiply.js'</span>, <span class=\"hljs-string\">'jsliang-module'</span> ]\n  }\n})\n<span class=\"copy-code-btn copy-085\">复制代码</span></code></pre><p> 如上，我们成功做到了读取文件和读取目录。</p>\n<p> <strong>最后</strong>，我们再回顾一开始的目标：</p>\n<p><s>1. <code>fs.stat</code> 检测是文件还是目录</s><br>\n<s>2. <code>fs.mkdir</code> 创建目录</s><br>\n<s>3. <code>fs.writeFile</code> 创建写入文件</s><br>\n<s>4. <code>fs.appendFile</code> 追加文件</s><br>\n<s>5. <code>fs.readFile</code> 读取文件</s><br>\n<s>6. <code>fs.readdir</code> 读取目录</s><br>\n7. <code>fs.rename</code> 重命名<br>\n<s>8. <code>fs.rmdir</code> 删除目录</s><br>\n<s>9. <code>fs.unlink</code> 删除文件</s></p>\n<p> 很好，我们就剩下重命名了：</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-027\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'index.js'</span>, <span class=\"hljs-string\">'jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"重命名成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn copy-086\">复制代码</span></code></pre><p> 当然，如果 <code>fs.rename</code> 还有更劲爆的功能：剪切</p>\n<blockquote>\n<p>05_fs.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-028\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 7. fs.rename 重命名\nfs.rename(<span class=\"hljs-string\">'jsliang.js'</span>, <span class=\"hljs-string\">'node_modules/jsliang.js'</span>, (err) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"剪切成功！\"</span>);\n  }\n})\n<span class=\"copy-code-btn copy-087\">复制代码</span></code></pre><p> OK，通通搞定，现在目录变成了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4968b350f54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"231\" data-height=\"329\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"231\" height=\"329\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-11\"><a id=\"chapter-three-six\" name=\"chapter-three-six\">3.6 fs 案例</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-six\">返回目录</a></p>\n</blockquote>\n<p> 在上一章节中，我们了解了 <code>fs</code> 的文件管理。<br>\n 那么，在这里，我们尝试使用 <code>fs</code> 做点小事情：</p>\n<blockquote>\n<p>06_fsDemo.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-029\" lang=\"bash\">/**\n * 1. fs.stat 检测是文件还是目录\n * 2. fs.mkdir 创建目录\n * 3. fs.writeFile 创建写入文件\n * 4. fs.appendFile 追加文件\n * 5. fs.readFile 读取文件\n * 6. fs.readdir 读取目录\n * 7. fs.rename 重命名\n * 8. fs.rmdir 删除目录\n * 9. fs.unlink 删除文件\n */\n\n// 1. 判断服务器上面有没有 upload 目录，没有就创建这个目录\n// 2. 找出 html 目录下面的所有的目录，然后打印出来\n\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n\n// 图片上传\nfs.stat(<span class=\"hljs-string\">'upload'</span>, (err, stats) => {\n  // 判断有没有 upload 目录\n  <span class=\"hljs-keyword\">if</span>(err) {\n    // 如果没有\n    fs.mkdir(<span class=\"hljs-string\">'upload'</span>, (error) => {\n      <span class=\"hljs-keyword\">if</span>(error) {\n        console.log(error);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"创建 upload 目录成功！\"</span>);\n      }\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    // 如果有\n    console.log(stats.isDirectory());\n    console.log(<span class=\"hljs-string\">\"有 upload 目录，你可以做更多操作！\"</span>);\n  }\n})\n\n// 读取目录全部文件\nfs.readdir(<span class=\"hljs-string\">'node_modules'</span>, (err, files) => {\n  <span class=\"hljs-keyword\">if</span>(err) {\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    // 判断是目录还是文件夹\n    console.log(files);\n\n    <span class=\"hljs-built_in\">let</span> filesArr = [];\n\n    (<span class=\"hljs-keyword\">function</span> getFile(i) {\n      \n      // 循环结束\n      <span class=\"hljs-keyword\">if</span>(i == files.length) {\n        // 打印出所有目录\n        console.log(<span class=\"hljs-string\">\"目录：\"</span>);\n        console.log(filesArr);\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      // 判断目录是文件还是文件夹\n      fs.stat(<span class=\"hljs-string\">'node_modules/'</span> + files[i], (error, stats) => {\n\n        <span class=\"hljs-keyword\">if</span>(stats.isDirectory()) {\n          filesArr.push(files[i]);\n        }\n\n        // 递归调用\n        getFile(i+1);\n        \n      })\n    })(0)\n  }\n})\n<span class=\"copy-code-btn copy-088\">复制代码</span></code></pre><h3 class=\"heading\" data-id=\"heading-12\"><a id=\"chapter-three-seven\" name=\"chapter-three-seven\">3.7 fs 流</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-seven\">返回目录</a></p>\n</blockquote>\n<p> 话不多说，我们了解下 <code>fs</code> 流及其读取：</p>\n<pre><code class=\"hljs bash copyable code-030\" lang=\"bash\">// 新建 fs\nconst fs = require(<span class=\"hljs-string\">'fs'</span>);\n// 流的方式读取文件\n<span class=\"hljs-built_in\">let</span> fileReadStream = fs.createReadStream(<span class=\"hljs-string\">'index.js'</span>);\n// 读取次数\n<span class=\"hljs-built_in\">let</span> count = 0;\n// 保存数据\n<span class=\"hljs-built_in\">let</span> str = <span class=\"hljs-string\">''</span>;\n// 开始读取\nfileReadStream.on(<span class=\"hljs-string\">'data'</span>, (chunk) => {\n  console.log(`<span class=\"hljs-variable\">${++count}</span> 接收到：<span class=\"hljs-variable\">${chunk.length}</span>`);\n  // Console：1 接收到：30\n  str += chunk;\n})\n// 读取完成\nfileReadStream.on(<span class=\"hljs-string\">'end'</span>, () => {\n  console.log(<span class=\"hljs-string\">\"——结束——\"</span>);\n  console.log(count);\n  console.log(str);\n\n  // Console：——结束——\n  // 1\n  // console.log(<span class=\"hljs-string\">\"Hello World！\"</span>);\n})\n// 读取失败\nfileReadStream.on(<span class=\"hljs-string\">'error'</span>, (error) => {\n  console.log(error);\n})\n<span class=\"copy-code-btn copy-089\">复制代码</span></code></pre><p> 在这里，我们通过 <code>fs</code> 模块的 <code>createReadStream</code> 创建了读取流，然后读取文件 <code>index.js</code>，从而最后在控制台输出了：</p>\n<pre><code class=\"hljs bash copyable code-031\" lang=\"bash\">1 接收到：259\n——结束——\n1\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\nconsole.log(<span class=\"hljs-string\">\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"</span>);\n<span class=\"copy-code-btn copy-090\">复制代码</span></code></pre><p> 其中 <code>console.log()</code> 那三行就是 <code>index.js</code> 的文本内容。</p>\n<p> 然后，我们试下流的存入：</p>\n<pre><code class=\"hljs bash copyable code-032\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-built_in\">let</span> data = <span class=\"hljs-string\">'console.log(\"Hello World! 我要存入数据！\")'</span>;\n\n// 创建一个可以写入的流，写入到文件 index.js 中\n<span class=\"hljs-built_in\">let</span> writeStream = fs.createWriteStream(<span class=\"hljs-string\">'index.js'</span>);\n// 开始写入\nwriteStream.write(data, <span class=\"hljs-string\">'utf8'</span>);\n// 写入完成\nwriteStream.end();\nwriteStream.on(<span class=\"hljs-string\">'finish'</span>, () => {\n  console.log(<span class=\"hljs-string\">'写入完成！'</span>);\n  // Console：写入完成\n});\n<span class=\"copy-code-btn copy-091\">复制代码</span></code></pre><p> 我们打开 <code>index.js</code>，会发现里面的内容变成了 <code>console.log(\"Hello World! 我要存入数据！\")</code>，依次，我们通过流的形式进行了读取和写入的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-13\"><a id=\"chapter-three-eight\" name=\"chapter-three-eight\">3.8 创建 Web 服务器</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eight\">返回目录</a></p>\n</blockquote>\n<p> 在这里，我们利用 http 模块、url 模块、path 模块、fs 模块创建一个 Web 服务器。</p>\n<p> 什么是 Web 服务器？<br>\n Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。</p>\n<p> 下面，我们使用 Node 来创建一个 Web 服务：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db499027a9b6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"240\" data-height=\"580\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"240\" height=\"580\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-033\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\nhttp.createServer((req, res) => {\n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        \n        // 如果不存在这个文件\n        \n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(<span class=\"hljs-string\">'./08_WebService/404.html'</span>, (errorNotFound, dataNotFound) => {\n          <span class=\"hljs-keyword\">if</span>(errorNotFound) {\n            console.log(errorNotFound);\n          } <span class=\"hljs-keyword\">else</span> {\n            res.writeHead(200, {\n              <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n            });\n            // 读取写入文件\n            res.write(dataNotFound);\n            // 结束响应\n            res.end();\n          }\n        })\n        <span class=\"hljs-built_in\">return</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n\n        // 返回这个文件\n        \n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n<span class=\"copy-code-btn copy-092\">复制代码</span></code></pre><p> 这样，我们在浏览器输入 <code>localhost:8080</code> 即可以看到：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db49cdf6207cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1220\" data-height=\"1080\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1220\" height=\"1080\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 好家伙，感情它就加载了整个 <code>index.html</code> 文件，连 CSS 这些没引入么？<br>\n 所以，下一步，我们要动态加载 <code>html</code>、<code>css</code> 以及 <code>js</code>：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-034\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  switch(extName) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.html'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.css'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/css'</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'.js'</span>: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/js'</span>;\n    default: <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'text/html'</span>;\n  }\n}\n<span class=\"copy-code-btn copy-093\">复制代码</span></code></pre><p> 这样，当我们再次请求的时候，浏览器就变成了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4a2ba76f9ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"720\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"720\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 当然，在上面，我们仅仅模拟了 <code>html</code>、<code>css</code>、<code>js</code> 这三种文件类型而已，我们需要模拟更多的文件类型：</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/blob/master/NodeBase/08_ext.json\" rel=\"nofollow noopener noreferrer\"> 08_ext.json</a></p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-035\" lang=\"bash\"> 代码详情请点击上面的链接\n<span class=\"copy-code-btn copy-094\">复制代码</span></code></pre><p> 在上面的 <code>json</code> 文件中，我们定义了各种的文件类型，此刻文件目录如下所示：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4ab7f829e99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"236\" data-height=\"422\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"236\" height=\"422\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 这时候，我们需要修改下我们的 <code>js</code> 文件，让它适应多种请求响应了：</p>\n<blockquote>\n<p>08_WebService.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-036\" lang=\"bash\">// 引入 http 模块\n<span class=\"hljs-built_in\">let</span> http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n// 引入 url 模块\n<span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 path 模块\n<span class=\"hljs-built_in\">let</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n\nhttp.createServer((req, res) => {\n  \n  // 获取响应路径\n  <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n  // 默认加载路径\n  <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/\"</span>) {\n    // 默认加载的首页\n    pathName = <span class=\"hljs-string\">\"index.html\"</span>;\n  }\n\n  // 获取文件的后缀名\n  <span class=\"hljs-built_in\">let</span> extName = path.extname(pathName);\n\n  // 过滤 /favicon.ico 的请求\n  <span class=\"hljs-keyword\">if</span> (pathName != <span class=\"hljs-string\">\"/favicon.ico\"</span>) {\n    // 获取 08_WebService 下的 index.html\n    fs.readFile(<span class=\"hljs-string\">\"./08_WebService/\"</span> + pathName, (err, data) => {\n      // 如果不存在这个文件\n      <span class=\"hljs-keyword\">if</span> (err) {\n        console.log(<span class=\"hljs-string\">\"404 Not Found!\"</span>);\n        fs.readFile(\n          <span class=\"hljs-string\">\"./08_WebService/404.html\"</span>,\n          (errorNotFound, dataNotFound) => {\n            <span class=\"hljs-keyword\">if</span> (errorNotFound) {\n              console.log(errorNotFound);\n            } <span class=\"hljs-keyword\">else</span> {\n              res.writeHead(200, {\n                <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html; charset='utf-8'\"</span>\n              });\n              // 读取写入文件\n              res.write(dataNotFound);\n              // 结束响应\n              res.end();\n            }\n          }\n        );\n        <span class=\"hljs-built_in\">return</span>;\n      }\n      // 返回这个文件\n      <span class=\"hljs-keyword\">else</span> {\n        // 获取文件类型\n        <span class=\"hljs-built_in\">let</span> ext = getExt(extName);\n        console.log(ext);\n\n        // 设置请求头\n        res.writeHead(200, {\n          <span class=\"hljs-string\">\"Content-Type\"</span>: ext + <span class=\"hljs-string\">\"; charset='utf-8'\"</span>\n        });\n        // 读取写入文件\n        res.write(data);\n        // 结束响应\n        res.end();\n      }\n    });\n  }\n}).listen(8080);\n\n// 获取后缀名\ngetExt = (extName) => {\n  // <span class=\"hljs-built_in\">read</span>File 是异步操作，所以需要使用 <span class=\"hljs-built_in\">read</span>FileSync\n  <span class=\"hljs-built_in\">let</span> data = fs.readFileSync(<span class=\"hljs-string\">'./08_ext.json'</span>);\n  <span class=\"hljs-built_in\">let</span> ext = JSON.parse(data.toString());\n  <span class=\"hljs-built_in\">return</span> ext[extName];\n}\n<span class=\"copy-code-btn copy-095\">复制代码</span></code></pre><p> 如此，我们做了个简单的 Web 服务器。</p>\n<h3 class=\"heading\" data-id=\"heading-14\"><a id=\"chapter-three-night\" name=\"chapter-three-night\">3.9 非阻塞 I/O 事件驱动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-night\">返回目录</a></p>\n</blockquote>\n<p> Java、PHP 或者 .NET 等服务端语言，会为每一个客户端的连接创建一个新的线程。<br>\n Node 不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。<br>\n 当有用户连接了，就会触发一个内部事件，通过非租塞 I/O、事件驱动机制，让 Node 程序宏观上也是并行的。<br>\n 使用 Node，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。</p>\n<p> 在这一章节中，主要解决：</p>\n<ol>\n<li>Node 的非阻塞 I/O 是什么？</li>\n<li>Node events 模块是什么？</li>\n</ol>\n<p> 首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-037\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"2\"</span>);\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 2\n * 3\n */\n<span class=\"copy-code-btn copy-096\">复制代码</span></code></pre><p> 但是，事与愿违。<br>\n 我们有时候，会执行一些异步方法（函数）：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-038\" lang=\"bash\">console.log(<span class=\"hljs-string\">\"1\"</span>);\n\n// console.log(<span class=\"hljs-string\">\"2\"</span>);\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    console.log(<span class=\"hljs-string\">\"2\"</span>);\n  })\n}\ngetExt();\n\nconsole.log(<span class=\"hljs-string\">\"3\"</span>);\n\n/**\n * Console：\n * 1\n * 3\n * 2\n */\n<span class=\"copy-code-btn copy-097\">复制代码</span></code></pre><p> 在上面代码中，由于 <code>fs.readFile</code> 是 Node 的异步函数。所以，程序先执行了 1 和 3，最后才执行 <code>fs.readFile</code> 的 2 部分。</p>\n<blockquote>\n<p>在这里，可以看出 Node 不会因为一段代码的逻辑错误，从而导致其他代码无法运行。</p>\n</blockquote>\n<p> 这样子，就导致了一个问题：步骤 3 可能拿不到步骤 2 的执行结果了！这就是 Node 的非租塞性 I/O 驱动。<br>\n 那么，我们有没有办法解决这个问题呢？<br>\n 有的！</p>\n<ol>\n<li>通过回调函数</li>\n<li>通过 Node 的 <code>events</code> 模块</li>\n</ol>\n<p> 首先，我们通过回调函数来解决这个异步问题：</p>\n<blockquote>\n<p>09_io.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-039\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\ngetExt = (callback) => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    callback(data);\n  })  \n}\n\ngetExt( (result) => {\n  console.log(result.toString());\n})\n<span class=\"copy-code-btn copy-098\">复制代码</span></code></pre><p> 通过回调，我们可以将 <code>getExt</code> 的数据提取出来。</p>\n<p> 然后，我们通过 Node 的 <code>events</code> 模块来解决这个异步问题：</p>\n<pre><code class=\"hljs bash copyable code-040\" lang=\"bash\">// 引入 fs 模块\n<span class=\"hljs-built_in\">let</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n\n/**\n * Node 事件循环：\n * 1. Node 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。\n * 2. Node 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。\n * 3. Node 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。\n */\n\n// 引入 events 模块\n<span class=\"hljs-built_in\">let</span> events = require(<span class=\"hljs-string\">\"events\"</span>);\n// 实例化事件对象\n<span class=\"hljs-built_in\">let</span> EventEmitter = new events.EventEmitter();\n\ngetExt = () => {\n  fs.readFile(<span class=\"hljs-string\">'08_ext.json'</span>, (err, data) => {\n    // 将 data 广播出去\n    EventEmitter.emit(<span class=\"hljs-string\">'data'</span>, data.toString());\n  })  \n};\n\ngetExt();\n\n// 监听 data\nEventEmitter.on(<span class=\"hljs-string\">'data'</span>, (ext) => {\n  console.log(ext);\n});\n<span class=\"copy-code-btn copy-099\">复制代码</span></code></pre><p> 在这里，<code>EventEmitter.on</code> 通过监听 <code>data</code> 的形式，获取了 <code>getExt</code> 内部的执行结果。<br>\n 如此，我们就了解了 Node 的 I/O 事件及 <code>events</code> 模块</p>\n<h3 class=\"heading\" data-id=\"heading-15\"><a id=\"chapter-three-ten\" name=\"chapter-three-ten\">3.10 get 与 post</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-ten\">返回目录</a></p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4adefcf3363?imageslim\" data-width=\"970\" data-height=\"618\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"970\" height=\"618\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 话不多说，先上代码：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-041\" lang=\"bash\">// 加载 http 模块\nvar http = require(<span class=\"hljs-string\">'http'</span>);\n\n// 虚拟 SQL 读取出来的数据\nvar items = [];\n\n// 创建 http 服务\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n  \n  // 设置跨域的域名，* 代表允许任意域名跨域\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  // 判断请求\n  switch (req.method) {\n    \n    // post 请求时，浏览器会先发一次 options 请求，如果请求通过，则继续发送正式的 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'OPTIONS'</span>:\n      res.statusCode = 200;\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n    \n      // 如果是 get 请求，则直接返回 items 数组\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'GET'</span>:\n      <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n      res.write(data);\n      res.end();\n      <span class=\"hljs-built_in\">break</span>;\n      \n    // 如果是 post 请求\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'POST'</span>:\n      <span class=\"hljs-built_in\">let</span> item = <span class=\"hljs-string\">''</span>;\n      // 读取每次发送的数据\n      req.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n        item += chunk;\n      });\n      // 数据发送完成\n      req.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 存入\n        item = JSON.parse(item);\n        items.push(item.item);\n        // 将数据返回到客户端\n        <span class=\"hljs-built_in\">let</span> data = JSON.stringify(items);\n        res.write(data);\n        res.end();\n      });\n      <span class=\"hljs-built_in\">break</span>;\n  }\n}).listen(3000)\n\nconsole.log(<span class=\"hljs-string\">'http server is start...'</span>);\n<span class=\"copy-code-btn copy-0100\">复制代码</span></code></pre><p> <strong>首先</strong>，我们加载了 <code>http</code> 模块，并创建了服务。<br>\n <strong>然后</strong>，我们设置了跨域的处理方式，允许进行跨域。<br>\n <strong>接着</strong>，我们进行了请求的判断处理，由于只做简单演练，故只判断是 <code>get</code> 请求还是 <code>post</code> 请求。<br>\n <strong>最后</strong>，我们将请求的结果返回给客户端。</p>\n<p> 在上面，我们进行了后端 Node 的部署，那么前端页面要怎么做呢？</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-042\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-⌃-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>Node Web</title>\n\n</head>\n\n<body>\n\n  <div id=<span class=\"hljs-string\">\"app\"</span>>\n    <h1>Todo List</h1>\n    <ul>\n      <li v-for=<span class=\"hljs-string\">\"(item, index) in items\"</span> :key=<span class=\"hljs-string\">\"index\"</span>>{{ item }}</li>\n    </ul>\n    <input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> v-model=<span class=\"hljs-string\">\"item\"</span>>\n    <button @click=<span class=\"hljs-string\">\"postApi\"</span>>添加</button>\n  </div>\n\n  <!-- cdn 引用：Vue 和 Node -->\n  <script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"https://unpkg.com/axios/dist/axios.min.js\"</span>></script>\n  \n  <script>\n    new Vue({\n      el: document.getElementById(<span class=\"hljs-string\">'app'</span>),\n      data: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        <span class=\"hljs-built_in\">return</span> {\n          items: [],\n          item: <span class=\"hljs-string\">''</span>,\n        }\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-title\">created</span></span>() {\n        // 进入页面请求数据\n        axios.get(<span class=\"hljs-string\">'http://localhost:3000/'</span>).then(res => {\n          console.log(<span class=\"hljs-string\">\"\\n【API - get 数据】\"</span>);\n          console.log(res);\n          this.items = res.data;\n        }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err)\n        })\n      },\n      methods: {\n        // 点击按钮提交数据\n        <span class=\"hljs-function\"><span class=\"hljs-title\">postApi</span></span>() {\n          axios.post(<span class=\"hljs-string\">'http://localhost:3000/'</span>, {\n            item: this.item\n          }).then(res => {\n            console.log(<span class=\"hljs-string\">\"\\n【API - post 数据】\"</span>)\n            console.log(res);\n            this.items = res.data;\n          }).catch(<span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err)\n          })\n        }\n      }\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn copy-0101\">复制代码</span></code></pre><p> 我们通过 Vue 进行了布局，通过 Axios 进行了接口的请求。从而完成了对数据的操作。</p>\n<h3 class=\"heading\" data-id=\"heading-16\"><a id=\"chapter-three-eleven\" name=\"chapter-three-eleven\">3.11 Node 连接 MySQL</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-three-eleven\">返回目录</a></p>\n</blockquote>\n<blockquote>\n<p>关于 MySQL 的安装，可以查看 <strong>jsliang</strong> 写的：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">MySQL 安装及图形化工具</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们通过可视化工具进行表的设计：</p>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>age</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>然后</strong>，我们进行表的填充：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>jslliang</td>\n<td>23</td>\n</tr>\n<tr>\n<td>2</td>\n<td>梁峻荣</td>\n<td>23</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>接着</strong>，我们安装 Node 连接 MySQL 的包：</p>\n<pre><code class=\"hljs bash copyable code-043\" lang=\"bash\">npm i mysql -D\n<span class=\"copy-code-btn copy-0102\">复制代码</span></code></pre><p> <strong>再来</strong>，我们编写 Node 的 <code>index.js</code>：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-044\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\nconnection.query(<span class=\"hljs-string\">'SELECT * FROM user'</span>, <span class=\"hljs-keyword\">function</span> (error, results, fields) {\n  <span class=\"hljs-keyword\">if</span> (error) throw error;\n  console.log(results);\n});\n\nconnection.end();\n<span class=\"copy-code-btn copy-0103\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，打开该服务：</p>\n<pre><code class=\"hljs bash copyable code-045\" lang=\"bash\">[ RowDataPacket { id: 1, name: <span class=\"hljs-string\">'jsliang'</span>, age: <span class=\"hljs-string\">'23'</span> },\n  RowDataPacket { id: 2, name: <span class=\"hljs-string\">'梁峻荣'</span>, age: <span class=\"hljs-string\">'23'</span> } ]\n<span class=\"copy-code-btn copy-0104\">复制代码</span></code></pre><p> 如此，我们便完成了 Node 连接 MySQL。</p>\n<p> ———————华丽分割线———————</p>\n<p> 当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。</p>\n<p> 先看目录：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b034ab5dc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"178\" data-height=\"261\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"178\" height=\"261\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>新增表字段</strong></li>\n</ul>\n<blockquote>\n<p>add.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-046\" lang=\"bash\">var mysql = require(<span class=\"hljs-string\">'mysql'</span>);\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\nconnection.connect();\n\n<span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(id,name,age) VALUES(0,?,?)\"</span>;\n<span class=\"hljs-built_in\">let</span> addSqlParams = [<span class=\"hljs-string\">\"jsliang\"</span>, <span class=\"hljs-string\">\"23\"</span>];\n\nconnection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"新增成功：\"</span>);\n    console.log(res);\n  }\n});\n\nconnection.end();\n<span class=\"copy-code-btn copy-0105\">复制代码</span></code></pre><p> 我们只需要直接 <code>node add.js</code>，就能往数据库中新增数据了。</p>\n<ul>\n<li><strong>删除表字段</strong></li>\n</ul>\n<blockquote>\n<p>delete.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-047\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\nvar delSql = <span class=\"hljs-string\">'DELETE FROM user where id = 2'</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(delSql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"删除错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"删除成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn copy-0106\">复制代码</span></code></pre><ul>\n<li><strong>修改表字段</strong></li>\n</ul>\n<blockquote>\n<p>update.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-048\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> updateSql = <span class=\"hljs-string\">\"UPDATE user SET name = ?,age = ? WHERE Id = ?\"</span>;\n<span class=\"hljs-built_in\">let</span> updateSqlParams = [<span class=\"hljs-string\">\"LiangJunrong\"</span>, <span class=\"hljs-string\">\"23\"</span>, 1];\n\n// 连接 SQL 并实施语句\nconnection.query(updateSql, updateSqlParams, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    console.log(<span class=\"hljs-string\">\"修改错误：\"</span>);\n    console.log(err);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    console.log(<span class=\"hljs-string\">\"修改成功：\"</span>);\n    console.log(res);\n  }\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn copy-0107\">复制代码</span></code></pre><ul>\n<li><strong>查询表字段</strong></li>\n</ul>\n<blockquote>\n<p>read.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-049\" lang=\"bash\">// 连接 MySQL\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'node'</span>\n});\n\n// 开始连接\nconnection.connect();\n\n// 新增的 SQL 语句及新增的字段信息\n<span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n\n// 连接 SQL 并实施语句\nconnection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (err, res) {\n  <span class=\"hljs-keyword\">if</span> (err) throw err;\n  console.log(res);\n});\n\n// 终止连接\nconnection.end();\n<span class=\"copy-code-btn copy-0108\">复制代码</span></code></pre><p> 以上，我们打通了 Node 与 MySQL 的壁垒，实现了数据的增删改查。</p>\n<h2 class=\"heading\" data-id=\"heading-17\"><a id=\"chapter-four\" name=\"chapter-four\">四 Web 实战 —— 企业官网</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-four\">返回目录</a></p>\n</blockquote>\n<p> 在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo 制作、ico 制作、icon 挑选等……</p>\n<p> 下面这些都是 <strong>jsliang</strong> 平时碰到的，小伙伴有需要的可以 mark 啦~</p>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.uugai.com/logoa/wenzi.php\" rel=\"nofollow noopener noreferrer\">logo 制作</a></li>\n<li><a target=\"_blank\" href=\"http://www.bitbug.net/\" rel=\"nofollow noopener noreferrer\">ico 制作</a></li>\n<li><a target=\"_blank\" href=\"https://www.iconfont.cn/home/index\" rel=\"nofollow noopener noreferrer\">icon 挑选</a></li>\n</ul>\n<p> 另外，由于 HTML 与 CSS 没什么好讲的，所以本章节的前提静态页面 <strong>jsliang</strong> 已经写好了，小伙伴们在学习前可以预先下载：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">本文静态页面代码地址</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-18\"><a id=\"chapter-four-one\" name=\"chapter-four-one\">4.1 编程环境</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-one\">返回目录</a></p>\n</blockquote>\n<p> <strong>首先</strong>，我们查看下我们的前端基本代码：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/Node/tree/FrontEndCodeBase\" rel=\"nofollow noopener noreferrer\">地址</a></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b22a71f82d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1010\" data-height=\"340\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1010\" height=\"340\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 如上，我们仅需要了解 FrontEndCode 目录以及 NodeWeb 目录即可，其他目录为上面章节练习参考。</p>\n<p> <strong>然后</strong>，我们进行后端功能分析：</p>\n<ol>\n<li>留言板。用户点击 <strong>留言板</strong> 的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到 <strong>登录页</strong>；如果用户登录了，则显示 <strong>留言板页面</strong>。</li>\n</ol>\n<p> 在 <strong>留言板页面</strong> 中，存在两个接口：</p>\n<ul>\n<li><strong>获取留言内容</strong>：调取 <code>getMessage</code> 接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。</li>\n<li><strong>提交留言内容</strong>：调取 <code>sendMessage</code> 接口，将用户名、用户 id、留言内容发送给后端。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4b629555859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1219\" data-height=\"828\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1219\" height=\"828\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol start=\"2\">\n<li>在 <strong>登录页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>登录</strong>：调取 <code>login</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db4eac593083f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1180\" data-height=\"810\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1180\" height=\"810\"></svg>\"><figcaption></figcaption></figure><p></p>\n<ol start=\"3\">\n<li>在 <strong>注册页面</strong> 中，存在一个接口：</li>\n</ol>\n<ul>\n<li><strong>注册</strong>：调取 <code>register</code> 接口，提交用户填写的姓名和密码。</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db50d7d913be2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1200\" data-height=\"800\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1200\" height=\"800\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 由此，我们可以设计下前后端的接口结合：</p>\n<blockquote>\n<p>接口文档</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>类型</th>\n<th>参数</th>\n<th>返回信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getMessage</code>：获取留言信息</td>\n<td>get</td>\n<td>无参</td>\n<td>n 条记录：id(用户 id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间)</td>\n</tr>\n<tr>\n<td><code>sendMessage</code>：提交留言信息</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_message(用户留言内容)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>login</code>：登录</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n<tr>\n<td><code>register</code>：注册</td>\n<td>post</td>\n<td>id(用户 id)、user_name(用户名)、user_password(用户密码)</td>\n<td>status 状态</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>最后</strong>，我们进行 MySQL 数据库的表设计：</p>\n<blockquote>\n<p>user 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_password</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>message 表</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名</th>\n<th>类型</th>\n<th>长度</th>\n<th>键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int</td>\n<td>11</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>user_message</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>varchar</td>\n<td>255</td>\n<td>外键</td>\n</tr>\n<tr>\n<td>user_name</td>\n<td>varchar</td>\n<td>255</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>datetime</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" data-id=\"heading-19\"><a id=\"chapter-four-two\" name=\"chapter-four-two\">4.2 后端接口</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-two\">返回目录</a></p>\n</blockquote>\n<p> 在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个 <code>test</code> 文件夹，里面放一个 <code>index.html</code> 以及一个 <code>index.js</code> 来测试一下。</p>\n<pre><code class=\"hljs bash copyable code-050\" lang=\"bash\">- text\n - index.html\n - index.js\n<span class=\"copy-code-btn copy-0109\">复制代码</span></code></pre><p> <strong>首先</strong>，我们就 4.1 提到的接口，提前进行后端接口的设置：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-051\" lang=\"bash\">// 连接 MySQL：先安装 npm i mysql -D\nvar mysql = require(<span class=\"hljs-string\">'mysql'</span>);\n// MySQL 的连接信息\nvar connection = mysql.createConnection({\n  host: <span class=\"hljs-string\">'localhost'</span>,\n  user: <span class=\"hljs-string\">'root'</span>,\n  password: <span class=\"hljs-string\">'123456'</span>,\n  database: <span class=\"hljs-string\">'nodebase'</span>\n});\n// 开始连接\nconnection.connect();\n\n// 引入 http 模块：http 是提供 Web 服务的基础\nconst http = require(<span class=\"hljs-string\">\"http\"</span>);\n\n// 引入 url 模块：url 是对用户提交的路径进行解析\nconst url = require(<span class=\"hljs-string\">\"url\"</span>);\n\n// 引入 qs 模块：qs 是对路径进行 json 化或者将 json 转换为 string 路径\nconst qs = require(<span class=\"hljs-string\">\"querystring\"</span>);\n\n// 用 http 模块创建服务\n/**\n * req 获取 url 信息 (request)\n * res 浏览器返回响应信息 (response)\n */\nhttp.createServer(<span class=\"hljs-keyword\">function</span> (req, res) {\n\n  // 设置 cors 跨域\n  res.setHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"hljs-string\">\"*\"</span>);\n  // 设置 header 类型\n  res.setHeader(<span class=\"hljs-string\">'Access-Control-Allow-Headers'</span>, <span class=\"hljs-string\">'Content-Type'</span>);\n  // 跨域允许的请求方式\n  res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\n  <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"POST\"</span>) { // 接口 POST 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【POST 形式】\"</span>);\n\n    // 获取前端发来的路由地址\n    <span class=\"hljs-built_in\">let</span> pathName = req.url;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    // 接收发送过来的参数\n    <span class=\"hljs-built_in\">let</span> tempResult = <span class=\"hljs-string\">\"\"</span>;\n\n    // 数据接入中\n    req.addListener(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-keyword\">function</span> (chunk) {\n      tempResult += chunk;\n    });\n\n    // 数据接收完成\n    req.addListener(<span class=\"hljs-string\">\"end\"</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n      var result = JSON.stringify(qs.parse(tempResult));\n      console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n      console.log(result);\n\n      <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n        console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n      }\n      // 接口信息处理完毕\n    })\n    // 数据接收完毕\n\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (req.method == <span class=\"hljs-string\">\"GET\"</span>) { // 接口 GET 形式\n\n    console.log(<span class=\"hljs-string\">\"\\n【GET 形式】\"</span>);\n\n    // 解析 url 接口\n    <span class=\"hljs-built_in\">let</span> pathName = url.parse(req.url).pathname;\n\n    console.log(<span class=\"hljs-string\">\"\\n接口为：\"</span> + pathName);\n\n    <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n      console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n      res.writeHead(200, {\n        <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n      });\n\n      res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n      res.end();\n    }\n\n  }\n\n}).listen(8888); // 监听的端口\n\n// 获取当前时间\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getNowFormatDate</span></span>() {\n  var date = new Date();\n  var year = date.getFullYear(); // 年\n  var month = date.getMonth() + 1; // 月\n  var strDate = date.getDate(); // 日\n  var hour = date.getHours(); // 时\n  var minute = date.getMinutes(); // 分\n  var second = date.getMinutes(); // 秒\n  <span class=\"hljs-keyword\">if</span> (month >= 1 && month <= 9) {\n    month = <span class=\"hljs-string\">\"0\"</span> + month;\n  }\n  <span class=\"hljs-keyword\">if</span> (strDate >= 0 && strDate <= 9) {\n    strDate = <span class=\"hljs-string\">\"0\"</span> + strDate;\n  }\n  // 返回 yyyy-mm-dd hh:mm:ss 形式\n  var currentdate = year + <span class=\"hljs-string\">\"-\"</span> + month + <span class=\"hljs-string\">\"-\"</span> + strDate + <span class=\"hljs-string\">\" \"</span> + hour + <span class=\"hljs-string\">\":\"</span> + minute + <span class=\"hljs-string\">\":\"</span> + second;\n  <span class=\"hljs-built_in\">return</span> currentdate;\n}\n<span class=\"copy-code-btn copy-0110\">复制代码</span></code></pre><p> 通过判断 <code>req.method</code> 属于 <code>GET</code> 还是 <code>POST</code> 形式，从而确定加载的接口：</p>\n<ul>\n<li>在 <code>POST</code> 中，判断是属于 <strong>提交留言信息</strong>、<strong>登录</strong> 还是 <strong>注册</strong>；</li>\n<li>在 <code>GET</code> 中，判断是不是 <strong>获取留言信息</strong>。</li>\n</ul>\n<p> <strong>同时</strong>，我们在其中定义了 MySQL 的连接以及一个 <code>getNowFormatDate</code> 用来获取当前时间，格式为：<code>2018-12-21 10:03:59</code></p>\n<p> <strong>然后</strong>，我们通过一个前端页面来演示我们的接口是否能使用：</p>\n<blockquote>\n<p>index.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-052\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>演示代码</title>\n</head>\n\n<body>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"user\"</span>>用户名</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text\"</span> id=<span class=\"hljs-string\">\"user\"</span>>\n  </div>\n  <div>\n    <label <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">\"password\"</span>>密&nbsp;&nbsp;&nbsp;码</label><input <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"password\"</span> id=<span class=\"hljs-string\">\"password\"</span>>\n  </div>\n  <div>\n    <button id=<span class=\"hljs-string\">\"register\"</span>>注册</button>\n  </div>\n\n  <script src=<span class=\"hljs-string\">\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      // 测试 get 接口\n      $.ajax({\n        url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n        <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n        data: {\n          username: <span class=\"hljs-string\">\"jsliang\"</span>\n        },\n        success: <span class=\"hljs-keyword\">function</span> (res) {\n          console.log(res);\n        },\n        error: <span class=\"hljs-keyword\">function</span> (err) {\n          console.log(err);\n        }\n      })\n\n      $(<span class=\"hljs-string\">\"#register\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n        // 测试 post 接口\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">\"POST\"</span>,\n          data: {\n            username: $(<span class=\"hljs-string\">\"#user\"</span>).val(),\n            password: $(<span class=\"hljs-string\">\"#password\"</span>).val()\n          },\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      })\n    });\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn copy-0111\">复制代码</span></code></pre><p> <strong>最后</strong>，我们通过 <code>node index.js</code>，并打开 <code>index.html</code>，通过 <code>F12</code> 控制台查看我们的接口是否正常：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db510727a4435?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"684\" data-height=\"662\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"684\" height=\"662\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这 4 个接口的设计了。</p>\n<blockquote>\n<p>如果小伙伴们觉得每次更新 Node 代码后，又要重启一遍 <code>node index.js</code> 觉得麻烦，可以通过 <code>supervisor</code> 来监听 Node 代码的改动，<code>supervisor</code> 的安装使用：<a href=\"#chapter-five-one\">supervisor</a></p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-20\"><a id=\"chapter-four-three\" name=\"chapter-four-three\">4.3 注册功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-three\">返回目录</a></p>\n</blockquote>\n<p> 很好，我们回到仿企业网站的页面上，准备编写接口以及丰富 Node 的接口。</p>\n<p> <strong>首先</strong>，我们开启前端和 Node 服务：</p>\n<ol>\n<li>\n<p>打开命令行/终端</p>\n</li>\n<li>\n<p>开启前端</p>\n</li>\n</ol>\n<ul>\n<li><code>cd FrontEndCode</code></li>\n<li><code>live-server</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>live-server</code>：<code>npm i live-server -g</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>开启后端</li>\n</ol>\n<ul>\n<li><code>cd NodeWeb</code></li>\n<li><code>supervisor index.js</code></li>\n</ul>\n<blockquote>\n<p>安装 <code>supervisor</code>：<code>npm i supervisor -g</code></p>\n</blockquote>\n<p> <strong>然后</strong>，我们在注册页面通过点击事件来触发调接口：</p>\n<blockquote>\n<p>register.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-053\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>注册-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  <!-- 省略 body 中代码，有需要的请前往第四章开头下载查看全部代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#register-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val();\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val();\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          // 如果用户输入的没毛病，那就加载接口\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/register\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册成功，前往登录！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./login.html\"</span>;\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>) {\n                alert(<span class=\"hljs-string\">\"用户名已被注册！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，名额已满！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"注册失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn copy-0112\">复制代码</span></code></pre><p> 如此，我们在用户点击 <strong>注册</strong> 按钮的时候，进行接口的调用，发送数据到了后端，如果成功了，那就弹窗，并跳转到登录页；如果没成功，就弹窗提示。</p>\n<p> <strong>接着</strong>，我们编写 Node，前端调用接口后，Node 判断这两个参数是否为空，如果不为空，则将数据存储到数据库。</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-054\" lang=\"bash\">// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"注册失败，用户名为空。\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"注册失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) { // 姓名过长\n    res.end(<span class=\"hljs-string\">\"注册失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) { // 密码过长\n    res.end(<span class=\"hljs-string\">\"注册失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 查询 user 表\n    // 使用 Promise 的原因是因为中间调用了两次数据库，而数据库查询是异步的，所以需要用 Promise。\n    new Promise( (resolve, reject) => {\n\n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user\"</span>;\n      \n      // 连接 SQL 并实施语句\n      connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n        \n        <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n          throw error1;\n        } <span class=\"hljs-keyword\">else</span> {\n          \n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n\n          // 将结果先去掉 RowDataPacket，再转换为 json 对象\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          // 判断姓名重复与否\n          <span class=\"hljs-built_in\">let</span> userNameRepeat = <span class=\"hljs-literal\">false</span>;\n          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> newRes) {\n            <span class=\"hljs-keyword\">if</span>(newRes[item].user_name == username) {\n              userNameRepeat = <span class=\"hljs-literal\">true</span>;\n            }\n          }\n\n          // 如果姓名重复\n          <span class=\"hljs-keyword\">if</span>(userNameRepeat) {\n            res.end(<span class=\"hljs-string\">\"注册失败，姓名重复！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(newRes.length > 300) { // 如果注册名额已满\n            res.end(<span class=\"hljs-string\">\"注册失败，名额已满！\"</span>);\n            <span class=\"hljs-built_in\">return</span>;\n          } <span class=\"hljs-keyword\">else</span> { // 可以注册\n            resolve();\n          }\n          \n        }\n      });\n\n    }).then( () => {\n      \n      console.log(<span class=\"hljs-string\">\"\\n第二步：\"</span>);\n      \n      // 新增的 SQL 语句及新增的字段信息\n      <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO user(user_name,user_password, time) VALUES(?,?,?)\"</span>;\n      <span class=\"hljs-built_in\">let</span> addSqlParams = [result.username, result.password, time];\n\n      // 连接 SQL 并实施语句\n      connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error2, response2) {\n        <span class=\"hljs-keyword\">if</span> (error2) { // 如果 SQL 语句错误\n          console.log(<span class=\"hljs-string\">\"新增错误：\"</span>);\n          console.log(error2);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n          console.log(<span class=\"hljs-string\">\"\\nSQL 查询结果：\"</span>);\n          console.log(response2);\n\n          console.log(<span class=\"hljs-string\">\"\\n注册成功！\"</span>);\n\n          // 返回数据\n          res.write(JSON.stringify({\n            code: <span class=\"hljs-string\">\"0\"</span>,\n            message: <span class=\"hljs-string\">\"注册成功！\"</span>\n          }));\n\n          // 结束响应\n          res.end();\n        }\n      });\n\n    })\n    // Promise 结束\n  }\n  // 注册流程结束\n}\n<span class=\"copy-code-btn copy-0113\">复制代码</span></code></pre><p> <strong>最后</strong>，我们在查看下该功能是否成功：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5157604487c?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-21\"><a id=\"chapter-four-four\" name=\"chapter-four-four\">4.4 登录功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-four\">返回目录</a></p>\n</blockquote>\n<p> 在上面，我们完成了注册功能，那么相对来说，登录功能就容易通了，因为查询部分我们已经试过了一次。</p>\n<blockquote>\n<p>login.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-055\" lang=\"bash\"><!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>登录-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，有需要的小伙伴请在第四章前言部分下载代码 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      $(<span class=\"hljs-string\">\"#login-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\n        <span class=\"hljs-built_in\">let</span> userName = $(<span class=\"hljs-string\">\"#userName\"</span>).val(); // 用户名\n        <span class=\"hljs-built_in\">let</span> userPassword = $(<span class=\"hljs-string\">\"#userPassword\"</span>).val(); // 密码\n\n        <span class=\"hljs-keyword\">if</span> (!userName) {\n          alert(<span class=\"hljs-string\">\"请输入用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!userPassword) {\n          alert(<span class=\"hljs-string\">\"请输入密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userName.length > 10) {\n          alert(<span class=\"hljs-string\">\"请输入少于 10 位的用户名\"</span>);\n          $(<span class=\"hljs-string\">\"#userName\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (userPassword.length > 20) {\n          alert(<span class=\"hljs-string\">\"请输入少于 20 位的密码\"</span>);\n          $(<span class=\"hljs-string\">\"#userPassword\"</span>).focus();\n        } <span class=\"hljs-keyword\">else</span> {\n\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/login\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              username: userName,\n              password: userPassword\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                sessionStorage.setItem(<span class=\"hljs-string\">\"id\"</span>, res.data.id);\n                sessionStorage.setItem(<span class=\"hljs-string\">\"userName\"</span>, res.data.userName);\n                alert(<span class=\"hljs-string\">\"登录成功！\"</span>);\n                window.location.href = <span class=\"hljs-string\">\"./messageBoard.html\"</span>;\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.code == <span class=\"hljs-string\">\"1\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码错误！\"</span>);\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"不存在该用户！\"</span>) {\n                alert(<span class=\"hljs-string\">\"不存在该用户！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，密码过长！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n\n        }\n\n      })\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn copy-0114\">复制代码</span></code></pre><p> 编写完前端的代码后，我们进行 Node 代码的编辑：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-056\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> username = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> password = result.password; // 密码\n\n  <span class=\"hljs-keyword\">if</span> (!username) { // 用户名为空\n    res.end(<span class=\"hljs-string\">\"登录失败，用户名为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!password) { // 密码为空\n    res.end(<span class=\"hljs-string\">\"登录失败，密码为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(username.length > 10) {\n    res.end(<span class=\"hljs-string\">\"登录失败，姓名过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(password.length > 20) {\n    res.end(<span class=\"hljs-string\">\"登录失败，密码过长！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> { \n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM user WHERE user_name  = '\"</span> + username + <span class=\"hljs-string\">\"'\"</span>;\n\n    // 连接 SQL 并实施语句\n    connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) {\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">if</span>(response1 == undefined || response1.length == 0) { // 不存在用户\n          res.end(<span class=\"hljs-string\">\"\\n不存在该用户！\"</span>);\n          <span class=\"hljs-built_in\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> { // 存在用户\n          console.log(<span class=\"hljs-string\">\"\\n存在该用户！\"</span>);\n\n          <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n          console.log(newRes);\n\n          <span class=\"hljs-keyword\">if</span>(newRes[0].user_password == password) { // 密码正确\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"0\"</span>,\n              message: <span class=\"hljs-string\">\"登录成功！\"</span>,\n              data: {\n                id: newRes[0].id,\n                userName: newRes[0].user_name\n              }\n            }));\n\n            res.end();\n          } <span class=\"hljs-keyword\">else</span> { // 密码错误\n            // 返回数据\n            res.write(JSON.stringify({\n              code: <span class=\"hljs-string\">\"1\"</span>,\n              message: <span class=\"hljs-string\">\"登录失败，密码错误！\"</span>\n            }));\n\n            res.end();\n          }\n          // 判断密码正确与否完毕\n        }\n        // 存在用户处理结束\n      }\n    });\n  }\n  // 登录步骤结束\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n<span class=\"copy-code-btn copy-0115\">复制代码</span></code></pre><p> 很好，前端和后端都编写完毕，是时候查验下功能是否实现了：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db52440fdaf7f?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-22\"><a id=\"chapter-four-five\" name=\"chapter-four-five\">4.5 留言功能</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-four-five\">返回目录</a></p>\n</blockquote>\n<p> 现在，我们就剩下留言功能了，一鼓作气做好它吧！</p>\n<blockquote>\n<p>messageBoard.html</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-057\" lang=\"bash\"><!-- 留言板 -->\n<!DOCTYPE html>\n<html lang=<span class=\"hljs-string\">\"en\"</span>>\n\n<head>\n  <meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"keywords\"</span> content=<span class=\"hljs-string\">\"前端,jsliang,bootstrap,企业建站\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"description\"</span> content=<span class=\"hljs-string\">\"jsliang 为你打造最好的企业服务\"</span>>\n  <link rel=<span class=\"hljs-string\">\"shortcut icon\"</span> href=<span class=\"hljs-string\">\"./images/favicon.ico\"</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span> />\n  <meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>>\n  <meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"ie=edge\"</span>>\n  <title>留言板-jsliang 前端有限公司</title>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/index.css\"</span>>\n  <link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"./css/bootstrap.min.css\"</span>>\n</head>\n\n<body>\n  \n  <!-- 代码省略，基础代码请前往本章节前言下载 -->\n\n  <script src=<span class=\"hljs-string\">\"./js/jquery-3.3.1.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/bootstrap.min.js\"</span>></script>\n  <script src=<span class=\"hljs-string\">\"./js/islogin.js\"</span>></script>\n  <script>\n    $(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n      \n      <span class=\"hljs-built_in\">let</span> userName = sessionStorage.getItem(<span class=\"hljs-string\">\"userName\"</span>);\n      <span class=\"hljs-built_in\">let</span> userId = sessionStorage.getItem(<span class=\"hljs-string\">\"id\"</span>);\n      \n      // 查询留言板\n      <span class=\"hljs-keyword\">if</span>(userName && userId) { // 如果有存储\n        $.ajax({\n          url: <span class=\"hljs-string\">\"http://localhost:8888/getMessage\"</span>,\n          <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'get'</span>,\n          dataType: <span class=\"hljs-string\">'json'</span>,\n          success: <span class=\"hljs-keyword\">function</span> (res) {\n            console.log(res);\n            <span class=\"hljs-built_in\">let</span> li = ``;\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">let</span> item <span class=\"hljs-keyword\">in</span> res.data) {\n              li = li + `\n                <li>\n                  <span class=<span class=\"hljs-string\">\"text-warning font-bold\"</span>>☆ </span>\n                  <span class=<span class=\"hljs-string\">\"user-message\"</span>><span class=\"hljs-variable\">${res.data[item].user_message}</span></span>\n                  <span>—— </span>\n                  <span class=<span class=\"hljs-string\">\"user-name\"</span>><span class=\"hljs-variable\">${res.data[item].user_name}</span> [<span class=\"hljs-variable\">${res.data[item].user_id}</span>]</span>\n                  <span class=<span class=\"hljs-string\">\"message-time\"</span>><span class=\"hljs-variable\">${res.data[item].time}</span></span>\n                </li>\n              `;\n            }\n            $(<span class=\"hljs-string\">\"#message-board-ul\"</span>).append(li);\n          },\n          error: <span class=\"hljs-keyword\">function</span> (err) {\n            console.log(err);\n          }\n        })\n      } <span class=\"hljs-keyword\">else</span> { // 如果没有存储\n        window.location.href = <span class=\"hljs-string\">\"../login.html\"</span>;\n      }\n\n      // 提交留言\n      $(<span class=\"hljs-string\">\"#message-submit\"</span>).click(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-built_in\">let</span> messageText = $(<span class=\"hljs-string\">\"#message\"</span>).val()\n        <span class=\"hljs-keyword\">if</span>(!messageText) {\n          alert(<span class=\"hljs-string\">\"留言内容不能为空\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n          alert(<span class=\"hljs-string\">\"留言长度不能超过 140 位！\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          $.ajax({\n            url: <span class=\"hljs-string\">\"http://localhost:8888/sendMessage\"</span>,\n            <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'post'</span>,\n            dataType: <span class=\"hljs-string\">'json'</span>,\n            data: {\n              userid: userId,\n              username: userName,\n              message: messageText\n            },\n            success: <span class=\"hljs-keyword\">function</span> (res) {\n              console.log(res);\n              <span class=\"hljs-keyword\">if</span>(res.code == <span class=\"hljs-string\">\"0\"</span>) {\n                alert(<span class=\"hljs-string\">\"新增成功！\"</span>);\n                window.location.reload();\n              }\n            },\n            error: <span class=\"hljs-keyword\">function</span> (err) {\n              console.log(err);\n              console.log(err.responseText);\n              <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (err.responseText == <span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>) {\n                alert(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n              } <span class=\"hljs-keyword\">else</span> {\n                alert(<span class=\"hljs-string\">\"未知错误！\"</span>);\n              }\n            }\n          })\n        }\n      })\n\n    })\n  </script>\n</body>\n\n</html>\n<span class=\"copy-code-btn copy-0116\">复制代码</span></code></pre><p> 接着编写下 Node 后端：</p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code class=\"hljs bash copyable code-058\" lang=\"bash\">\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/sendMessage\"</span>) { // 提交留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 提交留言信息】\"</span>);\n\n  result = JSON.parse(result);\n\n  <span class=\"hljs-built_in\">let</span> id = result.userid; // id\n  <span class=\"hljs-built_in\">let</span> userName = result.username; // 用户名\n  <span class=\"hljs-built_in\">let</span> messageText = result.message; // 留言内容\n  <span class=\"hljs-built_in\">let</span> time = getNowFormatDate(); // 时间\n\n  <span class=\"hljs-keyword\">if</span>(!messageText) {\n    res.end(<span class=\"hljs-string\">\"登录失败，留言内容为空！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(messageText.length > 140) {\n    res.end(<span class=\"hljs-string\">\"登录失败，字数超过限制！\"</span>);\n    <span class=\"hljs-built_in\">return</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    \n    // 新增的 SQL 语句及新增的字段信息\n    <span class=\"hljs-built_in\">let</span> addSql = <span class=\"hljs-string\">\"INSERT INTO message(user_message, user_id, user_name, time) VALUES(?, ?, ?, ?)\"</span>;\n    <span class=\"hljs-built_in\">let</span> addSqlParams = [messageText, id, userName, time];\n\n    // 连接 SQL 并实施语句\n    connection.query(addSql, addSqlParams, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n      <span class=\"hljs-keyword\">if</span> (error1) { // 如果 SQL 语句错误\n        throw error1;\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(<span class=\"hljs-string\">\"\\n新增成功！\"</span>);\n\n        // 返回数据\n        res.write(JSON.stringify({\n          code: <span class=\"hljs-string\">\"0\"</span>,\n          message: <span class=\"hljs-string\">\"新增成功！\"</span>\n        }));\n\n        // 结束响应\n        res.end();\n      }\n    })\n  }\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/login\"</span>) { // 登录\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 登录】\"</span>);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/register\"</span>) { // 注册\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 注册】\"</span>);\n\n}\n\n\n\n// ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码\n\n\n\n<span class=\"hljs-keyword\">if</span> (pathName == <span class=\"hljs-string\">\"/getMessage\"</span>) { // 获取留言信息\n\n  console.log(<span class=\"hljs-string\">\"\\n【API - 获取留言信息】\"</span>);\n\n  // 解析 url 参数部分\n  <span class=\"hljs-built_in\">let</span> params = url.parse(req.url, <span class=\"hljs-literal\">true</span>).query;\n\n  console.log(<span class=\"hljs-string\">\"\\n参数为：\"</span>);\n  console.log(params);\n\n  // 新增的 SQL 语句及新增的字段信息\n  <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">read</span>Sql = <span class=\"hljs-string\">\"SELECT * FROM message\"</span>;\n\n  // 连接 SQL 并实施语句\n  connection.query(<span class=\"hljs-built_in\">read</span>Sql, <span class=\"hljs-keyword\">function</span> (error1, response1) {\n    <span class=\"hljs-keyword\">if</span> (error1) {\n      throw error1; \n    } <span class=\"hljs-keyword\">else</span> {\n      \n      <span class=\"hljs-built_in\">let</span> newRes = JSON.parse(JSON.stringify(response1));\n      console.log(newRes);\n\n      // 返回数据\n      res.write(JSON.stringify({\n        code: <span class=\"hljs-string\">\"1\"</span>,\n        message: <span class=\"hljs-string\">\"查询成功！\"</span>,\n        data: newRes\n      }));\n\n      // 结束响应\n      res.end();\n    }\n  });\n  // 查询完毕\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pathName == <span class=\"hljs-string\">\"/\"</span>) { // 首页\n  res.writeHead(200, {\n    <span class=\"hljs-string\">\"Content-Type\"</span>: <span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span>\n  });\n\n  res.write(<span class=\"hljs-string\">'<h1 style=\"text-align:center\">jsliang 前端有限公司服务已开启！</h1><h2 style=\"text-align:center\">详情可见：<a href=\"https://github.com/LiangJunrong/document-library/blob/master/other-library/Node/NodeBase.md\" target=\"_blank\">Node 基础</a></h2>'</span>);\n\n  res.end();\n}\n<span class=\"copy-code-btn copy-0117\">复制代码</span></code></pre><p> 敲完代码再看下功能是否实现：</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5280acce0c8?imageslim\" data-width=\"1182\" data-height=\"912\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1182\" height=\"912\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p> 综上，我们完成了所有的功能模块：注册、登录以及留言。</p>\n<h2 class=\"heading\" data-id=\"heading-23\"><a id=\"chapter-five\" name=\"chapter-five\">五 工具整合</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-five\">返回目录</a></p>\n</blockquote>\n<p> <strong>工欲善其事，必先利其器。</strong><br>\n 掌控好了工具，可以方便你更快地进行开发。</p>\n<h3 class=\"heading\" data-id=\"heading-24\"><a id=\"chapter-five-one\" name=\"chapter-five-one\">5.1 supervisor - 监听 Node 改动</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-one\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.supervisord.org/\" rel=\"nofollow noopener noreferrer\">supervisor 官网</a></li>\n</ul>\n<p> 正如其官网所说，它是一个进行控制系统：</p>\n<ol>\n<li>安装插件：<code>npm i supervisor -g</code></li>\n<li>运行文件：<code>supervisor app.js</code></li>\n<li>查看运行：<code>localhost:3000</code></li>\n</ol>\n<p> 平时，我们 <code>node app.js</code> 后，当我们修改了 <code>app.js</code> 的内容，就需要关闭 node 命令行再执行 <code>node app.js</code>。<br>\n 而我们使用 <code>supervisor</code> 后，我们修改了 <code>app.js</code> 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。</p>\n<p> 关于这个工具，网上更详细的攻略有：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.jianshu.com/p/6d84e5efe99d\" rel=\"nofollow noopener noreferrer\">详细版：用Supervisor守护你的Node.js进程 | 简书 - Mike的读书季</a></li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-25\"><a id=\"chapter-five-two\" name=\"chapter-five-two\">5.2 PM2 - Node 进程管理</a></h3>\n<blockquote>\n<p><a href=\"#catalog-chapter-five-two\">返回目录</a></p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.npmjs.com/package/pm2\" rel=\"nofollow noopener noreferrer\">PM2 - npm</a></li>\n</ul>\n<p> PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>\n<p> 下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置：</p>\n<ol>\n<li>全局安装 PM2：<code>npm i pm2 -g</code></li>\n<li>监听应用：<code>pm2 start index.js</code></li>\n<li>查看所有进程：<code>pm2 list</code></li>\n<li>查看某个进程：<code>pm2 describe App name/id</code></li>\n<li>停止某个进程：<code>pm2 stop App name/id</code>。例如：</li>\n</ol>\n<blockquote>\n<p>先通过 <code>pm2 list</code> 查看：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>App name</th>\n<th>id</th>\n<th>status</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>0</td>\n<td>online</td>\n</tr>\n</tbody>\n</table>\n<p> 只需要执行 <code>pm2 stop index</code> 或者 <code>pm2 stop 0</code> 即可。</p>\n<ol start=\"6\">\n<li>停止所有进程：<code>pm2 stop all</code></li>\n<li>重启某个进程：<code>pm2 restart App name/id</code></li>\n<li>删除某个进程：<code>pm2 delete App name/id</code></li>\n</ol>\n<p> 如上，如果说我们的 <code>supervisor</code> 是监听单个进程的话，那么 <code>PM2</code> 就是监听多个进程。</p>\n<p> 更多攻略：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://pm2.io/doc/en/runtime/quick-start/?utm_source=pm2&utm_medium=website&utm_campaign=rebranding\" rel=\"nofollow noopener noreferrer\">PM2 官网</a></li>\n<li><a target=\"_blank\" href=\"https://www.jianshu.com/p/f640450bd120\" rel=\"nofollow noopener noreferrer\">PM2 用法简介 | 简书 - LeavesLife</a></li>\n<li><a target=\"_blank\" href=\"http://www.cnblogs.com/chyingp/p/pm2-documentation.html\" rel=\"nofollow noopener noreferrer\">PM2实用入门指南 | 博客园 - 程序猿小卡</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-26\"><a id=\"chapter-six\" name=\"chapter-six\">六 参考资料</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-six\">返回目录</a></p>\n</blockquote>\n<p> 在编写这篇文章的过程中，有一些参考资料是值得保留阅读的：</p>\n<ol>\n<li><strong>经典：该类值得我们研读</strong></li>\n</ol>\n<blockquote>\n<p>经典，就是随着时间流逝，它还是那么有参考价值。</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://nodejs.cn/api/\" rel=\"nofollow noopener noreferrer\">API 文档 | Node.js 中文网</a></li>\n<li><a target=\"_blank\" href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\" rel=\"nofollow noopener noreferrer\">Node.js 教程 | 菜鸟教程</a></li>\n<li><a target=\"_blank\" href=\"http://www.expressjs.com.cn/\" rel=\"nofollow noopener noreferrer\">Express 文档 | Express 中文网</a></li>\n</ul>\n<ol start=\"2\">\n<li><strong>尝试：该类值得我们参考借鉴</strong></li>\n</ol>\n<blockquote>\n<p>Node 基础模块</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/whiteMu/p/5986297.html\" rel=\"nofollow noopener noreferrer\">nodejs之querystring模块 | 博客园 - whiteMu</a></li>\n</ul>\n<blockquote>\n<p>Node 编写接口</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.php.cn/js-tutorial-406242.html\" rel=\"nofollow noopener noreferrer\">用Node编写RESTful API接口 | php 中文网 - 不言</a></li>\n</ul>\n<blockquote>\n<p>MySQL 学习</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"http://www.runoob.com/mysql/mysql-tutorial.html\" rel=\"nofollow noopener noreferrer\">MySQL 教程 | 菜鸟教程</a></li>\n</ul>\n<blockquote>\n<p>Node 连接数据库</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/by-dxm/p/6723039.html\" rel=\"nofollow noopener noreferrer\">node.js前后台交互示例 -- 使用node.js实现用户注册功能 | 博客园 - 返回主页 党兴明</a></li>\n<li><a target=\"_blank\" href=\"https://www.cnblogs.com/bestjarvan/archive/2017/04/08/6680857.html\" rel=\"nofollow noopener noreferrer\">node.js实现简单的登录注册页面 - 博客园 - 返回主页 bestjarvan</a></li>\n</ul>\n<blockquote>\n<p>Node 仿 Express</p>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/tiantangyouzui/article/details/70184959\" rel=\"nofollow noopener noreferrer\">nodejs模块：简单http请求路由，仿express | CSDN - TTUZ</a></li>\n<li><a target=\"_blank\" href=\"http://www.html-js.com/article/1603\" rel=\"nofollow noopener noreferrer\">初学nodejs一：别被Express的API搞晕了 | 前端乱炖 - 飞天小黑神猪</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf227a751882516be2ec124\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（一） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://juejin.im/post/5bf4e46a6fb9a049f153d2ae\" rel>NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（二） | 倔强的石头 - 掘金</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/wallaceyuan/yuan-express\" rel=\"nofollow noopener noreferrer\">仿 Express | Github - wallaceyuan</a></li>\n<li><a target=\"_blank\" href=\"https://blog.csdn.net/cckevincyh/article/details/78695177\" rel=\"nofollow noopener noreferrer\">Node.js 封装仿照 express 的路由 | CSDN - c.</a></li>\n<li><a target=\"_blank\" href=\"https://github.com/BadWaka/node-express-middleware-study\" rel=\"nofollow noopener noreferrer\">学习node中express框架中间件的相关知识及实践 | Github - BadWaka</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-27\"><a id=\"chapter-seven\" name=\"chapter-seven\">七 线上部署</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-seven\">返回目录</a></p>\n</blockquote>\n<p> 关于线上部署及域名、服务器相关的配置，<strong>jsliang</strong> 在另外一篇文章有所交代：<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">云服务器建站</a>。</p>\n<p> 如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 <strong>jsliang</strong> QQ：<code>1741020489</code> 咨询，下面是一些优惠推广：</p>\n<p> <strong>腾讯云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://cloud.tencent.com/redirect.php?redirect=1025&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console\" rel=\"nofollow noopener noreferrer\">新客户无门槛 2775 元代金券</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c70d0376e68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://cloud.tencent.com/redirect.php?redirect=1014&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console\" rel=\"nofollow noopener noreferrer\">12 月优惠低至 168 元/年</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c7d4e1ea4f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1040\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1040\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<br>\n<p> <strong>阿里云推广</strong>：</p>\n<p> 新用户点这里：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">新用户云产品 1888 通用代金券</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c84a3c2cde4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"720\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"720\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">高性能云服务器 - 低至 293元/年</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c8c17693c71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1200\" data-height=\"100\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1200\" height=\"100\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<p> 购买企业级云服务器：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://promotion.aliyun.com/ntms/act/enterprise-discount.html?userCode=w7hismrh\" rel=\"nofollow noopener noreferrer\">企业级高性能云服务器</a>\n<figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/25/167e2c934dada38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1000\" data-height=\"90\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1000\" height=\"90\"></svg>\"><figcaption></figcaption></figure></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-28\"><a id=\"chapter-eight\" name=\"chapter-eight\">八 归纳总结</a></h2>\n<blockquote>\n<p><a href=\"#catalog-chapter-eight\">返回目录</a></p>\n</blockquote>\n<p> 综上，搞定一切！<br>\n 兴许在前面代码的摧残下，能看到这里的小伙伴已经寥寥无几了，但我坚信我该交代的基本都交代了，不该交代的也交代了~<br>\n 所以，如果小伙伴看完真觉得不错，那就点个赞或者给个 star 吧！你们的赞和 star 是我编写更多更精彩文章的动力！<a target=\"_blank\" href=\"https://github.com/LiangJunrong/document-library\" rel=\"nofollow noopener noreferrer\">GitHub 地址</a></p>\n<p> 如果小伙伴看完这里要评论的话，可以加个暗语：<code>Node 基础，***</code>，这样 <strong>jsliang</strong> 看到必回，哈哈~</p>\n<ul>\n<li>Node 基础，我完成了！</li>\n<li>Node 基础，我想说 jsliang 肯定还偷懒了，没写成最完美的，我不管我打赏了你赶紧给我完善下！</li>\n<li>……</li>\n</ul>\n<p> <strong>so, that's all, thanks~</strong></p>\n<p><em>-----------------------</em></p>\n<h2 class=\"heading\" data-id=\"heading-29\">后记</h2>\n<p><strong>撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~</strong></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db5346ad6c037?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167db537a115c675?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"320\" data-height=\"320\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"320\" height=\"320\"></svg>\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p><a href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\"><img style=\"border-width:0\" alt=\"知识共享许可协议\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/12/23/167d9537f3e29c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"88\" data-height=\"31\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"88\" height=\"31\"></svg>\"></a><br><a><strong>jsliang</strong> 的文档库</a> 由 <a href=\"https://github.com/LiangJunrong/document-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">梁峻荣</a> 采用 <a href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br>基于<a href=\"https://github.com/LiangJunrong/document-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.om/LiangJunron…</a>上的作品创作。<br>本许可协议授权之外的使用权限可以从 <a href=\"https://creativecommons.org/licenses/by-nc-sa/2.5/cn/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">creativecommons.org/licenses/by…</a> 处获得。</p>\n</blockquote>\n",
      "id": "24kijtp8gv5s",
      "author": "jsliang",
      "title": "Node - 从0基础到实战企业官网",
      "baseClassName": "article-content"
    },
    {
      "content": "<blockquote>\n<p>边做边学效率更高，爬虫是node的适用场景之一，关于爬虫的另一篇文章<br>为了验证“<strong><em>简书上，经验总结、资料归集类技术文章更容易上热榜</em></strong>”的猜想，可以做一个爬虫：爬取简书程序员专题热门文章前999篇，统计每篇文章的代码块数量（为什么是统计代码块数量，对于人来说，通过一篇文章的标题内容来判断文章的类型是一件轻而易举的事，然而对于计算机来说，这却是一件困难的事情，这已经属于人工智能的范畴了。然而获取文章的代码块数量对于计算机来说就容易得多了，可以认为，代码块为0或者较少的文章，属于经验类文章，代码块数量较多的文章如果不是资料归集的话，多半就属于谈源码实现的了）</p>\n</blockquote>\n<h2 id=\"-\" data-id=\"heading-0\">目录</h2>\n<ul>\n<li><a href=\"#1\" target=\"_blank\">知识点</a></li>\n<li><a href=\"#2\" target=\"_blank\">实现步骤</a><ul>\n<li><a href=\"#2.1\" target=\"_blank\">拉取页面列表</a></li>\n<li><a href=\"#2.2\" target=\"_blank\">拉取页面详情，分析统计</a></li>\n<li><a href=\"#2.3\" target=\"_blank\">生成统计页面</a></li>\n</ul>\n</li>\n<li><a href=\"#3\" target=\"_blank\">总结</a></li>\n</ul>\n<p></p><h2 id=\"1\" data-id=\"heading-1\">知识点</h2><p></p>\n<ol>\n<li>http.request：node http 模块的request方法可以作为http client向服务器发起http请求，爬虫需要向目标链接发起http请求来获得页面信息</li>\n<li>cheerio：通过 http 请求到的页面信息，由于缺乏浏览器的dom解析，看起来就是一段凌乱的字符串，实在糟糕。好在我们可以使用 cheerio 库将其解析为 dom ，这样我们就可以使用类似 jquery 的语法去分析页面信息</li>\n<li>promise：由于 node 单线程的特性，不可避免的需要用到大量异步编程的写法，层层嵌套的回调写法已经 low 了，来试试 promise 的写法</li>\n</ol>\n<p></p><h2 id=\"2\" data-id=\"heading-2\">实现步骤</h2><p></p>\n<p></p><h3 id=\"2.1\" data-id=\"heading-3\">拉取页面列表</h3><br>首先需要拿到程序员专题热门列表的请求链接<p></p>\n<p></p><figure><img atr=\"列表链接\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/13a5acb99dd86163df80dfe5860acc45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption>列表链接</figcaption></figure><p></p>\n<p>ajax请求，需要使用chrome dev tools，拉到底部还能加载更多：</p>\n<pre><code class=\"hljs javascript copyable code-00\"><span class=\"hljs-comment\">//order_by=likes_count 表示按照热门进行排序</span>\n<span class=\"hljs-comment\">//page是分页参数，每页9条，我们可以通过改变page=0~100来拉取900篇文章</span>\nhttp:<span class=\"hljs-comment\">//www.jianshu.com/collections/16/notes?order_by=likes_count&page=2</span><span class=\"copy-code-btn copy-05\">复制代码</span></code></pre><p>下一步通过这个链接拉取列表数据</p>\n<pre><code class=\"hljs javascript copyable code-01\">    <span class=\"hljs-comment\">/**\n     - 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com/collections/16/notes?order_by=likes_count&page='</span> + i,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                resolve(data);\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn copy-06\">复制代码</span></code></pre><p>可以创建一个promise对象来发起request请求（request的封装就不贴出来了，实验证明，代码块太多的文章不容易上热榜~~）</p>\n<p>起初我的做法是同时创建拉取1~100页数据的100个promise对象，同时异步的发起100个request请求，然而这样的做法会有几十个请求请求失败（兴许是简书那边做了限制），所以，还是耐心点，每次发起5个请求，直到100页都请求成功</p>\n<pre><code class=\"hljs javascript copyable code-02\">    <span class=\"hljs-comment\">/**\n     * 递归的请求，每次并发的请求5个\n     */</span>\n    Seek.prototype.seek = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n        times++;\n        <span class=\"hljs-keyword\">var</span> ot = times;\n        <span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-built_in\">Promise</span>.all([\n            self.createPromise(times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times),\n            self.createPromise(++times)\n        ]);\n        promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">result</span>) </span>{\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"seekList totals:\"</span> + times);\n            pages = pages.concat(result);\n            <span class=\"hljs-keyword\">if</span> (times < totalPage) {\n                self.seek(callback);\n            } <span class=\"hljs-keyword\">else</span> {\n                callback(pages);\n            }\n        });\n    }<span class=\"copy-code-btn copy-07\">复制代码</span></code></pre><p>拿到所有的列表数据之后，就可以使用cheerio库来分析列表页面，抓取文章详情链接(在这一步之前你同样需要使用chrome dev tools工具分析页面结构)</p>\n<pre><code class=\"hljs javascript copyable code-03\">    <span class=\"hljs-comment\">/**\n     * 使用cheerio载入列表页面\n     */</span>\n    Analyse.prototype.load = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, i</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n            <span class=\"hljs-keyword\">var</span> pages = [];\n            <span class=\"hljs-keyword\">var</span> els = $(<span class=\"hljs-string\">'.article-list li'</span>);\n            <span class=\"hljs-keyword\">if</span>(els.length === <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">'load error page:'</span> + i );\n                resolve([]);\n            }\n            els.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">index</span>) </span>{\n                <span class=\"hljs-keyword\">if</span> ($(<span class=\"hljs-keyword\">this</span>).attr(<span class=\"hljs-string\">'class'</span>) === <span class=\"hljs-string\">'have-img'</span>) {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                } <span class=\"hljs-keyword\">else</span> {\n                    pages.push($(<span class=\"hljs-keyword\">this</span>).children(<span class=\"hljs-string\">'div'</span>).children(<span class=\"hljs-string\">'.title'</span>).children(<span class=\"hljs-string\">'a'</span>).attr(<span class=\"hljs-string\">'href'</span>));\n                }\n\n                <span class=\"hljs-keyword\">if</span>(index === els.length - <span class=\"hljs-number\">1</span>) {\n                    resolve(pages);\n                }\n            });\n        });\n\n    }<span class=\"copy-code-btn copy-08\">复制代码</span></code></pre><p></p><h3 id=\"2.2\" data-id=\"heading-4\">拉取页面详情，分析统计</h3><br>从上一步中拿到900篇热门文章的地址之后，需要再次去抓取文章详情页面，同样的每次查5篇，使用chrome dev tools分析得知，简书文章的代码块使用的都是<code><code></code></code>标签，统计此标签出现的数量就可以了<p></p>\n<pre><code class=\"hljs javascript copyable code-04\">    <span class=\"hljs-comment\">/**\n     * 创建promise\n     */</span>\n    Seek.prototype.createPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">url</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> options = {\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://www.jianshu.com'</span> + url,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'get'</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            options.callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, _setCookie</span>) </span>{\n                <span class=\"hljs-keyword\">var</span> $ = cheerio.load(data);\n                <span class=\"hljs-comment\">//页面标题</span>\n                <span class=\"hljs-keyword\">var</span> title = $(<span class=\"hljs-string\">'h1.title'</span>).text();\n                <span class=\"hljs-comment\">//代码块数量</span>\n                <span class=\"hljs-keyword\">var</span> codes = $(<span class=\"hljs-string\">'code'</span>).length;\n                <span class=\"hljs-keyword\">if</span>(codes === <span class=\"hljs-number\">0</span>) {<span class=\"hljs-comment\">//代码块为0的总数</span>\n                    zeroCount++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">10</span>) {<span class=\"hljs-comment\">//代码块为<=10的总数</span>\n                    oneToTen++;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(codes <= <span class=\"hljs-number\">20</span>) {<span class=\"hljs-comment\">//代码块<=20的总数</span>\n                    elToTwo++;\n                } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//代码块>20的总数</span>\n                    beyondTwo++;\n                }\n                resolve({\n                    <span class=\"hljs-attr\">title</span>: title,\n                    <span class=\"hljs-attr\">codes</span>: codes\n                });\n            }\n            request(options, <span class=\"hljs-literal\">null</span>);\n        });\n    }<span class=\"copy-code-btn copy-09\">复制代码</span></code></pre><p></p><h3 id=\"2.3\" data-id=\"heading-5\">生成统计页面</h3><br>数据总需要一个展示的地方，使用nunjucks作为页面模板，注入抓取到的数据，在使用echarts生成统计图表，就是这个feel，<a href=\"https://zengwenfu.github.io/jian-analyse/app/views/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">结果页面</a><p></p>\n<p></p><figure><img atr=\"统计结果\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2017/5/31/8d76e15d56e4cd4328bc8428c77f7cdb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>\"><figcaption>统计结果</figcaption></figure><p></p>\n<p></p><h3 id=\"3\" data-id=\"heading-6\">总结</h3><br>开发爬虫是一件很酷的事情，在这个过程中还能学到知识，提升学习兴趣，从爬虫做起~~<br><a href=\"https://github.com/zengwenfu/jian-analyse\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">源码</a><p></p>\n<p><strong>下一篇文章讲 Node 爬虫进阶，敬请关注</strong></p>\n<blockquote>\n<p>补充说明：代码大半年前些的，简书的接口和页面结构已经做了改版，可能抓取不到想要的结果，如果感兴趣，可以按照思路和步骤改造现在的代码，自己动手丰衣足食</p>\n</blockquote>\n",
      "id": "1zok5x1671kw",
      "author": "小虫巨蟹",
      "title": "Node 爬虫入门",
      "baseClassName": "article-content"
    },
    {
      "content": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 383px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 38.690000000000005%;\"></div>\n<div class=\"image-view\" data-width=\"990\" data-height=\"383\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-dc3e11b3f475fa2e.png\" data-original-width=\"990\" data-original-height=\"383\" data-original-format=\"image/png\" data-original-filesize=\"19894\" class data-image-index=\"0\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/4479768-dc3e11b3f475fa2e.png?imageMogr2/auto-orient/strip|imageView2/2/w/990/format/webp\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>Node.js从2009年诞生开始，到现在已有10岁，在这10年里，它的成长和成熟是大家有目共睹的。它因后端简化并发编程而被关注，因作为前端辅助开发工具而流行，因异步流程控制和回调地狱而被人诟病，因npm批量安装模块而被人敬仰。</p>\n<p>作为技术领域里的明星项目，Node.js自诞生以来就一直处于风口浪尖之上。下面就来聊聊这些年Node.js被人们反复提起的“黑料”。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-db7a7390efe30040.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"5563\" class data-image-index=\"1\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/4479768-db7a7390efe30040.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><br>\n<p>Node.js 是名副其实的版本帝，版本更新确实很频繁，时间线如下。</p>\n\n<ul>\n<li>2013年，发布了0.10版本。</li>\n<li>2015年1月，发布了1.0.0版本（io.js）。</li>\n<li>2015年5月，发布了2.x版本（io.js）。</li>\n<li>2015年8月，发布了3.x版本（io.js）。</li>\n<li>2015年9月，Node.js基金会发布了5.0版本与io.js合并后的第一个版本。</li>\n<li>2015年10月，Node.js 5.2.0版本成为首个LTS（长期支持）版本。</li>\n<li>2015年年底，发布了5.2.4和5.5.0版本。</li>\n<li>2016年3月，发布了5.5.0 LTS版本和5.9.0 Stable稳定版本。</li>\n<li>2016年年底，6.0版本支持95%以上的ES6特性，7.0版本通过flag支持async函数，全面支持99%的ES6特性。</li>\n<li>2017年2月，发布了7.6版本，可以不通过flag使用async函数。</li>\n<li>2017年5月，发布了8.0版本，支持async Hooks，N-API等特性。</li>\n<li>2018年4月，发布了10.0版本，新增http2模块，将npm从v5.7更新到了v6，并且增强了对ESMModules的支持。</li>\n<li>2018年10月，发布了11.0版本，增加了多线程Worker Threads。</li>\n</ul>\n<p>整体上来说，Node.js的发展趋于稳定。成立Node.js基金会能够让Node.js在未来获得更好的开源社区支持；发布LTS版本意味着Node.js SDK API趋于稳定；频繁发布版本虽然被很多人诟病，但换个角度来看，这也是社区活跃的一个体现，如果大家真的看了Changelog，便会发现，新版本相比于旧版本只增加了一些小的改进，而且是边边角角的改进，也就是说，Node.js的核心代码已经非常稳定了，可以大规模使用。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-8d3ffb1d67e440e8.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9370\" class=\"image-loading\" data-image-index=\"2\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>Node.js在2009年横空出世，可以说靠异步特性获得了很大的性能优势。所有语言几乎没有能和它相比的。但是福祸相依，因为性能太出众，所以促使很多语言、编程模型都纷纷进行改进，比如产生了Go语言，比如PHP里的SWoole框架可以支持异步协程了，再比如鸟哥（惠新宸）对PHP的VM进行了改进，大家似乎都以不支持异步为耻。后来的故事大家都知道了，各种语言的性能都得到了提高。</p>\n<p><strong>那么在这种情况下，Node.js还有优势吗？</strong></p>\n<p><strong>在实现难易度上</strong>，Node.js除了异步流程控制稍复杂外，其他的都非常简单。比如在写法上，你可以选择编写面向过程、面向对象、函数式的程序。不要因为Node.js变化快，就觉得自己跟不上潮流。一般后端程序员转为Node.js开发人员时，几乎两周就能精通，这一点相比其他语言还是很有优势的。</p>\n<p><strong>在调优成本上，</strong>Node.js即使不进行优化，性能也非常好，另外，对Node.js进行优化也比其他语言更简单。</p>\n<p><strong>在学习成本上，</strong>Node.js是有优势的。学习其他语言，前后端至少要学两种以上，如果学习Node.js，你只需要学会JavaScript即可，可以少学一种语言。我想问，大前端离得开JavaScript吗？今日的前端还不够复杂吗？你真的有那么多精力学习更多语言吗？</p>\n<p>其实大家可以关注一下基于npm的开源生态，截至2019年3月，npm上已有超过94.7万个模块，“秒杀”无数竞品。npm是所有开源包管理中最强大的，我们说“更了不起的Node.js”，其实npm居功甚伟。</p>\n<p>下图展示了来自Module Counts的各个包管理模块的差异。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 388px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 55.36%;\"></div>\n<div class=\"image-view\" data-width=\"1716\" data-height=\"950\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-fff0fa3498d73e7a.png\" data-original-width=\"1716\" data-original-height=\"950\" data-original-format=\"image/png\" data-original-filesize=\"351318\" class=\"image-loading\" data-image-index=\"3\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\">来自Module Counts的各个包管理模块的差异</div>\n</div><br>\n<p>npm生态是Node.js的优势，可是说“Node.js没有性能优势”真的对吗？这其实是对Node.js的误解。Node.js的性能依然很好，不断迭代的版本其实就是在提升性能。而且Node.js具有npm极其完善的生态，可谓性能与生态双剑合璧，这是无与伦比的。</p>\n<br>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-875fdcaacac12c28.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9307\" class=\"image-loading\" data-image-index=\"4\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>正因为异步特性，Node.jsAPI设计只能采用错误优先（Error-First）风格的回调约定，于是大家硬生生地把多层回调写成了回调地狱（callback hell），这时就有各种“黑粉”冒出来对Node.js进行攻击。</p>\n<p>但正是因为回调地狱是最差的实践，所以大家才不得不求变，于是Thunk函数、Promise/A+规范等相继出现。虽然Promise/A+规范不是那么完美，但对于解决回调地狱问题来说已经足够。而且Generator特性和Generator的执行环境co模块也被逐渐引入新的异步解决方案，使得异步在写法上越来越接近于同步。当async函数落地的时候，Node.js 已经站在了同C#、Python一样的高度上，大家还有什么理由攻击它呢？</p>\n<p>下面列举了Node.js支持的所有异步解决方案，并给出了推荐建议（5星为最高级别）。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 401px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 41.77%;\"></div>\n<div class=\"image-view\" data-width=\"960\" data-height=\"401\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-6064714bc727e611.png\" data-original-width=\"960\" data-original-height=\"401\" data-original-format=\"image/png\" data-original-filesize=\"95519\" class=\"image-loading\" data-image-index=\"5\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>从推荐指数可以看出，我们应首选async函数，但要注意版本问题，要使用最新的版本。其次就是Promise，它都能非常好地驾驭callback和async函数，尤其是在异常捕获、扩展上，具有明显的优势。</p>\n<p>有时，将一件事做到极致，也许能收获另一片天地。异步流程控制是Node.js编程的核心，掌握异步流程控制之后，Node.js中就只剩API需要学习了，后面会详细讲解。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-d20456ac536b3570.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"9072\" class=\"image-loading\" data-image-index=\"6\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<p>自从ES6规范在Node.js中落地之后，整个Node.js开发领域都发生了翻天覆地的变化。从v0.10开始，Node.js中就逐渐加入了ES6特性，比如Node.js v0.12可以使用Generator，这也促使寻求异步流程控制的TJ Holowaychuk写出了co这个著名的模块，进而产生了Koa框架。但是在v5.0之前，必须通过flag才能开启Generator支持，因此Koa v1.0迟迟未发布，在Node.js v5.0发布后，Koa v1.0才发布。</p>\n<p>2015年，传统写法终结；2016年，变革写法开始兴起。其中核心变更是支持使用ES6语法编写Node.js代码。</p>\n<ul>\n<li>可以使用Node.js v5.x+里的ES6特性，如果想实现更高级的功能，可以使用Babel编译支持ES7特性，或者使用TypeScript。</li>\n<li>合理使用Standard或者xo模块代码风格约定。</li>\n<li>适当引入ES6语法，只要Node.js SDK内置支持的，都可以使用。</li>\n<li>大家要重视面向对象写法的使用，虽然ES6的面向对象机制不健全，但以后定会不断完善。面向对象对于大型软件开发更适合，这其实也是我推荐使用TypeScript的原因之一。</li>\n</ul>\n<p>下面对比了变革前后的技术栈选型，希望读者能够从中感受到其中的变化。</p>\n<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 571px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 47.78%;\"></div>\n<div class=\"image-view\" data-width=\"1195\" data-height=\"571\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-24815333363f00fa.png\" data-original-width=\"1195\" data-original-height=\"571\" data-original-format=\"image/png\" data-original-filesize=\"131982\" class=\"image-loading\" data-image-index=\"7\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div>\n<hr>\n<p><strong>本文选自《狼书（卷1）：更了不起的Node.js》一书。</strong><br>\n</p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 600px; max-height: 110px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 18.33%;\"></div>\n<div class=\"image-view\" data-width=\"600\" data-height=\"110\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-e6b46ef89f933c7f.png\" data-original-width=\"600\" data-original-height=\"110\" data-original-format=\"image/png\" data-original-filesize=\"13945\" class=\"image-loading\" data-image-index=\"8\" style=\"cursor: zoom-in;\"></div>\n</div>\n<div class=\"image-caption\"></div>\n</div><p></p>\n<p>对于Node.js来说，在简化并发编程方面，用“了不起”来形容并不过分。Node.js在2009年横空出世时，确实是独一无二的。但在今天，已经10岁的Node.js有了更多、更广泛的应用场景，它的意义已经远远大于设计时的初衷了，用“更了不起”来形容并不过分。</p>\n<p><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\"></a></p><div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 591px; max-height: 903px;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 128.92999999999998%;\"></div>\n<div class=\"image-view\" data-width=\"591\" data-height=\"762\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/4479768-7b9f6a2dd12deb1a.jpg\" data-original-width=\"591\" data-original-height=\"762\" data-original-format=\"image/jpeg\" data-original-filesize=\"93434\" class=\"image-loading\" data-image-index=\"9\" style=\"cursor: zoom-in;\"></div>\n</div>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\"><div class=\"image-caption\">点击封面了解详情</div></a>\n</div><p></p>\n<p>本书以Node.js为主，讲解了Node.js的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过最新的Node.js和npm编写出更具前端特色、更具工程化优势的代码。本书还讲解了Node.js中最核心、最复杂的异步流程控制，展望了未来异步流程的发展方向，非常适合大前端领域及后端领域的测试、运维及软件开发从业者阅读、学习。</p>\n<p>愿本书够带你打开Node.js世界的大门，领略大前端领域璀璨的星光。</p>\n<p><strong>作 者 简 介</strong></p>\n<hr>\n<p>狼叔（网名i5ting），Node.js 技术布道者，“Node全栈”公众号作者，全栈技术实践者。曾就职于多家知名IT企业，从事前端开发、后端开发、数据分析等工作，目前负责公司内的Node.js开发和基础框架开发工作。</p>\n<p><strong>本 书 内 容</strong></p>\n<hr>\n<p>本书共分7章，每章的内容简介如下。</p>\n<p><strong>第1章 Node.js初识</strong></p>\n<p>本章介绍了Node.js的一些基础知识，包括什么是Node.js、Node.js和JavaScript的关系、Node.js的特点和应用场景等。</p>\n<p><strong>第2章 Node.js安装与入门</strong></p>\n<p>本章介绍了Node.js安装与使用的基本方法，包括3m（即nvm、nrm、npm）安装法、Node.js基础示例，以及编辑器和调试等内容。</p>\n<p><strong>第3章 更了不起的Node.js</strong></p>\n<p>本章更加详细地介绍了Node.js的各类应用场景，对Node.js的核心作用进行了概括与总结，还对如何成为全栈工程师提供了宝贵建议。</p>\n<p><strong>第4章 更好的Node.js</strong></p>\n<p>本章介绍了Node.js的各种写法，包括单线程与集群，以及各种优秀实践，包括ES语法、多模块管理器Lerna、npm的替代品Yarn等。</p>\n<p><strong>第5章 Node.js是如何执行的</strong></p>\n<p>本章介绍了Node.js的源码构建和调试过程，阐述了Node.js是如何执行的，还介绍了API的调用过程，以及事件循环机制。</p>\n<p><strong>第6章 模块与核心</strong></p>\n<p>本章介绍了Node.js中的CommonJS规范、SDK模块与核心技术，还对未来的ES6模块功能进行了预测与展望。</p>\n<p><strong>第7章 异步写法与流程控制</strong></p>\n<p>本章介绍了异步流程控制的演进过程、Node.js的核心异步写法，以及更好的异步流程控制机制，如Thunk、Promise、async函数等。</p>\n<p>本书中的各章在内容上基本是相互独立的，因此各位读者可以挑选自己感兴趣的章节阅读。这本书是“狼书”系列的第1卷，还有第2卷和第3卷稍后会和各位读者见面，内容涉及Web应用和性能优化等，搭配阅读，效果更好。</p>\n<p>即将出版：</p>\n<p>《狼书（卷2）：Node.js Web应用开发》<br>\n《狼书（卷3）：Node.js高级技术》</p>\n<p><strong>了解本书详情：<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fitem.jd.com%2F12623248.html\" target=\"_blank\">京东</a>、<a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fproduct.dangdang.com%2F27880000.html\" target=\"_blank\">当当</a></strong></p>\n",
      "id": "470lupgyxi80",
      "author": "博文视点",
      "title": "Node.js十年，你大爷还是你大爷——《狼书（卷1）：更了不起的Node.js》",
      "baseClassName": "_2rhmJa"
    },
    {
      "content": "<div class=\"image-package\">\n<div class=\"image-container\" style=\"max-width: 350px; max-height: 350px; background-color: transparent;\">\n<div class=\"image-container-fill\" style=\"padding-bottom: 100.0%;\"></div>\n<div class=\"image-view\" data-width=\"350\" data-height=\"350\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/5720-96c4c01c641f597e.png\" data-original-width=\"350\" data-original-height=\"350\" data-original-format=\"image/png\" data-original-filesize=\"54806\" class data-image-index=\"0\" style=\"cursor: zoom-in;\" src=\"//upload-images.jianshu.io/upload_images/5720-96c4c01c641f597e.png?imageMogr2/auto-orient/strip|imageView2/2/w/350/format/webp\"></div>\n</div>\n<div class=\"image-caption\">封面</div>\n</div>\n<blockquote>\n<p>千呼万唤始出来，犹抱琵琶生哪吒。</p>\n<p>真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。</p>\n</blockquote>\n<p>Node.js 作为近几年新兴的一种编程运行时，托 V8 引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++ 开发 Node.js 原生扩展的口子，让开发者进行项目开发时有了更多的选择。</p>\n<p>《Node.js：来一打 C++ 扩展》以 Chrome V8 的知识作为基础，配合 GYP 的一些内容，将教会大家如何使用 Node.js提供的一些 API 来编写其 C++ 的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN 以及与异步相关的 libuv 知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的 Node.js 以及 C++ 基础。</p>\n<p>阅读《Node.js：来一打 C++ 扩展》，相当于同时学习Chrome V8 开发、libuv 开发以及 Node.js 的原生 C++ 扩展开发知识，非常值得！</p>\n<p><strong>最后十分感谢包括 Node.js TSC 之一的 Anna、几位 Collaborator 以及各位业界的大佬帮忙写推荐语，感谢 @yorkie 大佬和 @justjavac 大佬帮忙作序。</strong></p>\n<h2>编辑推荐</h2>\n<p>《Node.js：来一打 C++ 扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍 Node.js 的包和模块规范开始，深入解析（包括但不限于剖析 Node.js 自身的源码） Node.js 的模块是如何在运行时被引入的，尤其是如何引入 C++ 模块的；接下来详细讲解了在什么时候、为何要编写 C++ 模块；借此契机，深入介绍了 Node.js 的基石 Chrome V8 和 libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以 Node.js 的 C++ 扩展为中心，衍生出对 Node.js 底层风光的层层剖析，最后再回归到如何编写 Node.js 的 C++ 扩展，一气呵成。读来酣畅淋漓，痛快不已！</p>\n<p>买这一本书相当于买了“Node.js 的底层风光、C++ 扩展编写”、“Chrome V8”和“libuv”三本书！</p>\n<p>读完本书后，你甚至能为 Node.js 自身的添砖加瓦做出非凡贡献。</p>\n<h2>购书链接</h2>\n<p><strong>目前在预售阶段，顺便蹭 618 活动。</strong></p>\n<ul>\n<li><a href=\"https://item.jd.com/12380404.html\" target=\"_blank\" rel=\"nofollow\">京东</a></li>\n<li><a href=\"https://detail.tmall.com/item.htm?id=571628730908&cat_id=2\" target=\"_blank\" rel=\"nofollow\">天猫</a></li>\n<li><a href=\"http://product.dangdang.com/25291814.html\" target=\"_blank\" rel=\"nofollow\">当当</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07DL8GHQC/ie=UTF8&qid=1528969734\" target=\"_blank\" rel=\"nofollow\">亚马逊</a></li>\n<li>\n<a href=\"https://book.douban.com/subject/30247892/\" target=\"_blank\" rel=\"nofollow\">豆瓣</a>（不算购书链接）</li>\n</ul>\n<h2>目录</h2>\n<pre class=\"line-numbers  language-jsx\"><code class=\"  language-jsx\"><span class=\"token number\">1</span> Node<span class=\"token punctuation\">.</span>js 的 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展前驱知识储备 <span class=\"token number\">1</span>\n<span class=\"token number\">1.1</span> Node<span class=\"token punctuation\">.</span>js 的模块机制 <span class=\"token number\">2</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.1</span> CommonJS 的模块规范 <span class=\"token number\">2</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js 的模块 <span class=\"token number\">4</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">9</span>\n<span class=\"token number\">1.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span> Node<span class=\"token punctuation\">.</span>js 的包机制 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.1</span> CommonJS 的包规范 <span class=\"token number\">9</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js <span class=\"token operator\">/</span> <span class=\"token constant\">NPM</span> 下的包 <span class=\"token number\">13</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.3</span> <span class=\"token constant\">NPM</span> 与 <span class=\"token constant\">CNPM</span> <span class=\"token number\">16</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">19</span>\n<span class=\"token number\">1.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">19</span>\n<span class=\"token number\">1.3</span> Node<span class=\"token punctuation\">.</span>js 依赖简介 <span class=\"token number\">20</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.1</span> Chrome <span class=\"token constant\">V8</span> <span class=\"token number\">20</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.2</span> libuv <span class=\"token number\">25</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.3</span> 其他依赖 <span class=\"token number\">28</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">30</span>\n<span class=\"token number\">1.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">30</span>\n<span class=\"token number\">1.4</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展开发的准备工作 <span class=\"token number\">31</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.1</span> 编辑器 <span class=\"token operator\">/</span> <span class=\"token constant\">IDE</span> <span class=\"token number\">31</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.2</span> node<span class=\"token operator\">-</span>gyp <span class=\"token number\">36</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.3</span> 其他构建工具 <span class=\"token number\">54</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">56</span>\n<span class=\"token number\">1.4</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">56</span>\n<span class=\"token number\">2</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块原理简析 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span> 为什么要写 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 比 JavaScript 解释器高效 <span class=\"token number\">57</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.2</span> 已有的 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 轮子 <span class=\"token number\">72</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">77</span>\n<span class=\"token number\">2.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">77</span>\n<span class=\"token number\">2.2</span> 什么是 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展 <span class=\"token number\">78</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 模块本质 <span class=\"token number\">78</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.2</span> Node<span class=\"token punctuation\">.</span>js 模块加载原理 <span class=\"token number\">80</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">102</span>\n<span class=\"token number\">2.2</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">103</span>\n<span class=\"token number\">3</span> Chrome <span class=\"token constant\">V8</span> 基础 <span class=\"token number\">104</span>\n<span class=\"token number\">3.1</span> Node<span class=\"token punctuation\">.</span>js 与 Chrome <span class=\"token constant\">V8</span> <span class=\"token number\">104</span>\n<span class=\"token number\">3.2</span> 基本概念 <span class=\"token number\">105</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.1</span> 内存机制 <span class=\"token number\">105</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.2</span> 隔离实例（Isolate） <span class=\"token number\">108</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.3</span> 上下文（Context） <span class=\"token number\">109</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.4</span> 脚本（Script） <span class=\"token number\">110</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">110</span>\n<span class=\"token number\">3.2</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">111</span>\n<span class=\"token number\">3.3</span> 句柄（Handle） <span class=\"token number\">111</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.1</span> 本地句柄（Local） <span class=\"token number\">112</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.2</span> 持久句柄（Persistent） <span class=\"token number\">115</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.3</span> 永生句柄（Eternal） <span class=\"token number\">119</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.4</span> 待实本地句柄（Maybe Local） <span class=\"token number\">119</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">121</span>\n<span class=\"token number\">3.3</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">121</span>\n<span class=\"token number\">3.4</span> 句柄作用域 <span class=\"token number\">121</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.1</span> 一般句柄作用域（Handle Scope） <span class=\"token number\">122</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.2</span> 可逃句柄作用域（Escapable Handle Scope） <span class=\"token number\">125</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">129</span>\n<span class=\"token number\">3.4</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">129</span>\n<span class=\"token number\">3.5</span> 上下文（Context） <span class=\"token number\">129</span>\n<span class=\"token number\">3.6</span> 模板（Template） <span class=\"token number\">133</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.1</span> 函数模板（Function Template） <span class=\"token number\">133</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.2</span> 对象模板（Object Template） <span class=\"token number\">138</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.3</span> 对象模板的访问器（Accessor）与拦截器（Interceptor） <span class=\"token number\">144</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.4</span> 对象模板的内置字段（Internal Field） <span class=\"token number\">175</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.5</span> 函数模板的继承（Inherit） <span class=\"token number\">183</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">188</span>\n<span class=\"token number\">3.6</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span> 常用数据类型 <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.1</span> 基值（Value） <span class=\"token number\">189</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.2</span> 字符串（String） <span class=\"token number\">194</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.3</span> 数值类型 <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.4</span> 布尔类型（Boolean） <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.5</span> 对象（Object） <span class=\"token number\">196</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.6</span> 函数（Function） <span class=\"token number\">200</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.7</span> 数组（Array） <span class=\"token number\">202</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.8</span> <span class=\"token constant\">JSON</span> 解析器 <span class=\"token number\">203</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.9</span> 函数回调信息（Function Callback Info） <span class=\"token number\">203</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.10</span> 函数返回值（Return Value） <span class=\"token number\">204</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.11</span> 隔离实例（Isolate） <span class=\"token number\">204</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.12</span> 小结 <span class=\"token number\">205</span>\n<span class=\"token number\">3.7</span><span class=\"token number\">.13</span> 参考资料 <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span> 异常机制 <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.1</span> <span class=\"token keyword\">try</span><span class=\"token operator\">-</span>catch <span class=\"token number\">206</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.2</span> 抛出异常 <span class=\"token number\">209</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.3</span> 异常生成类（Exception） <span class=\"token number\">211</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">211</span>\n<span class=\"token number\">3.8</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">211</span>\n<span class=\"token number\">4</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展实战初探 <span class=\"token number\">212</span>\n<span class=\"token number\">4.1</span> binding<span class=\"token punctuation\">.</span>gyp <span class=\"token number\">212</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.1</span> 惊鸿一瞥 <span class=\"token number\">213</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.2</span> binding<span class=\"token punctuation\">.</span>gyp 基础结构 <span class=\"token number\">213</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.3</span> <span class=\"token constant\">GYP</span> 文件 <span class=\"token number\">214</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.4</span> 常用字段 <span class=\"token number\">221</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">228</span>\n<span class=\"token number\">4.1</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">228</span>\n<span class=\"token number\">4.2</span> 牛刀小试 <span class=\"token number\">229</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.1</span> 又是 Hello World <span class=\"token number\">229</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.2</span> 函数参数 <span class=\"token number\">232</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.3</span> 回调函数 <span class=\"token number\">234</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.4</span> 函数返回 <span class=\"token number\">238</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">239</span>\n<span class=\"token number\">4.2</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span> 循序渐进 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 与 JavaScript 类封装 <span class=\"token number\">240</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.2</span> 实例化 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 类封装对象的函数 <span class=\"token number\">250</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.3</span> 将 <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 类封装对象传来传去 <span class=\"token number\">253</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.4</span> 进程退出钩子 <span class=\"token number\">255</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">259</span>\n<span class=\"token number\">4.3</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">259</span>\n<span class=\"token number\">5</span> Node<span class=\"token punctuation\">.</span>js 原生抽象——<span class=\"token constant\">NAN</span> <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span> Node<span class=\"token punctuation\">.</span>js 原生模块开发方式的变迁 <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.1</span> 以不变应万变 <span class=\"token number\">260</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.2</span> 时代在召唤 <span class=\"token number\">261</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">267</span>\n<span class=\"token number\">5.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span> 基础开发 <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.1</span> 什么是 <span class=\"token constant\">NAN</span> <span class=\"token number\">267</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.2</span> 安装和配置 <span class=\"token number\">269</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.3</span> 先睹为快——搭上<span class=\"token constant\">NAN</span> 的快车 <span class=\"token number\">270</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.4</span> 基础帮助函数和宏 <span class=\"token number\">276</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.5</span> 忽略 node_modules <span class=\"token number\">279</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">279</span>\n<span class=\"token number\">5.2</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span> JavaScript 函数 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.1</span> 函数参数类型 <span class=\"token number\">280</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.2</span> 函数声明 <span class=\"token number\">282</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.3</span> 函数设置 <span class=\"token number\">288</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">296</span>\n<span class=\"token number\">5.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span> 常用帮助类与函数 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.1</span> 句柄相关 <span class=\"token number\">296</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.2</span> 创建数据对象 <span class=\"token number\">298</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.3</span> 与数据对象“玩耍” <span class=\"token number\">300</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.4</span> 封装一个类 <span class=\"token number\">314</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.5</span> 异常处理 <span class=\"token number\">315</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">315</span>\n<span class=\"token number\">5.4</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span> <span class=\"token constant\">NAN</span> 中的异步机制 <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.1</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncQueueWorker <span class=\"token number\">316</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.2</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Callback <span class=\"token number\">317</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.3</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncWorker <span class=\"token number\">317</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.4</span> Nan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>AsyncProgressWorker <span class=\"token number\">323</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">327</span>\n<span class=\"token number\">5.5</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">327</span>\n<span class=\"token number\">6</span> 异步之旅——libuv <span class=\"token number\">328</span>\n<span class=\"token number\">6.1</span> 基础概念 <span class=\"token number\">329</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.1</span> 事件循环 <span class=\"token number\">330</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.2</span> 句柄（Handle）与请求（Request） <span class=\"token number\">333</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.3</span> 尝尝甜头 <span class=\"token number\">335</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">340</span>\n<span class=\"token number\">6.1</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">340</span>\n<span class=\"token number\">6.2</span> libuv 的跨线程编程基础 <span class=\"token number\">341</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.1</span> libuv 的线程 <span class=\"token number\">342</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.2</span> 同步原语（Synchronization Primitive） <span class=\"token number\">347</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.3</span> 工作队列 <span class=\"token number\">355</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">356</span>\n<span class=\"token number\">6.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span> 跨线程通信 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.1</span> uv_async_t 句柄 <span class=\"token number\">357</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.2</span> Watchdog 半成品实战解析 <span class=\"token number\">358</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.3</span> Watchdog 试运行 <span class=\"token number\">367</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">368</span>\n<span class=\"token number\">6.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">369</span>\n<span class=\"token number\">7</span> 实战——文件监视器 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span> 准备工作 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.1</span> 功能规划 <span class=\"token number\">370</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.2</span> 文件系统监听库——efsw <span class=\"token number\">373</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">376</span>\n<span class=\"token number\">7.1</span><span class=\"token number\">.4</span> 参考资料 <span class=\"token number\">376</span>\n<span class=\"token number\">7.2</span> 核心设计 <span class=\"token number\">376</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.1</span> <span class=\"token constant\">API</span> 设计 <span class=\"token number\">377</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.2</span> EFSWCore 的血肉之躯 <span class=\"token number\">377</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.3</span> EFSWCore 的灵魂 <span class=\"token number\">381</span>\n<span class=\"token number\">7.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">385</span>\n<span class=\"token number\">7.3</span> 编写JavaScript 类 <span class=\"token number\">386</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.1</span> 类的设计 <span class=\"token number\">386</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.2</span> 核心逻辑 <span class=\"token number\">388</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.3</span> 简单容错 <span class=\"token number\">391</span>\n<span class=\"token number\">7.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span> 进一步完善 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.1</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 代码的完善 <span class=\"token number\">393</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.2</span> JavaScript 代码的完善 <span class=\"token number\">398</span>\n<span class=\"token number\">7.4</span><span class=\"token number\">.3</span> 小结 <span class=\"token number\">400</span>\n<span class=\"token number\">8</span> 实战——现有包剖析 <span class=\"token number\">401</span>\n<span class=\"token number\">8.1</span> 字符串哈希模块——Bling Hashes <span class=\"token number\">401</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.1</span> 文件设定 <span class=\"token number\">402</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.2</span> <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 源码剖析 <span class=\"token number\">403</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.3</span> JavaScript 源码剖析 <span class=\"token number\">408</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">409</span>\n<span class=\"token number\">8.1</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span> 类 Proxy 包——Auto Object <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.1</span> Proxy <span class=\"token number\">410</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.2</span> Auto Object 使用范例 <span class=\"token number\">412</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.3</span> 代码剖析 <span class=\"token number\">415</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">424</span>\n<span class=\"token number\">8.2</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">424</span>\n<span class=\"token number\">9</span> <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span>——下一代 Node<span class=\"token punctuation\">.</span>js <span class=\"token constant\">C</span><span class=\"token operator\">++</span> 扩展开发方式 <span class=\"token number\">425</span>\n<span class=\"token number\">9.1</span> 浅尝辄止 <span class=\"token number\">426</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.1</span> 实现一个 Echo 函数 <span class=\"token number\">426</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.2</span> 尝试运行 <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span> 扩展 <span class=\"token number\">430</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.3</span> 向下兼容 <span class=\"token number\">431</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.4</span> <span class=\"token constant\">N</span><span class=\"token operator\">-</span><span class=\"token constant\">API</span> Package——<span class=\"token constant\">C</span><span class=\"token operator\">++</span> 封装 <span class=\"token number\">433</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.5</span> 小结 <span class=\"token number\">433</span>\n<span class=\"token number\">9.1</span><span class=\"token number\">.6</span> 参考资料 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span> 基本数据类型与错误处理 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.1</span> 基本数据类型 <span class=\"token number\">433</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.2</span> 与作用域及生命周期相关的数据类型 <span class=\"token number\">435</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.3</span> 回调数据类型 <span class=\"token number\">438</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.4</span> 错误处理 <span class=\"token number\">439</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.5</span> 模块注册 <span class=\"token number\">441</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.6</span> 小结 <span class=\"token number\">442</span>\n<span class=\"token number\">9.2</span><span class=\"token number\">.7</span> 参考资料 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span> 对象与函数 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.1</span> 对象 <span class=\"token number\">442</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.2</span> 函数 <span class=\"token number\">448</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.3</span> 类的封装 <span class=\"token number\">453</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.4</span> 小结 <span class=\"token number\">455</span>\n<span class=\"token number\">9.3</span><span class=\"token number\">.5</span> 参考资料 <span class=\"token number\">455</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code><button class=\"VJbwyy\" type=\"button\" aria-label=\"复制代码\"><i aria-label=\"icon: copy\" class=\"anticon anticon-copy\"><svg viewBox=\"64 64 896 896\" focusable=\"false\" class=\"\" data-icon=\"copy\" width=\"1em\" height=\"1em\" fill=\"currentColor\" aria-hidden=\"true\"><path d=\"M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z\"/></svg></i></button></pre>\n<h2>推荐语</h2>\n<blockquote>\n<p>This book contains absolutely everything you need to know about how all the pieces of Node.js' C++ code work and interact, explaining the necessary concepts without needing prior knowledge about the internals of V8, libuv or other pieces of Node.js. It shows well how Node.js' own built-in modules are constructed using the APIs provided by V8, so that they are usable from JavaScript, and how you can create the same kind of modules from scratch.</p>\n<p>After having read this book, you will be able to write a production-quality, future-proof C++ extension for Node.js if you need to do that, or maybe even make changes Node.js itself if you're interested in that!</p>\n<p>这本书包含了所有你需要了解的有关于 Node.js C++ 代码是如何运行和交互的知识，解释了一些你不需要知道 V8 的内部机制就能理解的必要概念，另外该书还介绍了 libuv 以及其他一些内容的方方面面。这本书还展示了 Node.js 的内置模块是如何使用 V8 的 API 进行构建并在 JavaScript 层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。</p>\n<p>读完这本书，你将学到如何写出产品级质量的、面向未来的 Node.js C++ 扩展。感兴趣的话，你甚至可以对 Node.js 自身进行修改！</p>\n<p>——安娜·亨宁森（Anna Henningsen, addaleax），Node.js 技术指导委员会成员（Node.js TSC）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Node.js 不是第一个将 JavaScript 带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于 Node.js 适逢后端高并发潮流，巧妙结合 Reactor 模型和 JavaScript 所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合 JavaScript 和前端工程师的一套生态和工具链，Node.js 刚好成为前端 JavaScript 最易上手掌握的命令行环境。在 Node.js 发展这么火热之后，Node.js 的开发体验在不断提升，上手门槛也在不断降低。</p>\n<p>然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解 Node.js 的底层机制，去学习写一些 Node.js 的扩展。从 Node.js 的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。</p>\n<p>死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用 C++ 写一个扩展很有意思也很简单。作为 Node.js 工程师/爱好者的你，值得拥有本书。</p>\n<p>——曹力（ShiningRay），酷链科技 CEO，前暴走漫画 CTO，前糗事百科联合创始人，高级 Node.js 技术专家，《JavaScript 高级程序设计》译者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Native module is one of the most underappreciated features of Node.js. But even in the age of asm.js and WebAssembly, it is an irreplaceable part of the Node.js ecosystem due to its versatility and performance. XadillaX's book provides a refreshing introduction (or reintroduction), and is a must-read for all low-level Node.js engineers.</p>\n<p>原生模块是 Node.js 中最被低估的功能之一。因为它的性能和多样性，使其即使是在 asm.js 和 WebAssembly 时代，仍旧能作为 Node.js 生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js 工程师必读之物。</p>\n<p>——顾天骋（Timothy Gu），pug、ejs 前 Maintainer，Node.js Core Collaborator 之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>本书全面讲解了 V8、libuv 的原理并且手把手教你编写一打 Node.js 的 C++ 扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解 Node.js 的实现原理，除了熟读内置 API 文档之外，阅读这本书会是一个很好的选择。</p>\n<p>——雷宗民（老雷），《Node.js 实战》作者之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>这是一本角度刁钻的 Node.js 相关书籍，与市面上大多数的 Node.js 书籍定位不同。它借为 Node.js 开发 C++ 扩展为基石，顺带介绍了 Chrome V8 和 libuv 的内容，填补了市场上这一类书籍的空白，值得一读。</p>\n<p>——李启雷博士，趣链科技 CTO</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月一直把实战贯穿在整本书之内，无论是基础部分的 V8 练习，还是使用 Node.js 经典的 Addon 开发、用 NAN 来改写，或是 libuv 里的 WatchDog 案例、EFSW 的封装，甚至在第八章里还特意剖析了两个 C++ 模块，把之前讲解的基础知识部分综合起来，可以边学边练。</p>\n<p>这本《Node.js：来一打 C++ 扩展》，在如今追求大而全的时代，单纯的讲 Node.js 的某一个方面，而且讲的特别棒的书，真的难得。</p>\n<p>——刘琥（响马），西祠胡同创始人，fibjs 作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当你掌握了 Node.js 的上层使用，下一步进阶的方向就是研究 Node.js 的底层原理。本书为学习 Node.js 的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（Handle Scope）等概念直接来自于源码，对于阅读 Node.js 及 V8 的源码具有极高的参考价值。</p>\n<p>——潘旻琦（pmq20），Node.js 技术专家，Node.js Collaborator 之一，RubyConf 讲师之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>国内 Node.js 偏向于原理的书目前只有朴灵的《深入浅出 Node.js》一本，至今 4 年过去了，Node.js 已经从 v0.10 发展到 v9 版本，中间再没有这样的系统的有深度的书籍。</p>\n<p>很高兴死月的新书弥补了这一遗憾。本书以 C++ 为主线，涵盖 Node.js 最核心的 libuv 和 V8，对理解 Node.js 原理有极大的好处。当然最大的好处在于使用 C++ 编写 Node.js Addon 可以让 Node.js 有更广阔的应用空间。我们都知道 Node.js 擅长的是 I/O 密集型任务，对于 CPU 密集型运算这是极好的弥补。</p>\n<p>特别推荐大家阅读此书，Node.js 应用极其广泛的今天，使用 C++ 编写 Node.js Addon 是更出彩的部分，你值得拥有。</p>\n<p>——桑世龙（狼叔），StuQ 明星讲师，Node.js 技术布道者，《更了不起的 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月对 Node.js 底层机制有非常深入的了解。阅读本书，除了学习 C++ 扩展开发，还会跟随死月了解 V8、libuv，相信读后大家对于 Node.js 的理解会更上一层楼。</p>\n<p>——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>C++ 扩展其实是从外在，用 C++ 的角度去观察 Node.js 内在的形式。因为 Node.js 整个系统自身几乎就是构建在 C/C++ 之上的，只是内部称之为 built-in，在 user-land 则称之 Addon，它们本质上其实没有区别。死月凭借他在 C/C++ 的深厚积累，选择从 C++ 扩展作为突破口，带大家领略 Node.js 底层的风光，在书里，你能看到真正发挥巨大价值的 V8、libuv 亦是精彩纷呈。</p>\n<p>死月将 C++ 扩展写得这么透，我是服的。</p>\n<p>——田永强（朴灵），高级 Node.js 技术专家，《深入浅出 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>开发 C++ 扩展，可以扩充 Node.js 平台的本地 API，扩充 Node.js 应用的能力。这本书详细介绍了包括 libuv、V8 在内的各种必要知识，是该领域不可多得的好书。对 C++ 开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。</p>\n<p>——王文睿博士（Roger Wang），node-webkit 和 NW.js 项目创始人和维护者，因特尔软件架构师</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>清晰记得手写的第一个 Node.js C++ 扩展模块，在 Node.js 0.6.9 跑通的那种愉悦感。随着应用升级到 Node.js 0.8，依赖的 C++ 扩展模块无法安装编译成功，最后发现是 V8 的 API 变化导致不兼容，从此对 C++ 扩展模块产生抗拒。后来看到《Node.js：来一打 C++ 扩展》，从实现原理，到 V8 基础概念的一系列介绍，让我重新对 C++ 扩展模块产生兴趣。参考书里的实战例子，以及 NAN 的辅助下，现在编写一个跨 Node.js 版本的 C++ 扩展已经不是什么困难的事情。通过最后一章节，可以了解到 Node.js 官方的 N-API 计划，让 C++ 扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。</p>\n<p>——袁锋（fengmk2），Node.js 技术专家</p>\n</blockquote>\n",
      "id": "4djqlu0vlo80",
      "author": "機巧死月不會碼代碼",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "baseClassName": "_2rhmJa"
    }
  ],
  "hotResList": [
    {
      "url": "https://juejin.im/post/5dc81428e51d4523632ee793",
      "k": "juejin",
      "id": "33nexc9y7fc0",
      "author": "围的围",
      "title": "Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "前言想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）Github:传送门演示地址：传送门编辑器预览：技术栈前端：vue:模块化开发少不了angular，react，vue三选一，这里选择了vue。vuex:状态管理sass:css预编译器。elem..."
    },
    {
      "url": "https://juejin.im/post/5dcb5a80e51d4520db19b906",
      "k": "juejin",
      "id": "3oeglh3wuu00",
      "author": "火狼1",
      "title": "React 开发必须知道的 34 个技巧【近1W字】",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "前言React是前端三大框架之一,在开发中也是一项技能;本文从实际开发中总结了React开发的一些技巧技巧,适合React初学或者有一定项目经验的同学序列文章:Vue开发必须知道的36个技巧【近1W字】源码地址请戳，欢迎star效果图\">1组件通讯1.1props子组件importReactfrom\"react\";importPropTypesfrom\"prop-types\";import{Button}from\"antd\";exportdefaultclassEightteenChildOne..."
    },
    {
      "url": "https://juejin.im/post/5dccdd24f265da0c09156fb3",
      "k": "juejin",
      "id": "2lsn3ia5ux20",
      "author": "故事胶片",
      "title": "前端Vue中常用rules校验规则",
      "time": "4天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "前提在vue开发中，难免遇到各种表单校验，这里整理了网络上和自己平时高频率用到的一些校验方法。如果错误欢迎指出，后期不断补充更新。Git地址前端常用的正则校验git地址\">欢迎关注前端公众号【小夭同学】1、是否合法IP地址exportfunctionvalidateIP(rule,value,callback){if(value==''||value==undefined||value==null){callback();}else{constreg=/^(\\d{1,2}|1\\d\\d|2[0-4..."
    },
    {
      "url": "https://juejin.im/post/5dca1b376fb9a04a9f11c82e",
      "k": "juejin",
      "id": "dtgeiqwbt0g",
      "author": "winty",
      "title": "Web 安全总结(面试必备良药)",
      "time": "6天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "目录本文简单介绍几种常见的web安全问题：同源策略XSSCSRFSQL注入点击劫持window.opener安全问题文件上传漏洞同源策略如果两个URL的协议、域名和端口都相同，我们就称这两个URL同源。同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作。同源策略限制了不同源的站点读取当前站点的Cookie、IndexDB、LocalStorage等数据。同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点。解决同源策略的方法：跨文档消息机..."
    },
    {
      "url": "https://juejin.im/post/5dcbb828f265da4cf85d84b4",
      "k": "juejin",
      "id": "5veaqpetfv00",
      "author": "zz_jesse",
      "title": "【前方高能】新手到高级前端攻城狮都用的上的前端面试题库，备战明年金三银四",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "写在前面现在面试文章已很多，更不觉得新鲜，本文可能有点不同，正因为“多”也就才有了本文的输出。相信很多前端小伙伴也包括我在内，面试前都要做一些准备，而做做面试题是最平常不过的事儿了，然而每次面试前都要现找面试题，而且答案也不是现成的，其实这样重复的事情在不知不觉中浪费你很多时间。也就因为发现了这个问题，才有了把面试题进行整理的想法，希望能对一些人有所帮助，节省一点时间吧。题目整理这1个多月来一直在整理前端领域相关的面试题，阅读查看了将近100多篇的面试文章，文章大多来自技术社区，如掘金、思否等，..."
    },
    {
      "url": "https://juejin.im/post/5dcbd5f66fb9a06061527cb9",
      "k": "juejin",
      "id": "2ufzg9qxnh60",
      "author": "政采云前端团队",
      "title": "构建大型 Vue.js 项目的10条建议",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "下面是我在开发大型Vue项目时的最佳实践。这些技巧将帮助你开发更高效、更易于维护和共享的代码。今年做自由职业的时候，我有机会开发了一些大型Vue应用程序。我所说的这些项目，Vuexstore超过十个，包含大量的组件（有时候几百个）和视图页面。对我来说这是个很有益的经验，因为我发现了很多有意思的模式，可以让代码拥有更好的伸缩性。我还必须修正一些导致著名的意大利面条式代码困境的错误实践。因此，今天我将与你分享10个最佳实践，如果你正在处理大型代码库，我建议你参考这些方法。1.使用slot,让组件更强..."
    },
    {
      "url": "https://juejin.im/post/5dcbc236e51d451be55dde44",
      "k": "juejin",
      "id": "4b1ckg8sz840",
      "author": "陈大鱼头",
      "title": "让你的组件千变万化，Vue slot 剖玄析微",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "原创不易，希望能关注下我们，再顺手点个赞~~本文首发于政采云前端团队博客：让你的组件千变万化，Vueslot剖玄析微\">（一）前言Vue代码中的slot是什么，简单来说就是插槽。元素作为组件模板之中的内容分发插槽，传入内容后元素自身将被替换。看了上面这句官方解释，可能一样不知道slot指的是什么，那么就来看看在Vue中，什么时候你需要用到slot。举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如Button中是否显示icon，或者Modal框的中间内容展示..."
    },
    {
      "url": "https://juejin.im/post/5dcb9c126fb9a04aba52bdf4",
      "k": "juejin",
      "id": "3xbcscf7zpo0",
      "author": "郑闯",
      "title": "CSS的未来已来",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "作者：陈大鱼头github：KRISACHAN前言最近听说TypeScript3.7添加了对OptionalChaining的支持，然后就想着给鱼头的脚手架ying-template的TS版本升级，然后在命令行发现这样的一句信息：'postcss-cssnext'已经被'postcss-preset-env'代替了。详情请查看moox.io/blog/deprec…其实鱼头的脚手架里早就把postcss-cssnext换成了postcss-preset-env，不过一直没删，但是看到这句话之后，..."
    },
    {
      "url": "https://juejin.im/post/5dcad10df265da4d31074dc4",
      "k": "juejin",
      "id": "29zrp5xtuda8",
      "author": "政采云前端团队",
      "title": "说一说Angular“吊打”React和Vue的几个点",
      "time": "5天前",
      "baseClassName": "article-content",
      "baseSelectorToGetClassName": "empty",
      "detail": "前言首先这篇文章肯定是个标题党了，先给大家说声对不起。Angular肯定也有它不适用的场景，但是这一系列的文章是为了讲Angular，所以不管各位兄弟姐妹对自己钟爱的框架有多么热爱。这里也只会讲我自己在使用三种框架的过程中遇到的Angular中比较好解决的场景而React或者Vue中解决起来有些痛苦的场景。对不起了。。。。下面的场景有些只针对某一种框架，有些针对React和Vue两种框架。如果各位觉得自己用的框架解决起来还不错，请跳过这个场景。目录场景一：表单场景七：拖拽场景九：安全导航操作符(..."
    }
  ]
}